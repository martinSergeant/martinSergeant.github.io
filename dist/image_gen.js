/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/indexes/image_gen_index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/bam.js":
/*!********************!*\
  !*** ./src/bam.js ***!
  \********************/
/*! exports provided: loadBamIndex, BamReader, BamSource, BamFilter, BamAlignment, PairedAlignment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Zlib) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBamIndex\", function() { return loadBamIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamReader\", function() { return BamReader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamSource\", function() { return BamSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamFilter\", function() { return BamFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamAlignment\", function() { return BamAlignment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PairedAlignment\", function() { return PairedAlignment; });\n/* harmony import */ var _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n/* harmony import */ var _bigwig_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n/* harmony import */ var _vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vendor/inflate.js */ \"./src/vendor/inflate.js\");\n/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./feature.js */ \"./src/feature.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst BAI_MAGIC = 21578050;\r\nconst TABIX_MAGIC = 21578324;\r\nconst MAX_HEADER_SIZE = 100000000;   // IF the header is larger than this we can't read it !\r\nconst B_MAX_GZIP_BLOCK_SIZE = (1 << 16);\r\n\r\n\r\n    /**\r\n     * @param indexURL\r\n     * @param config\r\n     * @param tabix\r\n     *\r\n     * @returns a Promised for the bam or tabix index.  The fulfill function takes the index as an argument.\r\n     */\r\nlet loadBamIndex = function (indexURL, config, tabix) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var genome = null;\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(indexURL,\r\n                {\r\n                    headers: config.headers,\r\n                    withCredentials: config.withCredentials\r\n                }).then(function (arrayBuffer) {\r\n\r\n                var indices = [],\r\n                    magic, nbin, nintv, nref, parser,\r\n                    blockMin = Number.MAX_VALUE,\r\n                    blockMax = 0,\r\n                    binIndex, linearIndex, binNumber, cs, ce, b, i, ref, sequenceIndexMap;\r\n\r\n                if (!arrayBuffer) {\r\n                    fulfill(null);\r\n                    return;\r\n                }\r\n\r\n                if (tabix) {\r\n                \t  console.log(Zlib);\r\n                    var inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arrayBuffer));\r\n                    arrayBuffer = inflate.decompress().buffer;\r\n                   \r\n                   /*let r =pako.inflate(new Uint8Array(arrayBuffer));\r\n\r\n                    arrayBuffer =r.buffer;*/\r\n                }\r\n\r\n                parser = new _bigwig_js__WEBPACK_IMPORTED_MODULE_1__[\"BinaryParser\"](new DataView(arrayBuffer));\r\n\r\n                magic = parser.getInt();\r\n\r\n                if (magic === BAI_MAGIC || (tabix && magic === TABIX_MAGIC)) {\r\n\r\n                    nref = parser.getInt();\r\n\r\n\r\n                    if (tabix) {\r\n                        // Tabix header parameters aren't used, but they must be read to advance the pointer\r\n                        var format = parser.getInt();\r\n                        var col_seq = parser.getInt();\r\n                        var col_beg = parser.getInt();\r\n                        var col_end = parser.getInt();\r\n                        var meta = parser.getInt();\r\n                        var skip = parser.getInt();\r\n                        var l_nm = parser.getInt();\r\n\r\n                        sequenceIndexMap = {};\r\n                        for (i = 0; i < nref; i++) {\r\n                            var seq_name = parser.getString();\r\n\r\n                            // Translate to \"official\" chr name.\r\n                            if (genome) seq_name = genome.getChromosomeName(seq_name);\r\n\r\n                            sequenceIndexMap[seq_name] = i;\r\n                        }\r\n                    }\r\n\r\n                    for (ref = 0; ref < nref; ++ref) {\r\n\r\n                        binIndex = {};\r\n                        linearIndex = [];\r\n\r\n                        nbin = parser.getInt();\r\n\r\n                        for (b = 0; b < nbin; ++b) {\r\n\r\n                            binNumber = parser.getInt();\r\n\r\n                            if (binNumber == 37450) {\r\n                                // This is a psuedo bin, not used but we have to consume the bytes\r\n                                nchnk = parser.getInt(); // # of chunks for this bin\r\n                                cs = parser.getVPointer();   // unmapped beg\r\n                                ce = parser.getVPointer();   // unmapped end\r\n                                var n_maped = parser.getLong();\r\n                                var nUnmapped = parser.getLong();\r\n\r\n                            }\r\n                            else {\r\n                                \r\n                                binIndex[binNumber] = [];\r\n                                var nchnk = parser.getInt(); // # of chunks for this bin\r\n\r\n                                for (i = 0; i < nchnk; i++) {\r\n                                    cs = parser.getVPointer();\r\n                                    ce = parser.getVPointer();\r\n                                    if (cs && ce) {\r\n                                        if (cs.block < blockMin) {\r\n                                            blockMin = cs.block;    // Block containing first alignment\r\n                                        }\r\n                                        if (ce.block > blockMax) {\r\n                                            blockMax = ce.block;\r\n                                        }\r\n                                        binIndex[binNumber].push([cs, ce]);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                        nintv = parser.getInt();\r\n                        for (i = 0; i < nintv; i++) {\r\n                            cs = parser.getVPointer();\r\n                            linearIndex.push(cs);   // Might be null\r\n                        }\r\n\r\n                        if (nbin > 0) {\r\n                            indices[ref] = {\r\n                                binIndex: binIndex,\r\n                                linearIndex: linearIndex\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    throw new Error(indexURL + \" is not a \" + (tabix ? \"tabix\" : \"bai\") + \" file\");\r\n                }\r\n                fulfill(new BamIndex(indices, blockMin, sequenceIndexMap, tabix));\r\n            }).catch(reject);\r\n        })\r\n    }\r\n\r\n\r\nclass BamIndex{\r\n    constructor (indices, blockMin, sequenceIndexMap, tabix) {\r\n        this.firstAlignmentBlock = blockMin;\r\n        this.indices = indices;\r\n        this.sequenceIndexMap = sequenceIndexMap;\r\n        this.tabix = tabix;\r\n    }\r\n\r\n    /**\r\n     * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.\r\n     *\r\n     * @param refId  the sequence dictionary index of the chromosome\r\n     * @param min  genomic start position\r\n     * @param max  genomic end position\r\n     * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}\r\n     */\r\n    blocksForRange(refId, min, max) {\r\n\r\n        var bam = this,\r\n            ba = bam.indices[refId],\r\n            overlappingBins,\r\n            leafChunks,\r\n            otherChunks,\r\n            nintv,\r\n            lowest,\r\n            minLin,\r\n            maxLin,\r\n            lb,\r\n            prunedOtherChunks,\r\n            i,\r\n            chnk,\r\n            dif,\r\n            intChunks,\r\n            mergedChunks;\r\n\r\n        if (!ba) {\r\n            return [];\r\n        }\r\n        else {\r\n\r\n            overlappingBins = BamIndex.reg2bins(min, max);        // List of bin #s that might overlap min, max\r\n            leafChunks = [];\r\n            otherChunks = [];\r\n\r\n\r\n            overlappingBins.forEach(function (bin) {\r\n\r\n                if (ba.binIndex[bin]) {\r\n                    var chunks = ba.binIndex[bin],\r\n                        nchnk = chunks.length;\r\n\r\n                    for (var c = 0; c < nchnk; ++c) {\r\n                        var cs = chunks[c][0];\r\n                        var ce = chunks[c][1];\r\n                        (bin < 4681 ? otherChunks : leafChunks).push({minv: cs, maxv: ce, bin: bin});\r\n                    }\r\n\r\n                }\r\n            });\r\n\r\n            // Use the linear index to find the lowest chunk that could contain alignments in the region\r\n            nintv = ba.linearIndex.length;\r\n            lowest = null;\r\n            minLin = Math.min(min >> 14, nintv - 1), maxLin = Math.min(max >> 14, nintv - 1);\r\n            for (i = minLin; i <= maxLin; ++i) {\r\n                lb = ba.linearIndex[i];\r\n                if (!lb) {\r\n                    continue;\r\n                }\r\n                if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {\r\n                    lowest = lb;\r\n                }\r\n            }\r\n\r\n            // Prune chunks that end before the lowest chunk\r\n            prunedOtherChunks = [];\r\n            if (lowest != null) {\r\n                for (i = 0; i < otherChunks.length; ++i) {\r\n                    chnk = otherChunks[i];\r\n                    if (chnk.maxv.block > lowest.block || (chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset)) {\r\n                        prunedOtherChunks.push(chnk);\r\n                    }\r\n                }\r\n            }\r\n\r\n            intChunks = [];\r\n            for (i = 0; i < prunedOtherChunks.length; ++i) {\r\n                intChunks.push(prunedOtherChunks[i]);\r\n            }\r\n            for (i = 0; i < leafChunks.length; ++i) {\r\n                intChunks.push(leafChunks[i]);\r\n            }\r\n\r\n            intChunks.sort(function (c0, c1) {\r\n                dif = c0.minv.block - c1.minv.block;\r\n                if (dif != 0) {\r\n                    return dif;\r\n                } else {\r\n                    return c0.minv.offset - c1.minv.offset;\r\n                }\r\n            });\r\n\r\n            mergedChunks = [];\r\n            if (intChunks.length > 0) {\r\n                var cur = intChunks[0];\r\n                for (var i = 1; i < intChunks.length; ++i) {\r\n                    var nc = intChunks[i];\r\n                    if ((nc.minv.block - cur.maxv.block) < 65000) { // Merge blocks that are withing 65k of each other\r\n                        cur = {minv: cur.minv, maxv: nc.maxv};\r\n                    } else {\r\n                        mergedChunks.push(cur);\r\n                        cur = nc;\r\n                    }\r\n                }\r\n                mergedChunks.push(cur);\r\n            }\r\n            return mergedChunks;\r\n        }\r\n\r\n    };\r\n\r\n\r\n    /**\r\n     * Calculate the list of bins that may overlap with region [beg, end]\r\n     *\r\n     */\r\n    static reg2bins(beg, end) {\r\n        var i = 0, k, list = [];\r\n        if (end >= 1 << 29)   end = 1 << 29;\r\n        --end;\r\n        list.push(0);\r\n        for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) list.push(k);\r\n        for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) list.push(k);\r\n        for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) list.push(k);\r\n        for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) list.push(k);\r\n        for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) list.push(k);\r\n        return list;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nclass BGZFile{\r\n\r\n    constructor (config) {\r\n        this.filePosition = 0;\r\n        this.config = config;\r\n    }\r\n\r\n    nextBlock() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path,\r\n                {\r\n                    headers: self.config.headers,\r\n                    range: {start: self.filePosition, size: BLOCK_HEADER_LENGTH},\r\n                    withCredentials: self.config.withCredentials\r\n\r\n                }).then(function (arrayBuffer) {\r\n\r\n                var ba = new Uint8Array(arrayBuffer);\r\n                var xlen = (ba[11] << 8) | (ba[10]);\r\n                var si1 = ba[12];\r\n                var si2 = ba[13];\r\n                var slen = (ba[15] << 8) | (ba[14]);\r\n                var bsize = (ba[17] << 8) | (ba[16]) + 1;\r\n\r\n                self.filePosition += BLOCK_HEADER_LENGTH;\r\n\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, {\r\n                    headers: self.config.headers,\r\n                    range: {start: self.filePosition, size: bsize},\r\n                    withCredentials: self.config.withCredentials\r\n\r\n                }).then(function (arrayBuffer) {\r\n\r\n                    var unc = Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__[\"jszlib_inflate_buffer\"])(arrayBuffer);\r\n\r\n                    self.filePosition += (bsize + 8);  // \"8\" for CRC-32 and size of uncompressed data\r\n\r\n                    fulfill(unc);\r\n\r\n                }).catch(reject)\r\n            }).catch(reject);\r\n        })\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n    var BAM_MAGIC = 21840194;\r\n    var SECRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\r\n    var CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\r\n    var READ_STRAND_FLAG = 0x10;\r\n    var MATE_STRAND_FLAG = 0x20;\r\n    var FIRST_OF_PAIR_FLAG = 0x40;\r\n    var SECOND_OF_PAIR_FLAG = 0x80;\r\n    var READ_UNMAPPED_FLAG = 0x4;\r\n    var MATE_UNMAPPED_FLAG = 0x8;\r\n    var READ_PAIRED_FLAG = 0x1;\r\n    var PROPER_PAIR_FLAG = 0x2;\r\n    var SECONDARY_ALIGNMNET_FLAG = 0x100;\r\n    var SUPPLEMENTARY_ALIGNMENT_FLAG = 0x800;\r\n\r\n\r\n\r\n\r\n    var NOT_PRIMARY_ALIGNMENT_FLAG = 0x100;\r\n    var READ_FAILS_VENDOR_QUALITY_CHECK_FLAG = 0x200;\r\n    var DUPLICATE_READ_FLAG = 0x400;\r\n    var SUPPLEMENTARY_FLAG = 0x800;\r\n\r\n    const MAX_GZIP_BLOCK_SIZE = 65536;   //  APPARENTLY.  Where is this documented???\r\n    const DEFAULT_SAMPLING_WINDOW_SIZE = 100;\r\n    const DEFAULT_SAMPLING_DEPTH = 50;\r\n    const MAXIMUM_SAMPLING_DEPTH = 2500;\r\n\r\n    /**\r\n     * Class for reading a bam file\r\n     *\r\n     * @param config\r\n     * @constructor\r\n     */\r\n class BamReader{\r\n     constructor(config) {\r\n\r\n        this.config = config;\r\n\r\n        this.filter = config.filter || new BamFilter();\r\n\r\n        this.bamPath = config.url;\r\n        // Todo - deal with Picard convention.  WHY DOES THERE HAVE TO BE 2?\r\n        this.baiPath = config.indexURL || this.bamPath + \".bai\"; // If there is an indexURL provided, use it!\r\n        this.headPath = config.headURL || this.bamPath;\r\n\r\n\r\n        this.samplingWindowSize = config.samplingWindowSize === undefined ? DEFAULT_SAMPLING_WINDOW_SIZE : config.samplingWindowSize;\r\n        this.samplingDepth = config.samplingDepth === undefined ? DEFAULT_SAMPLING_DEPTH : config.samplingDepth;\r\n        if(this.samplingDepth > MAXIMUM_SAMPLING_DEPTH) {\r\n            igv.log(\"Warning: attempt to set sampling depth > maximum value of 2500\");\r\n            this.samplingDepth = MAXIMUM_SAMPLING_DEPTH;\r\n        }\r\n\r\n        if (config.viewAsPairs) {\r\n            this.pairsSupported = true;\r\n        }\r\n        else {\r\n            this.pairsSupported = config.pairsSupported === undefined ? true : config.pairsSupported;\r\n        }\r\n\r\n    }\r\n\r\n    readAlignments(chr, bpStart, bpEnd) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n\r\n            getChrIndex(self).then(function (chrToIndex) {\r\n\r\n                var chrId = chrToIndex[chr],\r\n\r\n                    alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, self.samplingWindowSize, self.samplingDepth, self.pairsSupported);\r\n                    \r\n                if (chrId === undefined) {\r\n                    fulfill(alignmentContainer);\r\n                } else {\r\n\r\n                    getIndex(self).then(function (bamIndex) {\r\n\r\n                        var chunks = bamIndex.blocksForRange(chrId, bpStart, bpEnd),\r\n                            promises = [];\r\n\r\n\r\n                        if (!chunks) {\r\n                            fulfill(null);\r\n                            reject(\"Error reading bam index\");\r\n                            return;\r\n                        }\r\n                        if (chunks.length === 0) {\r\n                            fulfill(alignmentContainer);\r\n                            return;\r\n                        }\r\n\r\n                        chunks.forEach(function (c) {\r\n\r\n                            promises.push(new Promise(function (fulfill, reject) {\r\n\r\n                                var fetchMin = c.minv.block,\r\n                                    fetchMax = c.maxv.block + MAX_GZIP_BLOCK_SIZE,   // Make sure we get the whole block.\r\n                                    range = {start: fetchMin, size: fetchMax - fetchMin + 1};\r\n\r\n                                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.bamPath,\r\n                                    {\r\n                                        headers: self.config.headers,\r\n                                        range: range,\r\n                                        withCredentials: self.config.withCredentials\r\n                                    }).then(function (compressed) {\r\n\r\n                                    var ba = new Uint8Array(new unbgzf(compressed)); //new Uint8Array(igv.unbgzf(compressed)); //, c.maxv.block - c.minv.block + 1));\r\n                                    decodeBamRecords(ba, c.minv.offset, alignmentContainer, bpStart, bpEnd, chrId, self.filter);\r\n\r\n                                    fulfill(alignmentContainer);\r\n\r\n                                }).catch(function (obj) {\r\n                                    reject(obj);\r\n                                });\r\n\r\n                            }))\r\n                        });\r\n\r\n\r\n                        Promise.all(promises).then(function (ignored) {\r\n                            alignmentContainer.finish();\r\n                            fulfill(alignmentContainer);\r\n                        }).catch(function (obj) {\r\n                            reject(obj);\r\n                        });\r\n                    }).catch(reject);\r\n                }\r\n            }).catch(reject);\r\n        });\r\n\r\n\r\n        function decodeBamRecords(ba, offset, alignmentContainer, min, max, chrId, filter) {\r\n\r\n            var blockSize,\r\n                blockEnd,\r\n                alignment,\r\n                blocks,\r\n                refID,\r\n                pos,\r\n                bmn,\r\n                bin,\r\n                mq,\r\n                nl,\r\n                flag_nc,\r\n                flag,\r\n                nc,\r\n                lseq,\r\n                mateRefID,\r\n                matePos,\r\n                readName,\r\n                j,\r\n                p,\r\n                lengthOnRef,\r\n                cigar,\r\n                c,\r\n                cigarArray,\r\n                seq,\r\n                seqBytes;\r\n\r\n            while (true) {\r\n\r\n                blockSize = readInt(ba, offset);\r\n                blockEnd = offset + blockSize + 4;\r\n\r\n                if (blockEnd > ba.length) {\r\n                    return;\r\n                }\r\n\r\n                alignment = new BamAlignment();\r\n\r\n                refID = readInt(ba, offset + 4);\r\n                pos = readInt(ba, offset + 8);\r\n\r\n                if(refID < 0) {\r\n                    return;   // unmapped reads\r\n                }\r\n                else if (refID > chrId || pos > max) {\r\n                    return;    // off right edge, we're done\r\n                }\r\n                else if (refID < chrId) {\r\n                    continue;   // to left of start, not sure this is possible\r\n                }\r\n\r\n                bmn = readInt(ba, offset + 12);\r\n                bin = (bmn & 0xffff0000) >> 16;\r\n                mq = (bmn & 0xff00) >> 8;\r\n                nl = bmn & 0xff;\r\n\r\n                flag_nc = readInt(ba, offset + 16);\r\n                flag = (flag_nc & 0xffff0000) >> 16;\r\n                nc = flag_nc & 0xffff;\r\n\r\n                alignment.flags = flag;\r\n                alignment.strand = !(flag & READ_STRAND_FLAG);\r\n\r\n                lseq = readInt(ba, offset + 20);\r\n\r\n                mateRefID = readInt(ba, offset + 24);\r\n                matePos = readInt(ba, offset + 28);\r\n                alignment.fragmentLength = readInt(ba, offset + 32);\r\n\r\n                readName = '';\r\n                for (j = 0; j < nl - 1; ++j) {\r\n                    readName += String.fromCharCode(ba[offset + 36 + j]);\r\n                }\r\n\r\n                p = offset + 36 + nl;\r\n\r\n                lengthOnRef = 0;\r\n                cigar = '';\r\n\r\n\r\n                cigarArray = [];\r\n                for (c = 0; c < nc; ++c) {\r\n                    var cigop = readInt(ba, p);\r\n                    var opLen = (cigop >> 4);\r\n                    var opLtr = CIGAR_DECODER[cigop & 0xf];\r\n                    if (opLtr == 'M' || opLtr == 'EQ' || opLtr == 'X' || opLtr == 'D' || opLtr == 'N' || opLtr == '=')\r\n                        lengthOnRef += opLen;\r\n                    cigar = cigar + opLen + opLtr;\r\n                    p += 4;\r\n\r\n                    cigarArray.push({len: opLen, ltr: opLtr});\r\n                }\r\n                alignment.cigar = cigar;\r\n                alignment.lengthOnRef = lengthOnRef;\r\n\r\n                if (alignment.start + alignment.lengthOnRef < min) continue;  // Record out-of-range \"to the left\", skip to next one\r\n\r\n\r\n                seq = '';\r\n                seqBytes = (lseq + 1) >> 1;\r\n                for (j = 0; j < seqBytes; ++j) {\r\n                    var sb = ba[p + j];\r\n                    seq += SECRET_DECODER[(sb & 0xf0) >> 4];\r\n                    seq += SECRET_DECODER[(sb & 0x0f)];\r\n                }\r\n                seq = seq.substring(0, lseq);  // seq might have one extra character (if lseq is an odd number)\r\n\r\n                p += seqBytes;\r\n                alignment.seq = seq;\r\n\r\n\r\n                if (lseq === 1 && String.fromCharCode(ba[p + j] + 33) === \"*\") {\r\n                    // TODO == how to represent this?\r\n                }\r\n                else {\r\n                    alignment.qual = [];\r\n                    for (j = 0; j < lseq; ++j) {\r\n                        alignment.qual.push(ba[p + j]);\r\n                    }\r\n                }\r\n                p += lseq;\r\n\r\n\r\n                alignment.start = pos;\r\n                alignment.mq = mq;\r\n                alignment.readName = readName;\r\n                alignment.chr = self.indexToChr[refID];\r\n\r\n                if (mateRefID >= 0) {\r\n                    alignment.mate = {\r\n                        chr: self.indexToChr[mateRefID],\r\n                        position: matePos,\r\n                        strand: !(flag & MATE_STRAND_FLAG)\r\n                    };\r\n                }\r\n\r\n\r\n                alignment.tagBA = new Uint8Array(ba.buffer.slice(p, blockEnd));  // decode thiese on demand\r\n                p += blockEnd;\r\n\r\n                if (!min || alignment.start <= max &&\r\n                    alignment.start + alignment.lengthOnRef >= min &&\r\n                    filter.pass(alignment)) {\r\n                    if (chrId === undefined || refID == chrId) {\r\n                        blocks = makeBlocks(alignment, cigarArray);\r\n                        alignment.blocks = blocks.blocks;\r\n                        alignment.insertions = blocks.insertions;\r\n                        alignmentContainer.push(alignment);\r\n                    }\r\n                }\r\n                offset = blockEnd;\r\n            }\r\n            // Exits via top of loop.\r\n        }\r\n\r\n        /**\r\n         * Split the alignment record into blocks as specified in the cigarArray.  Each aligned block contains\r\n         * its portion of the read sequence and base quality strings.  A read sequence or base quality string\r\n         * of \"*\" indicates the value is not recorded.  In all other cases the length of the block sequence (block.seq)\r\n         * and quality string (block.qual) must == the block length.\r\n         *\r\n         * NOTE: Insertions are not yet treated // TODO\r\n         *\r\n         * @param record\r\n         * @param cigarArray\r\n         * @returns array of blocks\r\n         */\r\n        function makeBlocks(record, cigarArray) {\r\n\r\n            var blocks = [],\r\n                insertions,\r\n                seqOffset = 0,\r\n                pos = record.start,\r\n                len = cigarArray.length,\r\n                blockSeq,\r\n                blockQuals,\r\n                gapType,\r\n                minQ = 5,  //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN)\r\n                maxQ = 20; //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX)\r\n\r\n            for (var i = 0; i < len; i++) {\r\n\r\n                var c = cigarArray[i];\r\n\r\n                switch (c.ltr) {\r\n                    case 'H' :\r\n                        break; // ignore hard clips\r\n                    case 'P' :\r\n                        break; // ignore pads\r\n                    case 'S' :\r\n                        seqOffset += c.len;\r\n                        gapType = 'S';\r\n                        break; // soft clip read bases\r\n                    case 'N' :\r\n                        pos += c.len;\r\n                        gapType = 'N';\r\n                        break;  // reference skip\r\n                    case 'D' :\r\n                        pos += c.len;\r\n                        gapType = 'D';\r\n                        break;\r\n                    case 'I' :\r\n                        blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\r\n                        blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\r\n                        if (insertions === undefined) insertions = [];\r\n                        insertions.push({start: pos, len: c.len, seq: blockSeq, qual: blockQuals});\r\n                        seqOffset += c.len;\r\n                        break;\r\n                    case 'M' :\r\n                    case 'EQ' :\r\n                    case '=' :\r\n                    case 'X' :\r\n\r\n                        blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\r\n                        blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\r\n                        blocks.push({start: pos, len: c.len, seq: blockSeq, qual: blockQuals, gapType: gapType});\r\n                        seqOffset += c.len;\r\n                        pos += c.len;\r\n\r\n                        break;\r\n\r\n                    default :\r\n                        console.log(\"Error processing cigar element: \" + c.len + c.ltr);\r\n                }\r\n            }\r\n\r\n            return {blocks: blocks, insertions: insertions};\r\n\r\n        }\r\n    }\r\n\r\n    readHeader() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            getIndex(self).then(function (index) {\r\n\r\n                var len = index.firstAlignmentBlock + MAX_GZIP_BLOCK_SIZE;   // Insure we get the complete compressed block containing the header\r\n\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.bamPath,\r\n                    {\r\n                        headers: self.config.headers,\r\n\r\n                        range: {start: 0, size: len},\r\n\r\n                        withCredentials: self.config.withCredentials\r\n                    }).then(function (compressedBuffer) {\r\n\r\n                    var unc = new unbgzf(compressedBuffer, len),\r\n                        uncba = new Uint8Array(unc),\r\n                        magic = readInt(uncba, 0),\r\n                        samHeaderLen = readInt(uncba, 4),\r\n                        samHeader = '',\r\n                        genome = null;\r\n\r\n                    for (var i = 0; i < samHeaderLen; ++i) {\r\n                        samHeader += String.fromCharCode(uncba[i + 8]);\r\n                    }\r\n\r\n                    var nRef = readInt(uncba, samHeaderLen + 8);\r\n                    var p = samHeaderLen + 12;\r\n\r\n                    self.chrToIndex = {};\r\n                    self.indexToChr = [];\r\n                    for (var i = 0; i < nRef; ++i) {\r\n                        var lName = readInt(uncba, p);\r\n                        var name = '';\r\n                        for (var j = 0; j < lName - 1; ++j) {\r\n                            name += String.fromCharCode(uncba[p + 4 + j]);\r\n                        }\r\n                        var lRef = readInt(uncba, p + lName + 4);\r\n                        //dlog(name + ': ' + lRef);\r\n\r\n                        if (genome && genome.getChromosomeName) {\r\n                            name = genome.getChromosomeName(name);\r\n                        }\r\n\r\n                        self.chrToIndex[name] = i;\r\n                        self.indexToChr.push(name);\r\n\r\n                        p = p + 8 + lName;\r\n                    }\r\n\r\n                    fulfill();\r\n\r\n                }).catch(reject);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n}\r\n    function getIndex(bam) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (bam.index) {\r\n                fulfill(bam.index);\r\n            }\r\n            else {\r\n                loadBamIndex(bam.baiPath, bam.config).then(function (index) {\r\n                    bam.index = index;\r\n\r\n                    fulfill(bam.index);\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    function getChrIndex(bam) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (bam.chrToIndex) {\r\n                fulfill(bam.chrToIndex);\r\n            }\r\n            else {\r\n                bam.readHeader().then(function () {\r\n                    fulfill(bam.chrToIndex);\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n    function readInt(ba, offset) {\r\n        return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);\r\n    }\r\n\r\n    function readShort(ba, offset) {\r\n        return (ba[offset + 1] << 8) | (ba[offset]);\r\n    }\r\n\r\n\r\n\r\n\r\nclass BamSource{\r\n    constructor(config) {\r\n\r\n        this.config = config;\r\n        this.alignmentContainer = undefined;\r\n        this.maxRows = config.maxRows || 1000;\r\n        this.sequence_source=new _feature_js__WEBPACK_IMPORTED_MODULE_3__[\"FastaSequence\"](config.seq_url);\r\n\r\n        if (config.sourceType === \"ga4gh\") {\r\n            this.bamReader = new igv.Ga4ghAlignmentReader(config);\r\n        }\r\n        else {\r\n            this.bamReader = new BamReader(config);\r\n        }\r\n\r\n       this.viewAsPairs = config.viewAsPairs;\r\n    };\r\n\r\n    setViewAsPairs(bool) {\r\n        var self = this;\r\n\r\n        if (this.viewAsPairs !== bool) {\r\n            this.viewAsPairs = bool;\r\n            // TODO -- repair alignments\r\n            if (this.alignmentContainer) {\r\n                var alignmentContainer = this.alignmentContainer,\r\n                    alignments;\r\n\r\n                if (bool) {\r\n                    alignments = pairAlignments(alignmentContainer.packedAlignmentRows);\r\n                }\r\n                else {\r\n                    alignments = unpairAlignments(alignmentContainer.packedAlignmentRows);\r\n                }\r\n                alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, self.maxRows);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    getAlignments(chr, bpStart, bpEnd) {\r\n\r\n        var self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.alignmentContainer && self.alignmentContainer.contains(chr, bpStart, bpEnd)) {\r\n                fulfill(self.alignmentContainer);\r\n            } else {\r\n\r\n                self.bamReader.readAlignments(chr, bpStart, bpEnd).then(function (alignmentContainer) {\r\n\r\n                    var maxRows = self.config.maxRows || 500,\r\n                        alignments = alignmentContainer.alignments;\r\n\r\n                    if (!self.viewAsPairs) {\r\n                        alignments = unpairAlignments([{alignments: alignments}]);\r\n                    }\r\n\r\n                    alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, maxRows);\r\n\r\n\r\n                    alignmentContainer.alignments = undefined;  // Don't need to hold onto these anymore\r\n                    self.alignmentContainer = alignmentContainer;\r\n\r\n                   self.sequence_source.getSequence(alignmentContainer.chr, alignmentContainer.start, alignmentContainer.end).then(\r\n                        function (sequence) {\r\n\r\n\r\n                            if (sequence) {\r\n\r\n                                alignmentContainer.coverageMap.refSeq = sequence;    // TODO -- fix this\r\n                                alignmentContainer.sequence = sequence;           // TODO -- fix this\r\n\r\n\r\n                                fulfill(alignmentContainer);\r\n                            }\r\n                        }).catch(reject);\r\n\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n    function pairAlignments(rows) {\r\n\r\n        var pairCache = {},\r\n            result = [];\r\n\r\n        rows.forEach(function (row) {\r\n\r\n            row.alignments.forEach(function (alignment) {\r\n\r\n                var pairedAlignment;\r\n\r\n                if (canBePaired(alignment)) {\r\n\r\n                    pairedAlignment = pairCache[alignment.readName];\r\n                    if (pairedAlignment) {\r\n                        pairedAlignment.setSecondAlignment(alignment);\r\n                        pairCache[alignment.readName] = undefined;   // Don't need to track this anymore.\r\n                    }\r\n                    else {\r\n                        pairedAlignment = new igv.PairedAlignment(alignment);\r\n                        pairCache[alignment.readName] = pairedAlignment;\r\n                        result.push(pairedAlignment);\r\n                    }\r\n                }\r\n\r\n                else {\r\n                    result.push(alignment);\r\n                }\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function unpairAlignments(rows) {\r\n        var result = [];\r\n        rows.forEach(function (row) {\r\n            row.alignments.forEach(function (alignment) {\r\n                if (alignment instanceof PairedAlignment) {\r\n                    if (alignment.firstAlignment) result.push(alignment.firstAlignment);  // shouldn't need the null test\r\n                    if (alignment.secondAlignment) result.push(alignment.secondAlignment);\r\n\r\n                }\r\n                else {\r\n                    result.push(alignment);\r\n                }\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function canBePaired(alignment) {\r\n        return alignment.isPaired() &&\r\n            alignment.isMateMapped() &&\r\n            alignment.chr === alignment.mate.chr &&\r\n            (alignment.isFirstOfPair() || alignment.isSecondOfPair()) && !(alignment.isSecondary() || alignment.isSupplementary());\r\n    }\r\n\r\n\r\n    function packAlignmentRows(alignments, start, end, maxRows) {\r\n\r\n        if (!alignments) return;\r\n\r\n        alignments.sort(function (a, b) {\r\n            return a.start - b.start;\r\n        });\r\n\r\n        if (alignments.length === 0) {\r\n\r\n            return [];\r\n\r\n        } else {\r\n\r\n            var bucketList = [],\r\n                allocatedCount = 0,\r\n                lastAllocatedCount = 0,\r\n                nextStart = start,\r\n                alignmentRow,\r\n                index,\r\n                bucket,\r\n                alignment,\r\n                alignmentSpace = 4 * 2,\r\n                packedAlignmentRows = [],\r\n                bucketStart = Math.max(start, alignments[0].start);\r\n\r\n            alignments.forEach(function (alignment) {\r\n\r\n                var buckListIndex = Math.max(0, alignment.start - bucketStart);\r\n                if (bucketList[buckListIndex] === undefined) {\r\n                    bucketList[buckListIndex] = [];\r\n                }\r\n                bucketList[buckListIndex].push(alignment);\r\n            });\r\n\r\n\r\n            while (allocatedCount < alignments.length && packedAlignmentRows.length < maxRows) {\r\n\r\n                alignmentRow = new BamAlignmentRow();\r\n\r\n                while (nextStart <= end) {\r\n\r\n                    bucket = undefined;\r\n\r\n                    while (!bucket && nextStart <= end) {\r\n\r\n                        index = nextStart - bucketStart;\r\n                        if (bucketList[index] === undefined) {\r\n                            ++nextStart;                     // No alignments at this index\r\n                        } else {\r\n                            bucket = bucketList[index];\r\n                        }\r\n\r\n                    } // while (bucket)\r\n\r\n                    if (!bucket) {\r\n                        break;\r\n                    }\r\n                    alignment = bucket.pop();\r\n                    if (0 === bucket.length) {\r\n                        bucketList[index] = undefined;\r\n                    }\r\n\r\n                    alignmentRow.alignments.push(alignment);\r\n                    nextStart = alignment.start + alignment.lengthOnRef + alignmentSpace;\r\n                    ++allocatedCount;\r\n\r\n                } // while (nextStart)\r\n\r\n                if (alignmentRow.alignments.length > 0) {\r\n                    packedAlignmentRows.push(alignmentRow);\r\n                }\r\n\r\n                nextStart = bucketStart;\r\n\r\n                if (allocatedCount === lastAllocatedCount) break;   // Protect from infinite loops\r\n\r\n                lastAllocatedCount = allocatedCount;\r\n\r\n            } // while (allocatedCount)\r\n\r\n            return packedAlignmentRows;\r\n        }\r\n    }\r\n\r\n\r\n\r\nclass BamAlignment{\r\n    constructor(){\r\n        this.hidden = false;\r\n    }\r\n\r\n    isMapped() {\r\n        return (this.flags & READ_UNMAPPED_FLAG) == 0;\r\n    }\r\n\r\n    isPaired () {\r\n        return (this.flags & READ_PAIRED_FLAG) != 0;\r\n    }\r\n\r\n    isProperPair () {\r\n        return (this.flags & PROPER_PAIR_FLAG) != 0;\r\n    }\r\n\r\n    isFirstOfPair() {\r\n        return (this.flags & FIRST_OF_PAIR_FLAG) != 0;\r\n    }\r\n\r\n    isSecondOfPair() {\r\n        return (this.flags & SECOND_OF_PAIR_FLAG) != 0;\r\n    }\r\n\r\n    isSecondary() {\r\n        return (this.flags & SECONDARY_ALIGNMNET_FLAG) != 0;\r\n    }\r\n\r\n    isSupplementary() {\r\n        return (this.flags & SUPPLEMENTARY_ALIGNMENT_FLAG) != 0;\r\n    }\r\n\r\n    isFailsVendorQualityCheck() {\r\n        return (this.flags & READ_FAILS_VENDOR_QUALITY_CHECK_FLAG) != 0;\r\n    }\r\n\r\n    isDuplicate() {\r\n        return (this.flags & DUPLICATE_READ_FLAG) != 0;\r\n    }\r\n\r\n    isMateMapped() {\r\n        return (this.flags & MATE_UNMAPPED_FLAG) == 0;\r\n    }\r\n\r\n    isNegativeStrand() {\r\n        return (this.flags & READ_STRAND_FLAG) != 0;\r\n    }\r\n\r\n    isMateNegativeStrand() {\r\n        return (this.flags & MATE_STRAND_FLAG) != 0;\r\n    }\r\n\r\n    tags() {\r\n\r\n        function decodeTags(ba) {\r\n\r\n            var p = 0,\r\n                len = ba.length,\r\n                tags = {};\r\n\r\n            while (p < len) {\r\n                var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);\r\n                var type = String.fromCharCode(ba[p + 2]);\r\n                var value;\r\n\r\n                if (type == 'A') {\r\n                    value = String.fromCharCode(ba[p + 3]);\r\n                    p += 4;\r\n                } else if (type === 'i' || type === 'I') {\r\n                    value = readInt(ba, p + 3);\r\n                    p += 7;\r\n                } else if (type === 'c' || type === 'C') {\r\n                    value = ba[p + 3];\r\n                    p += 4;\r\n                } else if (type === 's' || type === 'S') {\r\n                    value = readShort(ba, p + 3);\r\n                    p += 5;\r\n                } else if (type === 'f') {\r\n                    // TODO 'FIXME need floats';\r\n                    value = readFloat(ba, p + 3);\r\n                    p += 7;\r\n                } else if (type === 'Z') {\r\n                    p += 3;\r\n                    value = '';\r\n                    for (; ;) {\r\n                        var cc = ba[p++];\r\n                        if (cc === 0) {\r\n                            break;\r\n                        } else {\r\n                            value += String.fromCharCode(cc);\r\n                        }\r\n                    }\r\n                } else {\r\n                    //'Unknown type ' + type;\r\n                    value = 'Error unknown type: ' + type;\r\n                    tags[tag] = value;\r\n                    break;\r\n                }\r\n                tags[tag] = value;\r\n            }\r\n            return tags;\r\n        }\r\n\r\n        if (!this.tagDict) {\r\n            if (this.tagBA) {\r\n                this.tagDict = decodeTags(this.tagBA);\r\n                this.tagBA = undefined;\r\n            } else {\r\n                this.tagDict = {};  // Mark so we don't try again.  The record has not tags\r\n            }\r\n        }\r\n        return this.tagDict;\r\n\r\n    }\r\n\r\n    popupData(genomicLocation) {\r\n\r\n        // if the user clicks on a base next to an insertion, show just the\r\n        // inserted bases in a popup (like in desktop IGV).\r\n        var nameValues = [], isFirst, tagDict;\r\n\r\n        if(this.insertions) {\r\n            for(var i = 0; i < this.insertions.length; i += 1) {\r\n                var ins_start = this.insertions[i].start;\r\n                if(genomicLocation == ins_start || genomicLocation == ins_start - 1) {\r\n                    nameValues.push({name: 'Insertion', value: this.insertions[i].seq });\r\n                    nameValues.push({name: 'Location', value: ins_start });\r\n                    return nameValues;\r\n                }\r\n            }\r\n        }\r\n\r\n        nameValues.push({ name: 'Read Name', value: this.readName });\r\n\r\n        // Sample\r\n        // Read group\r\n        nameValues.push(\"<hr>\");\r\n\r\n        // Add 1 to genomic location to map from 0-based computer units to user-based units\r\n        nameValues.push({ name: 'Alignment Start', value: igv.numberFormatter(1 + this.start), borderTop: true });\r\n\r\n        nameValues.push({ name: 'Read Strand', value: (true === this.strand ? '(+)' : '(-)'), borderTop: true });\r\n        nameValues.push({ name: 'Cigar', value: this.cigar });\r\n        nameValues.push({ name: 'Mapped', value: yesNo(this.isMapped()) });\r\n        nameValues.push({ name: 'Mapping Quality', value: this.mq });\r\n        nameValues.push({ name: 'Secondary', value: yesNo(this.isSecondary()) });\r\n        nameValues.push({ name: 'Supplementary', value: yesNo(this.isSupplementary()) });\r\n        nameValues.push({ name: 'Duplicate', value: yesNo(this.isDuplicate()) });\r\n        nameValues.push({ name: 'Failed QC', value: yesNo(this.isFailsVendorQualityCheck()) });\r\n\r\n        if (this.isPaired()) {\r\n            nameValues.push(\"<hr>\");\r\n            nameValues.push({ name: 'First in Pair', value: !this.isSecondOfPair(), borderTop: true });\r\n            nameValues.push({ name: 'Mate is Mapped', value: yesNo(this.isMateMapped()) });\r\n            if (this.isMateMapped()) {\r\n                nameValues.push({ name: 'Mate Chromosome', value: this.mate.chr });\r\n                nameValues.push({ name: 'Mate Start', value: (this.mate.position + 1)});\r\n                nameValues.push({ name: 'Mate Strand', value: (true === this.mate.strand ? '(+)' : '(-)')});\r\n                nameValues.push({ name: 'Insert Size', value: this.fragmentLength });\r\n                // Mate Start\r\n                // Mate Strand\r\n                // Insert Size\r\n            }\r\n            // First in Pair\r\n            // Pair Orientation\r\n\r\n        }\r\n\r\n        nameValues.push(\"<hr>\");\r\n        tagDict = this.tags();\r\n        isFirst = true;\r\n        for (var key in tagDict) {\r\n\r\n            if (tagDict.hasOwnProperty(key)) {\r\n\r\n                if (isFirst) {\r\n                    nameValues.push({ name: key, value: tagDict[key], borderTop: true });\r\n                    isFirst = false;\r\n                } else {\r\n                    nameValues.push({ name: key, value: tagDict[key] });\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return nameValues;\r\n\r\n\r\n        function yesNo(bool) {\r\n            return bool ? 'Yes' : 'No';\r\n        }\r\n    }\r\n}\r\n\r\n\r\n   \r\n\r\n   \r\n\r\n    function readFloat(ba, offset) {\r\n\r\n        var dataView = new DataView(ba.buffer),\r\n            littleEndian = true;\r\n\r\n        return dataView.getFloat32(offset, littleEndian);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\nclass BamFilter{\r\n\r\n  constructor (options) {\r\n        if (!options) options = {};\r\n        this.vendorFailed = options.vendorFailed === undefined ? true : options.vendorFailed;\r\n        this.duplicates = options.duplicates === undefined ? true : options.duplicates;\r\n        this.secondary = options.secondary || false;\r\n        this.supplementary = options.supplementary || false;\r\n        this.mqThreshold = options.mqThreshold === undefined ? 0 : options.mqThreshold;\r\n    }\r\n\r\n    pass(alignment) {\r\n\r\n        if (this.vendorFailed && alignment.isFailsVendorQualityCheck()) return false;\r\n        if (this.duplicates && alignment.isDuplicate()) return false;\r\n        if (this.secondary && alignment.isSecondary()) return false;\r\n        if (this.supplementary && alignment.isSupplementary()) return false;\r\n        if (alignment.mq < this.mqThreshold) return false;\r\n\r\n        return true;\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n    var BLOCK_HEADER_LENGTH = 18;\r\n    var BLOCK_LENGTH_OFFSET = 16;  // Location in the gzip block of the total block size (actually total block size - 1)\r\n    var BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\r\n    var MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\r\n    var GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\r\n    var GZIP_ID1 = 31;   // Magic number\r\n    var GZIP_ID2 = 139;  // Magic number\r\n    var GZIP_FLG = 4; // FEXTRA flag means there are optional fields\r\n\r\n\r\n    // Uncompress data,  assumed to be series of bgzipped blocks\r\n    // Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\r\nclass unbgzf{\r\n    constructor(data, lim) {\r\n        for (let a in data){\r\n           console.log(a);\r\n         }\r\n        var oBlockList = [],\r\n            ptr = [0],\r\n            totalSize = 0;\r\n\r\n        lim = lim || data.byteLength - 18;\r\n\r\n        while (ptr[0] < lim) {\r\n\r\n            var ba = new Uint8Array(data, ptr[0], 18);\r\n\r\n            var xlen = (ba[11] << 8) | (ba[10]);\r\n            var si1 = ba[12];\r\n            var si2 = ba[13];\r\n            var slen = (ba[15] << 8) | (ba[14]);\r\n            var bsize = (ba[17] << 8) | (ba[16]) + 1;\r\n\r\n            var start = 12 + xlen + ptr[0];    // Start of CDATA\r\n            var length = data.byteLength - start;\r\n\r\n            if (length < (bsize + 8)) break;\r\n\r\n            var unc = Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__[\"jszlib_inflate_buffer\"])(data, start, length, ptr);\r\n\r\n            ptr[0] += 8;    // Skipping CRC-32 and size of uncompressed data\r\n\r\n            totalSize += unc.byteLength;\r\n            oBlockList.push(unc);\r\n        }\r\n\r\n        // Concatenate decompressed blocks\r\n        if (oBlockList.length == 1) {\r\n            return oBlockList[0];\r\n        } else {\r\n            var out = new Uint8Array(totalSize);\r\n            var cursor = 0;\r\n            for (var i = 0; i < oBlockList.length; ++i) {\r\n                var b = new Uint8Array(oBlockList[i]);\r\n                Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCopy\"])(b, 0, out, cursor, b.length);\r\n                cursor += b.length;\r\n            }\r\n            return out.buffer;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nclass AlignmentContainer{\r\n    constructor(chr, start, end, samplingWindowSize, samplingDepth, pairsSupported) {\r\n\r\n        this.chr = chr;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.length = (end - start);\r\n\r\n        this.coverageMap = new CoverageMap(chr, start, end);\r\n        this.alignments = [];\r\n        this.downsampledIntervals = [];\r\n\r\n        this.samplingWindowSize = samplingWindowSize === undefined ? 100 : samplingWindowSize;\r\n        this.samplingDepth = samplingDepth === undefined ? 50 : samplingDepth;\r\n\r\n        this.pairsSupported = pairsSupported;\r\n        this.paired = false;  // false until proven otherwise\r\n        this.pairsCache = {};  // working cache of paired alignments by read name\r\n\r\n        this.downsampledReads = new Set();\r\n\r\n        this.currentBucket = new DownsampleBucket(this.start, this.start + this.samplingWindowSize, this);\r\n\r\n        this.filter = function filter(alignment) {         // TODO -- pass this in\r\n            return alignment.isMapped() && !alignment.isFailsVendorQualityCheck();\r\n        }\r\n\r\n    }\r\n\r\n    push(alignment) {\r\n\r\n        if (this.filter(alignment) === false) return;\r\n\r\n        this.coverageMap.incCounts(alignment);   // Count coverage before any downsampling\r\n\r\n        if (this.pairsSupported && this.downsampledReads.has(alignment.readName)) {\r\n            return;   // Mate already downsampled -- pairs are treated as a single alignment for downsampling\r\n        }\r\n\r\n        if (alignment.start >= this.currentBucket.end) {\r\n            finishBucket.call(this);\r\n            this.currentBucket = new DownsampleBucket(alignment.start, alignment.start + this.samplingWindowSize, this);\r\n        }\r\n\r\n        this.currentBucket.addAlignment(alignment);\r\n\r\n    }\r\n\r\n    forEach(callback) {\r\n        this.alignments.forEach(callback);\r\n    }\r\n\r\n    finish() {\r\n\r\n        if (this.currentBucket !== undefined) {\r\n            finishBucket.call(this);\r\n        }\r\n\r\n        // Need to remove partial pairs whose mate was downsampled\r\n        if(this.pairsSupported) {\r\n            var tmp = [], ds = this.downsampledReads;\r\n\r\n            this.alignments.forEach(function (a) {\r\n                if (!ds.has(a.readName)) {\r\n                    tmp.push(a);\r\n                }\r\n            })\r\n            this.alignments = tmp;\r\n        }\r\n\r\n        this.alignments.sort(function (a, b) {\r\n            return a.start - b.start\r\n        });\r\n\r\n        this.pairsCache = undefined;\r\n        this.downsampledReads = undefined;\r\n    }\r\n\r\n    contains(chr, start, end) {\r\n        return this.chr == chr &&\r\n            this.start <= start &&\r\n            this.end >= end;\r\n    }\r\n\r\n    hasDownsampledIntervals() {\r\n        return this.downsampledIntervals && this.downsampledIntervals.length > 0;\r\n    }\r\n}\r\n    function finishBucket() {\r\n        this.alignments = this.alignments.concat(this.currentBucket.alignments);\r\n        if (this.currentBucket.downsampledCount > 0) {\r\n            this.downsampledIntervals.push(new DownsampledInterval(\r\n                this.currentBucket.start,\r\n                this.currentBucket.end,\r\n                this.currentBucket.downsampledCount));\r\n        }\r\n        this.paired = this.paired || this.currentBucket.paired;\r\n    }\r\n\r\nclass DownsampleBucket{\r\n    constructor(start, end, alignmentContainer) {\r\n\r\n        this.start = start;\r\n        this.end = end;\r\n        this.alignments = [];\r\n        this.downsampledCount = 0;\r\n        this.samplingDepth = alignmentContainer.samplingDepth;\r\n        this.pairsSupported = alignmentContainer.pairsSupported;\r\n        this.downsampledReads = alignmentContainer.downsampledReads;\r\n        this.pairsCache = alignmentContainer.pairsCache;\r\n    }\r\n\r\n    addAlignment(alignment) {\r\n\r\n        var samplingProb, idx, replacedAlignment, pairedAlignment;\r\n\r\n        if (this.alignments.length < this.samplingDepth) {\r\n\r\n            if (this.pairsSupported && canBePaired(alignment)) {\r\n                pairedAlignment = this.pairsCache[alignment.readName];\r\n                if (pairedAlignment) {\r\n                    //Not subject to downsampling, just update the existing alignment\r\n                    pairedAlignment.setSecondAlignment(alignment);\r\n                    this.pairsCache[alignment.readName] = undefined;   // Don't need to track this anymore. NOTE: Don't \"delete\", causes runtime performance issues\r\n                }\r\n                else {\r\n                    // First alignment in a pair\r\n                    pairedAlignment = new PairedAlignment(alignment);\r\n                    this.paired = true;\r\n                    this.pairsCache[alignment.readName] = pairedAlignment;\r\n                    this.alignments.push(pairedAlignment);\r\n                }\r\n            }\r\n            else {\r\n                this.alignments.push(alignment);\r\n            }\r\n\r\n        } else {\r\n\r\n            samplingProb = this.samplingDepth / (this.samplingDepth + this.downsampledCount + 1);\r\n\r\n            if (Math.random() < samplingProb) {\r\n\r\n                idx = Math.floor(Math.random() * (this.alignments.length - 1));\r\n                replacedAlignment = this.alignments[idx];   // To be replaced\r\n\r\n                if (this.pairsSupported && canBePaired(alignment)) {\r\n\r\n                    if(this.pairsCache[replacedAlignment.readName] !== undefined) {\r\n                        this.pairsCache[replacedAlignment.readName] = undefined;\r\n                    }\r\n\r\n                    pairedAlignment = new PairedAlignment(alignment);\r\n                    this.paired = true;\r\n                    this.pairsCache[alignment.readName] = pairedAlignment;\r\n                    this.alignments[idx] = pairedAlignment;\r\n\r\n                }\r\n                else {\r\n                    this.alignments[idx] = alignment;\r\n                }\r\n                this.downsampledReads.add(replacedAlignment.readName);\r\n\r\n            }\r\n            else {\r\n                this.downsampledReads.add(alignment.readName);\r\n            }\r\n\r\n            this.downsampledCount++;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\n    // TODO -- refactor this to use an object, rather than an array,  if end-start is > some threshold\r\nclass CoverageMap{\r\n    constructor(chr, start, end) {\r\n\r\n        this.chr = chr;\r\n        this.bpStart = start;\r\n        this.length = (end - start);\r\n\r\n        this.coverage = new Array(this.length);\r\n\r\n        this.maximum = 0;\r\n\r\n       \r\n    }\r\n\r\n    incCounts(alignment) {\r\n\r\n        var self = this;\r\n\r\n        if (alignment.blocks === undefined) {\r\n\r\n            incBlockCount(alignment);\r\n        }\r\n        else {\r\n            alignment.blocks.forEach(function (block) {\r\n                incBlockCount(block);\r\n            });\r\n        }\r\n\r\n        function incBlockCount(block) {\r\n\r\n            var key,\r\n                base,\r\n                i,\r\n                j,\r\n                q;\r\n\r\n            for (i = block.start - self.bpStart, j = 0; j < block.len; i++, j++) {\r\n\r\n                if (!self.coverage[i]) {\r\n                    self.coverage[i] = new Coverage();\r\n                }\r\n\r\n                base = block.seq.charAt(j);\r\n                key = (alignment.strand) ? \"pos\" + base : \"neg\" + base;\r\n                q = block.qual[j];\r\n\r\n                self.coverage[i][key] += 1;\r\n                self.coverage[i][\"qual\" + base] += q;\r\n\r\n                self.coverage[i].total += 1;\r\n                self.coverage[i].qual += q;\r\n\r\n                self.maximum = Math.max(self.coverage[i].total, self.maximum);\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nCoverageMap.threshold = 0.2;\r\nCoverageMap.qualityWeight = true;\r\n\r\nclass Coverage{\r\n    constructor() {\r\n        this.posA = 0;\r\n        this.negA = 0;\r\n\r\n        this.posT = 0;\r\n        this.negT = 0;\r\n\r\n        this.posC = 0;\r\n        this.negC = 0;\r\n        this.posG = 0;\r\n\r\n        this.negG = 0;\r\n\r\n        this.posN = 0;\r\n        this.negN = 0;\r\n\r\n        this.pos = 0;\r\n        this.neg = 0;\r\n\r\n        this.qualA = 0;\r\n        this.qualT = 0;\r\n        this.qualC = 0;\r\n        this.qualG = 0;\r\n        this.qualN = 0;\r\n\r\n        this.qual = 0;\r\n\r\n        this.total = 0;\r\n    }\r\n\r\n    isMismatch(refBase) {\r\n\r\n        var myself = this,\r\n            mismatchQualitySum,\r\n            threshold = CoverageMap.threshold * ((CoverageMap.qualityWeight && this.qual) ? this.qual : this.total);\r\n\r\n        mismatchQualitySum = 0;\r\n        [\"A\", \"T\", \"C\", \"G\"].forEach(function (base) {\r\n\r\n            if (base !== refBase) {\r\n                mismatchQualitySum += ((CoverageMap.qualityWeight && myself.qual) ? myself[\"qual\" + base] : (myself[\"pos\" + base] + myself[\"neg\" + base]));\r\n            }\r\n        });\r\n\r\n        return mismatchQualitySum >= threshold;\r\n\r\n    }\r\n}\r\n\r\nclass DownsampledInterval{\r\n    constructor(start, end, counts) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.counts = counts;\r\n    }\r\n\r\n    popupData(genomicLocation) {\r\n        return [\r\n            {name: \"start\", value: this.start + 1},\r\n            {name: \"end\", value: this.end},\r\n            {name: \"# downsampled:\", value: this.counts}]\r\n    }\r\n}\r\n\r\n\r\nclass PairedAlignment{\r\n    constructor(firstAlignment) {\r\n\r\n        this.firstAlignment = firstAlignment;\r\n        this.chr = firstAlignment.chr;\r\n        this.readName = firstAlignment.readName;\r\n\r\n        if (firstAlignment.start < firstAlignment.mate.position) {\r\n            this.start = firstAlignment.start;\r\n            this.end = Math.max(firstAlignment.mate.position, firstAlignment.start + firstAlignment.lengthOnRef);  // Approximate\r\n            this.connectingStart = firstAlignment.start + firstAlignment.lengthOnRef;\r\n            this.connectingEnd = firstAlignment.mate.position;\r\n        }\r\n        else {\r\n            this.start = firstAlignment.mate.position;\r\n            this.end = firstAlignment.start + firstAlignment.lengthOnRef;\r\n            this.connectingStart = firstAlignment.mate.position;\r\n            this.connectingEnd = firstAlignment.start;\r\n        }\r\n        this.lengthOnRef = this.end - this.start;\r\n\r\n    }\r\n\r\n    setSecondAlignment(alignment) {\r\n\r\n        // TODO -- check the chrs are equal,  error otherwise\r\n        this.secondAlignment = alignment;\r\n\r\n        if (alignment.start > this.firstAlignment.start) {\r\n            this.end = alignment.start + alignment.lengthOnRef;\r\n            this.connectingEnd = alignment.start;\r\n        }\r\n        else {\r\n            this.start = alignment.start;\r\n            this.connectingStart = alignment.start + alignment.lengthOnRef;\r\n        }\r\n        this.lengthOnRef = this.end - this.start;\r\n\r\n\r\n    }\r\n\r\n    popupData(genomicLocation) {\r\n\r\n        var nameValues = [];\r\n\r\n        nameValues = nameValues.concat(this.firstAlignment.popupData(genomicLocation));\r\n\r\n        if (this.secondAlignment) {\r\n            nameValues.push(\"-------------------------------\");\r\n            nameValues = nameValues.concat(this.secondAlignment.popupData(genomicLocation));\r\n        }\r\n        return nameValues;\r\n    }\r\n\r\n    isPaired () {\r\n        return true; // By definition\r\n    }\r\n\r\n    firstOfPairStrand () {\r\n        if (this.firstAlignment.isFirstOfPair()) {\r\n            return this.firstAlignment.strand;\r\n        }\r\n        else if (this.secondAlignment) {\r\n            return this.secondAlignment.strand;\r\n        }\r\n        else {\r\n            return this.firstAlignment.strand;          // This assumes inward pointing pairs\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass BamAlignmentRow {\r\n    constructor(){\r\n        this.alignments = [];\r\n        this.score = undefined;\r\n    }\r\n\r\n    findCenterAlignment(bpStart, bpEnd) {\r\n\r\n        var centerAlignment = undefined;\r\n\r\n        // find single alignment that overlaps sort location\r\n        this.alignments.forEach(function(a){\r\n\r\n            if (undefined === centerAlignment) {\r\n\r\n                if ((a.start + a.lengthOnRef) < bpStart || a.start > bpEnd) {\r\n                    // do nothing\r\n                } else {\r\n                    centerAlignment = a;\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n\r\n        return centerAlignment;\r\n    }\r\n\r\n    updateScore(genomicLocation, genomicInterval, sortOption) {\r\n\r\n        this.score = this.caculateScore(genomicLocation, (1 + genomicLocation), genomicInterval, sortOption);\r\n\r\n    };\r\n\r\n    caculateScore(bpStart, bpEnd, genomicInterval, sortOption) {\r\n\r\n        var baseScore,\r\n            alignment;\r\n\r\n        alignment = this.findCenterAlignment(bpStart, bpEnd);\r\n        if (undefined === alignment) {\r\n            return Number.MAX_VALUE;\r\n        }\r\n\r\n        if (\"NUCLEOTIDE\" === sortOption.sort) {\r\n\r\n            baseScore = undefined;\r\n\r\n            alignment.blocks.forEach(function (block) {\r\n\r\n                var sequence = genomicInterval.sequence,\r\n                    coverageMap = genomicInterval.coverageMap,\r\n                    reference,\r\n                    base,\r\n                    coverage,\r\n                    count,\r\n                    phred;\r\n\r\n                if (\"*\" !== block.seq) {\r\n\r\n                    for (var i = 0, indexReferenceSequence = block.start - genomicInterval.start, bpBlockSequence = block.start, lengthBlockSequence = block.seq.length;\r\n                         i < lengthBlockSequence;\r\n                         i++, indexReferenceSequence++, bpBlockSequence++) {\r\n\r\n                        if (bpStart === bpBlockSequence) {\r\n\r\n                            reference = sequence.charAt(indexReferenceSequence);\r\n                            base = block.seq.charAt(i);\r\n\r\n                            if (base === \"=\") {\r\n                                base = reference;\r\n                            }\r\n\r\n                            if (base === 'N') {\r\n                                baseScore = 2;\r\n                            }\r\n                            else if (base === reference) {\r\n                                baseScore = 3;\r\n                            }\r\n                            else if (base === \"X\" || base !== reference){\r\n\r\n                                coverage = coverageMap.coverage[ (bpBlockSequence - coverageMap.bpStart) ];\r\n                                count = coverage[ \"pos\" + base ] + coverage[ \"neg\" + base ];\r\n                                phred = (coverage.qual) ? coverage.qual : 0;\r\n                                baseScore = -(count + (phred / 1000.0));\r\n                            } else {\r\n                                console.log(\"BamAlignmentRow.caculateScore - huh?\");\r\n                            }\r\n\r\n                        } // bpStart === bpBlockSequence\r\n\r\n                    } // block.seq.length\r\n\r\n                }\r\n                else {\r\n                    baseScore = 3;\r\n                }\r\n\r\n            });\r\n\r\n            return (undefined === baseScore) ? Number.MAX_VALUE : baseScore;\r\n        }\r\n        else if (\"STRAND\" === sortOption.sort) {\r\n\r\n            return alignment.strand ? 1 : -1;\r\n        }\r\n        else if (\"START\" === sortOption.sort) {\r\n\r\n            return alignment.start;\r\n        }\r\n\r\n        return Number.MAX_VALUE;\r\n\r\n    }\r\n}\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2JhbS5qcz9jNzU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuaW1wb3J0IHtpZ3Z4aHJ9IGZyb20gXCIuL2lndnhoci5qc1wiO1xyXG5pbXBvcnQge0JpbmFyeVBhcnNlcn0gZnJvbSBcIi4vYmlnd2lnLmpzXCI7XHJcbmltcG9ydCB7anN6bGliX2luZmxhdGVfYnVmZmVyLGFycmF5Q29weX0gZnJvbSBcIi4vdmVuZG9yL2luZmxhdGUuanNcIjtcclxuaW1wb3J0IHtGYXN0YVNlcXVlbmNlfSBmcm9tIFwiLi9mZWF0dXJlLmpzXCJcclxuXHJcblxyXG5jb25zdCBCQUlfTUFHSUMgPSAyMTU3ODA1MDtcclxuY29uc3QgVEFCSVhfTUFHSUMgPSAyMTU3ODMyNDtcclxuY29uc3QgTUFYX0hFQURFUl9TSVpFID0gMTAwMDAwMDAwOyAgIC8vIElGIHRoZSBoZWFkZXIgaXMgbGFyZ2VyIHRoYW4gdGhpcyB3ZSBjYW4ndCByZWFkIGl0ICFcclxuY29uc3QgQl9NQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpbmRleFVSTFxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHRhYml4XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlZCBmb3IgdGhlIGJhbSBvciB0YWJpeCBpbmRleC4gIFRoZSBmdWxmaWxsIGZ1bmN0aW9uIHRha2VzIHRoZSBpbmRleCBhcyBhbiBhcmd1bWVudC5cclxuICAgICAqL1xyXG5sZXQgbG9hZEJhbUluZGV4ID0gZnVuY3Rpb24gKGluZGV4VVJMLCBjb25maWcsIHRhYml4KSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2Vub21lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoaW5kZXhVUkwsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBjb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFnaWMsIG5iaW4sIG5pbnR2LCBucmVmLCBwYXJzZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tNaW4gPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTWF4ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBiaW5JbmRleCwgbGluZWFySW5kZXgsIGJpbk51bWJlciwgY3MsIGNlLCBiLCBpLCByZWYsIHNlcXVlbmNlSW5kZXhNYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0YWJpeCkge1xyXG4gICAgICAgICAgICAgICAgXHQgIGNvbnNvbGUubG9nKFpsaWIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlID0gbmV3IFpsaWIuWmxpYi5HdW56aXAobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlciA9IGluZmxhdGUuZGVjb21wcmVzcygpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgLypsZXQgciA9cGFrby5pbmZsYXRlKG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5QnVmZmVyID1yLmJ1ZmZlcjsqL1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFnaWMgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hZ2ljID09PSBCQUlfTUFHSUMgfHwgKHRhYml4ICYmIG1hZ2ljID09PSBUQUJJWF9NQUdJQykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbnJlZiA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJpeCBoZWFkZXIgcGFyYW1ldGVycyBhcmVuJ3QgdXNlZCwgYnV0IHRoZXkgbXVzdCBiZSByZWFkIHRvIGFkdmFuY2UgdGhlIHBvaW50ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbF9zZXEgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xfYmVnID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sX2VuZCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbF9ubSA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSW5kZXhNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5yZWY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcV9uYW1lID0gcGFyc2VyLmdldFN0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBcIm9mZmljaWFsXCIgY2hyIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2Vub21lKSBzZXFfbmFtZSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShzZXFfbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJbmRleE1hcFtzZXFfbmFtZV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHJlZiA9IDA7IHJlZiA8IG5yZWY7ICsrcmVmKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmJpbiA9IHBhcnNlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoYiA9IDA7IGIgPCBuYmluOyArK2IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5OdW1iZXIgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbk51bWJlciA9PSAzNzQ1MCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwc3VlZG8gYmluLCBub3QgdXNlZCBidXQgd2UgaGF2ZSB0byBjb25zdW1lIHRoZSBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5jaG5rID0gcGFyc2VyLmdldEludCgpOyAvLyAjIG9mIGNodW5rcyBmb3IgdGhpcyBiaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpOyAgIC8vIHVubWFwcGVkIGJlZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlID0gcGFyc2VyLmdldFZQb2ludGVyKCk7ICAgLy8gdW5tYXBwZWQgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5fbWFwZWQgPSBwYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuVW5tYXBwZWQgPSBwYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4W2Jpbk51bWJlcl0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmNobmsgPSBwYXJzZXIuZ2V0SW50KCk7IC8vICMgb2YgY2h1bmtzIGZvciB0aGlzIGJpblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmNobms7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZSA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3MgJiYgY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcy5ibG9jayA8IGJsb2NrTWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNaW4gPSBjcy5ibG9jazsgICAgLy8gQmxvY2sgY29udGFpbmluZyBmaXJzdCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZS5ibG9jayA+IGJsb2NrTWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tNYXggPSBjZS5ibG9jaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4W2Jpbk51bWJlcl0ucHVzaChbY3MsIGNlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaW50diA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5pbnR2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gcGFyc2VyLmdldFZQb2ludGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleC5wdXNoKGNzKTsgICAvLyBNaWdodCBiZSBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYmluID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlc1tyZWZdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbkluZGV4OiBiaW5JbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lYXJJbmRleDogbGluZWFySW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbmRleFVSTCArIFwiIGlzIG5vdCBhIFwiICsgKHRhYml4ID8gXCJ0YWJpeFwiIDogXCJiYWlcIikgKyBcIiBmaWxlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChuZXcgQmFtSW5kZXgoaW5kaWNlcywgYmxvY2tNaW4sIHNlcXVlbmNlSW5kZXhNYXAsIHRhYml4KSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcblxyXG5jbGFzcyBCYW1JbmRleHtcclxuICAgIGNvbnN0cnVjdG9yIChpbmRpY2VzLCBibG9ja01pbiwgc2VxdWVuY2VJbmRleE1hcCwgdGFiaXgpIHtcclxuICAgICAgICB0aGlzLmZpcnN0QWxpZ25tZW50QmxvY2sgPSBibG9ja01pbjtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VJbmRleE1hcCA9IHNlcXVlbmNlSW5kZXhNYXA7XHJcbiAgICAgICAgdGhpcy50YWJpeCA9IHRhYml4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2ggYmxvY2tzIGZvciBhIHBhcnRpY3VsYXIgZ2Vub21pYyByYW5nZS4gIFRoaXMgbWV0aG9kIGlzIHB1YmxpYyBzbyBpdCBjYW4gYmUgdW5pdC10ZXN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlZklkICB0aGUgc2VxdWVuY2UgZGljdGlvbmFyeSBpbmRleCBvZiB0aGUgY2hyb21vc29tZVxyXG4gICAgICogQHBhcmFtIG1pbiAgZ2Vub21pYyBzdGFydCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIG1heCAgZ2Vub21pYyBlbmQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSByZXR1cm4gYW4gYXJyYXkgb2Yge21pbnY6IHtmaWxlUG9pbnRlciwgb2Zmc2V0fSwge21heHY6IHtmaWxlUG9pbnRlciwgb2Zmc2V0fX1cclxuICAgICAqL1xyXG4gICAgYmxvY2tzRm9yUmFuZ2UocmVmSWQsIG1pbiwgbWF4KSB7XHJcblxyXG4gICAgICAgIHZhciBiYW0gPSB0aGlzLFxyXG4gICAgICAgICAgICBiYSA9IGJhbS5pbmRpY2VzW3JlZklkXSxcclxuICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zLFxyXG4gICAgICAgICAgICBsZWFmQ2h1bmtzLFxyXG4gICAgICAgICAgICBvdGhlckNodW5rcyxcclxuICAgICAgICAgICAgbmludHYsXHJcbiAgICAgICAgICAgIGxvd2VzdCxcclxuICAgICAgICAgICAgbWluTGluLFxyXG4gICAgICAgICAgICBtYXhMaW4sXHJcbiAgICAgICAgICAgIGxiLFxyXG4gICAgICAgICAgICBwcnVuZWRPdGhlckNodW5rcyxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgY2huayxcclxuICAgICAgICAgICAgZGlmLFxyXG4gICAgICAgICAgICBpbnRDaHVua3MsXHJcbiAgICAgICAgICAgIG1lcmdlZENodW5rcztcclxuXHJcbiAgICAgICAgaWYgKCFiYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zID0gQmFtSW5kZXgucmVnMmJpbnMobWluLCBtYXgpOyAgICAgICAgLy8gTGlzdCBvZiBiaW4gI3MgdGhhdCBtaWdodCBvdmVybGFwIG1pbiwgbWF4XHJcbiAgICAgICAgICAgIGxlYWZDaHVua3MgPSBbXTtcclxuICAgICAgICAgICAgb3RoZXJDaHVua3MgPSBbXTtcclxuXHJcblxyXG4gICAgICAgICAgICBvdmVybGFwcGluZ0JpbnMuZm9yRWFjaChmdW5jdGlvbiAoYmluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtzID0gYmEuYmluSW5kZXhbYmluXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmNobmsgPSBjaHVua3MubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5jaG5rOyArK2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzID0gY2h1bmtzW2NdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2UgPSBjaHVua3NbY11bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChiaW4gPCA0NjgxID8gb3RoZXJDaHVua3MgOiBsZWFmQ2h1bmtzKS5wdXNoKHttaW52OiBjcywgbWF4djogY2UsIGJpbjogYmlufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGxpbmVhciBpbmRleCB0byBmaW5kIHRoZSBsb3dlc3QgY2h1bmsgdGhhdCBjb3VsZCBjb250YWluIGFsaWdubWVudHMgaW4gdGhlIHJlZ2lvblxyXG4gICAgICAgICAgICBuaW50diA9IGJhLmxpbmVhckluZGV4Lmxlbmd0aDtcclxuICAgICAgICAgICAgbG93ZXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgbWluTGluID0gTWF0aC5taW4obWluID4+IDE0LCBuaW50diAtIDEpLCBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgbGIgPSBiYS5saW5lYXJJbmRleFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICghbGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbG93ZXN0IHx8IGxiLmJsb2NrIDwgbG93ZXN0LmJsb2NrIHx8IGxiLm9mZnNldCA8IGxvd2VzdC5vZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb3dlc3QgPSBsYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJ1bmUgY2h1bmtzIHRoYXQgZW5kIGJlZm9yZSB0aGUgbG93ZXN0IGNodW5rXHJcbiAgICAgICAgICAgIHBydW5lZE90aGVyQ2h1bmtzID0gW107XHJcbiAgICAgICAgICAgIGlmIChsb3dlc3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG90aGVyQ2h1bmtzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2huayA9IG90aGVyQ2h1bmtzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaG5rLm1heHYuYmxvY2sgPiBsb3dlc3QuYmxvY2sgfHwgKGNobmsubWF4di5ibG9jayA9PSBsb3dlc3QuYmxvY2sgJiYgY2huay5tYXh2Lm9mZnNldCA+PSBsb3dlc3Qub2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcnVuZWRPdGhlckNodW5rcy5wdXNoKGNobmspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50Q2h1bmtzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcnVuZWRPdGhlckNodW5rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaW50Q2h1bmtzLnB1c2gocHJ1bmVkT3RoZXJDaHVua3NbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZWFmQ2h1bmtzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRDaHVua3MucHVzaChsZWFmQ2h1bmtzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaW50Q2h1bmtzLnNvcnQoZnVuY3Rpb24gKGMwLCBjMSkge1xyXG4gICAgICAgICAgICAgICAgZGlmID0gYzAubWludi5ibG9jayAtIGMxLm1pbnYuYmxvY2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlmO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYzAubWludi5vZmZzZXQgLSBjMS5taW52Lm9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBtZXJnZWRDaHVua3MgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGludENodW5rcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyID0gaW50Q2h1bmtzWzBdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbnRDaHVua3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmMgPSBpbnRDaHVua3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuYy5taW52LmJsb2NrIC0gY3VyLm1heHYuYmxvY2spIDwgNjUwMDApIHsgLy8gTWVyZ2UgYmxvY2tzIHRoYXQgYXJlIHdpdGhpbmcgNjVrIG9mIGVhY2ggb3RoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0ge21pbnY6IGN1ci5taW52LCBtYXh2OiBuYy5tYXh2fTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBuYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjdXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXJnZWRDaHVua3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBsaXN0IG9mIGJpbnMgdGhhdCBtYXkgb3ZlcmxhcCB3aXRoIHJlZ2lvbiBbYmVnLCBlbmRdXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVnMmJpbnMoYmVnLCBlbmQpIHtcclxuICAgICAgICB2YXIgaSA9IDAsIGssIGxpc3QgPSBbXTtcclxuICAgICAgICBpZiAoZW5kID49IDEgPDwgMjkpICAgZW5kID0gMSA8PCAyOTtcclxuICAgICAgICAtLWVuZDtcclxuICAgICAgICBsaXN0LnB1c2goMCk7XHJcbiAgICAgICAgZm9yIChrID0gMSArIChiZWcgPj4gMjYpOyBrIDw9IDEgKyAoZW5kID4+IDI2KTsgKytrKSBsaXN0LnB1c2goayk7XHJcbiAgICAgICAgZm9yIChrID0gOSArIChiZWcgPj4gMjMpOyBrIDw9IDkgKyAoZW5kID4+IDIzKTsgKytrKSBsaXN0LnB1c2goayk7XHJcbiAgICAgICAgZm9yIChrID0gNzMgKyAoYmVnID4+IDIwKTsgayA8PSA3MyArIChlbmQgPj4gMjApOyArK2spIGxpc3QucHVzaChrKTtcclxuICAgICAgICBmb3IgKGsgPSA1ODUgKyAoYmVnID4+IDE3KTsgayA8PSA1ODUgKyAoZW5kID4+IDE3KTsgKytrKSBsaXN0LnB1c2goayk7XHJcbiAgICAgICAgZm9yIChrID0gNDY4MSArIChiZWcgPj4gMTQpOyBrIDw9IDQ2ODEgKyAoZW5kID4+IDE0KTsgKytrKSBsaXN0LnB1c2goayk7XHJcbiAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQkdaRmlsZXtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5maWxlUG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIG5leHRCbG9jaygpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiBzZWxmLmZpbGVQb3NpdGlvbiwgc2l6ZTogQkxPQ0tfSEVBREVSX0xFTkdUSH0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHZhciB4bGVuID0gKGJhWzExXSA8PCA4KSB8IChiYVsxMF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgICAgIHZhciBzaTIgPSBiYVsxM107XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xlbiA9IChiYVsxNV0gPDwgOCkgfCAoYmFbMTRdKTtcclxuICAgICAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5maWxlUG9zaXRpb24gKz0gQkxPQ0tfSEVBREVSX0xFTkdUSDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYucGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc2VsZi5maWxlUG9zaXRpb24sIHNpemU6IGJzaXplfSxcclxuICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG5cclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmMgPSBqc3psaWJfaW5mbGF0ZV9idWZmZXIoYXJyYXlCdWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZpbGVQb3NpdGlvbiArPSAoYnNpemUgKyA4KTsgIC8vIFwiOFwiIGZvciBDUkMtMzIgYW5kIHNpemUgb2YgdW5jb21wcmVzc2VkIGRhdGFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbCh1bmMpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdClcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4gICAgdmFyIEJBTV9NQUdJQyA9IDIxODQwMTk0O1xyXG4gICAgdmFyIFNFQ1JFVF9ERUNPREVSID0gWyc9JywgJ0EnLCAnQycsICd4JywgJ0cnLCAneCcsICd4JywgJ3gnLCAnVCcsICd4JywgJ3gnLCAneCcsICd4JywgJ3gnLCAneCcsICdOJ107XHJcbiAgICB2YXIgQ0lHQVJfREVDT0RFUiA9IFsnTScsICdJJywgJ0QnLCAnTicsICdTJywgJ0gnLCAnUCcsICc9JywgJ1gnLCAnPycsICc/JywgJz8nLCAnPycsICc/JywgJz8nLCAnPyddO1xyXG4gICAgdmFyIFJFQURfU1RSQU5EX0ZMQUcgPSAweDEwO1xyXG4gICAgdmFyIE1BVEVfU1RSQU5EX0ZMQUcgPSAweDIwO1xyXG4gICAgdmFyIEZJUlNUX09GX1BBSVJfRkxBRyA9IDB4NDA7XHJcbiAgICB2YXIgU0VDT05EX09GX1BBSVJfRkxBRyA9IDB4ODA7XHJcbiAgICB2YXIgUkVBRF9VTk1BUFBFRF9GTEFHID0gMHg0O1xyXG4gICAgdmFyIE1BVEVfVU5NQVBQRURfRkxBRyA9IDB4ODtcclxuICAgIHZhciBSRUFEX1BBSVJFRF9GTEFHID0gMHgxO1xyXG4gICAgdmFyIFBST1BFUl9QQUlSX0ZMQUcgPSAweDI7XHJcbiAgICB2YXIgU0VDT05EQVJZX0FMSUdOTU5FVF9GTEFHID0gMHgxMDA7XHJcbiAgICB2YXIgU1VQUExFTUVOVEFSWV9BTElHTk1FTlRfRkxBRyA9IDB4ODAwO1xyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciBOT1RfUFJJTUFSWV9BTElHTk1FTlRfRkxBRyA9IDB4MTAwO1xyXG4gICAgdmFyIFJFQURfRkFJTFNfVkVORE9SX1FVQUxJVFlfQ0hFQ0tfRkxBRyA9IDB4MjAwO1xyXG4gICAgdmFyIERVUExJQ0FURV9SRUFEX0ZMQUcgPSAweDQwMDtcclxuICAgIHZhciBTVVBQTEVNRU5UQVJZX0ZMQUcgPSAweDgwMDtcclxuXHJcbiAgICBjb25zdCBNQVhfR1pJUF9CTE9DS19TSVpFID0gNjU1MzY7ICAgLy8gIEFQUEFSRU5UTFkuICBXaGVyZSBpcyB0aGlzIGRvY3VtZW50ZWQ/Pz9cclxuICAgIGNvbnN0IERFRkFVTFRfU0FNUExJTkdfV0lORE9XX1NJWkUgPSAxMDA7XHJcbiAgICBjb25zdCBERUZBVUxUX1NBTVBMSU5HX0RFUFRIID0gNTA7XHJcbiAgICBjb25zdCBNQVhJTVVNX1NBTVBMSU5HX0RFUFRIID0gMjUwMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsYXNzIGZvciByZWFkaW5nIGEgYmFtIGZpbGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gY2xhc3MgQmFtUmVhZGVye1xyXG4gICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG5cclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBjb25maWcuZmlsdGVyIHx8IG5ldyBCYW1GaWx0ZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYW1QYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICAvLyBUb2RvIC0gZGVhbCB3aXRoIFBpY2FyZCBjb252ZW50aW9uLiAgV0hZIERPRVMgVEhFUkUgSEFWRSBUTyBCRSAyP1xyXG4gICAgICAgIHRoaXMuYmFpUGF0aCA9IGNvbmZpZy5pbmRleFVSTCB8fCB0aGlzLmJhbVBhdGggKyBcIi5iYWlcIjsgLy8gSWYgdGhlcmUgaXMgYW4gaW5kZXhVUkwgcHJvdmlkZWQsIHVzZSBpdCFcclxuICAgICAgICB0aGlzLmhlYWRQYXRoID0gY29uZmlnLmhlYWRVUkwgfHwgdGhpcy5iYW1QYXRoO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ1dpbmRvd1NpemUgPSBjb25maWcuc2FtcGxpbmdXaW5kb3dTaXplID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1NBTVBMSU5HX1dJTkRPV19TSVpFIDogY29uZmlnLnNhbXBsaW5nV2luZG93U2l6ZTtcclxuICAgICAgICB0aGlzLnNhbXBsaW5nRGVwdGggPSBjb25maWcuc2FtcGxpbmdEZXB0aCA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9TQU1QTElOR19ERVBUSCA6IGNvbmZpZy5zYW1wbGluZ0RlcHRoO1xyXG4gICAgICAgIGlmKHRoaXMuc2FtcGxpbmdEZXB0aCA+IE1BWElNVU1fU0FNUExJTkdfREVQVEgpIHtcclxuICAgICAgICAgICAgaWd2LmxvZyhcIldhcm5pbmc6IGF0dGVtcHQgdG8gc2V0IHNhbXBsaW5nIGRlcHRoID4gbWF4aW11bSB2YWx1ZSBvZiAyNTAwXCIpO1xyXG4gICAgICAgICAgICB0aGlzLnNhbXBsaW5nRGVwdGggPSBNQVhJTVVNX1NBTVBMSU5HX0RFUFRIO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICB0aGlzLnBhaXJzU3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnNTdXBwb3J0ZWQgPSBjb25maWcucGFpcnNTdXBwb3J0ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcucGFpcnNTdXBwb3J0ZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZWFkQWxpZ25tZW50cyhjaHIsIGJwU3RhcnQsIGJwRW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBnZXRDaHJJbmRleChzZWxmKS50aGVuKGZ1bmN0aW9uIChjaHJUb0luZGV4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNocklkID0gY2hyVG9JbmRleFtjaHJdLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIgPSBuZXcgQWxpZ25tZW50Q29udGFpbmVyKGNociwgYnBTdGFydCwgYnBFbmQsIHNlbGYuc2FtcGxpbmdXaW5kb3dTaXplLCBzZWxmLnNhbXBsaW5nRGVwdGgsIHNlbGYucGFpcnNTdXBwb3J0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGNocklkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnZXRJbmRleChzZWxmKS50aGVuKGZ1bmN0aW9uIChiYW1JbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rcyA9IGJhbUluZGV4LmJsb2Nrc0ZvclJhbmdlKGNocklkLCBicFN0YXJ0LCBicEVuZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2h1bmtzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRXJyb3IgcmVhZGluZyBiYW0gaW5kZXhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZldGNoTWluID0gYy5taW52LmJsb2NrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaE1heCA9IGMubWF4di5ibG9jayArIE1BWF9HWklQX0JMT0NLX1NJWkUsICAgLy8gTWFrZSBzdXJlIHdlIGdldCB0aGUgd2hvbGUgYmxvY2suXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge3N0YXJ0OiBmZXRjaE1pbiwgc2l6ZTogZmV0Y2hNYXggLSBmZXRjaE1pbiArIDF9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYuYmFtUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KG5ldyB1bmJnemYoY29tcHJlc3NlZCkpOyAvL25ldyBVaW50OEFycmF5KGlndi51bmJnemYoY29tcHJlc3NlZCkpOyAvLywgYy5tYXh2LmJsb2NrIC0gYy5taW52LmJsb2NrICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVCYW1SZWNvcmRzKGJhLCBjLm1pbnYub2Zmc2V0LCBhbGlnbm1lbnRDb250YWluZXIsIGJwU3RhcnQsIGJwRW5kLCBjaHJJZCwgc2VsZi5maWx0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLmZpbmlzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUJhbVJlY29yZHMoYmEsIG9mZnNldCwgYWxpZ25tZW50Q29udGFpbmVyLCBtaW4sIG1heCwgY2hySWQsIGZpbHRlcikge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIGJsb2NrRW5kLFxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LFxyXG4gICAgICAgICAgICAgICAgYmxvY2tzLFxyXG4gICAgICAgICAgICAgICAgcmVmSUQsXHJcbiAgICAgICAgICAgICAgICBwb3MsXHJcbiAgICAgICAgICAgICAgICBibW4sXHJcbiAgICAgICAgICAgICAgICBiaW4sXHJcbiAgICAgICAgICAgICAgICBtcSxcclxuICAgICAgICAgICAgICAgIG5sLFxyXG4gICAgICAgICAgICAgICAgZmxhZ19uYyxcclxuICAgICAgICAgICAgICAgIGZsYWcsXHJcbiAgICAgICAgICAgICAgICBuYyxcclxuICAgICAgICAgICAgICAgIGxzZXEsXHJcbiAgICAgICAgICAgICAgICBtYXRlUmVmSUQsXHJcbiAgICAgICAgICAgICAgICBtYXRlUG9zLFxyXG4gICAgICAgICAgICAgICAgcmVhZE5hbWUsXHJcbiAgICAgICAgICAgICAgICBqLFxyXG4gICAgICAgICAgICAgICAgcCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmLFxyXG4gICAgICAgICAgICAgICAgY2lnYXIsXHJcbiAgICAgICAgICAgICAgICBjLFxyXG4gICAgICAgICAgICAgICAgY2lnYXJBcnJheSxcclxuICAgICAgICAgICAgICAgIHNlcSxcclxuICAgICAgICAgICAgICAgIHNlcUJ5dGVzO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBibG9ja1NpemUgPSByZWFkSW50KGJhLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2tFbmQgPSBvZmZzZXQgKyBibG9ja1NpemUgKyA0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChibG9ja0VuZCA+IGJhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBuZXcgQmFtQWxpZ25tZW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVmSUQgPSByZWFkSW50KGJhLCBvZmZzZXQgKyA0KTtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHJlZklEIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAvLyB1bm1hcHBlZCByZWFkc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmSUQgPiBjaHJJZCB8fCBwb3MgPiBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAgIC8vIG9mZiByaWdodCBlZGdlLCB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZJRCA8IGNocklkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7ICAgLy8gdG8gbGVmdCBvZiBzdGFydCwgbm90IHN1cmUgdGhpcyBpcyBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJtbiA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDEyKTtcclxuICAgICAgICAgICAgICAgIGJpbiA9IChibW4gJiAweGZmZmYwMDAwKSA+PiAxNjtcclxuICAgICAgICAgICAgICAgIG1xID0gKGJtbiAmIDB4ZmYwMCkgPj4gODtcclxuICAgICAgICAgICAgICAgIG5sID0gYm1uICYgMHhmZjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbGFnX25jID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMTYpO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IChmbGFnX25jICYgMHhmZmZmMDAwMCkgPj4gMTY7XHJcbiAgICAgICAgICAgICAgICBuYyA9IGZsYWdfbmMgJiAweGZmZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LmZsYWdzID0gZmxhZztcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5zdHJhbmQgPSAhKGZsYWcgJiBSRUFEX1NUUkFORF9GTEFHKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsc2VxID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjApO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdGVSZWZJRCA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDI0KTtcclxuICAgICAgICAgICAgICAgIG1hdGVQb3MgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAyOCk7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuZnJhZ21lbnRMZW5ndGggPSByZWFkSW50KGJhLCBvZmZzZXQgKyAzMik7XHJcblxyXG4gICAgICAgICAgICAgICAgcmVhZE5hbWUgPSAnJztcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBubCAtIDE7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWROYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbb2Zmc2V0ICsgMzYgKyBqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcCA9IG9mZnNldCArIDM2ICsgbmw7XHJcblxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoT25SZWYgPSAwO1xyXG4gICAgICAgICAgICAgICAgY2lnYXIgPSAnJztcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgY2lnYXJBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjID0gMDsgYyA8IG5jOyArK2MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2lnb3AgPSByZWFkSW50KGJhLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BMZW4gPSAoY2lnb3AgPj4gNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wTHRyID0gQ0lHQVJfREVDT0RFUltjaWdvcCAmIDB4Zl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wTHRyID09ICdNJyB8fCBvcEx0ciA9PSAnRVEnIHx8IG9wTHRyID09ICdYJyB8fCBvcEx0ciA9PSAnRCcgfHwgb3BMdHIgPT0gJ04nIHx8IG9wTHRyID09ICc9JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoT25SZWYgKz0gb3BMZW47XHJcbiAgICAgICAgICAgICAgICAgICAgY2lnYXIgPSBjaWdhciArIG9wTGVuICsgb3BMdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaWdhckFycmF5LnB1c2goe2xlbjogb3BMZW4sIGx0cjogb3BMdHJ9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5jaWdhciA9IGNpZ2FyO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Lmxlbmd0aE9uUmVmID0gbGVuZ3RoT25SZWY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZiA8IG1pbikgY29udGludWU7ICAvLyBSZWNvcmQgb3V0LW9mLXJhbmdlIFwidG8gdGhlIGxlZnRcIiwgc2tpcCB0byBuZXh0IG9uZVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBzZXEgPSAnJztcclxuICAgICAgICAgICAgICAgIHNlcUJ5dGVzID0gKGxzZXEgKyAxKSA+PiAxO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHNlcUJ5dGVzOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2IgPSBiYVtwICsgal07XHJcbiAgICAgICAgICAgICAgICAgICAgc2VxICs9IFNFQ1JFVF9ERUNPREVSWyhzYiAmIDB4ZjApID4+IDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcSArPSBTRUNSRVRfREVDT0RFUlsoc2IgJiAweDBmKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXEgPSBzZXEuc3Vic3RyaW5nKDAsIGxzZXEpOyAgLy8gc2VxIG1pZ2h0IGhhdmUgb25lIGV4dHJhIGNoYXJhY3RlciAoaWYgbHNlcSBpcyBhbiBvZGQgbnVtYmVyKVxyXG5cclxuICAgICAgICAgICAgICAgIHAgKz0gc2VxQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuc2VxID0gc2VxO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobHNlcSA9PT0gMSAmJiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyBqXSArIDMzKSA9PT0gXCIqXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPID09IGhvdyB0byByZXByZXNlbnQgdGhpcz9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5xdWFsID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxzZXE7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQucXVhbC5wdXNoKGJhW3AgKyBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcCArPSBsc2VxO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuc3RhcnQgPSBwb3M7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQubXEgPSBtcTtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5yZWFkTmFtZSA9IHJlYWROYW1lO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LmNociA9IHNlbGYuaW5kZXhUb0NocltyZWZJRF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGVSZWZJRCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Lm1hdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocjogc2VsZi5pbmRleFRvQ2hyW21hdGVSZWZJRF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBtYXRlUG9zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJhbmQ6ICEoZmxhZyAmIE1BVEVfU1RSQU5EX0ZMQUcpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnRhZ0JBID0gbmV3IFVpbnQ4QXJyYXkoYmEuYnVmZmVyLnNsaWNlKHAsIGJsb2NrRW5kKSk7ICAvLyBkZWNvZGUgdGhpZXNlIG9uIGRlbWFuZFxyXG4gICAgICAgICAgICAgICAgcCArPSBibG9ja0VuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW1pbiB8fCBhbGlnbm1lbnQuc3RhcnQgPD0gbWF4ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmID49IG1pbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci5wYXNzKGFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hySWQgPT09IHVuZGVmaW5lZCB8fCByZWZJRCA9PSBjaHJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MgPSBtYWtlQmxvY2tzKGFsaWdubWVudCwgY2lnYXJBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MgPSBibG9ja3MuYmxvY2tzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQuaW5zZXJ0aW9ucyA9IGJsb2Nrcy5pbnNlcnRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGJsb2NrRW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEV4aXRzIHZpYSB0b3Agb2YgbG9vcC5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNwbGl0IHRoZSBhbGlnbm1lbnQgcmVjb3JkIGludG8gYmxvY2tzIGFzIHNwZWNpZmllZCBpbiB0aGUgY2lnYXJBcnJheS4gIEVhY2ggYWxpZ25lZCBibG9jayBjb250YWluc1xyXG4gICAgICAgICAqIGl0cyBwb3J0aW9uIG9mIHRoZSByZWFkIHNlcXVlbmNlIGFuZCBiYXNlIHF1YWxpdHkgc3RyaW5ncy4gIEEgcmVhZCBzZXF1ZW5jZSBvciBiYXNlIHF1YWxpdHkgc3RyaW5nXHJcbiAgICAgICAgICogb2YgXCIqXCIgaW5kaWNhdGVzIHRoZSB2YWx1ZSBpcyBub3QgcmVjb3JkZWQuICBJbiBhbGwgb3RoZXIgY2FzZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmxvY2sgc2VxdWVuY2UgKGJsb2NrLnNlcSlcclxuICAgICAgICAgKiBhbmQgcXVhbGl0eSBzdHJpbmcgKGJsb2NrLnF1YWwpIG11c3QgPT0gdGhlIGJsb2NrIGxlbmd0aC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5PVEU6IEluc2VydGlvbnMgYXJlIG5vdCB5ZXQgdHJlYXRlZCAvLyBUT0RPXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gcmVjb3JkXHJcbiAgICAgICAgICogQHBhcmFtIGNpZ2FyQXJyYXlcclxuICAgICAgICAgKiBAcmV0dXJucyBhcnJheSBvZiBibG9ja3NcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtYWtlQmxvY2tzKHJlY29yZCwgY2lnYXJBcnJheSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsb2NrcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9ucyxcclxuICAgICAgICAgICAgICAgIHNlcU9mZnNldCA9IDAsXHJcbiAgICAgICAgICAgICAgICBwb3MgPSByZWNvcmQuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBjaWdhckFycmF5Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGJsb2NrU2VxLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tRdWFscyxcclxuICAgICAgICAgICAgICAgIGdhcFR5cGUsXHJcbiAgICAgICAgICAgICAgICBtaW5RID0gNSwgIC8vcHJlZnMuZ2V0QXNJbnQoUHJlZmVyZW5jZU1hbmFnZXIuU0FNX0JBU0VfUVVBTElUWV9NSU4pXHJcbiAgICAgICAgICAgICAgICBtYXhRID0gMjA7IC8vcHJlZnMuZ2V0QXNJbnQoUHJlZmVyZW5jZU1hbmFnZXIuU0FNX0JBU0VfUVVBTElUWV9NQVgpXHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjaWdhckFycmF5W2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYy5sdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZ25vcmUgaGFyZCBjbGlwc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1AnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIGlnbm9yZSBwYWRzXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUycgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFPZmZzZXQgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcFR5cGUgPSAnUyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBzb2Z0IGNsaXAgcmVhZCBiYXNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ04nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgIC8vIHJlZmVyZW5jZSBza2lwXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcFR5cGUgPSAnRCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0knIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTZXEgPSByZWNvcmQuc2VxID09PSBcIipcIiA/IFwiKlwiIDogcmVjb3JkLnNlcS5zdWJzdHIoc2VxT2Zmc2V0LCBjLmxlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMgPSByZWNvcmQucXVhbCA/IHJlY29yZC5xdWFsLnNsaWNlKHNlcU9mZnNldCwgYy5sZW4pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9ucyA9PT0gdW5kZWZpbmVkKSBpbnNlcnRpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnMucHVzaCh7c3RhcnQ6IHBvcywgbGVuOiBjLmxlbiwgc2VxOiBibG9ja1NlcSwgcXVhbDogYmxvY2tRdWFsc30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFPZmZzZXQgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nIDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdFUScgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nIDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdYJyA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NlcSA9IHJlY29yZC5zZXEgPT09IFwiKlwiID8gXCIqXCIgOiByZWNvcmQuc2VxLnN1YnN0cihzZXFPZmZzZXQsIGMubGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tRdWFscyA9IHJlY29yZC5xdWFsID8gcmVjb3JkLnF1YWwuc2xpY2Uoc2VxT2Zmc2V0LCBjLmxlbikgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHtzdGFydDogcG9zLCBsZW46IGMubGVuLCBzZXE6IGJsb2NrU2VxLCBxdWFsOiBibG9ja1F1YWxzLCBnYXBUeXBlOiBnYXBUeXBlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcU9mZnNldCArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGMubGVuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHByb2Nlc3NpbmcgY2lnYXIgZWxlbWVudDogXCIgKyBjLmxlbiArIGMubHRyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtibG9ja3M6IGJsb2NrcywgaW5zZXJ0aW9uczogaW5zZXJ0aW9uc307XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWFkSGVhZGVyKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBnZXRJbmRleChzZWxmKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBpbmRleC5maXJzdEFsaWdubWVudEJsb2NrICsgTUFYX0daSVBfQkxPQ0tfU0laRTsgICAvLyBJbnN1cmUgd2UgZ2V0IHRoZSBjb21wbGV0ZSBjb21wcmVzc2VkIGJsb2NrIGNvbnRhaW5pbmcgdGhlIGhlYWRlclxyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5iYW1QYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycyxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IDAsIHNpemU6IGxlbn0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbXByZXNzZWRCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVuYyA9IG5ldyB1bmJnemYoY29tcHJlc3NlZEJ1ZmZlciwgbGVuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5jYmEgPSBuZXcgVWludDhBcnJheSh1bmMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWdpYyA9IHJlYWRJbnQodW5jYmEsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1IZWFkZXJMZW4gPSByZWFkSW50KHVuY2JhLCA0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtSGVhZGVyID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbm9tZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtSGVhZGVyTGVuOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtSGVhZGVyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5jYmFbaSArIDhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuUmVmID0gcmVhZEludCh1bmNiYSwgc2FtSGVhZGVyTGVuICsgOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBzYW1IZWFkZXJMZW4gKyAxMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJUb0luZGV4ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleFRvQ2hyID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUmVmOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxOYW1lID0gcmVhZEludCh1bmNiYSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbE5hbWUgLSAxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmNiYVtwICsgNCArIGpdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbFJlZiA9IHJlYWRJbnQodW5jYmEsIHAgKyBsTmFtZSArIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Rsb2cobmFtZSArICc6ICcgKyBsUmVmKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5vbWUgJiYgZ2Vub21lLmdldENocm9tb3NvbWVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gZ2Vub21lLmdldENocm9tb3NvbWVOYW1lKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNoclRvSW5kZXhbbmFtZV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4VG9DaHIucHVzaChuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwICsgOCArIGxOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiAgICBmdW5jdGlvbiBnZXRJbmRleChiYW0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChiYW0uaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxvYWRCYW1JbmRleChiYW0uYmFpUGF0aCwgYmFtLmNvbmZpZykudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYW0uaW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChiYW0uaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDaHJJbmRleChiYW0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChiYW0uY2hyVG9JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChiYW0uY2hyVG9JbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiYW0ucmVhZEhlYWRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmNoclRvSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlYWRJbnQoYmEsIG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiAoYmFbb2Zmc2V0ICsgM10gPDwgMjQpIHwgKGJhW29mZnNldCArIDJdIDw8IDE2KSB8IChiYVtvZmZzZXQgKyAxXSA8PCA4KSB8IChiYVtvZmZzZXRdKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWFkU2hvcnQoYmEsIG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiAoYmFbb2Zmc2V0ICsgMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1Tb3VyY2V7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRDb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5tYXhSb3dzID0gY29uZmlnLm1heFJvd3MgfHwgMTAwMDtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlX3NvdXJjZT1uZXcgRmFzdGFTZXF1ZW5jZShjb25maWcuc2VxX3VybCk7XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuc291cmNlVHlwZSA9PT0gXCJnYTRnaFwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFtUmVhZGVyID0gbmV3IGlndi5HYTRnaEFsaWdubWVudFJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5iYW1SZWFkZXIgPSBuZXcgQmFtUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIHRoaXMudmlld0FzUGFpcnMgPSBjb25maWcudmlld0FzUGFpcnM7XHJcbiAgICB9O1xyXG5cclxuICAgIHNldFZpZXdBc1BhaXJzKGJvb2wpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnZpZXdBc1BhaXJzICE9PSBib29sKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld0FzUGFpcnMgPSBib29sO1xyXG4gICAgICAgICAgICAvLyBUT0RPIC0tIHJlcGFpciBhbGlnbm1lbnRzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFsaWdubWVudENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsaWdubWVudENvbnRhaW5lciA9IHRoaXMuYWxpZ25tZW50Q29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGJvb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gcGFpckFsaWdubWVudHMoYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cyA9IHVucGFpckFsaWdubWVudHMoYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnBhY2tlZEFsaWdubWVudFJvd3MgPSBwYWNrQWxpZ25tZW50Um93cyhhbGlnbm1lbnRzLCBhbGlnbm1lbnRDb250YWluZXIuc3RhcnQsIGFsaWdubWVudENvbnRhaW5lci5lbmQsIHNlbGYubWF4Um93cyk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldEFsaWdubWVudHMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmFsaWdubWVudENvbnRhaW5lciAmJiBzZWxmLmFsaWdubWVudENvbnRhaW5lci5jb250YWlucyhjaHIsIGJwU3RhcnQsIGJwRW5kKSkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5iYW1SZWFkZXIucmVhZEFsaWdubWVudHMoY2hyLCBicFN0YXJ0LCBicEVuZCkudGhlbihmdW5jdGlvbiAoYWxpZ25tZW50Q29udGFpbmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhSb3dzID0gc2VsZi5jb25maWcubWF4Um93cyB8fCA1MDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMgPSBhbGlnbm1lbnRDb250YWluZXIuYWxpZ25tZW50cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnZpZXdBc1BhaXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMgPSB1bnBhaXJBbGlnbm1lbnRzKFt7YWxpZ25tZW50czogYWxpZ25tZW50c31dKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzID0gcGFja0FsaWdubWVudFJvd3MoYWxpZ25tZW50cywgYWxpZ25tZW50Q29udGFpbmVyLnN0YXJ0LCBhbGlnbm1lbnRDb250YWluZXIuZW5kLCBtYXhSb3dzKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5hbGlnbm1lbnRzID0gdW5kZWZpbmVkOyAgLy8gRG9uJ3QgbmVlZCB0byBob2xkIG9udG8gdGhlc2UgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWxpZ25tZW50Q29udGFpbmVyID0gYWxpZ25tZW50Q29udGFpbmVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgIHNlbGYuc2VxdWVuY2Vfc291cmNlLmdldFNlcXVlbmNlKGFsaWdubWVudENvbnRhaW5lci5jaHIsIGFsaWdubWVudENvbnRhaW5lci5zdGFydCwgYWxpZ25tZW50Q29udGFpbmVyLmVuZCkudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHNlcXVlbmNlKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuY292ZXJhZ2VNYXAucmVmU2VxID0gc2VxdWVuY2U7ICAgIC8vIFRPRE8gLS0gZml4IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuc2VxdWVuY2UgPSBzZXF1ZW5jZTsgICAgICAgICAgIC8vIFRPRE8gLS0gZml4IHRoaXNcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiAgICBmdW5jdGlvbiBwYWlyQWxpZ25tZW50cyhyb3dzKSB7XHJcblxyXG4gICAgICAgIHZhciBwYWlyQ2FjaGUgPSB7fSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW107XHJcblxyXG4gICAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XHJcblxyXG4gICAgICAgICAgICByb3cuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYW5CZVBhaXJlZChhbGlnbm1lbnQpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IHBhaXJDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyZWRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50LnNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXSA9IHVuZGVmaW5lZDsgICAvLyBEb24ndCBuZWVkIHRvIHRyYWNrIHRoaXMgYW55bW9yZS5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IG5ldyBpZ3YuUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYWlyZWRBbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHVucGFpckFsaWdubWVudHMocm93cykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgICAgICByb3cuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQgaW5zdGFuY2VvZiBQYWlyZWRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KSByZXN1bHQucHVzaChhbGlnbm1lbnQuZmlyc3RBbGlnbm1lbnQpOyAgLy8gc2hvdWxkbid0IG5lZWQgdGhlIG51bGwgdGVzdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc2Vjb25kQWxpZ25tZW50KSByZXN1bHQucHVzaChhbGlnbm1lbnQuc2Vjb25kQWxpZ25tZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNhbkJlUGFpcmVkKGFsaWdubWVudCkge1xyXG4gICAgICAgIHJldHVybiBhbGlnbm1lbnQuaXNQYWlyZWQoKSAmJlxyXG4gICAgICAgICAgICBhbGlnbm1lbnQuaXNNYXRlTWFwcGVkKCkgJiZcclxuICAgICAgICAgICAgYWxpZ25tZW50LmNociA9PT0gYWxpZ25tZW50Lm1hdGUuY2hyICYmXHJcbiAgICAgICAgICAgIChhbGlnbm1lbnQuaXNGaXJzdE9mUGFpcigpIHx8IGFsaWdubWVudC5pc1NlY29uZE9mUGFpcigpKSAmJiAhKGFsaWdubWVudC5pc1NlY29uZGFyeSgpIHx8IGFsaWdubWVudC5pc1N1cHBsZW1lbnRhcnkoKSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHBhY2tBbGlnbm1lbnRSb3dzKGFsaWdubWVudHMsIHN0YXJ0LCBlbmQsIG1heFJvd3MpIHtcclxuXHJcbiAgICAgICAgaWYgKCFhbGlnbm1lbnRzKSByZXR1cm47XHJcblxyXG4gICAgICAgIGFsaWdubWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJ1Y2tldExpc3QgPSBbXSxcclxuICAgICAgICAgICAgICAgIGFsbG9jYXRlZENvdW50ID0gMCxcclxuICAgICAgICAgICAgICAgIGxhc3RBbGxvY2F0ZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSBzdGFydCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdyxcclxuICAgICAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICAgICAgYnVja2V0LFxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LFxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50U3BhY2UgPSA0ICogMixcclxuICAgICAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudFJvd3MgPSBbXSxcclxuICAgICAgICAgICAgICAgIGJ1Y2tldFN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIGFsaWdubWVudHNbMF0uc3RhcnQpO1xyXG5cclxuICAgICAgICAgICAgYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYnVja0xpc3RJbmRleCA9IE1hdGgubWF4KDAsIGFsaWdubWVudC5zdGFydCAtIGJ1Y2tldFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChidWNrZXRMaXN0W2J1Y2tMaXN0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2J1Y2tMaXN0SW5kZXhdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2J1Y2tMaXN0SW5kZXhdLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGFsbG9jYXRlZENvdW50IDwgYWxpZ25tZW50cy5sZW5ndGggJiYgcGFja2VkQWxpZ25tZW50Um93cy5sZW5ndGggPCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Um93ID0gbmV3IEJhbUFsaWdubWVudFJvdygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0U3RhcnQgPD0gZW5kKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFidWNrZXQgJiYgbmV4dFN0YXJ0IDw9IGVuZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0U3RhcnQgLSBidWNrZXRTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1Y2tldExpc3RbaW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbmV4dFN0YXJ0OyAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudHMgYXQgdGhpcyBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gYnVja2V0TGlzdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyB3aGlsZSAoYnVja2V0KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1Y2tldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gYnVja2V0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBidWNrZXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldExpc3RbaW5kZXhdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Um93LmFsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZiArIGFsaWdubWVudFNwYWNlO1xyXG4gICAgICAgICAgICAgICAgICAgICsrYWxsb2NhdGVkQ291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgfSAvLyB3aGlsZSAobmV4dFN0YXJ0KVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnRSb3cuYWxpZ25tZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFja2VkQWxpZ25tZW50Um93cy5wdXNoKGFsaWdubWVudFJvdyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gYnVja2V0U3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGFsbG9jYXRlZENvdW50ID09PSBsYXN0QWxsb2NhdGVkQ291bnQpIGJyZWFrOyAgIC8vIFByb3RlY3QgZnJvbSBpbmZpbml0ZSBsb29wc1xyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RBbGxvY2F0ZWRDb3VudCA9IGFsbG9jYXRlZENvdW50O1xyXG5cclxuICAgICAgICAgICAgfSAvLyB3aGlsZSAoYWxsb2NhdGVkQ291bnQpXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFja2VkQWxpZ25tZW50Um93cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbmNsYXNzIEJhbUFsaWdubWVudHtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpc01hcHBlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1VOTUFQUEVEX0ZMQUcpID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQYWlyZWQgKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfUEFJUkVEX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQcm9wZXJQYWlyICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBQUk9QRVJfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmlyc3RPZlBhaXIoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgRklSU1RfT0ZfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2Vjb25kT2ZQYWlyKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFNFQ09ORF9PRl9QQUlSX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNTZWNvbmRhcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgU0VDT05EQVJZX0FMSUdOTU5FVF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU3VwcGxlbWVudGFyeSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBTVVBQTEVNRU5UQVJZX0FMSUdOTUVOVF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUkVBRF9GQUlMU19WRU5ET1JfUVVBTElUWV9DSEVDS19GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRHVwbGljYXRlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIERVUExJQ0FURV9SRUFEX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXRlTWFwcGVkKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIE1BVEVfVU5NQVBQRURfRkxBRykgPT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc05lZ2F0aXZlU3RyYW5kKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfU1RSQU5EX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXRlTmVnYXRpdmVTdHJhbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgTUFURV9TVFJBTkRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICB0YWdzKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVUYWdzKGJhKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcCA9IDAsXHJcbiAgICAgICAgICAgICAgICBsZW4gPSBiYS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICB0YWdzID0ge307XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocCA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcF0pICsgU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAyXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ0EnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3AgKyAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaScgfHwgdHlwZSA9PT0gJ0knKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkSW50KGJhLCBwICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA3O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYycgfHwgdHlwZSA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiYVtwICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncycgfHwgdHlwZSA9PT0gJ1MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkU2hvcnQoYmEsIHAgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gJ0ZJWE1FIG5lZWQgZmxvYXRzJztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRGbG9hdChiYSwgcCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1onKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNjID0gYmFbcCsrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLydVbmtub3duIHR5cGUgJyArIHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnRXJyb3IgdW5rbm93biB0eXBlOiAnICsgdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YWdzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLnRhZ0RpY3QpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGFnQkEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnRGljdCA9IGRlY29kZVRhZ3ModGhpcy50YWdCQSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0JBID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdEaWN0ID0ge307ICAvLyBNYXJrIHNvIHdlIGRvbid0IHRyeSBhZ2Fpbi4gIFRoZSByZWNvcmQgaGFzIG5vdCB0YWdzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnRGljdDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikge1xyXG5cclxuICAgICAgICAvLyBpZiB0aGUgdXNlciBjbGlja3Mgb24gYSBiYXNlIG5leHQgdG8gYW4gaW5zZXJ0aW9uLCBzaG93IGp1c3QgdGhlXHJcbiAgICAgICAgLy8gaW5zZXJ0ZWQgYmFzZXMgaW4gYSBwb3B1cCAobGlrZSBpbiBkZXNrdG9wIElHVikuXHJcbiAgICAgICAgdmFyIG5hbWVWYWx1ZXMgPSBbXSwgaXNGaXJzdCwgdGFnRGljdDtcclxuXHJcbiAgICAgICAgaWYodGhpcy5pbnNlcnRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmluc2VydGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnNfc3RhcnQgPSB0aGlzLmluc2VydGlvbnNbaV0uc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZihnZW5vbWljTG9jYXRpb24gPT0gaW5zX3N0YXJ0IHx8IGdlbm9taWNMb2NhdGlvbiA9PSBpbnNfc3RhcnQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnSW5zZXJ0aW9uJywgdmFsdWU6IHRoaXMuaW5zZXJ0aW9uc1tpXS5zZXEgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHtuYW1lOiAnTG9jYXRpb24nLCB2YWx1ZTogaW5zX3N0YXJ0IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lVmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnUmVhZCBOYW1lJywgdmFsdWU6IHRoaXMucmVhZE5hbWUgfSk7XHJcblxyXG4gICAgICAgIC8vIFNhbXBsZVxyXG4gICAgICAgIC8vIFJlYWQgZ3JvdXBcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG5cclxuICAgICAgICAvLyBBZGQgMSB0byBnZW5vbWljIGxvY2F0aW9uIHRvIG1hcCBmcm9tIDAtYmFzZWQgY29tcHV0ZXIgdW5pdHMgdG8gdXNlci1iYXNlZCB1bml0c1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdBbGlnbm1lbnQgU3RhcnQnLCB2YWx1ZTogaWd2Lm51bWJlckZvcm1hdHRlcigxICsgdGhpcy5zdGFydCksIGJvcmRlclRvcDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1JlYWQgU3RyYW5kJywgdmFsdWU6ICh0cnVlID09PSB0aGlzLnN0cmFuZCA/ICcoKyknIDogJygtKScpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ0NpZ2FyJywgdmFsdWU6IHRoaXMuY2lnYXIgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hcHBlZCcsIHZhbHVlOiB5ZXNObyh0aGlzLmlzTWFwcGVkKCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXBwaW5nIFF1YWxpdHknLCB2YWx1ZTogdGhpcy5tcSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnU2Vjb25kYXJ5JywgdmFsdWU6IHllc05vKHRoaXMuaXNTZWNvbmRhcnkoKSkgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1N1cHBsZW1lbnRhcnknLCB2YWx1ZTogeWVzTm8odGhpcy5pc1N1cHBsZW1lbnRhcnkoKSkgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ0R1cGxpY2F0ZScsIHZhbHVlOiB5ZXNObyh0aGlzLmlzRHVwbGljYXRlKCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdGYWlsZWQgUUMnLCB2YWx1ZTogeWVzTm8odGhpcy5pc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkpIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1BhaXJlZCgpKSB7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaChcIjxocj5cIik7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdGaXJzdCBpbiBQYWlyJywgdmFsdWU6ICF0aGlzLmlzU2Vjb25kT2ZQYWlyKCksIGJvcmRlclRvcDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgaXMgTWFwcGVkJywgdmFsdWU6IHllc05vKHRoaXMuaXNNYXRlTWFwcGVkKCkpIH0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc01hdGVNYXBwZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgQ2hyb21vc29tZScsIHZhbHVlOiB0aGlzLm1hdGUuY2hyIH0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgU3RhcnQnLCB2YWx1ZTogKHRoaXMubWF0ZS5wb3NpdGlvbiArIDEpfSk7XHJcbiAgICAgICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnTWF0ZSBTdHJhbmQnLCB2YWx1ZTogKHRydWUgPT09IHRoaXMubWF0ZS5zdHJhbmQgPyAnKCspJyA6ICcoLSknKX0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ0luc2VydCBTaXplJywgdmFsdWU6IHRoaXMuZnJhZ21lbnRMZW5ndGggfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRlIFN0YXJ0XHJcbiAgICAgICAgICAgICAgICAvLyBNYXRlIFN0cmFuZFxyXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IFNpemVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGaXJzdCBpbiBQYWlyXHJcbiAgICAgICAgICAgIC8vIFBhaXIgT3JpZW50YXRpb25cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG4gICAgICAgIHRhZ0RpY3QgPSB0aGlzLnRhZ3MoKTtcclxuICAgICAgICBpc0ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGFnRGljdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRhZ0RpY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdGFnRGljdFtrZXldLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiBrZXksIHZhbHVlOiB0YWdEaWN0W2tleV0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHllc05vKGJvb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wgPyAnWWVzJyA6ICdObyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuICAgXHJcblxyXG4gICBcclxuXHJcbiAgICBmdW5jdGlvbiByZWFkRmxvYXQoYmEsIG9mZnNldCkge1xyXG5cclxuICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYmEuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEJhbUZpbHRlcntcclxuXHJcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLnZlbmRvckZhaWxlZCA9IG9wdGlvbnMudmVuZG9yRmFpbGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy52ZW5kb3JGYWlsZWQ7XHJcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVzID0gb3B0aW9ucy5kdXBsaWNhdGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5kdXBsaWNhdGVzO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5ID0gb3B0aW9ucy5zZWNvbmRhcnkgfHwgZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdXBwbGVtZW50YXJ5ID0gb3B0aW9ucy5zdXBwbGVtZW50YXJ5IHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubXFUaHJlc2hvbGQgPSBvcHRpb25zLm1xVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5tcVRocmVzaG9sZDtcclxuICAgIH1cclxuXHJcbiAgICBwYXNzKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy52ZW5kb3JGYWlsZWQgJiYgYWxpZ25tZW50LmlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLmR1cGxpY2F0ZXMgJiYgYWxpZ25tZW50LmlzRHVwbGljYXRlKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnkgJiYgYWxpZ25tZW50LmlzU2Vjb25kYXJ5KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zdXBwbGVtZW50YXJ5ICYmIGFsaWdubWVudC5pc1N1cHBsZW1lbnRhcnkoKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmIChhbGlnbm1lbnQubXEgPCB0aGlzLm1xVGhyZXNob2xkKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbiAgICB2YXIgQkxPQ0tfSEVBREVSX0xFTkdUSCA9IDE4O1xyXG4gICAgdmFyIEJMT0NLX0xFTkdUSF9PRkZTRVQgPSAxNjsgIC8vIExvY2F0aW9uIGluIHRoZSBnemlwIGJsb2NrIG9mIHRoZSB0b3RhbCBibG9jayBzaXplIChhY3R1YWxseSB0b3RhbCBibG9jayBzaXplIC0gMSlcclxuICAgIHZhciBCTE9DS19GT09URVJfTEVOR1RIID0gODsgLy8gTnVtYmVyIG9mIGJ5dGVzIHRoYXQgZm9sbG93IHRoZSBkZWZsYXRlZCBkYXRhXHJcbiAgICB2YXIgTUFYX0NPTVBSRVNTRURfQkxPQ0tfU0laRSA9IDY0ICogMTAyNDsgLy8gV2UgcmVxdWlyZSB0aGF0IGEgY29tcHJlc3NlZCBibG9jayAoaW5jbHVkaW5nIGhlYWRlciBhbmQgZm9vdGVyLCBiZSA8PSB0aGlzKVxyXG4gICAgdmFyIEdaSVBfT1ZFUkhFQUQgPSBCTE9DS19IRUFERVJfTEVOR1RIICsgQkxPQ0tfRk9PVEVSX0xFTkdUSCArIDI7IC8vIEd6aXAgb3ZlcmhlYWQgaXMgdGhlIGhlYWRlciwgdGhlIGZvb3RlciwgYW5kIHRoZSBibG9jayBzaXplIChlbmNvZGVkIGFzIGEgc2hvcnQpLlxyXG4gICAgdmFyIEdaSVBfSUQxID0gMzE7ICAgLy8gTWFnaWMgbnVtYmVyXHJcbiAgICB2YXIgR1pJUF9JRDIgPSAxMzk7ICAvLyBNYWdpYyBudW1iZXJcclxuICAgIHZhciBHWklQX0ZMRyA9IDQ7IC8vIEZFWFRSQSBmbGFnIG1lYW5zIHRoZXJlIGFyZSBvcHRpb25hbCBmaWVsZHNcclxuXHJcblxyXG4gICAgLy8gVW5jb21wcmVzcyBkYXRhLCAgYXNzdW1lZCB0byBiZSBzZXJpZXMgb2YgYmd6aXBwZWQgYmxvY2tzXHJcbiAgICAvLyBDb2RlIGlzIGJhc2VkIGhlYXZpbHkgb24gYmFtLmpzLCBwYXJ0IG9mIHRoZSBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyLCAgKGMpIFRob21hcyBEb3duIDIwMDYtMjAwMS5cclxuY2xhc3MgdW5iZ3pme1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgbGltKSB7XHJcbiAgICAgICAgZm9yIChsZXQgYSBpbiBkYXRhKXtcclxuICAgICAgICAgICBjb25zb2xlLmxvZyhhKTtcclxuICAgICAgICAgfVxyXG4gICAgICAgIHZhciBvQmxvY2tMaXN0ID0gW10sXHJcbiAgICAgICAgICAgIHB0ciA9IFswXSxcclxuICAgICAgICAgICAgdG90YWxTaXplID0gMDtcclxuXHJcbiAgICAgICAgbGltID0gbGltIHx8IGRhdGEuYnl0ZUxlbmd0aCAtIDE4O1xyXG5cclxuICAgICAgICB3aGlsZSAocHRyWzBdIDwgbGltKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShkYXRhLCBwdHJbMF0sIDE4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciB4bGVuID0gKGJhWzExXSA8PCA4KSB8IChiYVsxMF0pO1xyXG4gICAgICAgICAgICB2YXIgc2kxID0gYmFbMTJdO1xyXG4gICAgICAgICAgICB2YXIgc2kyID0gYmFbMTNdO1xyXG4gICAgICAgICAgICB2YXIgc2xlbiA9IChiYVsxNV0gPDwgOCkgfCAoYmFbMTRdKTtcclxuICAgICAgICAgICAgdmFyIGJzaXplID0gKGJhWzE3XSA8PCA4KSB8IChiYVsxNl0pICsgMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDEyICsgeGxlbiArIHB0clswXTsgICAgLy8gU3RhcnQgb2YgQ0RBVEFcclxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIHN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IChic2l6ZSArIDgpKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgIHZhciB1bmMgPSBqc3psaWJfaW5mbGF0ZV9idWZmZXIoZGF0YSwgc3RhcnQsIGxlbmd0aCwgcHRyKTtcclxuXHJcbiAgICAgICAgICAgIHB0clswXSArPSA4OyAgICAvLyBTa2lwcGluZyBDUkMtMzIgYW5kIHNpemUgb2YgdW5jb21wcmVzc2VkIGRhdGFcclxuXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSB1bmMuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgb0Jsb2NrTGlzdC5wdXNoKHVuYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb25jYXRlbmF0ZSBkZWNvbXByZXNzZWQgYmxvY2tzXHJcbiAgICAgICAgaWYgKG9CbG9ja0xpc3QubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9CbG9ja0xpc3RbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRvdGFsU2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9CbG9ja0xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkob0Jsb2NrTGlzdFtpXSk7XHJcbiAgICAgICAgICAgICAgICBhcnJheUNvcHkoYiwgMCwgb3V0LCBjdXJzb3IsIGIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGN1cnNvciArPSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgQWxpZ25tZW50Q29udGFpbmVye1xyXG4gICAgY29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kLCBzYW1wbGluZ1dpbmRvd1NpemUsIHNhbXBsaW5nRGVwdGgsIHBhaXJzU3VwcG9ydGVkKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2hyID0gY2hyO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IChlbmQgLSBzdGFydCk7XHJcblxyXG4gICAgICAgIHRoaXMuY292ZXJhZ2VNYXAgPSBuZXcgQ292ZXJhZ2VNYXAoY2hyLCBzdGFydCwgZW5kKTtcclxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdXaW5kb3dTaXplID0gc2FtcGxpbmdXaW5kb3dTaXplID09PSB1bmRlZmluZWQgPyAxMDAgOiBzYW1wbGluZ1dpbmRvd1NpemU7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gc2FtcGxpbmdEZXB0aCA9PT0gdW5kZWZpbmVkID8gNTAgOiBzYW1wbGluZ0RlcHRoO1xyXG5cclxuICAgICAgICB0aGlzLnBhaXJzU3VwcG9ydGVkID0gcGFpcnNTdXBwb3J0ZWQ7XHJcbiAgICAgICAgdGhpcy5wYWlyZWQgPSBmYWxzZTsgIC8vIGZhbHNlIHVudGlsIHByb3ZlbiBvdGhlcndpc2VcclxuICAgICAgICB0aGlzLnBhaXJzQ2FjaGUgPSB7fTsgIC8vIHdvcmtpbmcgY2FjaGUgb2YgcGFpcmVkIGFsaWdubWVudHMgYnkgcmVhZCBuYW1lXHJcblxyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRSZWFkcyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0ID0gbmV3IERvd25zYW1wbGVCdWNrZXQodGhpcy5zdGFydCwgdGhpcy5zdGFydCArIHRoaXMuc2FtcGxpbmdXaW5kb3dTaXplLCB0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIoYWxpZ25tZW50KSB7ICAgICAgICAgLy8gVE9ETyAtLSBwYXNzIHRoaXMgaW5cclxuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5pc01hcHBlZCgpICYmICFhbGlnbm1lbnQuaXNGYWlsc1ZlbmRvclF1YWxpdHlDaGVjaygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVzaChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKGFsaWdubWVudCkgPT09IGZhbHNlKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuY292ZXJhZ2VNYXAuaW5jQ291bnRzKGFsaWdubWVudCk7ICAgLy8gQ291bnQgY292ZXJhZ2UgYmVmb3JlIGFueSBkb3duc2FtcGxpbmdcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucGFpcnNTdXBwb3J0ZWQgJiYgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmhhcyhhbGlnbm1lbnQucmVhZE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgICAvLyBNYXRlIGFscmVhZHkgZG93bnNhbXBsZWQgLS0gcGFpcnMgYXJlIHRyZWF0ZWQgYXMgYSBzaW5nbGUgYWxpZ25tZW50IGZvciBkb3duc2FtcGxpbmdcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgPj0gdGhpcy5jdXJyZW50QnVja2V0LmVuZCkge1xyXG4gICAgICAgICAgICBmaW5pc2hCdWNrZXQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0ID0gbmV3IERvd25zYW1wbGVCdWNrZXQoYWxpZ25tZW50LnN0YXJ0LCBhbGlnbm1lbnQuc3RhcnQgKyB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmN1cnJlbnRCdWNrZXQuYWRkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmFsaWdubWVudHMuZm9yRWFjaChjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgZmluaXNoKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QnVja2V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZmluaXNoQnVja2V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOZWVkIHRvIHJlbW92ZSBwYXJ0aWFsIHBhaXJzIHdob3NlIG1hdGUgd2FzIGRvd25zYW1wbGVkXHJcbiAgICAgICAgaWYodGhpcy5wYWlyc1N1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICB2YXIgdG1wID0gW10sIGRzID0gdGhpcy5kb3duc2FtcGxlZFJlYWRzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZHMuaGFzKGEucmVhZE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IHRtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnBhaXJzQ2FjaGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5zKGNociwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNociA9PSBjaHIgJiZcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA8PSBzdGFydCAmJlxyXG4gICAgICAgICAgICB0aGlzLmVuZCA+PSBlbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgaGFzRG93bnNhbXBsZWRJbnRlcnZhbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bnNhbXBsZWRJbnRlcnZhbHMgJiYgdGhpcy5kb3duc2FtcGxlZEludGVydmFscy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG59XHJcbiAgICBmdW5jdGlvbiBmaW5pc2hCdWNrZXQoKSB7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gdGhpcy5hbGlnbm1lbnRzLmNvbmNhdCh0aGlzLmN1cnJlbnRCdWNrZXQuYWxpZ25tZW50cyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJ1Y2tldC5kb3duc2FtcGxlZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzLnB1c2gobmV3IERvd25zYW1wbGVkSW50ZXJ2YWwoXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCdWNrZXQuc3RhcnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCdWNrZXQuZW5kLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmRvd25zYW1wbGVkQ291bnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYWlyZWQgPSB0aGlzLnBhaXJlZCB8fCB0aGlzLmN1cnJlbnRCdWNrZXQucGFpcmVkO1xyXG4gICAgfVxyXG5cclxuY2xhc3MgRG93bnNhbXBsZUJ1Y2tldHtcclxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQsIGFsaWdubWVudENvbnRhaW5lcikge1xyXG5cclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5kb3duc2FtcGxlZENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNhbXBsaW5nRGVwdGggPSBhbGlnbm1lbnRDb250YWluZXIuc2FtcGxpbmdEZXB0aDtcclxuICAgICAgICB0aGlzLnBhaXJzU3VwcG9ydGVkID0gYWxpZ25tZW50Q29udGFpbmVyLnBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRSZWFkcyA9IGFsaWdubWVudENvbnRhaW5lci5kb3duc2FtcGxlZFJlYWRzO1xyXG4gICAgICAgIHRoaXMucGFpcnNDYWNoZSA9IGFsaWdubWVudENvbnRhaW5lci5wYWlyc0NhY2hlO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEFsaWdubWVudChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNhbXBsaW5nUHJvYiwgaWR4LCByZXBsYWNlZEFsaWdubWVudCwgcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5hbGlnbm1lbnRzLmxlbmd0aCA8IHRoaXMuc2FtcGxpbmdEZXB0aCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucGFpcnNTdXBwb3J0ZWQgJiYgY2FuQmVQYWlyZWQoYWxpZ25tZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50ID0gdGhpcy5wYWlyc0NhY2hlW2FsaWdubWVudC5yZWFkTmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Ob3Qgc3ViamVjdCB0byBkb3duc2FtcGxpbmcsIGp1c3QgdXBkYXRlIHRoZSBleGlzdGluZyBhbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQuc2V0U2Vjb25kQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyc0NhY2hlW2FsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7ICAgLy8gRG9uJ3QgbmVlZCB0byB0cmFjayB0aGlzIGFueW1vcmUuIE5PVEU6IERvbid0IFwiZGVsZXRlXCIsIGNhdXNlcyBydW50aW1lIHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgYWxpZ25tZW50IGluIGEgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IG5ldyBQYWlyZWRBbGlnbm1lbnQoYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyc0NhY2hlW2FsaWdubWVudC5yZWFkTmFtZV0gPSBwYWlyZWRBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRzLnB1c2gocGFpcmVkQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5wdXNoKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHNhbXBsaW5nUHJvYiA9IHRoaXMuc2FtcGxpbmdEZXB0aCAvICh0aGlzLnNhbXBsaW5nRGVwdGggKyB0aGlzLmRvd25zYW1wbGVkQ291bnQgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgc2FtcGxpbmdQcm9iKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRoaXMuYWxpZ25tZW50cy5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlZEFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50c1tpZHhdOyAgIC8vIFRvIGJlIHJlcGxhY2VkXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFpcnNTdXBwb3J0ZWQgJiYgY2FuQmVQYWlyZWQoYWxpZ25tZW50KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnBhaXJzQ2FjaGVbcmVwbGFjZWRBbGlnbm1lbnQucmVhZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyc0NhY2hlW3JlcGxhY2VkQWxpZ25tZW50LnJlYWROYW1lXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IG5ldyBQYWlyZWRBbGlnbm1lbnQoYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyc0NhY2hlW2FsaWdubWVudC5yZWFkTmFtZV0gPSBwYWlyZWRBbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRzW2lkeF0gPSBwYWlyZWRBbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnbm1lbnRzW2lkeF0gPSBhbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMuYWRkKHJlcGxhY2VkQWxpZ25tZW50LnJlYWROYW1lKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMuYWRkKGFsaWdubWVudC5yZWFkTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuZG93bnNhbXBsZWRDb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4gICAgLy8gVE9ETyAtLSByZWZhY3RvciB0aGlzIHRvIHVzZSBhbiBvYmplY3QsIHJhdGhlciB0aGFuIGFuIGFycmF5LCAgaWYgZW5kLXN0YXJ0IGlzID4gc29tZSB0aHJlc2hvbGRcclxuY2xhc3MgQ292ZXJhZ2VNYXB7XHJcbiAgICBjb25zdHJ1Y3RvcihjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jaHIgPSBjaHI7XHJcbiAgICAgICAgdGhpcy5icFN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAoZW5kIC0gc3RhcnQpO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tYXhpbXVtID0gMDtcclxuXHJcbiAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBpbmNDb3VudHMoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKGFsaWdubWVudC5ibG9ja3MgPT09IHVuZGVmaW5lZCkge1xyXG5cclxuICAgICAgICAgICAgaW5jQmxvY2tDb3VudChhbGlnbm1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWxpZ25tZW50LmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xyXG4gICAgICAgICAgICAgICAgaW5jQmxvY2tDb3VudChibG9jayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW5jQmxvY2tDb3VudChibG9jaykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGtleSxcclxuICAgICAgICAgICAgICAgIGJhc2UsXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgICAgIHE7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSBibG9jay5zdGFydCAtIHNlbGYuYnBTdGFydCwgaiA9IDA7IGogPCBibG9jay5sZW47IGkrKywgaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNvdmVyYWdlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb3ZlcmFnZVtpXSA9IG5ldyBDb3ZlcmFnZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJhc2UgPSBibG9jay5zZXEuY2hhckF0KGopO1xyXG4gICAgICAgICAgICAgICAga2V5ID0gKGFsaWdubWVudC5zdHJhbmQpID8gXCJwb3NcIiArIGJhc2UgOiBcIm5lZ1wiICsgYmFzZTtcclxuICAgICAgICAgICAgICAgIHEgPSBibG9jay5xdWFsW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV1ba2V5XSArPSAxO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb3ZlcmFnZVtpXVtcInF1YWxcIiArIGJhc2VdICs9IHE7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5jb3ZlcmFnZVtpXS50b3RhbCArPSAxO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5jb3ZlcmFnZVtpXS5xdWFsICs9IHE7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5tYXhpbXVtID0gTWF0aC5tYXgoc2VsZi5jb3ZlcmFnZVtpXS50b3RhbCwgc2VsZi5tYXhpbXVtKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbkNvdmVyYWdlTWFwLnRocmVzaG9sZCA9IDAuMjtcclxuQ292ZXJhZ2VNYXAucXVhbGl0eVdlaWdodCA9IHRydWU7XHJcblxyXG5jbGFzcyBDb3ZlcmFnZXtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucG9zQSA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdBID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NUID0gMDtcclxuICAgICAgICB0aGlzLm5lZ1QgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnBvc0MgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnQyA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3NHID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5uZWdHID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NOID0gMDtcclxuICAgICAgICB0aGlzLm5lZ04gPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnBvcyA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWcgPSAwO1xyXG5cclxuICAgICAgICB0aGlzLnF1YWxBID0gMDtcclxuICAgICAgICB0aGlzLnF1YWxUID0gMDtcclxuICAgICAgICB0aGlzLnF1YWxDID0gMDtcclxuICAgICAgICB0aGlzLnF1YWxHID0gMDtcclxuICAgICAgICB0aGlzLnF1YWxOID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5xdWFsID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNaXNtYXRjaChyZWZCYXNlKSB7XHJcblxyXG4gICAgICAgIHZhciBteXNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBtaXNtYXRjaFF1YWxpdHlTdW0sXHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IENvdmVyYWdlTWFwLnRocmVzaG9sZCAqICgoQ292ZXJhZ2VNYXAucXVhbGl0eVdlaWdodCAmJiB0aGlzLnF1YWwpID8gdGhpcy5xdWFsIDogdGhpcy50b3RhbCk7XHJcblxyXG4gICAgICAgIG1pc21hdGNoUXVhbGl0eVN1bSA9IDA7XHJcbiAgICAgICAgW1wiQVwiLCBcIlRcIiwgXCJDXCIsIFwiR1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChiYXNlKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFzZSAhPT0gcmVmQmFzZSkge1xyXG4gICAgICAgICAgICAgICAgbWlzbWF0Y2hRdWFsaXR5U3VtICs9ICgoQ292ZXJhZ2VNYXAucXVhbGl0eVdlaWdodCAmJiBteXNlbGYucXVhbCkgPyBteXNlbGZbXCJxdWFsXCIgKyBiYXNlXSA6IChteXNlbGZbXCJwb3NcIiArIGJhc2VdICsgbXlzZWxmW1wibmVnXCIgKyBiYXNlXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBtaXNtYXRjaFF1YWxpdHlTdW0gPj0gdGhyZXNob2xkO1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgRG93bnNhbXBsZWRJbnRlcnZhbHtcclxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQsIGNvdW50cykge1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLmNvdW50cyA9IGNvdW50cztcclxuICAgIH1cclxuXHJcbiAgICBwb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAge25hbWU6IFwic3RhcnRcIiwgdmFsdWU6IHRoaXMuc3RhcnQgKyAxfSxcclxuICAgICAgICAgICAge25hbWU6IFwiZW5kXCIsIHZhbHVlOiB0aGlzLmVuZH0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcIiMgZG93bnNhbXBsZWQ6XCIsIHZhbHVlOiB0aGlzLmNvdW50c31dXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5jbGFzcyBQYWlyZWRBbGlnbm1lbnR7XHJcbiAgICBjb25zdHJ1Y3RvcihmaXJzdEFsaWdubWVudCkge1xyXG5cclxuICAgICAgICB0aGlzLmZpcnN0QWxpZ25tZW50ID0gZmlyc3RBbGlnbm1lbnQ7XHJcbiAgICAgICAgdGhpcy5jaHIgPSBmaXJzdEFsaWdubWVudC5jaHI7XHJcbiAgICAgICAgdGhpcy5yZWFkTmFtZSA9IGZpcnN0QWxpZ25tZW50LnJlYWROYW1lO1xyXG5cclxuICAgICAgICBpZiAoZmlyc3RBbGlnbm1lbnQuc3RhcnQgPCBmaXJzdEFsaWdubWVudC5tYXRlLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBmaXJzdEFsaWdubWVudC5zdGFydDtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBNYXRoLm1heChmaXJzdEFsaWdubWVudC5tYXRlLnBvc2l0aW9uLCBmaXJzdEFsaWdubWVudC5zdGFydCArIGZpcnN0QWxpZ25tZW50Lmxlbmd0aE9uUmVmKTsgIC8vIEFwcHJveGltYXRlXHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ1N0YXJ0ID0gZmlyc3RBbGlnbm1lbnQuc3RhcnQgKyBmaXJzdEFsaWdubWVudC5sZW5ndGhPblJlZjtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nRW5kID0gZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBmaXJzdEFsaWdubWVudC5tYXRlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0ICsgZmlyc3RBbGlnbm1lbnQubGVuZ3RoT25SZWY7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ1N0YXJ0ID0gZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW5nRW5kID0gZmlyc3RBbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVuZ3RoT25SZWYgPSB0aGlzLmVuZCAtIHRoaXMuc3RhcnQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgLy8gVE9ETyAtLSBjaGVjayB0aGUgY2hycyBhcmUgZXF1YWwsICBlcnJvciBvdGhlcndpc2VcclxuICAgICAgICB0aGlzLnNlY29uZEFsaWdubWVudCA9IGFsaWdubWVudDtcclxuXHJcbiAgICAgICAgaWYgKGFsaWdubWVudC5zdGFydCA+IHRoaXMuZmlyc3RBbGlnbm1lbnQuc3RhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWY7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGFsaWdubWVudC5zdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBhbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ1N0YXJ0ID0gYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aE9uUmVmID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikge1xyXG5cclxuICAgICAgICB2YXIgbmFtZVZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgICBuYW1lVmFsdWVzID0gbmFtZVZhbHVlcy5jb25jYXQodGhpcy5maXJzdEFsaWdubWVudC5wb3B1cERhdGEoZ2Vub21pY0xvY2F0aW9uKSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzID0gbmFtZVZhbHVlcy5jb25jYXQodGhpcy5zZWNvbmRBbGlnbm1lbnQucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuICAgIH1cclxuXHJcbiAgICBpc1BhaXJlZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEJ5IGRlZmluaXRpb25cclxuICAgIH1cclxuXHJcbiAgICBmaXJzdE9mUGFpclN0cmFuZCAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RBbGlnbm1lbnQuaXNGaXJzdE9mUGFpcigpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0QWxpZ25tZW50LnN0cmFuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZWNvbmRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kQWxpZ25tZW50LnN0cmFuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0QWxpZ25tZW50LnN0cmFuZDsgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIGlud2FyZCBwb2ludGluZyBwYWlyc1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIEJhbUFsaWdubWVudFJvdyB7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2NvcmUgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZmluZENlbnRlckFsaWdubWVudChicFN0YXJ0LCBicEVuZCkge1xyXG5cclxuICAgICAgICB2YXIgY2VudGVyQWxpZ25tZW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvLyBmaW5kIHNpbmdsZSBhbGlnbm1lbnQgdGhhdCBvdmVybGFwcyBzb3J0IGxvY2F0aW9uXHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzLmZvckVhY2goZnVuY3Rpb24oYSl7XHJcblxyXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjZW50ZXJBbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGEuc3RhcnQgKyBhLmxlbmd0aE9uUmVmKSA8IGJwU3RhcnQgfHwgYS5zdGFydCA+IGJwRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJBbGlnbm1lbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNlbnRlckFsaWdubWVudDtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVTY29yZShnZW5vbWljTG9jYXRpb24sIGdlbm9taWNJbnRlcnZhbCwgc29ydE9wdGlvbikge1xyXG5cclxuICAgICAgICB0aGlzLnNjb3JlID0gdGhpcy5jYWN1bGF0ZVNjb3JlKGdlbm9taWNMb2NhdGlvbiwgKDEgKyBnZW5vbWljTG9jYXRpb24pLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgY2FjdWxhdGVTY29yZShicFN0YXJ0LCBicEVuZCwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKSB7XHJcblxyXG4gICAgICAgIHZhciBiYXNlU2NvcmUsXHJcbiAgICAgICAgICAgIGFsaWdubWVudDtcclxuXHJcbiAgICAgICAgYWxpZ25tZW50ID0gdGhpcy5maW5kQ2VudGVyQWxpZ25tZW50KGJwU3RhcnQsIGJwRW5kKTtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBhbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXCJOVUNMRU9USURFXCIgPT09IHNvcnRPcHRpb24uc29ydCkge1xyXG5cclxuICAgICAgICAgICAgYmFzZVNjb3JlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgYWxpZ25tZW50LmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IGdlbm9taWNJbnRlcnZhbC5zZXF1ZW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmFnZU1hcCA9IGdlbm9taWNJbnRlcnZhbC5jb3ZlcmFnZU1hcCxcclxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZSxcclxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmFnZSxcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCxcclxuICAgICAgICAgICAgICAgICAgICBwaHJlZDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoXCIqXCIgIT09IGJsb2NrLnNlcSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaW5kZXhSZWZlcmVuY2VTZXF1ZW5jZSA9IGJsb2NrLnN0YXJ0IC0gZ2Vub21pY0ludGVydmFsLnN0YXJ0LCBicEJsb2NrU2VxdWVuY2UgPSBibG9jay5zdGFydCwgbGVuZ3RoQmxvY2tTZXF1ZW5jZSA9IGJsb2NrLnNlcS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpIDwgbGVuZ3RoQmxvY2tTZXF1ZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGkrKywgaW5kZXhSZWZlcmVuY2VTZXF1ZW5jZSsrLCBicEJsb2NrU2VxdWVuY2UrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJwU3RhcnQgPT09IGJwQmxvY2tTZXF1ZW5jZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZSA9IHNlcXVlbmNlLmNoYXJBdChpbmRleFJlZmVyZW5jZVNlcXVlbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSBibG9jay5zZXEuY2hhckF0KGkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSBcIj1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSByZWZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2UgPT09ICdOJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VTY29yZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlID09PSByZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZSA9PT0gXCJYXCIgfHwgYmFzZSAhPT0gcmVmZXJlbmNlKXtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2UgPSBjb3ZlcmFnZU1hcC5jb3ZlcmFnZVsgKGJwQmxvY2tTZXF1ZW5jZSAtIGNvdmVyYWdlTWFwLmJwU3RhcnQpIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSBjb3ZlcmFnZVsgXCJwb3NcIiArIGJhc2UgXSArIGNvdmVyYWdlWyBcIm5lZ1wiICsgYmFzZSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBocmVkID0gKGNvdmVyYWdlLnF1YWwpID8gY292ZXJhZ2UucXVhbCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNjb3JlID0gLShjb3VudCArIChwaHJlZCAvIDEwMDAuMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkJhbUFsaWdubWVudFJvdy5jYWN1bGF0ZVNjb3JlIC0gaHVoP1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gYnBTdGFydCA9PT0gYnBCbG9ja1NlcXVlbmNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gYmxvY2suc2VxLmxlbmd0aFxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VTY29yZSA9IDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAodW5kZWZpbmVkID09PSBiYXNlU2NvcmUpID8gTnVtYmVyLk1BWF9WQUxVRSA6IGJhc2VTY29yZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXCJTVFJBTkRcIiA9PT0gc29ydE9wdGlvbi5zb3J0KSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50LnN0cmFuZCA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXCJTVEFSVFwiID09PSBzb3J0T3B0aW9uLnNvcnQpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB7bG9hZEJhbUluZGV4LEJhbVJlYWRlcixCYW1Tb3VyY2UsQmFtRmlsdGVyLEJhbUFsaWdubWVudCxQYWlyZWRBbGlnbm1lbnR9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/bam.js\n");

/***/ }),

/***/ "./src/bigwig.js":
/*!***********************!*\
  !*** ./src/bigwig.js ***!
  \***********************/
/*! exports provided: BWSource, BinaryParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Zlib, __webpack_provided_$_dot_extend) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BWSource\", function() { return BWSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryParser\", function() { return BinaryParser; });\n/* harmony import */ var _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n//***********js/bigwig/bufferedReader.js*****************\r\nclass BufferedReader{\r\n    constructor(config, contentLength, bufferSize) {\r\n        this.path = config.url;\r\n        this.contentLength = contentLength;\r\n        this.bufferSize = bufferSize ? bufferSize : 512000;\r\n        this.range = {start: -1, size: -1};\r\n        this.config = config;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param requestedRange - byte rangeas {start, size}\r\n     * @param fulfill - function to receive result\r\n     * @param asUint8 - optional flag to return result as an UInt8Array\r\n     */\r\n    dataViewForRange(requestedRange, asUint8) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var hasData = (self.data && (self.range.start <= requestedRange.start) &&\r\n                ((self.range.start + self.range.size) >= (requestedRange.start + requestedRange.size))),\r\n                bufferSize,\r\n                loadRange;\r\n\r\n            if (hasData) {\r\n                subbuffer(self, requestedRange, asUint8);\r\n            }\r\n            else {\r\n                // Expand buffer size if needed, but not beyond content length\r\n                bufferSize = Math.max(self.bufferSize, requestedRange.size);\r\n\r\n                if (self.contentLength > 0 && requestedRange.start + bufferSize > self.contentLength) {\r\n                    loadRange = {start: requestedRange.start};\r\n                }\r\n                else {\r\n                    loadRange = {start: requestedRange.start, size: bufferSize};\r\n                }\r\n\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, Object.assign(self.config, {range: loadRange}))\r\n                    .then(function (arrayBuffer) {\r\n                    self.data = arrayBuffer;\r\n                    self.range = loadRange;\r\n                    subbuffer(self, requestedRange, asUint8);\r\n                }).catch(reject);\r\n\r\n            }\r\n\r\n\r\n            function subbuffer(bufferedReader, requestedRange, asUint8) {\r\n\r\n                var len = bufferedReader.data.byteLength,\r\n                    bufferStart = requestedRange.start - bufferedReader.range.start,\r\n                    result = asUint8 ?\r\n                        new Uint8Array(bufferedReader.data, bufferStart, len - bufferStart) :\r\n                        new DataView(bufferedReader.data, bufferStart, len - bufferStart);\r\n                fulfill(result);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n//**********js/bigwig/bwSource.js***************\r\nclass BWSource{\r\n\r\n    constructor(config,create_feature_function) {\r\n        this.reader = new BWReader(config);\r\n        this.bufferedReader = new BufferedReader(config);\r\n        if (!create_feature_function){\r\n            this.create_feature=BWSource.createFeature;\r\n        }\r\n        else{\r\n            this.create_feature=create_feature_function;\r\n        }\r\n    }\r\n    \r\n    /**\r\n\t* Creates a panel\r\n\t* @param {string} chr - The chromosome\r\n\t* @param {int} bpStart The starting postition \r\n\t* @param {int} bpEnd - The end of the region to show\r\n\t* @param {boolean} use_existing - If true then the cached feature will be used- only used\r\n\t* if the co-oridinates have not changed. Although, the BWreader has a cache, it is sometimes\r\n\t* ignored and features are re-fetched for the same region\r\n\t* @param {object} data - Should contain pixelWidth- the width of the entire canvas and \r\n\t* bpPerPixel.\r\n\t*/\r\n    getFeatures(chr, bpStart, bpEnd,use_existing,data) {\r\n        this.st = new Date().getTime();\r\n        var self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n            if (self.features && use_existing){\r\n                fulfill(self.features);\r\n                return;\r\n            }\r\n            self.reader.getZoomHeaders().then(function (zoomLevelHeaders) {\r\n\r\n                // Select a biwig \"zoom level\" appropriate for the current resolution\r\n                var bwReader = self.reader,\r\n                    bufferedReader = self.bufferedReader,\r\n                    bpp =data.bpPerPixel,\r\n                    zoomLevelHeader=BWSource.zoomLevelForScale(bpp, zoomLevelHeaders),\r\n                    treeOffset\r\n                \r\n               \r\n                if (zoomLevelHeader && bwReader.type===\"BigWig\") {\r\n                    treeOffset = zoomLevelHeader.indexOffset;\r\n                    self.decodeFunction = BWSource.decodeZoomData;\r\n                } else {\r\n                    treeOffset = bwReader.header.fullIndexOffset;\r\n                    if (bwReader.type === \"BigWig\") {\r\n                        self.decodeFunction =BWSource.decodeWigData;\r\n                    }\r\n                    else {\r\n                        self.decodeFunction =self.decodeBedData;\r\n                    }\r\n                }\r\n\r\n                bwReader.loadRPTree(treeOffset).then(function (rpTree) {\r\n\r\n                    var chrIdx = self.reader.chromTree.dictionary[chr];\r\n                    if (chrIdx === undefined) {\r\n                        fulfill(null);\r\n                    }\r\n                    else {\r\n\r\n                        rpTree.findLeafItemsOverlapping(chrIdx, bpStart, bpEnd).then(function (leafItems) {\r\n\r\n                            var promises = [];\r\n\r\n                            if (!leafItems || leafItems.length == 0) fulfill([]);\r\n\r\n                            leafItems.forEach(function (item) {\r\n\r\n                                promises.push(new Promise(function (fulfill, reject) {\r\n                                    var features = [];\r\n\r\n                                    bufferedReader.dataViewForRange({\r\n                                        start: item.dataOffset,\r\n                                        size: item.dataSize\r\n                                    }, true).then(function (uint8Array) {\r\n                                  \r\n                                       var inflate = new Zlib.Zlib.Inflate(uint8Array);\r\n                                       var plain= inflate.decompress();\r\n                                       //var inflate = new pako.Inflate();\r\n                                       //inflate.push(uint8Array, true);\r\n                                        //var plain = inflate.result;\r\n                                        self.decodeFunction(new DataView(plain.buffer), chr, chrIdx, bpStart, bpEnd, features);\r\n\r\n                                        fulfill(features);\r\n\r\n                                    }).catch(reject);\r\n                                }));\r\n                            });\r\n\r\n\r\n                            Promise.all(promises).then(function (featureArrays) {\r\n                                var en = new Date().getTime();\r\n                                var e = en-self.st;\r\n                                var a = bpp;\r\n                                //console.log(e);\r\n                                var i, allFeatures = featureArrays[0];\r\n                                if(featureArrays.length > 1) {\r\n                                   for(i=1; i<featureArrays.length; i++) {\r\n                                       allFeatures = allFeatures.concat(featureArrays[i]);\r\n                                   }\r\n                                }  \r\n                                allFeatures.sort(function (a, b) {\r\n                                    return a.start - b.start;\r\n                                })\r\n                                self.features=allFeatures;\r\n                                fulfill(allFeatures)\r\n                            }).catch(reject);\r\n\r\n                        }).catch(function(error){\r\n                            reject(error);\r\n                        });\r\n                    }\r\n                }).catch(function(error){\r\n                    reject(error)\r\n                });\r\n            }).catch(function(error){\r\n                reject(error);\r\n            }\r\n            );\r\n\r\n\r\n        });\r\n    }\r\n    \r\n    \r\n    getDefaultRange() {\r\n        \r\n        if(this.reader.totalSummary != undefined) {\r\n            return this.reader.totalSummary.defaultRange;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    static zoomLevelForScale(bpPerPixel, zoomLevelHeaders) {\r\n\r\n        var level = null, i, zl;\r\n\r\n        for (i = 0; i < zoomLevelHeaders.length; i++) {\r\n\r\n            zl = zoomLevelHeaders[i];\r\n\r\n            if (zl.reductionLevel > bpPerPixel) {\r\n                level = zl;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (null == level) {\r\n            level = zoomLevelHeaders[zoomLevelHeaders.length - 1];\r\n        }\r\n\r\n        return (level && level.reductionLevel < 4 * bpPerPixel) ? level : null;\r\n    }\r\n\r\n\r\n    static decodeWigData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\r\n\r\n        var binaryParser = new BinaryParser(data),\r\n            chromId = binaryParser.getInt(),\r\n            chromStart = binaryParser.getInt(),\r\n            chromEnd = binaryParser.getInt(),\r\n            itemStep = binaryParser.getInt(),\r\n            itemSpan = binaryParser.getInt(),\r\n            type = binaryParser.getByte(),\r\n            reserved = binaryParser.getByte(),\r\n            itemCount = binaryParser.getUShort(),\r\n            value;\r\n\r\n        if (chromId === chrIdx) {\r\n\r\n            while (itemCount-- > 0) {\r\n\r\n                switch (type) {\r\n                    case 1:\r\n                        chromStart = binaryParser.getInt();\r\n                        chromEnd = binaryParser.getInt();\r\n                        value = binaryParser.getFloat();\r\n                        break;\r\n                    case 2:\r\n                        chromStart = binaryParser.getInt();\r\n                        value = binaryParser.getFloat();\r\n                        chromEnd = chromStart + itemSpan;\r\n                        break;\r\n                    case 3:  // Fixed step\r\n                        value = binaryParser.getFloat();\r\n                        chromEnd = chromStart + itemSpan;\r\n                        chromStart += itemStep;\r\n                        break;\r\n\r\n                }\r\n\r\n                if (chromStart >= bpEnd) {\r\n                    break; // Out of interval\r\n                } else if (chromEnd > bpStart && Number.isFinite(value)) {\r\n                    featureArray.push({chr: chr, start: chromStart, end: chromEnd, value: value});\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static decodeZoomData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\r\n\r\n        var binaryParser = new BinaryParser(data),\r\n            minSize = 8 * 4,   // Minimum # of bytes required for a zoom record\r\n            chromId,\r\n            chromStart,\r\n            chromEnd,\r\n            validCount,\r\n            minVal,\r\n            maxVal,\r\n            sumData,\r\n            sumSquares,\r\n            value;\r\n\r\n        while (binaryParser.remLength() >= minSize) {\r\n            chromId = binaryParser.getInt();\r\n            if (chromId === chrIdx) {\r\n\r\n                chromStart = binaryParser.getInt();\r\n                chromEnd = binaryParser.getInt();\r\n                validCount = binaryParser.getInt();\r\n                minVal = binaryParser.getFloat();\r\n                maxVal = binaryParser.getFloat();\r\n                sumData = binaryParser.getFloat();\r\n                sumSquares = binaryParser.getFloat();\r\n                value = validCount == 0 ? 0 : sumData / validCount;\r\n\r\n                if (chromStart >= bpEnd && chromStart<1000000000) {\r\n                     console.log(\"should have broken\")\r\n\r\n                    break; // Out of interval\r\n                   \r\n                } else if (chromEnd > bpStart && Number.isFinite(value)) {\r\n                    featureArray.push({chr: chr, start: chromStart, end: chromEnd, value: value});\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    decodeBedData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\r\n\r\n        var binaryParser = new BinaryParser(data),\r\n            minSize = 3 * 4 + 1,   // Minimum # of bytes required for a bed record\r\n            chromId,\r\n            chromStart,\r\n            chromEnd,\r\n            rest,\r\n            tokens,\r\n            feature,\r\n            exonCount, exonSizes, exonStarts, exons, eStart, eEnd;\r\n\r\n\r\n        while (binaryParser.remLength() >= minSize) {\r\n\r\n            chromId = binaryParser.getInt();\r\n            if (chromId != chrIdx) continue;\r\n\r\n            chromStart = binaryParser.getInt();\r\n            chromEnd = binaryParser.getInt();\r\n            rest = binaryParser.getString();\r\n\r\n            feature = {chr: chr, start: chromStart, end: chromEnd};\r\n\r\n            if (chromStart < bpEnd && chromEnd >= bpStart) {\r\n                featureArray.push(feature);\r\n\r\n                tokens = rest.split(\"\\t\");\r\n                this.create_feature(tokens,feature);\r\n\r\n                \r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    static createFeature(tokens,feature){\r\n        if (tokens.length > 0) {\r\n                    feature.name = tokens[0];\r\n                }\r\n\r\n                if (tokens.length > 1) {\r\n                    feature.score = parseFloat(tokens[1]);\r\n                }\r\n                if (tokens.length > 2) {\r\n                    feature.strand = tokens[2];\r\n                }\r\n                if (tokens.length > 3) {\r\n                    feature.cdStart = parseInt(tokens[3]);\r\n                }\r\n                if (tokens.length > 4) {\r\n                    feature.cdEnd = parseInt(tokens[4]);\r\n                }\r\n                if (tokens.length > 5) {\r\n                    //if (tokens[5] !== \".\" && tokens[5] !== \"0\")\r\n                        //feature.color = igv.createColorString(tokens[5]);\r\n                }\r\n                if (tokens.length > 8) {\r\n                    exonCount = parseInt(tokens[6]);\r\n                    exonSizes = tokens[7].split(',');\r\n                    exonStarts = tokens[8].split(',');\r\n                    exons = [];\r\n\r\n                    for (var i = 0; i < exonCount; i++) {\r\n                        eStart = start + parseInt(exonStarts[i]);\r\n                        eEnd = eStart + parseInt(exonSizes[i]);\r\n                        exons.push({start: eStart, end: eEnd});\r\n                    }\r\n\r\n                    feature.exons = exons;\r\n                }\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n//************js/bigwig/bwReader.js*****************\r\n\r\n\r\nconst BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High\r\nconst BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low\r\nconst BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High\r\nconst BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low\r\nconst BBFILE_HEADER_SIZE = 64;\r\n\r\n\r\nclass BWReader{\r\n    constructor(config) {\r\n        this.path = config.url;\r\n        this.headPath = config.headURL || this.path;\r\n        this.rpTreeCache = {};\r\n        this.config = __webpack_provided_$_dot_extend({},config,true);\r\n    };\r\n\r\n    getZoomHeaders() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            if (self.zoomLevelHeaders) {\r\n                fulfill(self.zoomLevelHeaders);\r\n            }\r\n            else {\r\n                self.loadHeader().then(function () {\r\n                    fulfill(self.zoomLevelHeaders);\r\n                }).catch(function (error) {\r\n                    reject(error);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    loadHeader() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, Object.assign(self.config, {range: {start: 0, size: BBFILE_HEADER_SIZE}}))\r\n                .then(function (data) {\r\n\r\n                if (!data) return;\r\n\r\n                // Assume low-to-high unless proven otherwise\r\n                self.littleEndian = true;\r\n\r\n                var binaryParser = new BinaryParser(new DataView(data));\r\n\r\n                var magic = binaryParser.getUInt();\r\n\r\n                if (magic === BIGWIG_MAGIC_LTH) {\r\n                    self.type = \"BigWig\";\r\n                }\r\n                else if (magic == BIGBED_MAGIC_LTH) {\r\n                    self.type = \"BigBed\";\r\n                }\r\n                else {\r\n                    //Try big endian order\r\n                    self.littleEndian = false;\r\n\r\n                    binaryParser.littleEndian = false;\r\n                    binaryParser.position = 0;\r\n                    var magic = binaryParser.getUInt();\r\n\r\n                    if (magic === BIGWIG_MAGIC_HTL) {\r\n                        self.type = \"BigWig\";\r\n                    }\r\n                    else if (magic == BIGBED_MAGIC_HTL) {\r\n                        self.type = \"BigBed\";\r\n                    }\r\n                    else {\r\n                        // TODO -- error, unknown file type  or BE\r\n                    }\r\n\r\n                }\r\n                // Table 5  \"Common header for BigWig and BigBed files\"\r\n                self.header = {};\r\n                self.header.bwVersion = binaryParser.getUShort();\r\n                self.header.nZoomLevels = binaryParser.getUShort();\r\n                self.header.chromTreeOffset = binaryParser.getLong();\r\n                self.header.fullDataOffset = binaryParser.getLong();\r\n                self.header.fullIndexOffset = binaryParser.getLong();\r\n                self.header.fieldCount = binaryParser.getUShort();\r\n                self.header.definedFieldCount = binaryParser.getUShort();\r\n                self.header.autoSqlOffset = binaryParser.getLong();\r\n                self.header.totalSummaryOffset = binaryParser.getLong();\r\n                self.header.uncompressBuffSize = binaryParser.getInt();\r\n                self.header.reserved = binaryParser.getLong();\r\n\r\n                self.loadZoomHeadersAndChrTree().then(fulfill).catch(reject);\r\n            }).catch(function (error) {\r\n                    reject(error);\r\n                });\r\n\r\n        });\r\n    }\r\n\r\n\r\n   loadZoomHeadersAndChrTree() {\r\n\r\n\r\n        var startOffset = BBFILE_HEADER_SIZE,\r\n            self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            \r\n            var range = {start: startOffset, size: (self.header.fullDataOffset - startOffset + 5)};\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, Object.assign(self.config, {range: range}))\r\n                .then(function (data) {\r\n\r\n                var nZooms = self.header.nZoomLevels,\r\n                    binaryParser = new BinaryParser(new DataView(data)),\r\n                    i,\r\n                    len,\r\n                    zoomNumber,\r\n                    zlh;\r\n\r\n                self.zoomLevelHeaders = [];\r\n\r\n                self.firstZoomDataOffset = Number.MAX_VALUE;\r\n                for (i = 0; i < nZooms; i++) {\r\n                    zoomNumber = nZooms - i;\r\n                    zlh = new ZoomLevelHeader(zoomNumber, binaryParser);\r\n                    self.firstZoomDataOffset = Math.min(zlh.dataOffset, self.firstZoomDataOffset);\r\n                    self.zoomLevelHeaders.push(zlh);\r\n                }\r\n\r\n                // Autosql\r\n                if (self.header.autoSqlOffset > 0) {\r\n                    binaryParser.position = self.header.autoSqlOffset - startOffset;\r\n                    self.autoSql = binaryParser.getString();\r\n                }\r\n\r\n                // Total summary\r\n                if (self.header.totalSummaryOffset > 0) {\r\n                    binaryParser.position = self.header.totalSummaryOffset - startOffset;\r\n                    self.totalSummary = new BWTotalSummary(binaryParser);\r\n                }\r\n\r\n                // Chrom data index\r\n                if (self.header.chromTreeOffset > 0) {\r\n                    binaryParser.position = self.header.chromTreeOffset - startOffset;\r\n                    self.chromTree = new BPTree(binaryParser, startOffset);\r\n                }\r\n                else {\r\n                    // TODO -- this is an error, not expected\r\n                }\r\n\r\n                //Finally total data count\r\n                binaryParser.position = self.header.fullDataOffset - startOffset;\r\n                self.dataCount = binaryParser.getInt();\r\n\r\n                fulfill();\r\n\r\n            }).catch(function(error){\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    loadRPTree(offset) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var rpTree = self.rpTreeCache[offset];\r\n            if (rpTree) {\r\n                fulfill(rpTree);\r\n            }\r\n            else {\r\n                rpTree = new RPTree(offset, self.contentLength, self.config, self.littleEndian);\r\n                self.rpTreeCache[offset] = rpTree;\r\n                rpTree.load().then(function () {\r\n                    fulfill(rpTree);\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n class ZoomLevelHeader{\r\n     constructor(index, byteBuffer) {\r\n        this.index = index;\r\n        this.reductionLevel = byteBuffer.getInt();\r\n        this.reserved = byteBuffer.getInt();\r\n        this.dataOffset = byteBuffer.getLong();\r\n        this.indexOffset = byteBuffer.getLong();\r\n    }\r\n }\r\n\r\n\r\nconst RPTREE_MAGIC_LTH = 0x2468ACE0;\r\nconst RPTREE_MAGIC_HTL = 0xE0AC6824;\r\nconst RPTREE_HEADER_SIZE = 48;\r\nconst RPTREE_NODE_LEAF_ITEM_SIZE = 32;   // leaf item size\r\nconst RPTREE_NODE_CHILD_ITEM_SIZE = 24;  // child item size\r\nconst BUFFER_SIZE = 512000; \r\n\r\n//***********js/bigwig/RPTree*******************\r\n\r\n\r\n     //  buffer\r\n\r\nclass RPTree{\r\n\r\n    constructor (fileOffset, contentLength, config, littleEndian) {\r\n\r\n        this.config = config;\r\n        this.filesize = contentLength;\r\n        this.fileOffset = fileOffset; // File offset to beginning of tree\r\n        this.path = config.url;\r\n        this.littleEndian = littleEndian;\r\n    }\r\n\r\n\r\n    load() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var rootNodeOffset = self.fileOffset + RPTREE_HEADER_SIZE,\r\n                bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\r\n\r\n            self.readNode(rootNodeOffset, bufferedReader).then(function (node) {\r\n                self.rootNode = node;\r\n                fulfill(self);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n\r\n    readNode(filePosition, bufferedReader) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            bufferedReader.dataViewForRange({start: filePosition, size: 4}, false).then(function (dataView) {\r\n                var binaryParser = new BinaryParser(dataView, self.littleEndian);\r\n\r\n                var type = binaryParser.getByte();\r\n                var isLeaf = (type === 1) ? true : false;\r\n                var reserved = binaryParser.getByte();\r\n                var count = binaryParser.getUShort();\r\n\r\n                filePosition += 4;\r\n\r\n                var bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);\r\n                var range2 = {start: filePosition, size: bytesRequired};\r\n\r\n                bufferedReader.dataViewForRange(range2, false).then(function (dataView) {\r\n\r\n                    var i,\r\n                        items = new Array(count),\r\n                        binaryParser = new BinaryParser(dataView);\r\n\r\n                    if (isLeaf) {\r\n                        for (i = 0; i < count; i++) {\r\n                            var item = {\r\n                                isLeaf: true,\r\n                                startChrom: binaryParser.getInt(),\r\n                                startBase: binaryParser.getInt(),\r\n                                endChrom: binaryParser.getInt(),\r\n                                endBase: binaryParser.getInt(),\r\n                                dataOffset: binaryParser.getLong(),\r\n                                dataSize: binaryParser.getLong()\r\n                            };\r\n                            items[i] = item;\r\n\r\n                        }\r\n                        fulfill(new RPTreeNode(items));\r\n                    }\r\n                    else { // non-leaf\r\n                        for (i = 0; i < count; i++) {\r\n\r\n                            var item = {\r\n                                isLeaf: false,\r\n                                startChrom: binaryParser.getInt(),\r\n                                startBase: binaryParser.getInt(),\r\n                                endChrom: binaryParser.getInt(),\r\n                                endBase: binaryParser.getInt(),\r\n                                childOffset: binaryParser.getLong()\r\n                            };\r\n                            items[i] = item;\r\n\r\n                        }\r\n\r\n                        fulfill(new RPTreeNode(items));\r\n                    }\r\n                }).catch(reject);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n\r\n    findLeafItemsOverlapping(chrIdx, startBase, endBase) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var leafItems = [],\r\n                processing = new Set(),\r\n                bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\r\n\r\n            processing.add(0);  // Zero represents the root node\r\n            findLeafItems(self.rootNode, 0);\r\n\r\n            function findLeafItems(node, nodeId) {\r\n\r\n                if (RPTree.overlaps(node, chrIdx, startBase, endBase)) {\r\n\r\n                    var items = node.items;\r\n\r\n                    items.forEach(function (item) {\r\n\r\n                        if (RPTree.overlaps(item, chrIdx, startBase, endBase)) {\r\n\r\n                            if (item.isLeaf) {\r\n                                leafItems.push(item);\r\n                            }\r\n\r\n                            else {\r\n                                if (item.childNode) {\r\n                                    findLeafItems(item.childNode);\r\n                                }\r\n                                else {\r\n                                    processing.add(item.childOffset);  // Represent node to-be-loaded by its file position\r\n                                    self.readNode(item.childOffset, bufferedReader).then(function (node) {\r\n                                        item.childNode = node;\r\n                                        findLeafItems(node, item.childOffset);\r\n                                    }).catch(reject);\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                }\r\n\r\n                if (nodeId != undefined) processing.delete(nodeId);\r\n\r\n                // Wait until all nodes are processed\r\n                if (processing.size===0) {\r\n                    fulfill(leafItems);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Return true if {chrIdx:startBase-endBase} overlaps item's interval\r\n     * @returns {boolean}\r\n     */\r\n    static overlaps(item, chrIdx, startBase, endBase) {\r\n\r\n        //  if (chrIdx > item.endChrom || chrIdx < item.startChrom) return false;\r\n\r\n        if (!item) {\r\n            console.log(\"null item\");\r\n            return false;\r\n        }\r\n\r\n        return ((chrIdx > item.startChrom) || (chrIdx == item.startChrom && endBase >= item.startBase)) &&\r\n            ((chrIdx < item.endChrom) || (chrIdx == item.endChrom && startBase < item.endBase));\r\n    }\r\n}\r\n\r\n\r\nclass RPTreeNode{\r\n    constructor(items) {\r\n        this.items = items;\r\n\r\n        var minChromId = Number.MAX_VALUE,\r\n            maxChromId = 0,\r\n            minStartBase = Number.MAX_VALUE,\r\n            maxEndBase = 0,\r\n            i,\r\n            item;\r\n\r\n        for (i = 0; i < items.length; i++) {\r\n            item = items[i];\r\n            minChromId = Math.min(minChromId, item.startChrom);\r\n            maxChromId = Math.max(maxChromId, item.endChrom);\r\n            minStartBase = Math.min(minStartBase, item.startBase);\r\n            maxEndBase = Math.max(maxEndBase, item.endBase);\r\n        }\r\n\r\n        this.startChrom = minChromId;\r\n        this.endChrom = maxChromId;\r\n        this.startBase = minStartBase;\r\n        this.endBase = maxEndBase;\r\n\r\n    }\r\n}\r\n\r\n//*******************js/binary.js******************\r\nclass BinaryParser{\r\n    constructor(dataView, littleEndian) {\r\n\r\n        this.littleEndian = (littleEndian ? littleEndian : true);\r\n        this.position = 0;\r\n        this.view = dataView;\r\n        this.length = dataView.byteLength;\r\n    }\r\n\r\n    available() {\r\n        return this.length - this.position;\r\n    }\r\n\r\n    remLength() {\r\n        return this.length - this.position;\r\n    }\r\n\r\n    hasNext() {\r\n        return this.position < this.length - 1;\r\n    }\r\n\r\n    getByte() {\r\n        var retValue = this.view.getUint8(this.position, this.littleEndian);\r\n        this.position++;\r\n        return retValue;\r\n    }\r\n\r\n    getShort() {\r\n\r\n        var retValue = this.view.getInt16(this.position, this.littleEndian);\r\n        this.position += 2\r\n        return retValue;\r\n    }\r\n\r\n    getUShort(){\r\n\r\n        // var byte1 = this.getByte(),\r\n        //     byte2 = this.getByte(),\r\n        //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\r\n        //     return retValue;\r\n\r\n       //\r\n        var retValue = this.view.getUint16 (this.position, this.littleEndian);\r\n        this.position += 2\r\n        return retValue;\r\n    }\r\n\r\n\r\n    getInt() {\r\n\r\n        var retValue = this.view.getInt32(this.position, this.littleEndian);\r\n        this.position += 4;\r\n        return retValue;\r\n    }\r\n\r\n\r\n    getUInt() {\r\n        var retValue = this.view.getUint32(this.position, this.littleEndian);\r\n        this.position += 4;\r\n        return retValue;\r\n    }\r\n\r\n    getLong() {\r\n\r\n        // DataView doesn't support long. So we'll try manually\r\n\r\n        var b = [];\r\n        b[0] = this.view.getUint8(this.position);\r\n        b[1] = this.view.getUint8(this.position + 1);\r\n        b[2] = this.view.getUint8(this.position + 2);\r\n        b[3] = this.view.getUint8(this.position + 3);\r\n        b[4] = this.view.getUint8(this.position + 4);\r\n        b[5] = this.view.getUint8(this.position + 5);\r\n        b[6] = this.view.getUint8(this.position + 6);\r\n        b[7] = this.view.getUint8(this.position + 7);\r\n\r\n        var value = 0;\r\n        if (this.littleEndian) {\r\n            for (var i = b.length - 1; i >= 0; i--) {\r\n                value = (value * 256) + b[i];\r\n            }\r\n        } else {\r\n            for (var i = 0; i < b.length; i++) {\r\n                value = (value * 256) + b[i];\r\n            }\r\n        }\r\n\r\n\r\n        this.position += 8;\r\n        return value;\r\n    }\r\n\r\n    getString(len) {\r\n\r\n        var s = \"\";\r\n        var c;\r\n        while ((c = this.view.getUint8(this.position++)) != 0) {\r\n            s += String.fromCharCode(c);\r\n            if (len && s.length == len) break;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    getFixedLengthString(len) {\r\n\r\n        var s = \"\";\r\n        var i;\r\n        var c;\r\n        for (i = 0; i < len; i++) {\r\n            c = this.view.getUint8(this.position++);\r\n            if (c > 0) {\r\n                s += String.fromCharCode(c);\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n\r\n    getFixedLengthTrimmedString(len) {\r\n\r\n        var s = \"\";\r\n        var i;\r\n        var c;\r\n        for (i = 0; i < len; i++) {\r\n            c = this.view.getUint8(this.position++);\r\n            if (c > 32) {\r\n                s += String.fromCharCode(c);\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n\r\n    getFloat() {\r\n\r\n        var retValue = this.view.getFloat32(this.position, this.littleEndian);\r\n        this.position += 4;\r\n        return retValue;\r\n\r\n\r\n    }\r\n\r\n    getDouble() {\r\n\r\n        var retValue = this.view.getFloat64(this.position, this.littleEndian);\r\n        this.position += 8;\r\n        return retValue;\r\n    }\r\n\r\n    skip(n) {\r\n\r\n        this.position += n;\r\n        return this.position;\r\n    }\r\n\r\n\r\n    /**\r\n     * Return a bgzip (bam and tabix) virtual pointer\r\n     * TODO -- why isn't 8th byte used ?\r\n     * @returns {*}\r\n     */\r\n    getVPointer() {\r\n\r\n        var position = this.position,\r\n            offset = (this.view.getUint8(position + 1) << 8) | (this.view.getUint8(position)),\r\n            byte6 = ((this.view.getUint8(position + 6) & 0xff) * 0x100000000),\r\n            byte5 = ((this.view.getUint8(position + 5) & 0xff) * 0x1000000),\r\n            byte4 = ((this.view.getUint8(position + 4) & 0xff) * 0x10000),\r\n            byte3 = ((this.view.getUint8(position + 3) & 0xff) * 0x100),\r\n            byte2 = ((this.view.getUint8(position + 2) & 0xff)),\r\n            block = byte6 + byte5 + byte4 + byte3 + byte2;\r\n        this.position += 8;\r\n\r\n        //       if (block == 0 && offset == 0) {\r\n        //           return null;\r\n        //       } else {\r\n        return new VPointer(block, offset);\r\n        //       }\r\n    }\r\n}\r\n\r\nclass VPointer{\r\n    constructor(block, offset) {\r\n        this.block = block;\r\n        this.offset = offset;\r\n    }\r\n\r\n    isLessThan(vp) {\r\n        return this.block < vp.block ||\r\n            (this.block === vp.block && this.offset < vp.offset);\r\n    }\r\n\r\n    isGreaterThan(vp) {\r\n        return this.block > vp.block ||\r\n            (this.block === vp.block && this.offset > vp.offset);\r\n    }\r\n\r\n    print() {\r\n        return \"\" + this.block + \":\" + this.offset;\r\n    }\r\n}\r\n\r\n\r\n//*******js/bigwig/bwTotalSummary.js*************\r\n\r\n\r\n\r\nclass BWTotalSummary{\r\n    constructor(byteBuffer) {\r\n\r\n        if (byteBuffer) {\r\n\r\n            this.basesCovered = byteBuffer.getLong();\r\n            this.minVal = byteBuffer.getDouble();\r\n            this.maxVal = byteBuffer.getDouble();\r\n            this.sumData = byteBuffer.getDouble();\r\n            this.sumSquares = byteBuffer.getDouble();\r\n\r\n            this.computeStats();\r\n        }\r\n        else {\r\n            this.basesCovered = 0;\r\n            this.minVal = 0;\r\n            this.maxVal = 0;\r\n            this.sumData = 0;\r\n            this.sumSquares = 0;\r\n            this.mean = 0;\r\n            this.stddev = 0;\r\n        }\r\n    }\r\n\r\n\r\n     computeStats() {\r\n        var n = this.basesCovered;\r\n        if (n > 0) {\r\n            this.mean = this.sumData / n;\r\n            this.stddev = Math.sqrt(this.sumSquares / (n - 1));\r\n\r\n            var min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,\r\n                max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;\r\n\r\n            this.defaultRange = {\r\n                min: 0,\r\n                max: this.mean + 3 * this.stddev\r\n            }\r\n        }\r\n    }\r\n\r\n    updateStats(stats) {\r\n\r\n        this.basesCovered += stats.count;\r\n        this.sumData += status.sumData;\r\n        this.sumSquares += sumSquares;\r\n        this.minVal = MIN(_minVal, min);\r\n        this.maxVal = MAX(_maxVal, max);\r\n\r\n        computeStats.call(this);\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//***************js/bigwig/bwBPTree.js**************\r\n\r\n\r\nconst BPTREE_MAGIC_LTH = 0x78CA8C91;\r\nconst BPTREE_MAGIC_HTL = 0x918CCA78;\r\nconst BPTREE_HEADER_SIZE = 32;\r\n\r\n\r\n class BPTree{\r\n     constructor(binaryParser, startOffset) {\r\n\r\n        var self = this,\r\n            genome =  null;\r\n\r\n        this.header = {};\r\n        this.header.magic = binaryParser.getInt();\r\n        this.header.blockSize = binaryParser.getInt();\r\n        this.header.keySize = binaryParser.getInt();\r\n        this.header.valSize = binaryParser.getInt();\r\n        this.header.itemCount = binaryParser.getLong();\r\n        this.header.reserved = binaryParser.getLong();\r\n\r\n        this.dictionary = {};\r\n\r\n        // Recursively walk tree to populate dictionary\r\n        readTreeNode(binaryParser, -1, this.header.keySize, this.dictionary);\r\n\r\n        var itemSize = 8 + this.header.keySize;\r\n        var minSize = 4 + itemSize;   // Bytes for a node with 1 item\r\n\r\n        function readTreeNode(byteBuffer, offset, keySize, dictionary) {\r\n\r\n            if (offset >= 0) byteBuffer.position = offset;\r\n\r\n            var type = byteBuffer.getByte(),\r\n                reserved = byteBuffer.getByte(),\r\n                count = byteBuffer.getUShort(),\r\n                i,\r\n                key,\r\n                chromId,\r\n                chromSize,\r\n                childOffset,\r\n                bufferOffset,\r\n                currOffset;\r\n\r\n\r\n            if (type == 1) {\r\n\r\n                for (i = 0; i < count; i++) {\r\n\r\n                    key = byteBuffer.getFixedLengthTrimmedString(keySize);\r\n                    chromId = byteBuffer.getInt();\r\n                    chromSize = byteBuffer.getInt();\r\n\r\n                    if(genome) key = genome.getChromosomeName(key);  // Translate to canonical chr name\r\n                    dictionary[key] = chromId;\r\n\r\n                }\r\n            }\r\n            else { // non-leaf\r\n\r\n                for (i = 0; i < count; i++) {\r\n\r\n                    key = byteBuffer.getFixedLengthTrimmedString(keySize);\r\n                    childOffset = byteBuffer.getLong();\r\n                    bufferOffset = childOffset - startOffset;\r\n                    currOffset = byteBuffer.position;\r\n                    readTreeNode(byteBuffer, bufferOffset, keySize, dictionary);\r\n                    byteBuffer.position = currOffset;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\"), __webpack_require__(/*! extend */ \"extend\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmlnd2lnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2JpZ3dpZy5qcz9lODgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5pbXBvcnQge2lndnhocn0gZnJvbSBcIi4vaWd2eGhyLmpzXCI7XHJcblxyXG5cclxuLy8qKioqKioqKioqKmpzL2JpZ3dpZy9idWZmZXJlZFJlYWRlci5qcyoqKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJ1ZmZlcmVkUmVhZGVye1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBjb250ZW50TGVuZ3RoLCBidWZmZXJTaXplKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemUgPyBidWZmZXJTaXplIDogNTEyMDAwO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSB7c3RhcnQ6IC0xLCBzaXplOiAtMX07XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZFJhbmdlIC0gYnl0ZSByYW5nZWFzIHtzdGFydCwgc2l6ZX1cclxuICAgICAqIEBwYXJhbSBmdWxmaWxsIC0gZnVuY3Rpb24gdG8gcmVjZWl2ZSByZXN1bHRcclxuICAgICAqIEBwYXJhbSBhc1VpbnQ4IC0gb3B0aW9uYWwgZmxhZyB0byByZXR1cm4gcmVzdWx0IGFzIGFuIFVJbnQ4QXJyYXlcclxuICAgICAqL1xyXG4gICAgZGF0YVZpZXdGb3JSYW5nZShyZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNEYXRhID0gKHNlbGYuZGF0YSAmJiAoc2VsZi5yYW5nZS5zdGFydCA8PSByZXF1ZXN0ZWRSYW5nZS5zdGFydCkgJiZcclxuICAgICAgICAgICAgICAgICgoc2VsZi5yYW5nZS5zdGFydCArIHNlbGYucmFuZ2Uuc2l6ZSkgPj0gKHJlcXVlc3RlZFJhbmdlLnN0YXJ0ICsgcmVxdWVzdGVkUmFuZ2Uuc2l6ZSkpKSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlclNpemUsXHJcbiAgICAgICAgICAgICAgICBsb2FkUmFuZ2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc3ViYnVmZmVyKHNlbGYsIHJlcXVlc3RlZFJhbmdlLCBhc1VpbnQ4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBidWZmZXIgc2l6ZSBpZiBuZWVkZWQsIGJ1dCBub3QgYmV5b25kIGNvbnRlbnQgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplID0gTWF0aC5tYXgoc2VsZi5idWZmZXJTaXplLCByZXF1ZXN0ZWRSYW5nZS5zaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb250ZW50TGVuZ3RoID4gMCAmJiByZXF1ZXN0ZWRSYW5nZS5zdGFydCArIGJ1ZmZlclNpemUgPiBzZWxmLmNvbnRlbnRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkUmFuZ2UgPSB7c3RhcnQ6IHJlcXVlc3RlZFJhbmdlLnN0YXJ0fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRSYW5nZSA9IHtzdGFydDogcmVxdWVzdGVkUmFuZ2Uuc3RhcnQsIHNpemU6IGJ1ZmZlclNpemV9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5wYXRoLCBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCB7cmFuZ2U6IGxvYWRSYW5nZX0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF0YSA9IGFycmF5QnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmFuZ2UgPSBsb2FkUmFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViYnVmZmVyKHNlbGYsIHJlcXVlc3RlZFJhbmdlLCBhc1VpbnQ4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3ViYnVmZmVyKGJ1ZmZlcmVkUmVhZGVyLCByZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXJlZFJlYWRlci5kYXRhLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyU3RhcnQgPSByZXF1ZXN0ZWRSYW5nZS5zdGFydCAtIGJ1ZmZlcmVkUmVhZGVyLnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzVWludDggP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXJlZFJlYWRlci5kYXRhLCBidWZmZXJTdGFydCwgbGVuIC0gYnVmZmVyU3RhcnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcmVkUmVhZGVyLmRhdGEsIGJ1ZmZlclN0YXJ0LCBsZW4gLSBidWZmZXJTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqKioqanMvYmlnd2lnL2J3U291cmNlLmpzKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJXU291cmNle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxjcmVhdGVfZmVhdHVyZV9mdW5jdGlvbikge1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gbmV3IEJXUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIGlmICghY3JlYXRlX2ZlYXR1cmVfZnVuY3Rpb24pe1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlPUJXU291cmNlLmNyZWF0ZUZlYXR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlX2ZlYXR1cmU9Y3JlYXRlX2ZlYXR1cmVfZnVuY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuXHQqIENyZWF0ZXMgYSBwYW5lbFxyXG5cdCogQHBhcmFtIHtzdHJpbmd9IGNociAtIFRoZSBjaHJvbW9zb21lXHJcblx0KiBAcGFyYW0ge2ludH0gYnBTdGFydCBUaGUgc3RhcnRpbmcgcG9zdGl0aW9uIFxyXG5cdCogQHBhcmFtIHtpbnR9IGJwRW5kIC0gVGhlIGVuZCBvZiB0aGUgcmVnaW9uIHRvIHNob3dcclxuXHQqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlX2V4aXN0aW5nIC0gSWYgdHJ1ZSB0aGVuIHRoZSBjYWNoZWQgZmVhdHVyZSB3aWxsIGJlIHVzZWQtIG9ubHkgdXNlZFxyXG5cdCogaWYgdGhlIGNvLW9yaWRpbmF0ZXMgaGF2ZSBub3QgY2hhbmdlZC4gQWx0aG91Z2gsIHRoZSBCV3JlYWRlciBoYXMgYSBjYWNoZSwgaXQgaXMgc29tZXRpbWVzXHJcblx0KiBpZ25vcmVkIGFuZCBmZWF0dXJlcyBhcmUgcmUtZmV0Y2hlZCBmb3IgdGhlIHNhbWUgcmVnaW9uXHJcblx0KiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIFNob3VsZCBjb250YWluIHBpeGVsV2lkdGgtIHRoZSB3aWR0aCBvZiB0aGUgZW50aXJlIGNhbnZhcyBhbmQgXHJcblx0KiBicFBlclBpeGVsLlxyXG5cdCovXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kLHVzZV9leGlzdGluZyxkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5mZWF0dXJlcyAmJiB1c2VfZXhpc3Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmZlYXR1cmVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnJlYWRlci5nZXRab29tSGVhZGVycygpLnRoZW4oZnVuY3Rpb24gKHpvb21MZXZlbEhlYWRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgYSBiaXdpZyBcInpvb20gbGV2ZWxcIiBhcHByb3ByaWF0ZSBmb3IgdGhlIGN1cnJlbnQgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ3UmVhZGVyID0gc2VsZi5yZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIgPSBzZWxmLmJ1ZmZlcmVkUmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJwcCA9ZGF0YS5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbEhlYWRlcj1CV1NvdXJjZS56b29tTGV2ZWxGb3JTY2FsZShicHAsIHpvb21MZXZlbEhlYWRlcnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVPZmZzZXRcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICh6b29tTGV2ZWxIZWFkZXIgJiYgYndSZWFkZXIudHlwZT09PVwiQmlnV2lnXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlT2Zmc2V0ID0gem9vbUxldmVsSGVhZGVyLmluZGV4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24gPSBCV1NvdXJjZS5kZWNvZGVab29tRGF0YTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZU9mZnNldCA9IGJ3UmVhZGVyLmhlYWRlci5mdWxsSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ3UmVhZGVyLnR5cGUgPT09IFwiQmlnV2lnXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVGdW5jdGlvbiA9QldTb3VyY2UuZGVjb2RlV2lnRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24gPXNlbGYuZGVjb2RlQmVkRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYndSZWFkZXIubG9hZFJQVHJlZSh0cmVlT2Zmc2V0KS50aGVuKGZ1bmN0aW9uIChycFRyZWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNocklkeCA9IHNlbGYucmVhZGVyLmNocm9tVHJlZS5kaWN0aW9uYXJ5W2Nocl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocklkeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcnBUcmVlLmZpbmRMZWFmSXRlbXNPdmVybGFwcGluZyhjaHJJZHgsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bmN0aW9uIChsZWFmSXRlbXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxlYWZJdGVtcyB8fCBsZWFmSXRlbXMubGVuZ3RoID09IDApIGZ1bGZpbGwoW10pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyLmRhdGFWaWV3Rm9yUmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGl0ZW0uZGF0YU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGl0ZW0uZGF0YVNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSkudGhlbihmdW5jdGlvbiAodWludDhBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlID0gbmV3IFpsaWIuWmxpYi5JbmZsYXRlKHVpbnQ4QXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhaW49IGluZmxhdGUuZGVjb21wcmVzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2luZmxhdGUucHVzaCh1aW50OEFycmF5LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIHBsYWluID0gaW5mbGF0ZS5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uKG5ldyBEYXRhVmlldyhwbGFpbi5idWZmZXIpLCBjaHIsIGNocklkeCwgYnBTdGFydCwgYnBFbmQsIGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChmZWF0dXJlQXJyYXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBlbi1zZWxmLnN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gYnBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGFsbEZlYXR1cmVzID0gZmVhdHVyZUFycmF5c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmZWF0dXJlQXJyYXlzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaT0xOyBpPGZlYXR1cmVBcnJheXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBhbGxGZWF0dXJlcy5jb25jYXQoZmVhdHVyZUFycmF5c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlcz1hbGxGZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsbEZlYXR1cmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgZ2V0RGVmYXVsdFJhbmdlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeS5kZWZhdWx0UmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIHpvb21MZXZlbEZvclNjYWxlKGJwUGVyUGl4ZWwsIHpvb21MZXZlbEhlYWRlcnMpIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gbnVsbCwgaSwgemw7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICB6bCA9IHpvb21MZXZlbEhlYWRlcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoemwucmVkdWN0aW9uTGV2ZWwgPiBicFBlclBpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHpsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChudWxsID09IGxldmVsKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gem9vbUxldmVsSGVhZGVyc1t6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsZXZlbCAmJiBsZXZlbC5yZWR1Y3Rpb25MZXZlbCA8IDQgKiBicFBlclBpeGVsKSA/IGxldmVsIDogbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZ0RhdGEoZGF0YSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YSksXHJcbiAgICAgICAgICAgIGNocm9tSWQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICBpdGVtU3RlcCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgaXRlbVNwYW4gPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIHR5cGUgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgICAgICByZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKSxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChjaHJvbUlkID09PSBjaHJJZHgpIHtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVtQ291bnQtLSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6ICAvLyBGaXhlZCBzdGVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHJvbVN0YXJ0ICs9IGl0ZW1TdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNocm9tU3RhcnQgPj0gYnBFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gT3V0IG9mIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVpvb21EYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gOCAqIDQsICAgLy8gTWluaW11bSAjIG9mIGJ5dGVzIHJlcXVpcmVkIGZvciBhIHpvb20gcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICB2YWxpZENvdW50LFxyXG4gICAgICAgICAgICBtaW5WYWwsXHJcbiAgICAgICAgICAgIG1heFZhbCxcclxuICAgICAgICAgICAgc3VtRGF0YSxcclxuICAgICAgICAgICAgc3VtU3F1YXJlcyxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIHdoaWxlIChiaW5hcnlQYXJzZXIucmVtTGVuZ3RoKCkgPj0gbWluU2l6ZSkge1xyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCA9PT0gY2hySWR4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIG1pblZhbCA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1EYXRhID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1TcXVhcmVzID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkQ291bnQgPT0gMCA/IDAgOiBzdW1EYXRhIC8gdmFsaWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyb21TdGFydCA+PSBicEVuZCAmJiBjaHJvbVN0YXJ0PDEwMDAwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaG91bGQgaGF2ZSBicm9rZW5cIilcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIE91dCBvZiBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBkZWNvZGVCZWREYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gMyAqIDQgKyAxLCAgIC8vIE1pbmltdW0gIyBvZiBieXRlcyByZXF1aXJlZCBmb3IgYSBiZWQgcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICByZXN0LFxyXG4gICAgICAgICAgICB0b2tlbnMsXHJcbiAgICAgICAgICAgIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGV4b25Db3VudCwgZXhvblNpemVzLCBleG9uU3RhcnRzLCBleG9ucywgZVN0YXJ0LCBlRW5kO1xyXG5cclxuXHJcbiAgICAgICAgd2hpbGUgKGJpbmFyeVBhcnNlci5yZW1MZW5ndGgoKSA+PSBtaW5TaXplKSB7XHJcblxyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCAhPSBjaHJJZHgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgIHJlc3QgPSBiaW5hcnlQYXJzZXIuZ2V0U3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZH07XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hyb21TdGFydCA8IGJwRW5kICYmIGNocm9tRW5kID49IGJwU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVBcnJheS5wdXNoKGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRva2VucyA9IHJlc3Quc3BsaXQoXCJcXHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlKHRva2VucyxmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRpYyBjcmVhdGVGZWF0dXJlKHRva2VucyxmZWF0dXJlKXtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm5hbWUgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3RyYW5kID0gdG9rZW5zWzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5jZFN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuY2RFbmQgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAodG9rZW5zWzVdICE9PSBcIi5cIiAmJiB0b2tlbnNbNV0gIT09IFwiMFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZlYXR1cmUuY29sb3IgPSBpZ3YuY3JlYXRlQ29sb3JTdHJpbmcodG9rZW5zWzVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4b25Db3VudCA9IHBhcnNlSW50KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvblNpemVzID0gdG9rZW5zWzddLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvblN0YXJ0cyA9IHRva2Vuc1s4XS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4b25zID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVN0YXJ0ID0gc3RhcnQgKyBwYXJzZUludChleG9uU3RhcnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZUVuZCA9IGVTdGFydCArIHBhcnNlSW50KGV4b25TaXplc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4b25zLnB1c2goe3N0YXJ0OiBlU3RhcnQsIGVuZDogZUVuZH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vLyoqKioqKioqKioqKmpzL2JpZ3dpZy9id1JlYWRlci5qcyoqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgQklHV0lHX01BR0lDX0xUSCA9IDB4ODg4RkZDMjY7IC8vIEJpZ1dpZyBNYWdpYyBMb3cgdG8gSGlnaFxyXG5jb25zdCBCSUdXSUdfTUFHSUNfSFRMID0gMHgyNkZDOEY2NjsgLy8gQmlnV2lnIE1hZ2ljIEhpZ2ggdG8gTG93XHJcbmNvbnN0IEJJR0JFRF9NQUdJQ19MVEggPSAweDg3ODlGMkVCOyAvLyBCaWdCZWQgTWFnaWMgTG93IHRvIEhpZ2hcclxuY29uc3QgQklHQkVEX01BR0lDX0hUTCA9IDB4RUJGMjg5ODc7IC8vIEJpZ0JlZCBNYWdpYyBIaWdoIHRvIExvd1xyXG5jb25zdCBCQkZJTEVfSEVBREVSX1NJWkUgPSA2NDtcclxuXHJcblxyXG5jbGFzcyBCV1JlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5oZWFkUGF0aCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMucGF0aDtcclxuICAgICAgICB0aGlzLnJwVHJlZUNhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSAkLmV4dGVuZCh7fSxjb25maWcsdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdldFpvb21IZWFkZXJzKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnpvb21MZXZlbEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi56b29tTGV2ZWxIZWFkZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZEhlYWRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi56b29tTGV2ZWxIZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRIZWFkZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZToge3N0YXJ0OiAwLCBzaXplOiBCQkZJTEVfSEVBREVSX1NJWkV9fSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBsb3ctdG8taGlnaCB1bmxlc3MgcHJvdmVuIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgc2VsZi5saXR0bGVFbmRpYW4gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKG5ldyBEYXRhVmlldyhkYXRhKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldFVJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWFnaWMgPT09IEJJR1dJR19NQUdJQ19MVEgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGUgPSBcIkJpZ1dpZ1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnaWMgPT0gQklHQkVEX01BR0lDX0xUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnQmVkXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyeSBiaWcgZW5kaWFuIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXR0bGVFbmRpYW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldFVJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hZ2ljID09PSBCSUdXSUdfTUFHSUNfSFRMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnV2lnXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2ljID09IEJJR0JFRF9NQUdJQ19IVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdCZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gZXJyb3IsIHVua25vd24gZmlsZSB0eXBlICBvciBCRVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSA1ICBcIkNvbW1vbiBoZWFkZXIgZm9yIEJpZ1dpZyBhbmQgQmlnQmVkIGZpbGVzXCJcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyID0ge307XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5id1ZlcnNpb24gPSBiaW5hcnlQYXJzZXIuZ2V0VVNob3J0KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5uWm9vbUxldmVscyA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5mdWxsSW5kZXhPZmZzZXQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuZmllbGRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmRlZmluZWRGaWVsZENvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci50b3RhbFN1bW1hcnlPZmZzZXQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIudW5jb21wcmVzc0J1ZmZTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIucmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZFpvb21IZWFkZXJzQW5kQ2hyVHJlZSgpLnRoZW4oZnVsZmlsbCkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICBsb2FkWm9vbUhlYWRlcnNBbmRDaHJUcmVlKCkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gQkJGSUxFX0hFQURFUl9TSVpFLFxyXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHtzdGFydDogc3RhcnRPZmZzZXQsIHNpemU6IChzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCAtIHN0YXJ0T2Zmc2V0ICsgNSl9O1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZTogcmFuZ2V9KSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5ab29tcyA9IHNlbGYuaGVhZGVyLm5ab29tTGV2ZWxzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGRhdGEpKSxcclxuICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbixcclxuICAgICAgICAgICAgICAgICAgICB6b29tTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHpsaDtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnpvb21MZXZlbEhlYWRlcnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmZpcnN0Wm9vbURhdGFPZmZzZXQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ab29tczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgem9vbU51bWJlciA9IG5ab29tcyAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgemxoID0gbmV3IFpvb21MZXZlbEhlYWRlcih6b29tTnVtYmVyLCBiaW5hcnlQYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCA9IE1hdGgubWluKHpsaC5kYXRhT2Zmc2V0LCBzZWxmLmZpcnN0Wm9vbURhdGFPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuem9vbUxldmVsSGVhZGVycy5wdXNoKHpsaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXV0b3NxbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyLmF1dG9TcWxPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXV0b1NxbCA9IGJpbmFyeVBhcnNlci5nZXRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUb3RhbCBzdW1tYXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLnRvdGFsU3VtbWFyeU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudG90YWxTdW1tYXJ5ID0gbmV3IEJXVG90YWxTdW1tYXJ5KGJpbmFyeVBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hyb20gZGF0YSBpbmRleFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5jaHJvbVRyZWVPZmZzZXQgLSBzdGFydE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tVHJlZSA9IG5ldyBCUFRyZWUoYmluYXJ5UGFyc2VyLCBzdGFydE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0tIHRoaXMgaXMgYW4gZXJyb3IsIG5vdCBleHBlY3RlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vRmluYWxseSB0b3RhbCBkYXRhIGNvdW50XHJcbiAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZFJQVHJlZShvZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcnBUcmVlID0gc2VsZi5ycFRyZWVDYWNoZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICBpZiAocnBUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHJwVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBycFRyZWUgPSBuZXcgUlBUcmVlKG9mZnNldCwgc2VsZi5jb250ZW50TGVuZ3RoLCBzZWxmLmNvbmZpZywgc2VsZi5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5ycFRyZWVDYWNoZVtvZmZzZXRdID0gcnBUcmVlO1xyXG4gICAgICAgICAgICAgICAgcnBUcmVlLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJwVHJlZSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiBjbGFzcyBab29tTGV2ZWxIZWFkZXJ7XHJcbiAgICAgY29uc3RydWN0b3IoaW5kZXgsIGJ5dGVCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZWR1Y3Rpb25MZXZlbCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5yZXNlcnZlZCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5kYXRhT2Zmc2V0ID0gYnl0ZUJ1ZmZlci5nZXRMb25nKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleE9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgfVxyXG4gfVxyXG5cclxuXHJcbmNvbnN0IFJQVFJFRV9NQUdJQ19MVEggPSAweDI0NjhBQ0UwO1xyXG5jb25zdCBSUFRSRUVfTUFHSUNfSFRMID0gMHhFMEFDNjgyNDtcclxuY29uc3QgUlBUUkVFX0hFQURFUl9TSVpFID0gNDg7XHJcbmNvbnN0IFJQVFJFRV9OT0RFX0xFQUZfSVRFTV9TSVpFID0gMzI7ICAgLy8gbGVhZiBpdGVtIHNpemVcclxuY29uc3QgUlBUUkVFX05PREVfQ0hJTERfSVRFTV9TSVpFID0gMjQ7ICAvLyBjaGlsZCBpdGVtIHNpemVcclxuY29uc3QgQlVGRkVSX1NJWkUgPSA1MTIwMDA7IFxyXG5cclxuLy8qKioqKioqKioqKmpzL2JpZ3dpZy9SUFRyZWUqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuICAgICAvLyAgYnVmZmVyXHJcblxyXG5jbGFzcyBSUFRyZWV7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKGZpbGVPZmZzZXQsIGNvbnRlbnRMZW5ndGgsIGNvbmZpZywgbGl0dGxlRW5kaWFuKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuZmlsZXNpemUgPSBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZmlsZU9mZnNldCA9IGZpbGVPZmZzZXQ7IC8vIEZpbGUgb2Zmc2V0IHRvIGJlZ2lubmluZyBvZiB0cmVlXHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgbG9hZCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdE5vZGVPZmZzZXQgPSBzZWxmLmZpbGVPZmZzZXQgKyBSUFRSRUVfSEVBREVSX1NJWkUsXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihzZWxmLmNvbmZpZywgc2VsZi5maWxlc2l6ZSwgQlVGRkVSX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5yZWFkTm9kZShyb290Tm9kZU9mZnNldCwgYnVmZmVyZWRSZWFkZXIpLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYucm9vdE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVhZE5vZGUoZmlsZVBvc2l0aW9uLCBidWZmZXJlZFJlYWRlcikge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHtzdGFydDogZmlsZVBvc2l0aW9uLCBzaXplOiA0fSwgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGRhdGFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihkYXRhVmlldywgc2VsZi5saXR0bGVFbmRpYW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYmluYXJ5UGFyc2VyLmdldEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xlYWYgPSAodHlwZSA9PT0gMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVQb3NpdGlvbiArPSA0O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBieXRlc1JlcXVpcmVkID0gY291bnQgKiAoaXNMZWFmID8gUlBUUkVFX05PREVfTEVBRl9JVEVNX1NJWkUgOiBSUFRSRUVfTk9ERV9DSElMRF9JVEVNX1NJWkUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlMiA9IHtzdGFydDogZmlsZVBvc2l0aW9uLCBzaXplOiBieXRlc1JlcXVpcmVkfTtcclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHJhbmdlMiwgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGRhdGFWaWV3KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IG5ldyBBcnJheShjb3VudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YVZpZXcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWFmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWY6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDaHJvbTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQ6IGJpbmFyeVBhcnNlci5nZXRMb25nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNpemU6IGJpbmFyeVBhcnNlci5nZXRMb25nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobmV3IFJQVHJlZU5vZGUoaXRlbXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIG5vbi1sZWFmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFmOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ2hyb206IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRPZmZzZXQ6IGJpbmFyeVBhcnNlci5nZXRMb25nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG5ldyBSUFRyZWVOb2RlKGl0ZW1zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZmluZExlYWZJdGVtc092ZXJsYXBwaW5nKGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsZWFmSXRlbXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgPSBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihzZWxmLmNvbmZpZywgc2VsZi5maWxlc2l6ZSwgQlVGRkVSX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgcHJvY2Vzc2luZy5hZGQoMCk7ICAvLyBaZXJvIHJlcHJlc2VudHMgdGhlIHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKHNlbGYucm9vdE5vZGUsIDApO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZExlYWZJdGVtcyhub2RlLCBub2RlSWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoUlBUcmVlLm92ZXJsYXBzKG5vZGUsIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBub2RlLml0ZW1zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUlBUcmVlLm92ZXJsYXBzKGl0ZW0sIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzTGVhZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZJdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKGl0ZW0uY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcuYWRkKGl0ZW0uY2hpbGRPZmZzZXQpOyAgLy8gUmVwcmVzZW50IG5vZGUgdG8tYmUtbG9hZGVkIGJ5IGl0cyBmaWxlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZE5vZGUoaXRlbS5jaGlsZE9mZnNldCwgYnVmZmVyZWRSZWFkZXIpLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRMZWFmSXRlbXMobm9kZSwgaXRlbS5jaGlsZE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgIT0gdW5kZWZpbmVkKSBwcm9jZXNzaW5nLmRlbGV0ZShub2RlSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG5vZGVzIGFyZSBwcm9jZXNzZWRcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nLnNpemU9PT0wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChsZWFmSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB7Y2hySWR4OnN0YXJ0QmFzZS1lbmRCYXNlfSBvdmVybGFwcyBpdGVtJ3MgaW50ZXJ2YWxcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb3ZlcmxhcHMoaXRlbSwgY2hySWR4LCBzdGFydEJhc2UsIGVuZEJhc2UpIHtcclxuXHJcbiAgICAgICAgLy8gIGlmIChjaHJJZHggPiBpdGVtLmVuZENocm9tIHx8IGNocklkeCA8IGl0ZW0uc3RhcnRDaHJvbSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJudWxsIGl0ZW1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKGNocklkeCA+IGl0ZW0uc3RhcnRDaHJvbSkgfHwgKGNocklkeCA9PSBpdGVtLnN0YXJ0Q2hyb20gJiYgZW5kQmFzZSA+PSBpdGVtLnN0YXJ0QmFzZSkpICYmXHJcbiAgICAgICAgICAgICgoY2hySWR4IDwgaXRlbS5lbmRDaHJvbSkgfHwgKGNocklkeCA9PSBpdGVtLmVuZENocm9tICYmIHN0YXJ0QmFzZSA8IGl0ZW0uZW5kQmFzZSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgUlBUcmVlTm9kZXtcclxuICAgIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xyXG5cclxuICAgICAgICB2YXIgbWluQ2hyb21JZCA9IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIG1heENocm9tSWQgPSAwLFxyXG4gICAgICAgICAgICBtaW5TdGFydEJhc2UgPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBtYXhFbmRCYXNlID0gMCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaXRlbTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgICAgbWluQ2hyb21JZCA9IE1hdGgubWluKG1pbkNocm9tSWQsIGl0ZW0uc3RhcnRDaHJvbSk7XHJcbiAgICAgICAgICAgIG1heENocm9tSWQgPSBNYXRoLm1heChtYXhDaHJvbUlkLCBpdGVtLmVuZENocm9tKTtcclxuICAgICAgICAgICAgbWluU3RhcnRCYXNlID0gTWF0aC5taW4obWluU3RhcnRCYXNlLCBpdGVtLnN0YXJ0QmFzZSk7XHJcbiAgICAgICAgICAgIG1heEVuZEJhc2UgPSBNYXRoLm1heChtYXhFbmRCYXNlLCBpdGVtLmVuZEJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydENocm9tID0gbWluQ2hyb21JZDtcclxuICAgICAgICB0aGlzLmVuZENocm9tID0gbWF4Q2hyb21JZDtcclxuICAgICAgICB0aGlzLnN0YXJ0QmFzZSA9IG1pblN0YXJ0QmFzZTtcclxuICAgICAgICB0aGlzLmVuZEJhc2UgPSBtYXhFbmRCYXNlO1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuLy8qKioqKioqKioqKioqKioqKioqanMvYmluYXJ5LmpzKioqKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJpbmFyeVBhcnNlcntcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFWaWV3LCBsaXR0bGVFbmRpYW4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSAobGl0dGxlRW5kaWFuID8gbGl0dGxlRW5kaWFuIDogdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gZGF0YVZpZXc7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGF2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbUxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPCB0aGlzLmxlbmd0aCAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qnl0ZSgpIHtcclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2hvcnQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyXHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFVTaG9ydCgpe1xyXG5cclxuICAgICAgICAvLyB2YXIgYnl0ZTEgPSB0aGlzLmdldEJ5dGUoKSxcclxuICAgICAgICAvLyAgICAgYnl0ZTIgPSB0aGlzLmdldEJ5dGUoKSxcclxuICAgICAgICAvLyAgICAgcmV0VmFsdWUgPSAoKGJ5dGUyIDw8IDI0ID4+PiAxNikgKyAoYnl0ZTEgPDwgMjQgPj4+IDI0KSk7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiByZXRWYWx1ZTtcclxuXHJcbiAgICAgICAvL1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYgKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDJcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEludCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRVSW50KCkge1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TG9uZygpIHtcclxuXHJcbiAgICAgICAgLy8gRGF0YVZpZXcgZG9lc24ndCBzdXBwb3J0IGxvbmcuIFNvIHdlJ2xsIHRyeSBtYW51YWxseVxyXG5cclxuICAgICAgICB2YXIgYiA9IFtdO1xyXG4gICAgICAgIGJbMF0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgYlsxXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMSk7XHJcbiAgICAgICAgYlsyXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMik7XHJcbiAgICAgICAgYlszXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMyk7XHJcbiAgICAgICAgYls0XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNCk7XHJcbiAgICAgICAgYls1XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNSk7XHJcbiAgICAgICAgYls2XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNik7XHJcbiAgICAgICAgYls3XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNyk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICB3aGlsZSAoKGMgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbisrKSkgIT0gMCkge1xyXG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIGlmIChsZW4gJiYgcy5sZW5ndGggPT0gbGVuKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Rml4ZWRMZW5ndGhTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspO1xyXG4gICAgICAgICAgICBpZiAoYyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspO1xyXG4gICAgICAgICAgICBpZiAoYyA+IDMyKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmxvYXQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RG91YmxlKCkge1xyXG5cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBza2lwKG4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGJnemlwIChiYW0gYW5kIHRhYml4KSB2aXJ0dWFsIHBvaW50ZXJcclxuICAgICAqIFRPRE8gLS0gd2h5IGlzbid0IDh0aCBieXRlIHVzZWQgP1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGdldFZQb2ludGVyKCkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMSkgPDwgOCkgfCAodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uKSksXHJcbiAgICAgICAgICAgIGJ5dGU2ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA2KSAmIDB4ZmYpICogMHgxMDAwMDAwMDApLFxyXG4gICAgICAgICAgICBieXRlNSA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgNSkgJiAweGZmKSAqIDB4MTAwMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGU0ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA0KSAmIDB4ZmYpICogMHgxMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGUzID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAzKSAmIDB4ZmYpICogMHgxMDApLFxyXG4gICAgICAgICAgICBieXRlMiA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMikgJiAweGZmKSksXHJcbiAgICAgICAgICAgIGJsb2NrID0gYnl0ZTYgKyBieXRlNSArIGJ5dGU0ICsgYnl0ZTMgKyBieXRlMjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDg7XHJcblxyXG4gICAgICAgIC8vICAgICAgIGlmIChibG9jayA9PSAwICYmIG9mZnNldCA9PSAwKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIC8vICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWUG9pbnRlcihibG9jaywgb2Zmc2V0KTtcclxuICAgICAgICAvLyAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFZQb2ludGVye1xyXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIG9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpc0xlc3NUaGFuKHZwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPCB2cC5ibG9jayB8fFxyXG4gICAgICAgICAgICAodGhpcy5ibG9jayA9PT0gdnAuYmxvY2sgJiYgdGhpcy5vZmZzZXQgPCB2cC5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzR3JlYXRlclRoYW4odnApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA+IHZwLmJsb2NrIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmJsb2NrID09PSB2cC5ibG9jayAmJiB0aGlzLm9mZnNldCA+IHZwLm9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLmJsb2NrICsgXCI6XCIgKyB0aGlzLm9mZnNldDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vKioqKioqKmpzL2JpZ3dpZy9id1RvdGFsU3VtbWFyeS5qcyoqKioqKioqKioqKipcclxuXHJcblxyXG5cclxuY2xhc3MgQldUb3RhbFN1bW1hcnl7XHJcbiAgICBjb25zdHJ1Y3RvcihieXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgIGlmIChieXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pblZhbCA9IGJ5dGVCdWZmZXIuZ2V0RG91YmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4VmFsID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdW1EYXRhID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdW1TcXVhcmVzID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZVN0YXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubWluVmFsID0gMDtcclxuICAgICAgICAgICAgdGhpcy5tYXhWYWwgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN1bURhdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN1bVNxdWFyZXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm1lYW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZGRldiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAgY29tcHV0ZVN0YXRzKCkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5iYXNlc0NvdmVyZWQ7XHJcbiAgICAgICAgaWYgKG4gPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVhbiA9IHRoaXMuc3VtRGF0YSAvIG47XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZGV2ID0gTWF0aC5zcXJ0KHRoaXMuc3VtU3F1YXJlcyAvIChuIC0gMSkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMubWluVmFsIDwgMCA/IHRoaXMubWVhbiAtIDIgKiB0aGlzLnN0ZGRldiA6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLm1heFZhbCA+IDAgPyB0aGlzLm1lYW4gKyAyICogdGhpcy5zdGRkZXYgOiAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0UmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWVhbiArIDMgKiB0aGlzLnN0ZGRldlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVN0YXRzKHN0YXRzKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmFzZXNDb3ZlcmVkICs9IHN0YXRzLmNvdW50O1xyXG4gICAgICAgIHRoaXMuc3VtRGF0YSArPSBzdGF0dXMuc3VtRGF0YTtcclxuICAgICAgICB0aGlzLnN1bVNxdWFyZXMgKz0gc3VtU3F1YXJlcztcclxuICAgICAgICB0aGlzLm1pblZhbCA9IE1JTihfbWluVmFsLCBtaW4pO1xyXG4gICAgICAgIHRoaXMubWF4VmFsID0gTUFYKF9tYXhWYWwsIG1heCk7XHJcblxyXG4gICAgICAgIGNvbXB1dGVTdGF0cy5jYWxsKHRoaXMpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqKioqKioqKipqcy9iaWd3aWcvYndCUFRyZWUuanMqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJQVFJFRV9NQUdJQ19MVEggPSAweDc4Q0E4QzkxO1xyXG5jb25zdCBCUFRSRUVfTUFHSUNfSFRMID0gMHg5MThDQ0E3ODtcclxuY29uc3QgQlBUUkVFX0hFQURFUl9TSVpFID0gMzI7XHJcblxyXG5cclxuIGNsYXNzIEJQVHJlZXtcclxuICAgICBjb25zdHJ1Y3RvcihiaW5hcnlQYXJzZXIsIHN0YXJ0T2Zmc2V0KSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgZ2Vub21lID0gIG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhZGVyID0ge307XHJcbiAgICAgICAgdGhpcy5oZWFkZXIubWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIuYmxvY2tTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLmtleVNpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIudmFsU2l6ZSA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci5pdGVtQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLnJlc2VydmVkID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaWN0aW9uYXJ5ID0ge307XHJcblxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHdhbGsgdHJlZSB0byBwb3B1bGF0ZSBkaWN0aW9uYXJ5XHJcbiAgICAgICAgcmVhZFRyZWVOb2RlKGJpbmFyeVBhcnNlciwgLTEsIHRoaXMuaGVhZGVyLmtleVNpemUsIHRoaXMuZGljdGlvbmFyeSk7XHJcblxyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IDggKyB0aGlzLmhlYWRlci5rZXlTaXplO1xyXG4gICAgICAgIHZhciBtaW5TaXplID0gNCArIGl0ZW1TaXplOyAgIC8vIEJ5dGVzIGZvciBhIG5vZGUgd2l0aCAxIGl0ZW1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZFRyZWVOb2RlKGJ5dGVCdWZmZXIsIG9mZnNldCwga2V5U2l6ZSwgZGljdGlvbmFyeSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKG9mZnNldCA+PSAwKSBieXRlQnVmZmVyLnBvc2l0aW9uID0gb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBieXRlQnVmZmVyLmdldEJ5dGUoKSxcclxuICAgICAgICAgICAgICAgIHJlc2VydmVkID0gYnl0ZUJ1ZmZlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IGJ5dGVCdWZmZXIuZ2V0VVNob3J0KCksXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgY2hyb21JZCxcclxuICAgICAgICAgICAgICAgIGNocm9tU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgY3Vyck9mZnNldDtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gYnl0ZUJ1ZmZlci5nZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcoa2V5U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21JZCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21TaXplID0gYnl0ZUJ1ZmZlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZ2Vub21lKSBrZXkgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUoa2V5KTsgIC8vIFRyYW5zbGF0ZSB0byBjYW5vbmljYWwgY2hyIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0gPSBjaHJvbUlkO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gbm9uLWxlYWZcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBieXRlQnVmZmVyLmdldEZpeGVkTGVuZ3RoVHJpbW1lZFN0cmluZyhrZXlTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlck9mZnNldCA9IGNoaWxkT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCA9IGJ5dGVCdWZmZXIucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRyZWVOb2RlKGJ5dGVCdWZmZXIsIGJ1ZmZlck9mZnNldCwga2V5U2l6ZSwgZGljdGlvbmFyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUJ1ZmZlci5wb3NpdGlvbiA9IGN1cnJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQge0JXU291cmNlLEJpbmFyeVBhcnNlcn07XHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/bigwig.js\n");

/***/ }),

/***/ "./src/feature.js":
/*!************************!*\
  !*** ./src/feature.js ***!
  \************************/
/*! exports provided: FeatureSource, FastaSequence, BigBedFeatureSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FeatureSource\", function() { return FeatureSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FastaSequence\", function() { return FastaSequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BigBedFeatureSource\", function() { return BigBedFeatureSource; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n/* harmony import */ var _bam_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bam.js */ \"./src/bam.js\");\n/* harmony import */ var _bigwig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MAX_GZIP_BLOCK_SIZE = (1 << 16);\r\n\r\n    /**\r\n     * feature source for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n     *\r\n     * @param config\r\n     * @constructor\r\n     */\r\nclass FeatureSource{\r\n    constructor(config) {\r\n\r\n        this.config = config || {};\r\n\r\n        this.sourceType = (config.sourceType === undefined ? \"file\" : config.sourceType);\r\n\r\n        if (config.sourceType === \"ga4gh\") {\r\n            this.reader = new igv.Ga4ghVariantReader(config);\r\n        } else if (config.sourceType === \"immvar\") {\r\n            this.reader = new igv.ImmVarReader(config);\r\n        } else if (config.type === \"eqtl\") {\r\n            if (config.sourceType === \"gtex-ws\") {\r\n                this.reader = new igv.GtexReader(config);\r\n            }\r\n            else {\r\n                this.reader = new igv.GtexFileReader(config);\r\n            }\r\n        } else if (config.sourceType === \"bigquery\") {\r\n            this.reader = new igv.BigQueryFeatureReader(config);\r\n        }\r\n        else {\r\n            // Default for all sorts of ascii tab-delimited file formts\r\n            this.reader = new FeatureFileReader(config);\r\n        }\r\n        this.visibilityWindow = config.visibilityWindow;\r\n\r\n    }\r\n\r\n\r\n    getFileHeader() {\r\n\r\n        var self = this,\r\n            maxRows = this.config.maxRows || 500;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.header) {\r\n                fulfill(self.header);\r\n            } else {\r\n                if (typeof self.reader.readHeader === \"function\") {\r\n\r\n                    self.reader.readHeader().then(function (header) {\r\n                        self.is_indexed=true;\r\n                        // Non-indexed readers will return features as a side effect.  This is an important,\r\n                        // if unfortunate, performance hack\r\n\r\n                        if(header) {\r\n                            var features = header.features;\r\n                            if (features) {\r\n\r\n                                if (\"gtf\" === self.config.format || \"gff3\" === self.config.format || \"gff\" === self.config.format) {\r\n                                    features = (new igv.GFFHelper(self.config.format)).combineFeatures(features);\r\n                                }\r\n\r\n                                // Assign overlapping features to rows\r\n\r\n                                packFeatures(features, maxRows);\r\n                                self.featureCache = new FeatureCache(features);\r\n\r\n                                // If track is marked \"searchable\"< cache features by name -- use this with caution, memory intensive\r\n                                if (self.config.searchable) {\r\n                                    self.addFeaturesToDB(features);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (header && header.format) {\r\n                            self.config.format = header.format;\r\n                        }\r\n\r\n                        fulfill(header);\r\n                    }).catch(reject);\r\n                }\r\n                else {\r\n                    fulfill(null);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    static addFeaturesToDB(featureList) {\r\n        featureList.forEach(function (feature) {\r\n            if (feature.name) {\r\n                igv.browser.featureDB[feature.name.toUpperCase()] = feature;\r\n            }\r\n        })\r\n    }\r\n\r\n    getFeatures(chr,start,end,force,data){\r\n      \r\n        //no need to get header\r\n        if (this.is_indexed){\r\n            return this._getFeatures(chr,start,end,force,data);\r\n        }\r\n        //get headers/index then get features\r\n        var self = this;\r\n        return new Promise(function(fulfill,reject){\r\n            self.getFileHeader().then(function(){\r\n                self._getFeatures(chr,start,end,force,data).then(function(features){\r\n                    fulfill(features);\r\n                }).catch(reject)\r\n            }).catch(reject);\r\n        });\r\n        \r\n    }\r\n    /**\r\n     * Required function fo all data source objects.  Fetches features for the\r\n     * range requested and passes them on to the success function.  Usually this is\r\n     * a function that renders the features on the canvas\r\n     *\r\n     * @param chr\r\n     * @param bpStart\r\n     * @param bpEnd\r\n     */\r\n\r\n    _getFeatures(chr, bpStart, bpEnd,force,data) {\r\n        if (bpStart===0){\r\n            bpStart=1;\r\n        }\r\n        var self = this;\r\n        self.time=Date.now();\r\n        return new Promise(function (fulfill, reject) {\r\n            if (self.featureCache && chr !== self.featureCache.range.chr){\r\n                self.featureCache=null;\r\n            }\r\n            var genomicInterval = new GenomicInterval(chr, bpStart, bpEnd),\r\n                featureCache = self.featureCache,\r\n                maxRows = self.config.maxRows || 500;\r\n           \r\n            let ranges_to_get=false;\r\n            if (!featureCache){\r\n                ranges_to_get={all:[bpStart,bpEnd]};\r\n            }\r\n            else{\r\n                if (featureCache.range !== undefined){\r\n                    ranges_to_get=featureCache.range.rangesToGet(genomicInterval)\r\n                }\r\n            }\r\n            if (!ranges_to_get) {\r\n                fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\r\n\r\n            }\r\n            else {\r\n         \r\n             let promises=[];\r\n             let p_types=[];\r\n             for (let type in ranges_to_get){\r\n                    let range= ranges_to_get[type];\r\n                     promises.push(self.retrieveFeatures(chr, range[0], range[1],force,data));\r\n                     p_types.push([type,ranges_to_get[type]]);\r\n             }\r\n            \r\n\r\n            \r\n              Promise.all(promises).then(\r\n\r\n                    function (all_features) {\r\n                       \r\n                        let existing_features=[];\r\n                        if (self.featureCache){\r\n                            existing_features=self.featureCache.allFeatures();//featureCache.allFeatures(chr,self.featureCache.range.start,self.featureCache.range.end);\r\n                        }\r\n                        console.log(\"exisiting features:\"+existing_features.length)\r\n                    \r\n                        let index=0;\r\n                       \r\n                        for (let featureList of all_features){\r\n                            if (featureList === null){\r\n                                featureList=[];\r\n                            }\r\n                            \r\n                          /*  if (p_types[index][0]===\"all\"){\r\n                                new_range.start=p_types[index][1][0];\r\n                                new_range.end=p_types[index][1][1]\r\n                                if (featureList.length>0){\r\n                                   let st = featureList[0].start;\r\n                                   let end =featureList[featureList.length-1].end;\r\n                                   if (end>new_range.end){\r\n                                       new_range.end=end;\r\n                                   } \r\n                                   if (st<new_range.start){\r\n                                       new_range.start=st;\r\n                                   }      \r\n                                }\r\n                               */\r\n                               if (p_types[index][0]===\"left\"){\r\n                                   let end = p_types[index][1][1];\r\n                                   \r\n                                   //remove any already retieved\r\n                                  \r\n                                   let splice=0;\r\n                                   for (let n=featureList.length-1;n>=0;n--){\r\n                                       \r\n                                        if (featureList[n].end< end){\r\n                                            break;\r\n                                        }\r\n                                        splice++;\r\n                                   }\r\n                                   if (splice!==0){\r\n                                       featureList.splice(-splice)\r\n                                   }\r\n                                   console.log(\":::!!\"+featureList.length)\r\n                                   \r\n\r\n                                     \r\n                               \r\n                              }\r\n                              if (p_types[index][0]===\"right\"){\r\n                                  let start=p_types[index][1][0];\r\n                                \r\n                                   \r\n                                   //remove any already retieved\r\n                                   let n=0\r\n                                   for (n=0;n<featureList.length;n++){\r\n                                       \r\n                                        if (featureList[n].start> start){\r\n                                            break;\r\n                                        }\r\n                                   }\r\n                                   if (n!==0){\r\n                                       featureList.splice(0,n)\r\n                                   }\r\n                             }\r\n                            \r\n                            index++;\r\n\r\n                            console.log(\"new_features:\"+featureList.length)\r\n                            if (featureList && typeof featureList.forEach === 'function') {  // Have result AND its an array type\r\n\r\n                                var isIndexed =\r\n                                self.reader.indexed ||\r\n                                self.config.sourceType === \"ga4gh\" ||\r\n                                self.config.sourceType === \"immvar\" ||\r\n                                self.config.sourceType === \"gtex\" ||\r\n                                self.config.sourceType === \"bigquery\"||\r\n                                self.config.sourceType === \"custom\";\r\n\r\n                            // TODO -- COMBINE GFF FEATURES HERE\r\n                            // if(self.isGFF) featureList = combineFeatures(featureList);\r\n                                if (\"gtf\" === self.config.format || \"gff3\" === self.config.format || \"gff\" === self.config.format) {\r\n                                    featureList = (new igv.GFFHelper(self.config.format)).combineFeatures(featureList);\r\n                                }\r\n                                existing_features=existing_features.concat(featureList);\r\n                                console.log(\"all features:\"+existing_features.length)\r\n\r\n                            }\r\n                        }\r\n\r\n            \r\n\r\n                    \r\n                        let gi = self.featureCache?self.featureCache.range:genomicInterval;\r\n\r\n                        self.featureCache = isIndexed ?\r\n                                new FeatureCache(existing_features, gi) :\r\n                                new FeatureCache(featureList);   // Note - replacing previous cache with new one\r\n\r\n\r\n                            // Assign overlapping features to rows\r\n                            FeatureSource.packFeatures(existing_features, maxRows);\r\n\r\n                            // If track is marked \"searchable\"< cache features by name -- use this with caution, memory intensive\r\n                            if (self.config.searchable) {\r\n                                addFeaturesToDB(existing_features);\r\n                            }\r\n\r\n                            // Finally pass features for query interval to continuation\r\n                          /*  let alr ={};\r\n                            let f= self.featureCache.allFeatures();\r\n                            for (let i of f){\r\n                                if (alr[i.id]){\r\n                                    //console.log(i);\r\n                                    //console.log(alr[i.id]);\r\n                                }\r\n                                alr[i.id]=i;\r\n                            }\r\n                         */\r\n                        \r\n                            fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\r\n                      \r\n                        \r\n                      \r\n\r\n                    }).catch(function(error){\r\n                        reject(error);\r\n                    });\r\n            }\r\n        });\r\n    }\r\n\r\n    retrieveFeatures(chr,start,end){\r\n        return this.reader.readFeatures(chr,start,end);\r\n    }\r\n\r\n\r\n    static packFeatures(features, maxRows) {\r\n\r\n        if (features == null || features.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Segregate by chromosome\r\n\r\n        var chrFeatureMap = {},\r\n            chrs = [];\r\n        features.forEach(function (feature) {\r\n\r\n            var chr = feature.chr,\r\n                flist = chrFeatureMap[chr];\r\n\r\n            if (!flist) {\r\n                flist = [];\r\n                chrFeatureMap[chr] = flist;\r\n                chrs.push(chr);\r\n            }\r\n\r\n            flist.push(feature);\r\n        });\r\n\r\n        // Loop through chrosomosomes and pack features;\r\n\r\n        chrs.forEach(function (chr) {\r\n\r\n            pack(chrFeatureMap[chr], maxRows);\r\n        });\r\n\r\n\r\n        // Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no\r\n        // row number is assigned.\r\n        function pack(featureList, maxRows) {\r\n\r\n            var rows = [];\r\n\r\n            featureList.sort(function (a, b) {\r\n                return a.start - b.start;\r\n            })\r\n\r\n\r\n            rows.push(-1000);\r\n            featureList.forEach(function (feature) {\r\n\r\n                var i,\r\n                    r,\r\n                    len = Math.min(rows.length, maxRows),\r\n                    start = feature.start;\r\n\r\n                for (r = 0; r < len; r++) {\r\n                    if (start >= rows[r]) {\r\n                        feature.row = r;\r\n                        rows[r] = feature.end;\r\n                        return;\r\n                    }\r\n                }\r\n                feature.row = r;\r\n                rows[r] = feature.end;\r\n\r\n\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass BigBedFeatureSource extends FeatureSource{\r\n    constructor(config,decode_function){\r\n\t\tconfig.sourceType=\"gtex\";\r\n\t\tsuper(config);\r\n\t\tthis.header=true;\r\n\t\tthis.feature_source=new _bigwig_js__WEBPACK_IMPORTED_MODULE_3__[\"BWSource\"](config,decode_function);\r\n\t}\r\n\r\n\tretrieveFeatures(chr,bpStart,bpEnd,force,data){\r\n\t\treturn this.feature_source.getFeatures(chr,bpStart,bpEnd,false,data);     \t\r\n\t}\r\n}\r\n\r\n//********js/FeatureFileReader.js*****\r\n\r\n\r\n\r\nconst F_MAX_GZIP_BLOCK_SIZE = (1 << 16);\r\n\r\n    /**\r\n     * Reader for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n     *\r\n     * @param config\r\n     * @constructor\r\n     */\r\nclass FeatureFileReader{\r\n    constructor(config) {\r\n\r\n        this.config = config || {};\r\n\r\n        if (config.localFile) {\r\n            this.localFile = config.localFile;\r\n            this.filename = config.localFile.name;\r\n        }\r\n        else {\r\n            this.url = config.url;\r\n            this.indexURL = config.indexURL;\r\n            this.headURL = config.headURL || this.filename;\r\n\r\n            var uriParts = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].parseUri(config.url);\r\n            this.filename = uriParts.file;\r\n            this.path = uriParts.path;\r\n        }\r\n\r\n        this.format = config.format;\r\n\r\n        this.parser = this.getParser(this.format, config.decode);\r\n    };\r\n\r\n\r\n    getParser(format, decode) {\r\n        switch (format) {\r\n            case \"vcf\":\r\n                return new VcfParser();\r\n            case \"seg\" :\r\n                return new SegParser();\r\n            default:\r\n                return new FeatureParser(format, decode, this.config);\r\n        }\r\n\r\n    }\r\n\r\n    // seg files don't have an index\r\n    isIndexable() {\r\n        var configIndexURL = this.config.indexURL,\r\n            type = this.type,\r\n            configIndexed = this.config.indexed;\r\n\r\n        return configIndexURL || (type != \"wig\" && configIndexed != false);\r\n    }\r\n\r\n\r\n    /**\r\n     * Return a Promise for the async loaded index\r\n     */\r\n    loadIndex() {\r\n        var idxFile = this.indexURL;\r\n        if (this.filename.endsWith(\".gz\")) {\r\n            if (!idxFile) idxFile = this.url + \".tbi\";\r\n            return Object(_bam_js__WEBPACK_IMPORTED_MODULE_2__[\"loadBamIndex\"])(idxFile, this.config, true);\r\n        }\r\n        else {\r\n            if (!idxFile) idxFile = this.url + \".idx\";\r\n            return loadTribbleIndex(idxFile, this.config);\r\n        }\r\n    }\r\n\r\n    loadFeaturesNoIndex() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var parser = self.parser,\r\n                options = {\r\n                    headers: self.config.headers,           // http headers, not file header\r\n                    withCredentials: self.config.withCredentials\r\n                };\r\n\r\n            if (self.localFile) {\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadStringFromFile(self.localFile, options).then(parseData).catch(reject);\r\n            }\r\n            else {\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadString(self.url, options).then(parseData).catch(reject);\r\n            }\r\n\r\n\r\n            function parseData(data) {\r\n                self.header = parser.parseHeader(data);\r\n                if (self.header instanceof String && self.header.startsWith(\"##gff-version 3\")) {\r\n                    self.format = 'gff3';\r\n                }\r\n                fulfill(parser.parseFeatures(data));   // <= PARSING DONE HERE\r\n            };\r\n        });\r\n    }\r\n\r\n\r\n    loadFeaturesWithIndex(chr, start, end) {\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var blocks,\r\n                index = self.index,\r\n                tabix = index && index.tabix,\r\n                refId = tabix ? index.sequenceIndexMap[chr] : chr,\r\n                promises = [];\r\n\r\n            blocks = index.blocksForRange(refId, start, end);\r\n\r\n            if (!blocks || blocks.length === 0) {\r\n                fulfill(null);       // TODO -- is this correct?  Should it return an empty array?\r\n            }\r\n            else {\r\n\r\n                blocks.forEach(function (block) {\r\n\r\n                    promises.push(new Promise(function (fulfill, reject) {\r\n\r\n                        var startPos = block.minv.block,\r\n                            startOffset = block.minv.offset,\r\n                            endPos = block.maxv.block + (index.tabix ? F_MAX_GZIP_BLOCK_SIZE : 0),\r\n                            options = {\r\n                                headers: self.config.headers,           // http headers, not file header\r\n                                range: {start: startPos, size: endPos - startPos + 1},\r\n                                withCredentials: self.config.withCredentials\r\n                            },\r\n                            success;\r\n\r\n                        success = function (data) {\r\n\r\n                            var inflated, slicedData;\r\n\r\n                            if (index.tabix) {\r\n\r\n                                inflated = _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].arrayBufferToString(Object(_igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"unbgzf\"])(data));\r\n                                // need to decompress data\r\n                            }\r\n                            else {\r\n                                inflated = data;\r\n                            }\r\n\r\n                            slicedData = startOffset ? inflated.slice(startOffset) : inflated;\r\n                            var f = self.parser.parseFeatures(slicedData);\r\n                            fulfill(f);\r\n                        };\r\n\r\n\r\n                        // Async load\r\n                        if (self.localFile) {\r\n                            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadStringFromFile(self.localFile, options).then(success).catch(reject);\r\n                        }\r\n                        else {\r\n                            if (index.tabix) {\r\n                                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadArrayBuffer(self.url, options).then(success).catch(reject);\r\n                            }\r\n                            else {\r\n                                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadString(self.url, options).then(success).catch(reject);\r\n                            }\r\n                        }\r\n                    }))\r\n                });\r\n\r\n                Promise.all(promises).then(function (featureArrays) {\r\n\r\n                    var i, allFeatures;\r\n\r\n                    if (featureArrays.length === 1) {\r\n                        allFeatures = featureArrays[0];\r\n                    } else {\r\n                        allFeatures = featureArrays[0];\r\n\r\n                        for (i = 1; i < featureArrays.length; i++) {\r\n                            allFeatures = allFeatures.concat(featureArrays[i]);\r\n                        }\r\n\r\n                        allFeatures.sort(function (a, b) {\r\n                            return a.start - b.start;\r\n                        });\r\n                    }\r\n\r\n                    fulfill(allFeatures)\r\n                }).catch(reject);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n\r\n    getIndex() {\r\n\r\n        var self = this,\r\n        isIndeedIndexible = this.isIndexable();\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.indexed === undefined && isIndeedIndexible) {\r\n                self.loadIndex().then(function (index) {\r\n                    if (index) {\r\n                        self.index = index;\r\n                        self.indexed = true;\r\n                    }\r\n                    else {\r\n                        self.indexed = false;\r\n                    }\r\n                    fulfill(self.index);\r\n                }).catch(reject);\r\n            }\r\n            else {\r\n                fulfill(self.index);   // Is either already loaded, or there isn't one\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    readHeader() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n\r\n            if (self.header) {\r\n                fulfill(self.header);\r\n            }\r\n\r\n            else {\r\n\r\n                // We force a load of the index first\r\n\r\n               self. getIndex().then(function (index) {\r\n\r\n                    if (index) {\r\n                        // Load the file header (not HTTP header) for an indexed file.\r\n                        // TODO -- note this will fail if the file header is > 65kb in size\r\n                        var options = {\r\n                                headers: self.config.headers,           // http headers, not file header\r\n                                bgz: index.tabix,\r\n                                range: {start: 0, size: 65000},\r\n                                withCredentials: self.config.withCredentials\r\n                            },\r\n                            success = function (data) {\r\n                                self.header = self.parser.parseHeader(data);\r\n                                fulfill(self.header);\r\n                            };\r\n\r\n                        if (self.localFile) {\r\n                            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadStringFromFile(self.localFile, options).then(success);\r\n                        }\r\n                        else {\r\n                            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadString(self.url, options).then(success).catch(reject);\r\n                        }\r\n                    }\r\n                    else {\r\n                        self.loadFeaturesNoIndex(undefined).then(function (features) {\r\n                            var header = self.header || {};\r\n                            header.features = features;\r\n                            fulfill(header);\r\n                        }).catch(error);\r\n                    }\r\n                }).catch(reject);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param fulfill\r\n     * @param range -- genomic range to load.  For use with indexed source (optional)\r\n     */\r\n    readFeatures(chr, start, end) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.index) {\r\n                self.loadFeaturesWithIndex(chr, start, end).then(packFeatures);\r\n            }\r\n            else {\r\n                self.loadFeaturesNoIndex().then(packFeatures);\r\n            }\r\n\r\n            function packFeatures(features) {\r\n                // TODO pack\r\n                fulfill(features);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//***js/feature/FeatureParsers.js**************\r\n\r\n\r\nconst maxFeatureCount = Number.MAX_VALUE;    // For future use,  controls downsampling\r\n\r\nconst gffNameFields = [\"Name\", \"gene_name\", \"gene\", \"gene_id\", \"alias\", \"locus\"];\r\n\r\n    /**\r\n     * A factory function.  Return a parser for the given file format.\r\n     */\r\nclass FeatureParser{\r\n    constructor(format, decode, config) {\r\n\r\n        var customFormat;\r\n\r\n        this.format = format;\r\n        this.nameField = config ? config.nameField : undefined;\r\n        this.skipRows = 0;   // The number of fixed header rows to skip.  Override for specific types as needed\r\n\r\n        if (decode) {\r\n            this.decode = decode;\r\n        }\r\n\r\n\r\n        switch (format) {\r\n            case \"narrowpeak\":\r\n            case \"broadpeak\":\r\n            case \"peaks\":\r\n                this.decode = this.decodePeak;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"bedgraph\":\r\n                this.decode = this.decodeBedGraph;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"wig\":\r\n                this.decode = this.decodeWig;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"gff3\" :\r\n            case \"gff\" :\r\n            case \"gtf\" :\r\n                this.decode = this.decodeGFF;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            case \"aneu\":\r\n                this.decode = this.decodeAneu;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            case \"fusionjuncspan\":\r\n                // bhaas, needed for FusionInspector view\r\n                this.decode = this.decodeFusionJuncSpan;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"gtexgwas\":\r\n                this.skipRows = 1;\r\n                this.decode = this.decodeGtexGWAS;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            case \"refflat\":\r\n                this.decode = this.decodeRefflat;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            default:\r\n\r\n               /* customFormat = igv.browser.getFormat(format);\r\n                if (customFormat !== undefined) {\r\n                    this.decode = decodeCustom;\r\n                    this.format = customFormat;\r\n                    this.delimiter = customFormat.delimiter || \"\\t\";\r\n                }\r\n\r\n                else {\r\n                                                */\r\n                    this.decode = FeatureParser.decodeBed;\r\n                    this.delimiter = /\\s+/;\r\n               // }\r\n\r\n        }\r\n\r\n    };\r\n\r\n    parseHeader(data) {\r\n\r\n        var lines = data.split(\"\\n\"),\r\n            len = lines.length,\r\n            line,\r\n            i,\r\n            header;\r\n\r\n        for (i = 0; i < len; i++) {\r\n            line = lines[i];\r\n            if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\r\n                if (line.startsWith(\"track\")) {\r\n                    header = this.parseTrackLine(line);\r\n                }\r\n                else if (line.startsWith(\"##gff-version 3\")) {\r\n                    this.format = \"gff3\";\r\n                    if (!header) header = {};\r\n                    header[\"format\"] = \"gff3\";\r\n                }\r\n            }\r\n            else {\r\n                header={};\r\n                break;\r\n            }\r\n        }\r\n        return header;\r\n    };\r\n\r\n    parseFeatures(data) {\r\n\r\n        if (!data) return null;\r\n\r\n        var wig,\r\n            feature,\r\n            lines = data.split(\"\\n\"),\r\n            len = lines.length,\r\n            tokens,\r\n            allFeatures = [],\r\n            line,\r\n            i,\r\n            cnt = 0,\r\n            j,\r\n            decode = this.decode,\r\n            format = this.format,\r\n            delimiter = this.delimiter || \"\\t\";\r\n\r\n\r\n        for (i = this.skipRows; i < len; i++) {\r\n            line = lines[i];\r\n            if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\r\n                continue;\r\n            }\r\n            else if (format === \"wig\" && line.startsWith(\"fixedStep\")) {\r\n                wig = this.parseFixedStep(line);\r\n                continue;\r\n            }\r\n            else if (format === \"wig\" && line.startsWith(\"variableStep\")) {\r\n                wig = this.parseVariableStep(line);\r\n                continue;\r\n            }\r\n\r\n            tokens = lines[i].split(delimiter);\r\n            if (tokens.length < 1) continue;\r\n\r\n            feature = this.decode(tokens, wig);\r\n\r\n            if (feature) {\r\n                if (allFeatures.length < maxFeatureCount) {\r\n                    allFeatures.push(feature);\r\n                }\r\n                else {\r\n                    // Reservoir sampling,  conditionally replace existing feature with new one.\r\n                    j = Math.floor(Math.random() * cnt);\r\n                    if (j < maxFeatureCount) {\r\n                        allFeatures[j] = feature;\r\n                    }\r\n                }\r\n                cnt++;\r\n            }\r\n        }\r\n\r\n        return allFeatures;\r\n    };\r\n\r\n\r\n    static parseFixedStep(line) {\r\n\r\n        var tokens = line.split(/\\s+/),\r\n            cc = tokens[1].split(\"=\")[1],\r\n            ss = parseInt(tokens[2].split(\"=\")[1], 10),\r\n            step = parseInt(tokens[3].split(\"=\")[1], 10),\r\n            span = (tokens.length > 4) ? parseInt(tokens[4].split(\"=\")[1], 10) : 1;\r\n\r\n        return {format: \"fixedStep\", chrom: cc, start: ss, step: step, span: span, index: 0};\r\n\r\n    }\r\n\r\n    static parseVariableStep(line) {\r\n\r\n        var tokens = line.split(/\\s+/),\r\n            cc = tokens[1].split(\"=\")[1],\r\n            span = tokens.length > 2 ? parseInt(tokens[2].split(\"=\")[1], 10) : 1;\r\n        return {format: \"variableStep\", chrom: cc, span: span}\r\n\r\n    }\r\n\r\n    static parseTrackLine(line) {\r\n        var properties = {},\r\n            tokens = line.split(/(?:\")([^\"]+)(?:\")|([^\\s\"]+)(?=\\s+|$)/g),\r\n            tmp = [],\r\n            i, tk, curr;\r\n\r\n        // Clean up tokens array\r\n        for (i = 1; i < tokens.length; i++) {\r\n            if (!tokens[i] || tokens[i].trim().length === 0) continue;\r\n\r\n            tk = tokens[i].trim();\r\n\r\n            if (tk.endsWith(\"=\") > 0) {\r\n                curr = tk;\r\n            }\r\n            else if (curr) {\r\n                tmp.push(curr + tk);\r\n                curr = undefined;\r\n            }\r\n            else {\r\n                tmp.push(tk);\r\n            }\r\n\r\n        }\r\n\r\n\r\n        tmp.forEach(function (str) {\r\n            if (!str) return;\r\n            var kv = str.split('=', 2);\r\n            if (kv.length == 2) {\r\n                properties[kv[0]] = kv[1];\r\n            }\r\n\r\n        });\r\n\r\n        return properties;\r\n    }\r\n\r\n    /**\r\n     * Decode the \"standard\" UCSC bed format\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns decoded feature, or null if this is not a valid record\r\n     */\r\n    static decodeBed(tokens, ignore) {\r\n\r\n        var chr, start, end, id, name, tmp, idName, exonCount, exonSizes, exonStarts, exons, exon, feature,\r\n            eStart, eEnd;\r\n\r\n        if (tokens.length < 3) return null;\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]);\r\n        end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;\r\n\r\n        feature = {chr: chr, start: start, end: end, score: 1000};\r\n\r\n        if (tokens.length > 3) {\r\n            // Note: these are very special rules for the gencode gene files.\r\n            tmp = tokens[3].replace(/\"/g, '');\r\n            idName = tmp.split(';');\r\n            for (var i = 0; i < idName.length; i++) {\r\n                var kv = idName[i].split('=');\r\n                if (kv[0] == \"gene_id\") {\r\n                    id = kv[1];\r\n                }\r\n                if (kv[0] == \"gene_name\") {\r\n                    name = kv[1];\r\n                }\r\n            }\r\n            feature.id = id ? id : tmp;\r\n            feature.name = name ? name : tmp;\r\n        }\r\n\r\n        if (tokens.length > 4) {\r\n            feature.score = parseFloat(tokens[4]);\r\n        }\r\n        if (tokens.length > 5) {\r\n            feature.strand = tokens[5];\r\n        }\r\n        if (tokens.length > 6) {\r\n            feature.cdStart = parseInt(tokens[6]);\r\n        }\r\n        if (tokens.length > 7) {\r\n            feature.cdEnd = parseInt(tokens[7]);\r\n        }\r\n        if (tokens.length > 8) {\r\n            if (tokens[8] !== \".\" && tokens[8] !== \"0\")\r\n                feature.color = igv.createColorString(tokens[8]);\r\n        }\r\n        if (tokens.length > 11) {\r\n            exonCount = parseInt(tokens[9]);\r\n            exonSizes = tokens[10].split(',');\r\n            exonStarts = tokens[11].split(',');\r\n            exons = [];\r\n\r\n            for (var i = 0; i < exonCount; i++) {\r\n                eStart = start + parseInt(exonStarts[i]);\r\n                eEnd = eStart + parseInt(exonSizes[i]);\r\n                var exon = {start: eStart, end: eEnd};\r\n\r\n                if (feature.cdStart > eEnd || feature.cdEnd < feature.cdStart) exon.utr = true;   // Entire exon is UTR\r\n                if (feature.cdStart >= eStart && feature.cdStart <= eEnd) exon.cdStart = feature.cdStart;\r\n                if (feature.cdEnd >= eStart && feature.cdEnd <= eEnd) exon.cdEnd = feature.cdEnd;\r\n\r\n                exons.push(exon);\r\n            }\r\n\r\n            feature.exons = exons;\r\n        }\r\n\r\n        feature.popupData = function () {\r\n            var data = [];\r\n            if (feature.name) data.push({name: \"Name\", value: feature.name});\r\n            if (\"+\" === feature.strand || \"-\" === feature.strand) data.push({name: \"Strand\", value: feature.strand});\r\n            return data;\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    /**\r\n     * Decode a UCSC \"refflat\" record\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns {*}\r\n     */\r\n    static decodeRefflat(tokens, ignore) {\r\n\r\n        if (tokens.length < 10) return null;\r\n\r\n        var feature = {\r\n                chr: tokens[2],\r\n                start: parseInt(tokens[4]),\r\n                end: parseInt(tokens[5]),\r\n                id: tokens[1],\r\n                name: tokens[0],\r\n                strand: tokens[3],\r\n                cdStart: parseInt(tokens[6]),\r\n                cdEnd: parseInt(tokens[7])\r\n            },\r\n            exonCount = parseInt(tokens[8]),\r\n            exonStarts = tokens[9].split(','),\r\n            exonEnds = tokens[10].split(','),\r\n            exons = [];\r\n\r\n        for (var i = 0; i < exonCount; i++) {\r\n            exons.push({start: parseInt(exonStarts[i]), end: parseInt(exonEnds[i])});\r\n        }\r\n\r\n        feature.exons = exons;\r\n\r\n        feature.popupData = function () {\r\n            return [{name: \"Name\", value: feature.name}];\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    static decodePeak(tokens, ignore) {\r\n\r\n        var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\r\n\r\n        tokenCount = tokens.length;\r\n        if (tokenCount < 9) {\r\n            return null;\r\n        }\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]);\r\n        end = parseInt(tokens[2]);\r\n        name = tokens[3];\r\n        score = parseFloat(tokens[4]);\r\n        strand = tokens[5].trim();\r\n        signal = parseFloat(tokens[6]);\r\n        pValue = parseFloat(tokens[7]);\r\n        qValue = parseFloat(tokens[8]);\r\n\r\n        if (score === 0) score = signal;\r\n\r\n        return {\r\n            chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\r\n            pValue: pValue, qValue: qValue\r\n        };\r\n    }\r\n\r\n    static decodeBedGraph(tokens, ignore) {\r\n\r\n        var chr, start, end, value;\r\n\r\n        if (tokens.length < 3) return null;\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]);\r\n        end = parseInt(tokens[2]);\r\n\r\n        value = parseFloat(tokens[3]);\r\n\r\n        return {chr: chr, start: start, end: end, value: value};\r\n    }\r\n\r\n    static decodeWig(tokens, wig) {\r\n\r\n        var ss,\r\n            ee,\r\n            value;\r\n\r\n        if (wig.format === \"fixedStep\") {\r\n\r\n            ss = (wig.index * wig.step) + wig.start;\r\n            ee = ss + wig.span;\r\n            value = parseFloat(tokens[0]);\r\n            ++(wig.index);\r\n            return isNaN(value) ? null : {chr: wig.chrom, start: ss, end: ee, value: value};\r\n        }\r\n        else if (wig.format === \"variableStep\") {\r\n\r\n            if (tokens.length < 2) return null;\r\n\r\n            ss = parseInt(tokens[0], 10);\r\n            ee = ss + wig.span;\r\n            value = parseFloat(tokens[1]);\r\n            return isNaN(value) ? null : {chr: wig.chrom, start: ss, end: ee, value: value};\r\n\r\n        }\r\n        else {\r\n            return decodeBedGraph(tokens);\r\n        }\r\n    }\r\n\r\n    static decodeAneu(tokens, ignore) {\r\n\r\n        var chr, start, end, feature;\r\n\r\n\r\n        if (tokens.length < 4) return null;\r\n\r\n        chr = tokens[1];\r\n        start = parseInt(tokens[2]);\r\n        end = tokens.length > 3 ? parseInt(tokens[3]) : start + 1;\r\n\r\n        feature = {chr: chr, start: start, end: end};\r\n\r\n        if (tokens.length > 4) {\r\n            feature.score = parseFloat(tokens[4]);\r\n            feature.value = feature.score;\r\n        }\r\n\r\n\r\n        feature.popupData = function () {\r\n            return [{name: \"Name\", value: feature.name}];\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    static decodeFusionJuncSpan(tokens, ignore) {\r\n\r\n        /*\r\n         Format:\r\n\r\n         0       #scaffold\r\n         1       fusion_break_name\r\n         2       break_left\r\n         3       break_right\r\n         4       num_junction_reads\r\n         5       num_spanning_frags\r\n         6       spanning_frag_coords\r\n\r\n         0       B3GNT1--NPSR1\r\n         1       B3GNT1--NPSR1|2203-10182\r\n         2       2203\r\n         3       10182\r\n         4       189\r\n         5       1138\r\n         6       1860-13757,1798-13819,1391-18127,1443-17174,...\r\n\r\n         */\r\n\r\n\r\n       \r\n\r\n        var chr = tokens[0];\r\n        var fusion_name = tokens[1];\r\n        var junction_left = parseInt(tokens[2]);\r\n        var junction_right = parseInt(tokens[3]);\r\n        var num_junction_reads = parseInt(tokens[4]);\r\n        var num_spanning_frags = parseInt(tokens[5]);\r\n\r\n        var spanning_frag_coords_text = tokens[6];\r\n\r\n        var feature = {\r\n            chr: chr,\r\n            name: fusion_name,\r\n            junction_left: junction_left,\r\n            junction_right: junction_right,\r\n            num_junction_reads: num_junction_reads,\r\n            num_spanning_frags: num_spanning_frags,\r\n            spanning_frag_coords: [],\r\n\r\n            start: -1,\r\n            end: -1\r\n        }; // set start and end later based on min/max of span coords\r\n\r\n        var min_coord = junction_left;\r\n        var max_coord = junction_right;\r\n\r\n        if (num_spanning_frags > 0) {\r\n\r\n            var coord_pairs = spanning_frag_coords_text.split(',');\r\n\r\n            for (var i = 0; i < coord_pairs.length; i++) {\r\n                var split_coords = coord_pairs[i].split('-');\r\n\r\n                var span_left = split_coords[0];\r\n                var span_right = split_coords[1];\r\n\r\n                if (span_left < min_coord) {\r\n                    min_coord = span_left;\r\n                }\r\n                if (span_right > max_coord) {\r\n                    max_coord = span_right;\r\n                }\r\n                feature.spanning_frag_coords.push({left: span_left, right: span_right});\r\n\r\n            }\r\n        }\r\n\r\n        feature.start = min_coord;\r\n        feature.end = max_coord;\r\n\r\n\r\n        feature.popupData = function () {\r\n            return [{name: \"Name\", value: feature.name}];\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    static decodeGtexGWAS(tokens, ignore) {\r\n\r\n\r\n        var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\r\n\r\n        tokenCount = tokens.length;\r\n        if (tokenCount < 8) {\r\n            return null;\r\n        }\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]) - 1;\r\n        end = parseInt(tokens[3].split(':')[1]);\r\n        //name = tokens[3];\r\n        //score = parseFloat(tokens[4]);\r\n        //strand = tokens[5].trim();\r\n        //signal = parseFloat(tokens[6]);\r\n        pValue = parseFloat(tokens[5]);\r\n        //qValue = parseFloat(tokens[8]);\r\n\r\n        //return {chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\r\n        //    pValue: pValue, qValue: qValue};\r\n        return {chr: chr, start: start, end: end, pvalue: pValue};\r\n    }\r\n\r\n    /**\r\n     * Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.\r\n     *      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns {*}\r\n     */\r\n    static decodeGFF(tokens, ignore) {\r\n\r\n        var tokenCount, chr, start, end, strand, type, score, phase, attributeString, id, parent, color, name,\r\n            transcript_id, i,\r\n            format = this.format;\r\n\r\n        tokenCount = tokens.length;\r\n        if (tokenCount < 9) {\r\n            return null;      // Not a valid gff record\r\n        }\r\n\r\n        chr = tokens[0];\r\n        type = tokens[2];\r\n        start = parseInt(tokens[3]) - 1;\r\n        end = parseInt(tokens[4]);\r\n        score = \".\" === tokens[5] ? 0 : parseFloat(tokens[5]);\r\n        strand = tokens[6];\r\n        phase = \".\" === tokens[7] ? 0 : parseInt(tokens[7]);\r\n        attributeString = tokens[8];\r\n\r\n        // Find ID and Parent, or transcript_id\r\n        var delim = ('gff3' === format) ? '=' : /\\s+/;\r\n        var attributes = {};\r\n        attributeString.split(';').forEach(function (kv) {\r\n            var t = kv.trim().split(delim, 2), key, value;\r\n            if (t.length == 2) {\r\n                key = t[0].trim();\r\n                value = t[1].trim();\r\n                //Strip off quotes, if any\r\n                if (value.startsWith('\"') && value.endsWith('\"')) {\r\n                    value = value.substr(1, value.length - 2);\r\n                }\r\n                if (\"ID\" === t[0]) id = t[1];\r\n                else if (\"Parent\" === t[0]) parent = t[1];\r\n                else if (\"color\" === t[0].toLowerCase()) color = igv.createColorString(t[1]);\r\n                else if (\"transcript_id\" === t[0]) id = t[1];     // gtf format\r\n                attributes[key] = value;\r\n            }\r\n        });\r\n\r\n        // Find name (label) property\r\n        if (this.nameField) {\r\n            name = attributes[this.nameField];\r\n        }\r\n        else {\r\n            for (i = 0; i < gffNameFields.length; i++) {\r\n                if (attributes.hasOwnProperty(gffNameFields[i])) {\r\n                    this.nameField = gffNameFields[i];\r\n                    name = attributes[this.nameField];\r\n\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return {\r\n            id: id,\r\n            parent: parent,\r\n            name: name,\r\n            type: type,\r\n            chr: chr,\r\n            start: start,\r\n            end: end,\r\n            score: score,\r\n            strand: strand,\r\n            color: color,\r\n            attributeString: attributeString,\r\n            popupData: function () {\r\n                var kvs = this.attributeString.split(';'),\r\n                    pd = [],\r\n                    key, value;\r\n                kvs.forEach(function (kv) {\r\n                    var t = kv.trim().split(delim, 2);\r\n                    if (t.length === 2 && t[1] !== undefined) {\r\n                        key = t[0].trim();\r\n                        value = t[1].trim();\r\n                        //Strip off quotes, if any\r\n                        if (value.startsWith('\"') && value.endsWith('\"')) {\r\n                            value = value.substr(1, value.length - 2);\r\n                        }\r\n                        pd.push({name: key, value: value});\r\n                    }\r\n                });\r\n                return pd;\r\n            }\r\n\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decode the \"standard\" UCSC bed format\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns decoded feature, or null if this is not a valid record\r\n     */\r\n    decodeCustom(tokens, ignore) {\r\n\r\n        var feature,\r\n            chr, start, end,\r\n            format = this.format,         // \"this\" refers to FeatureParser instance\r\n            coords = format.coords || 0;\r\n\r\n        if (tokens.length < 3) return null;\r\n\r\n        chr = tokens[format.chr];\r\n        start = parseInt(tokens[format.start]) - coords;\r\n        end = format.end !== undefined ? parseInt(tokens[format.end]) : start + 1;\r\n\r\n        feature = {chr: chr, start: start, end: end};\r\n\r\n        if (format.fields) {\r\n            format.fields.forEach(function (field, index) {\r\n                if (index != format.chr && index != format.start && index != format.end) {\r\n                    feature[field] = tokens[index];\r\n                }\r\n            });\r\n        }\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//*******js/feature/featureCache.js**********************\r\n\r\n\r\n    /**\r\n     * Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)\r\n     *\r\n     * @param featureList\r\n     * @param The genomic range spanned by featureList (optional)\r\n     * @constructor\r\n     */\r\n\r\nclass FeatureCache{\r\n    constructor(featureList, range) {\r\n        this.treeMap = FeatureCache.buildTreeMap(featureList);\r\n        this.range = range;\r\n    }\r\n\r\n    queryFeatures(chr, start, end) {\r\n         \r\n\r\n        var featureList, intervalFeatures, feature, len, i, tree, intervals;\r\n\r\n        tree = this.treeMap[chr];\r\n\r\n        if (!tree) return [];\r\n\r\n        intervals = tree.findOverlapping(start, end);\r\n\r\n        if (intervals.length == 0) {\r\n            return [];\r\n        }\r\n        else {\r\n            // Trim the list of features in the intervals to those\r\n            // overlapping the requested range.\r\n            // Assumption: features are sorted by start position\r\n\r\n            featureList = [];\r\n\r\n            intervals.forEach(function (interval) {\r\n                intervalFeatures = interval.value;\r\n                len = intervalFeatures.length;\r\n                for (i = 0; i < len; i++) {\r\n                    feature = intervalFeatures[i];\r\n                    if (feature.start > end) break;\r\n                    else if (feature.end >= start) {\r\n                        featureList.push(feature)\r\n                    }\r\n                }\r\n            });\r\n            return featureList;\r\n        }\r\n\r\n    };\r\n\r\n    allFeatures() {\r\n\r\n        var allFeatures = [];\r\n        var treeMap = this.treeMap;\r\n        if (treeMap) {\r\n            for (var key in treeMap) {\r\n                if (treeMap.hasOwnProperty(key)) {\r\n\r\n                    var tree = treeMap[key];\r\n                    tree.mapIntervals(function (interval) {\r\n                        allFeatures = allFeatures.concat(interval.value);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return allFeatures;\r\n\r\n    }\r\n\r\n    static buildTreeMap(featureList) {\r\n\r\n        var featureCache = {},\r\n            chromosomes = [],\r\n            treeMap = {},\r\n            genome = null;\r\n\r\n        if (featureList) {\r\n\r\n            featureList.forEach(function (feature) {\r\n\r\n                var chr = feature.chr,\r\n                    geneList;\r\n\r\n                // Translate to \"official\" name\r\n                if(genome) chr = genome.getChromosomeName(chr);\r\n\r\n                geneList = featureCache[chr];\r\n\r\n                if (!geneList) {\r\n                    chromosomes.push(chr);\r\n                    geneList = [];\r\n                    featureCache[chr] = geneList;\r\n                }\r\n\r\n                geneList.push(feature);\r\n\r\n            });\r\n\r\n\r\n            // Now build interval tree for each chromosome\r\n\r\n            for (let i = 0; i < chromosomes.length; i++) {\r\n                let chr = chromosomes[i];\r\n                treeMap[chr] =FeatureCache.buildIntervalTree(featureCache[chr]);\r\n            }\r\n        }\r\n\r\n        return treeMap;\r\n    };\r\n\r\n    /**\r\n     * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups\r\n     * of 10, or total size / 100,   to reduce size of the tree.\r\n     *\r\n     * @param featureList\r\n     */\r\n    static buildIntervalTree(featureList) {\r\n\r\n        var i, e, iStart, iEnd, tree, chunkSize, len, subArray;\r\n\r\n        tree = new IntervalTree();\r\n        len = featureList.length;\r\n\r\n        chunkSize = Math.max(10, Math.round(len / 100));\r\n\r\n        featureList.sort(function (f1, f2) {\r\n            return (f1.start === f2.start ? 0 : (f1.start > f2.start ? 1 : -1));\r\n        });\r\n\r\n        for (i = 0; i < len; i += chunkSize) {\r\n            e = Math.min(len, i + chunkSize);\r\n            subArray = featureList.slice(i, e);\r\n            iStart = subArray[0].start;\r\n            //\r\n            iEnd = iStart;\r\n            subArray.forEach(function (feature) {\r\n                iEnd = Math.max(iEnd, feature.end);\r\n            });\r\n            tree.insert(iStart, iEnd, subArray);\r\n        }\r\n\r\n        return tree;\r\n    }\r\n\r\n\r\n}\r\n\r\n//*****js/intervalTree.js************\r\n\r\n\r\nconst BLACK = 1;\r\nconst RED = 2;\r\n\r\nlet NIL = {}\r\nNIL.color = BLACK;\r\nNIL.parent = NIL;\r\nNIL.left = NIL;\r\nNIL.right = NIL;\r\n\r\n  \r\nclass IntervalTree{\r\n    constructor() {    \r\n        this.root = NIL;\r\n    }\r\n\r\n\r\n    insert(start, end, value) {\r\n\r\n        var interval = new Interval(start, end, value);\r\n        var x = new Node(interval);\r\n        this.treeInsert(x);\r\n        x.color = RED;\r\n        while (x != this.root && x.parent.color == RED) {\r\n            if (x.parent == x.parent.parent.left) {\r\n                var y = x.parent.parent.right;\r\n                if (y.color == RED) {\r\n                    x.parent.color = BLACK;\r\n                    y.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    x = x.parent.parent;\r\n                } else {\r\n                    if (x == x.parent.right) {\r\n                        x = x.parent;\r\n                        this.leftRotate(x);\r\n                    }\r\n                    x.parent.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    this.rightRotate(x.parent.parent);\r\n                }\r\n            } else {\r\n                var y = x.parent.parent.left;\r\n                if (y.color == RED) {\r\n                    x.parent.color = BLACK;\r\n                    y.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    x = x.parent.parent;\r\n                } else {\r\n                    if (x == x.parent.left) {\r\n                        x = x.parent;\r\n                        this.rightRotate(x);\r\n                    }\r\n                    x.parent.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    this.leftRotate(x.parent.parent);\r\n                }\r\n            }\r\n        }\r\n        this.root.color = BLACK;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param start - query interval\r\n     * @param end - query interval\r\n     * @returns Array of all intervals overlapping the query region\r\n     */\r\n    findOverlapping(start, end) {\r\n\r\n\r\n        var searchInterval = new Interval(start, end, 0);\r\n\r\n        if (this.root === NIL) return [];\r\n\r\n        var intervals = this.searchAll(searchInterval, this.root, []);\r\n\r\n        if(intervals.length > 1) {\r\n            intervals.sort(function(i1, i2) {\r\n                 return i1.low - i2.low;\r\n            });\r\n        }\r\n\r\n        return intervals;\r\n    }\r\n\r\n    /**\r\n     * Dump info on intervals to console.  For debugging.\r\n     */\r\n    logIntervals() {\r\n\r\n        logNode(this.root, 0);\r\n\r\n        function logNode(node, indent) {\r\n\r\n            var space = \"\";\r\n            for(var i=0; i<indent; i++) space += \" \";\r\n            console.log(space + node.interval.low + \" \" + node.interval.high); // + \" \" + (node.interval.value ? node.interval.value : \" null\"));\r\n\r\n            indent += 5;\r\n\r\n            if(node.left != NIL) logNode(node.left, indent);\r\n            if(node.right != NIL) logNode(node.right, indent);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    mapIntervals(func) {\r\n\r\n        applyInterval(this.root);\r\n\r\n        function applyInterval(node) {\r\n\r\n            func(node.interval);\r\n\r\n            if(node.left != NIL) applyInterval(node.left);\r\n            if(node.right != NIL) applyInterval(node.right);\r\n        }\r\n    }\r\n\r\n    searchAll(interval, node, results) {\r\n\r\n        if (node.interval.overlaps(interval)) {\r\n            results.push(node.interval);\r\n        }\r\n\r\n        if (node.left != NIL && node.left.max >= interval.low) {\r\n            this.searchAll(interval, node.left, results);\r\n        }\r\n\r\n        if (node.right != NIL && node.right.min <= interval.high) {\r\n            this.searchAll(interval, node.right, results);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    leftRotate(x) {\r\n        var y = x.right;\r\n        x.right = y.left;\r\n        if (y.left != NIL) {\r\n            y.left.parent = x;\r\n        }\r\n        y.parent = x.parent;\r\n        if (x.parent == NIL) {\r\n            this.root = y;\r\n        } else {\r\n            if (x.parent.left == x) {\r\n                x.parent.left = y;\r\n            } else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;\r\n        x.parent = y;\r\n\r\n        this.applyUpdate(x);\r\n        // no need to apply update on y, since it'll y is an ancestor\r\n        // of x, and will be touched by applyUpdate().\r\n    }\r\n\r\n\r\n    rightRotate(x) {\r\n        var y = x.left;\r\n        x.left = y.right;\r\n        if (y.right != NIL) {\r\n            y.right.parent = x;\r\n        }\r\n        y.parent = x.parent;\r\n        if (x.parent == NIL) {\r\n            this.root = y;\r\n        } else {\r\n            if (x.parent.right == x) {\r\n                x.parent.right = y;\r\n            } else {\r\n                x.parent.left = y;\r\n            }\r\n        }\r\n        y.right = x;\r\n        x.parent = y;\r\n\r\n\r\n        this.applyUpdate(x);\r\n        // no need to apply update on y, since it'll y is an ancestor\r\n        // of x, and will be touched by applyUpdate().\r\n    }\r\n\r\n\r\n    /**\r\n     * Note:  Does not maintain RB constraints,  this is done post insert\r\n     *\r\n     * @param x  a Node\r\n     */\r\n   treeInsert(x) {\r\n        var node = this.root;\r\n        var y = NIL;\r\n        while (node != NIL) {\r\n            y = node;\r\n            if (x.interval.low <= node.interval.low) {\r\n                node = node.left;\r\n            } else {\r\n                node = node.right;\r\n            }\r\n        }\r\n        x.parent = y;\r\n\r\n        if (y == NIL) {\r\n            this.root = x;\r\n            x.left = x.right = NIL;\r\n        } else {\r\n            if (x.interval.low <= y.interval.low) {\r\n                y.left = x;\r\n            } else {\r\n                y.right = x;\r\n            }\r\n        }\r\n\r\n        this.applyUpdate(x);\r\n    }\r\n\r\n\r\n    // Applies the statistic update on the node and its ancestors.\r\n    applyUpdate (node) {\r\n        while (node != NIL) {\r\n            var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;\r\n            var intervalHigh = node.interval.high;\r\n            node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;\r\n\r\n            var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;\r\n            var intervalLow = node.interval.low;\r\n            node.min = nodeMin < intervalLow ? nodeMin : intervalLow;\r\n\r\n            node = node.parent;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Interval {\r\n    constructor(low, high, value) {\r\n        this.low = low;\r\n        this.high = high;\r\n        this.value = value;\r\n    }\r\n\r\n\r\n    equals(other) {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        if (this == other) {\r\n            return true;\r\n        }\r\n        return (this.low == otherInterval.low &&\r\n            this.high == otherInterval.high);\r\n\r\n    }\r\n\r\n\r\n    compareTo(other) {\r\n        if (this.low < other.low)\r\n            return -1;\r\n        if (this.low > other.low)\r\n            return 1;\r\n\r\n        if (this.high < other.high)\r\n            return -1;\r\n        if (this.high > other.high)\r\n            return 1;\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this interval overlaps the other.\r\n     */\r\n    overlaps(other) {\r\n        try {\r\n            return (this.low <= other.high && other.low <= this.high);\r\n        } catch (e) {\r\n            //alert(e);\r\n            igv.presentAlert(e);\r\n        }\r\n    }\r\n}\r\n\r\nclass Node{\r\n    constructor(interval) {\r\n        this.parent = NIL;\r\n        this.left = NIL;\r\n        this.right = NIL;\r\n        this.interval = interval;\r\n        this.color = RED;\r\n    }\r\n}\r\n\r\nclass GenomicInterval{\r\n\r\n\tconstructor(chr, start, end, features) {\r\n        this.chr = chr;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.features = features;\r\n    }\r\n\r\n    contains (chr, start, end) {\r\n        return this.chr == chr &&\r\n            this.start <= start &&\r\n            this.end >= end;\r\n    }\r\n\r\n    containsRange(range) {\r\n        return this.chr === range.chr &&\r\n            this.start <= range.start &&\r\n            this.end >= range.end;\r\n    }\r\n    rangesToGet(range){\r\n        let needs_range=false;\r\n        let ranges={};\r\n        if (this.chr !== range.chr){\r\n            ranges.all=[range.start,range.end];\r\n            needs_range=true;\r\n            this.start=range.start;\r\n            this.end=range.end;\r\n\r\n        }\r\n        else{   \r\n            if (range.start<this.start){\r\n                ranges.left=[range.start,this.start];\r\n                needs_range=true;\r\n                this.start=range.start;\r\n              \r\n            }\r\n            if (range.end>this.end){\r\n                ranges.right=[this.end,range.end];\r\n                needs_range=true;\r\n                this.end=range.end;\r\n            }\r\n        }\r\n        if (!needs_range){\r\n            return false;\r\n        }\r\n        return ranges;\r\n    }\r\n}\r\n\r\n\r\n\r\nclass FastaSequence{\r\n\r\n    constructor(url) {\r\n\r\n        this.file = url;\r\n        this.indexed = true;\r\n        if (this.indexed) {\r\n            this.indexFile = this.file + \".fai\";\r\n        }\r\n    \r\n\r\n    }\r\n\r\n   init(){\r\n\r\n        var self = this;\r\n\r\n        if (self.indexed) {\r\n\r\n            return new Promise(function (fulfill, reject) {\r\n\r\n                self.getIndex().then(function (index) {\r\n                    var order = 0;\r\n                    self.chromosomes = {};\r\n                    self.chromosomeNames.forEach(function (chrName) {\r\n                        var bpLength = self.index[chrName].size;\r\n                        self.chromosomes[chrName] = new igv.Chromosome(chrName, order++, bpLength);\r\n                    });\r\n\r\n\r\n                    // Ignore index, getting chr names as a side effect.  Really bad practice\r\n                    fulfill();\r\n                }).catch(reject);\r\n            });\r\n        }\r\n        else {\r\n            return self.loadAll();\r\n        }\r\n\r\n    }\r\n\r\n    getSequence(chr, start, end) {\r\n\r\n        if (this.indexed) {\r\n            return this.getSequenceIndexed(chr, start, end);\r\n        }\r\n        else {\r\n            return getSequenceNonIndexed.this(chr, start, end);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    getSequenceIndexed(chr, start, end) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var interval = self.interval;\r\n\r\n            if (interval && interval.contains(chr, start, end)) {\r\n\r\n                fulfill(getSequenceFromInterval(interval, start, end));\r\n            }\r\n            else {\r\n\r\n                //console.log(\"Cache miss: \" + (interval === undefined ? \"nil\" : interval.chr + \":\" + interval.start + \"-\" + interval.end));\r\n\r\n                // Expand query, to minimum of 100kb\r\n                var qstart = start;\r\n                var qend = end;\r\n                if ((end - start) < 100000) {\r\n                    var w = (end - start);\r\n                    var center = Math.round(start + w / 2);\r\n                    qstart = Math.max(0, center - 50000);\r\n                    qend = center + 50000;\r\n                }\r\n\r\n\r\n                self.readSequence(chr, qstart, qend).then(function (seqBytes) {\r\n                    self.interval = new GenomicInterval(chr, qstart, qend, seqBytes);\r\n                    fulfill(getSequenceFromInterval(self.interval, start, end));\r\n                }).catch(reject);\r\n            }\r\n\r\n            function getSequenceFromInterval(interval, start, end) {\r\n                var offset = start - interval.start;\r\n                var n = end - start;\r\n                var seq = interval.features ? interval.features.substr(offset, n) : null;\r\n                return seq;\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    getSequenceNonIndexed(chr, start, end) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var seq = self.sequences[chr];\r\n            if (seq && seq.length > end) {\r\n                fulfill(seq.substring(start, end));\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    getIndex() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.index) {\r\n                fulfill(self.index);\r\n            } else {\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].load(self.indexFile,{}).then(function (data) {\r\n                    var lines = data.split(\"\\n\");\r\n                    var len = lines.length;\r\n                    var lineNo = 0;\r\n\r\n                    self.chromosomeNames = [];     // TODO -- eliminate this side effect !!!!\r\n                    self.index = {};               // TODO -- ditto\r\n                    while (lineNo < len) {\r\n\r\n                        var tokens = lines[lineNo++].split(\"\\t\");\r\n                        var nTokens = tokens.length;\r\n                        if (nTokens == 5) {\r\n                            // Parse the index line.\r\n                            var chr = tokens[0];\r\n                            var size = parseInt(tokens[1]);\r\n                            var position = parseInt(tokens[2]);\r\n                            var basesPerLine = parseInt(tokens[3]);\r\n                            var bytesPerLine = parseInt(tokens[4]);\r\n\r\n                            var indexEntry = {\r\n                                size: size, position: position, basesPerLine: basesPerLine, bytesPerLine: bytesPerLine\r\n                            };\r\n\r\n                            self.chromosomeNames.push(chr);\r\n                            self.index[chr] = indexEntry;\r\n                        }\r\n                    }\r\n\r\n                    if (fulfill) {\r\n                        fulfill(self.index);\r\n                    }\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n    loadAll(){\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            self.chromosomeNames = [];\r\n            self.chromosomes = {};\r\n            self.sequences = {};\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].load(self.file, {\r\n                withCredentials: self.withCredentials\r\n\r\n            }).then(function (data) {\r\n\r\n                var lines = data.splitLines(),\r\n                    len = lines.length,\r\n                    lineNo = 0,\r\n                    nextLine,\r\n                    currentSeq = \"\",\r\n                    currentChr,\r\n                    order = 0;\r\n\r\n\r\n                while (lineNo < len) {\r\n                    nextLine = lines[lineNo++].trim();\r\n                    if (nextLine.startsWith(\"#\") || nextLine.length === 0) {\r\n                        continue;\r\n                    }\r\n                    else if (nextLine.startsWith(\">\")) {\r\n                        if (currentSeq) {\r\n                            self.chromosomeNames.push(currentChr);\r\n                            self.sequences[currentChr] = currentSeq;\r\n                            self.chromosomes[currentChr] = new igv.Chromosome(currentChr, order++, currentSeq.length);\r\n                        }\r\n                        currentChr = nextLine.substr(1).split(\"\\\\s+\")[0];\r\n                        currentSeq = \"\";\r\n                    }\r\n                    else {\r\n                        currentSeq += nextLine;\r\n                    }\r\n                }\r\n\r\n                fulfill();\r\n\r\n            });\r\n        });\r\n    }\r\n\r\n    readSequence(chr, qstart, qend) {\r\n\r\n        //console.log(\"Read sequence \" + chr + \":\" + qstart + \"-\" + qend);\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            self.getIndex().then(function () {\r\n\r\n                var idxEntry = self.index[chr];\r\n                if (!idxEntry) {\r\n                    console.log(\"No index entry for chr: \" + chr);\r\n\r\n                    // Tag interval with null so we don't try again\r\n                    self.interval = new GenomicInterval(chr, qstart, qend, null);\r\n                    fulfill(null);\r\n\r\n                } else {\r\n\r\n                    var start = Math.max(0, qstart);    // qstart should never be < 0\r\n                    var end = Math.min(idxEntry.size, qend);\r\n                    var bytesPerLine = idxEntry.bytesPerLine;\r\n                    var basesPerLine = idxEntry.basesPerLine;\r\n                    var position = idxEntry.position;\r\n                    var nEndBytes = bytesPerLine - basesPerLine;\r\n\r\n                    var startLine = Math.floor(start / basesPerLine);\r\n                    var endLine = Math.floor(end / basesPerLine);\r\n\r\n                    var base0 = startLine * basesPerLine;   // Base at beginning of start line\r\n\r\n                    var offset = start - base0;\r\n\r\n                    var startByte = position + startLine * bytesPerLine + offset;\r\n\r\n                    var base1 = endLine * basesPerLine;\r\n                    var offset1 = end - base1;\r\n                    var endByte = position + endLine * bytesPerLine + offset1 - 1;\r\n                    var byteCount = endByte - startByte + 1;\r\n                    if (byteCount <= 0) {\r\n                        fulfill(null);\r\n                    }\r\n\r\n                    _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].load(self.file, {\r\n                        range: {start: startByte, size: byteCount}\r\n                    }).then(function (allBytes) {\r\n\r\n                        var nBases,\r\n                            seqBytes = \"\",\r\n                            srcPos = 0,\r\n                            desPos = 0,\r\n                            allBytesLength = allBytes.length;\r\n\r\n                        if (offset > 0) {\r\n                            nBases = Math.min(end - start, basesPerLine - offset);\r\n                            seqBytes += allBytes.substr(srcPos, nBases);\r\n                            srcPos += (nBases + nEndBytes);\r\n                            desPos += nBases;\r\n                        }\r\n\r\n                        while (srcPos < allBytesLength) {\r\n                            nBases = Math.min(basesPerLine, allBytesLength - srcPos);\r\n                            seqBytes += allBytes.substr(srcPos, nBases);\r\n                            srcPos += (nBases + nEndBytes);\r\n                            desPos += nBases;\r\n                        }\r\n\r\n                        fulfill(seqBytes);\r\n                    }).catch(reject)\r\n                }\r\n            }).catch(reject)\r\n        });\r\n    }\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmVhdHVyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9mZWF0dXJlLmpzPzhkOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5pbXBvcnQge1V0aWxzfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG5pbXBvcnQge2lndnhocix1bmJnemZ9IGZyb20gXCIuL2lndnhoci5qc1wiO1xyXG5pbXBvcnQge2xvYWRCYW1JbmRleH0gZnJvbSBcIi4vYmFtLmpzXCI7XHJcbmltcG9ydCB7QldTb3VyY2V9IGZyb20gXCIuL2JpZ3dpZy5qc1wiO1xyXG5cclxuY29uc3QgTUFYX0daSVBfQkxPQ0tfU0laRSA9ICgxIDw8IDE2KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZlYXR1cmUgc291cmNlIGZvciBcImJlZCBsaWtlXCIgZmlsZXMgKHRhYiBkZWxpbWl0ZWQgZmlsZXMgd2l0aCAxIGZlYXR1cmUgcGVyIGxpbmU6IGJlZCwgZ2ZmLCB2Y2YsIGV0YylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG5jbGFzcyBGZWF0dXJlU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICB0aGlzLnNvdXJjZVR5cGUgPSAoY29uZmlnLnNvdXJjZVR5cGUgPT09IHVuZGVmaW5lZCA/IFwiZmlsZVwiIDogY29uZmlnLnNvdXJjZVR5cGUpO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiZ2E0Z2hcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBpZ3YuR2E0Z2hWYXJpYW50UmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuc291cmNlVHlwZSA9PT0gXCJpbW12YXJcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBpZ3YuSW1tVmFyUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcudHlwZSA9PT0gXCJlcXRsXCIpIHtcclxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zb3VyY2VUeXBlID09PSBcImd0ZXgtd3NcIikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgaWd2Lkd0ZXhSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IGlndi5HdGV4RmlsZVJlYWRlcihjb25maWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuc291cmNlVHlwZSA9PT0gXCJiaWdxdWVyeVwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IGlndi5CaWdRdWVyeUZlYXR1cmVSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlZmF1bHQgZm9yIGFsbCBzb3J0cyBvZiBhc2NpaSB0YWItZGVsaW1pdGVkIGZpbGUgZm9ybXRzXHJcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IEZlYXR1cmVGaWxlUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eVdpbmRvdyA9IGNvbmZpZy52aXNpYmlsaXR5V2luZG93O1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0RmlsZUhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgICBtYXhSb3dzID0gdGhpcy5jb25maWcubWF4Um93cyB8fCA1MDA7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5oZWFkZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxmLnJlYWRlci5yZWFkSGVhZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWFkZXIucmVhZEhlYWRlcigpLnRoZW4oZnVuY3Rpb24gKGhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmlzX2luZGV4ZWQ9dHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9uLWluZGV4ZWQgcmVhZGVycyB3aWxsIHJldHVybiBmZWF0dXJlcyBhcyBhIHNpZGUgZWZmZWN0LiAgVGhpcyBpcyBhbiBpbXBvcnRhbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHVuZm9ydHVuYXRlLCBwZXJmb3JtYW5jZSBoYWNrXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihoZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IGhlYWRlci5mZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJndGZcIiA9PT0gc2VsZi5jb25maWcuZm9ybWF0IHx8IFwiZ2ZmM1wiID09PSBzZWxmLmNvbmZpZy5mb3JtYXQgfHwgXCJnZmZcIiA9PT0gc2VsZi5jb25maWcuZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gKG5ldyBpZ3YuR0ZGSGVscGVyKHNlbGYuY29uZmlnLmZvcm1hdCkpLmNvbWJpbmVGZWF0dXJlcyhmZWF0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gb3ZlcmxhcHBpbmcgZmVhdHVyZXMgdG8gcm93c1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrRmVhdHVyZXMoZmVhdHVyZXMsIG1heFJvd3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNhY2hlID0gbmV3IEZlYXR1cmVDYWNoZShmZWF0dXJlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRyYWNrIGlzIG1hcmtlZCBcInNlYXJjaGFibGVcIjwgY2FjaGUgZmVhdHVyZXMgYnkgbmFtZSAtLSB1c2UgdGhpcyB3aXRoIGNhdXRpb24sIG1lbW9yeSBpbnRlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2VhcmNoYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZEZlYXR1cmVzVG9EQihmZWF0dXJlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyICYmIGhlYWRlci5mb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmZvcm1hdCA9IGhlYWRlci5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBhZGRGZWF0dXJlc1RvREIoZmVhdHVyZUxpc3QpIHtcclxuICAgICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGlndi5icm93c2VyLmZlYXR1cmVEQltmZWF0dXJlLm5hbWUudG9VcHBlckNhc2UoKV0gPSBmZWF0dXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kLGZvcmNlLGRhdGEpe1xyXG4gICAgICBcclxuICAgICAgICAvL25vIG5lZWQgdG8gZ2V0IGhlYWRlclxyXG4gICAgICAgIGlmICh0aGlzLmlzX2luZGV4ZWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9nZXQgaGVhZGVycy9pbmRleCB0aGVuIGdldCBmZWF0dXJlc1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oZnVsZmlsbCxyZWplY3Qpe1xyXG4gICAgICAgICAgICBzZWxmLmdldEZpbGVIZWFkZXIoKS50aGVuKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9nZXRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kLGZvcmNlLGRhdGEpLnRoZW4oZnVuY3Rpb24oZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBmdW5jdGlvbiBmbyBhbGwgZGF0YSBzb3VyY2Ugb2JqZWN0cy4gIEZldGNoZXMgZmVhdHVyZXMgZm9yIHRoZVxyXG4gICAgICogcmFuZ2UgcmVxdWVzdGVkIGFuZCBwYXNzZXMgdGhlbSBvbiB0byB0aGUgc3VjY2VzcyBmdW5jdGlvbi4gIFVzdWFsbHkgdGhpcyBpc1xyXG4gICAgICogYSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGhlIGZlYXR1cmVzIG9uIHRoZSBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2hyXHJcbiAgICAgKiBAcGFyYW0gYnBTdGFydFxyXG4gICAgICogQHBhcmFtIGJwRW5kXHJcbiAgICAgKi9cclxuXHJcbiAgICBfZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcbiAgICAgICAgaWYgKGJwU3RhcnQ9PT0wKXtcclxuICAgICAgICAgICAgYnBTdGFydD0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc2VsZi50aW1lPURhdGUubm93KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYuZmVhdHVyZUNhY2hlICYmIGNociAhPT0gc2VsZi5mZWF0dXJlQ2FjaGUucmFuZ2UuY2hyKXtcclxuICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNhY2hlPW51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdlbm9taWNJbnRlcnZhbCA9IG5ldyBHZW5vbWljSW50ZXJ2YWwoY2hyLCBicFN0YXJ0LCBicEVuZCksXHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlQ2FjaGUgPSBzZWxmLmZlYXR1cmVDYWNoZSxcclxuICAgICAgICAgICAgICAgIG1heFJvd3MgPSBzZWxmLmNvbmZpZy5tYXhSb3dzIHx8IDUwMDtcclxuICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHJhbmdlc190b19nZXQ9ZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICghZmVhdHVyZUNhY2hlKXtcclxuICAgICAgICAgICAgICAgIHJhbmdlc190b19nZXQ9e2FsbDpbYnBTdGFydCxicEVuZF19O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUNhY2hlLnJhbmdlICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlc190b19nZXQ9ZmVhdHVyZUNhY2hlLnJhbmdlLnJhbmdlc1RvR2V0KGdlbm9taWNJbnRlcnZhbClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXJhbmdlc190b19nZXQpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kKSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICBcclxuICAgICAgICAgICAgIGxldCBwcm9taXNlcz1bXTtcclxuICAgICAgICAgICAgIGxldCBwX3R5cGVzPVtdO1xyXG4gICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiByYW5nZXNfdG9fZ2V0KXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2U9IHJhbmdlc190b19nZXRbdHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5yZXRyaWV2ZUZlYXR1cmVzKGNociwgcmFuZ2VbMF0sIHJhbmdlWzFdLGZvcmNlLGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgcF90eXBlcy5wdXNoKFt0eXBlLHJhbmdlc190b19nZXRbdHlwZV1dKTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFsbF9mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdfZmVhdHVyZXM9W107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmZlYXR1cmVDYWNoZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19mZWF0dXJlcz1zZWxmLmZlYXR1cmVDYWNoZS5hbGxGZWF0dXJlcygpOy8vZmVhdHVyZUNhY2hlLmFsbEZlYXR1cmVzKGNocixzZWxmLmZlYXR1cmVDYWNoZS5yYW5nZS5zdGFydCxzZWxmLmZlYXR1cmVDYWNoZS5yYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZXhpc2l0aW5nIGZlYXR1cmVzOlwiK2V4aXN0aW5nX2ZlYXR1cmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4PTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmVMaXN0IG9mIGFsbF9mZWF0dXJlcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3QgPT09IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0PVtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIGlmIChwX3R5cGVzW2luZGV4XVswXT09PVwiYWxsXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19yYW5nZS5zdGFydD1wX3R5cGVzW2luZGV4XVsxXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcmFuZ2UuZW5kPXBfdHlwZXNbaW5kZXhdWzFdWzFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3QgPSBmZWF0dXJlTGlzdFswXS5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID1mZWF0dXJlTGlzdFtmZWF0dXJlTGlzdC5sZW5ndGgtMV0uZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQ+bmV3X3JhbmdlLmVuZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19yYW5nZS5lbmQ9ZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0PG5ld19yYW5nZS5zdGFydCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19yYW5nZS5zdGFydD1zdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwX3R5cGVzW2luZGV4XVswXT09PVwibGVmdFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kID0gcF90eXBlc1tpbmRleF1bMV1bMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYW55IGFscmVhZHkgcmV0aWV2ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGxpY2U9MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBuPWZlYXR1cmVMaXN0Lmxlbmd0aC0xO24+PTA7bi0tKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3Rbbl0uZW5kPCBlbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGxpY2UhPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxpc3Quc3BsaWNlKC1zcGxpY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiOjo6ISFcIitmZWF0dXJlTGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocF90eXBlc1tpbmRleF1bMF09PT1cInJpZ2h0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0PXBfdHlwZXNbaW5kZXhdWzFdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFueSBhbHJlYWR5IHJldGlldmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG49MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobj0wO248ZmVhdHVyZUxpc3QubGVuZ3RoO24rKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0W25dLnN0YXJ0PiBzdGFydCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuIT09MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0LnNwbGljZSgwLG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5ld19mZWF0dXJlczpcIitmZWF0dXJlTGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3QgJiYgdHlwZW9mIGZlYXR1cmVMaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHsgIC8vIEhhdmUgcmVzdWx0IEFORCBpdHMgYW4gYXJyYXkgdHlwZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJbmRleGVkID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlYWRlci5pbmRleGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc291cmNlVHlwZSA9PT0gXCJnYTRnaFwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc291cmNlVHlwZSA9PT0gXCJpbW12YXJcIiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiZ3RleFwiIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc291cmNlVHlwZSA9PT0gXCJiaWdxdWVyeVwifHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zb3VyY2VUeXBlID09PSBcImN1c3RvbVwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gQ09NQklORSBHRkYgRkVBVFVSRVMgSEVSRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYoc2VsZi5pc0dGRikgZmVhdHVyZUxpc3QgPSBjb21iaW5lRmVhdHVyZXMoZmVhdHVyZUxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImd0ZlwiID09PSBzZWxmLmNvbmZpZy5mb3JtYXQgfHwgXCJnZmYzXCIgPT09IHNlbGYuY29uZmlnLmZvcm1hdCB8fCBcImdmZlwiID09PSBzZWxmLmNvbmZpZy5mb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxpc3QgPSAobmV3IGlndi5HRkZIZWxwZXIoc2VsZi5jb25maWcuZm9ybWF0KSkuY29tYmluZUZlYXR1cmVzKGZlYXR1cmVMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdfZmVhdHVyZXM9ZXhpc3RpbmdfZmVhdHVyZXMuY29uY2F0KGZlYXR1cmVMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFsbCBmZWF0dXJlczpcIitleGlzdGluZ19mZWF0dXJlcy5sZW5ndGgpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBnaSA9IHNlbGYuZmVhdHVyZUNhY2hlP3NlbGYuZmVhdHVyZUNhY2hlLnJhbmdlOmdlbm9taWNJbnRlcnZhbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNhY2hlID0gaXNJbmRleGVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmVhdHVyZUNhY2hlKGV4aXN0aW5nX2ZlYXR1cmVzLCBnaSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBGZWF0dXJlQ2FjaGUoZmVhdHVyZUxpc3QpOyAgIC8vIE5vdGUgLSByZXBsYWNpbmcgcHJldmlvdXMgY2FjaGUgd2l0aCBuZXcgb25lXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBvdmVybGFwcGluZyBmZWF0dXJlcyB0byByb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGZWF0dXJlU291cmNlLnBhY2tGZWF0dXJlcyhleGlzdGluZ19mZWF0dXJlcywgbWF4Um93cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJhY2sgaXMgbWFya2VkIFwic2VhcmNoYWJsZVwiPCBjYWNoZSBmZWF0dXJlcyBieSBuYW1lIC0tIHVzZSB0aGlzIHdpdGggY2F1dGlvbiwgbWVtb3J5IGludGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNlYXJjaGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGZWF0dXJlc1RvREIoZXhpc3RpbmdfZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHkgcGFzcyBmZWF0dXJlcyBmb3IgcXVlcnkgaW50ZXJ2YWwgdG8gY29udGludWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIGxldCBhbHIgPXt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGY9IHNlbGYuZmVhdHVyZUNhY2hlLmFsbEZlYXR1cmVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIG9mIGYpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbHJbaS5pZF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFscltpLmlkXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscltpLmlkXT1pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuZmVhdHVyZUNhY2hlLnF1ZXJ5RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHJpZXZlRmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnJlYWRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIHBhY2tGZWF0dXJlcyhmZWF0dXJlcywgbWF4Um93cykge1xyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZXMgPT0gbnVsbCB8fCBmZWF0dXJlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VncmVnYXRlIGJ5IGNocm9tb3NvbWVcclxuXHJcbiAgICAgICAgdmFyIGNockZlYXR1cmVNYXAgPSB7fSxcclxuICAgICAgICAgICAgY2hycyA9IFtdO1xyXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjaHIgPSBmZWF0dXJlLmNocixcclxuICAgICAgICAgICAgICAgIGZsaXN0ID0gY2hyRmVhdHVyZU1hcFtjaHJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgZmxpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNockZlYXR1cmVNYXBbY2hyXSA9IGZsaXN0O1xyXG4gICAgICAgICAgICAgICAgY2hycy5wdXNoKGNocik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsaXN0LnB1c2goZmVhdHVyZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBjaHJvc29tb3NvbWVzIGFuZCBwYWNrIGZlYXR1cmVzO1xyXG5cclxuICAgICAgICBjaHJzLmZvckVhY2goZnVuY3Rpb24gKGNocikge1xyXG5cclxuICAgICAgICAgICAgcGFjayhjaHJGZWF0dXJlTWFwW2Nocl0sIG1heFJvd3MpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gQXNzaWducyBhIHJvdyAjIHRvIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBmZWF0dXJlIGRvZXMgbm90IGZpdCBpbiBhbnkgcm93IGFuZCAjcm93cyA9PSBtYXhSb3dzIG5vXHJcbiAgICAgICAgLy8gcm93IG51bWJlciBpcyBhc3NpZ25lZC5cclxuICAgICAgICBmdW5jdGlvbiBwYWNrKGZlYXR1cmVMaXN0LCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZmVhdHVyZUxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJvd3MucHVzaCgtMTAwMCk7XHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgICAgICByLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IE1hdGgubWluKHJvd3MubGVuZ3RoLCBtYXhSb3dzKSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZlYXR1cmUuc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IGxlbjsgcisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IHJvd3Nbcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5yb3cgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzW3JdID0gZmVhdHVyZS5lbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnJvdyA9IHI7XHJcbiAgICAgICAgICAgICAgICByb3dzW3JdID0gZmVhdHVyZS5lbmQ7XHJcblxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuY2xhc3MgQmlnQmVkRmVhdHVyZVNvdXJjZSBleHRlbmRzIEZlYXR1cmVTb3VyY2V7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsZGVjb2RlX2Z1bmN0aW9uKXtcclxuXHRcdGNvbmZpZy5zb3VyY2VUeXBlPVwiZ3RleFwiO1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHRcdHRoaXMuaGVhZGVyPXRydWU7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlPW5ldyBCV1NvdXJjZShjb25maWcsZGVjb2RlX2Z1bmN0aW9uKTtcclxuXHR9XHJcblxyXG5cdHJldHJpZXZlRmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZm9yY2UsZGF0YSl7XHJcblx0XHRyZXR1cm4gdGhpcy5mZWF0dXJlX3NvdXJjZS5nZXRGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmYWxzZSxkYXRhKTsgICAgIFx0XHJcblx0fVxyXG59XHJcblxyXG4vLyoqKioqKioqanMvRmVhdHVyZUZpbGVSZWFkZXIuanMqKioqKlxyXG5cclxuXHJcblxyXG5jb25zdCBGX01BWF9HWklQX0JMT0NLX1NJWkUgPSAoMSA8PCAxNik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkZXIgZm9yIFwiYmVkIGxpa2VcIiBmaWxlcyAodGFiIGRlbGltaXRlZCBmaWxlcyB3aXRoIDEgZmVhdHVyZSBwZXIgbGluZTogYmVkLCBnZmYsIHZjZiwgZXRjKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25maWdcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbmNsYXNzIEZlYXR1cmVGaWxlUmVhZGVye1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsRmlsZSA9IGNvbmZpZy5sb2NhbEZpbGU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSBjb25maWcubG9jYWxGaWxlLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhVUkwgPSBjb25maWcuaW5kZXhVUkw7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZFVSTCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMuZmlsZW5hbWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXJpUGFydHMgPSBVdGlscy5wYXJzZVVyaShjb25maWcudXJsKTtcclxuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IHVyaVBhcnRzLmZpbGU7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHVyaVBhcnRzLnBhdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IGNvbmZpZy5mb3JtYXQ7XHJcblxyXG4gICAgICAgIHRoaXMucGFyc2VyID0gdGhpcy5nZXRQYXJzZXIodGhpcy5mb3JtYXQsIGNvbmZpZy5kZWNvZGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZ2V0UGFyc2VyKGZvcm1hdCwgZGVjb2RlKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgY2FzZSBcInZjZlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWY2ZQYXJzZXIoKTtcclxuICAgICAgICAgICAgY2FzZSBcInNlZ1wiIDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2VnUGFyc2VyKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZlYXR1cmVQYXJzZXIoZm9ybWF0LCBkZWNvZGUsIHRoaXMuY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlZyBmaWxlcyBkb24ndCBoYXZlIGFuIGluZGV4XHJcbiAgICBpc0luZGV4YWJsZSgpIHtcclxuICAgICAgICB2YXIgY29uZmlnSW5kZXhVUkwgPSB0aGlzLmNvbmZpZy5pbmRleFVSTCxcclxuICAgICAgICAgICAgdHlwZSA9IHRoaXMudHlwZSxcclxuICAgICAgICAgICAgY29uZmlnSW5kZXhlZCA9IHRoaXMuY29uZmlnLmluZGV4ZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiBjb25maWdJbmRleFVSTCB8fCAodHlwZSAhPSBcIndpZ1wiICYmIGNvbmZpZ0luZGV4ZWQgIT0gZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIFByb21pc2UgZm9yIHRoZSBhc3luYyBsb2FkZWQgaW5kZXhcclxuICAgICAqL1xyXG4gICAgbG9hZEluZGV4KCkge1xyXG4gICAgICAgIHZhciBpZHhGaWxlID0gdGhpcy5pbmRleFVSTDtcclxuICAgICAgICBpZiAodGhpcy5maWxlbmFtZS5lbmRzV2l0aChcIi5nelwiKSkge1xyXG4gICAgICAgICAgICBpZiAoIWlkeEZpbGUpIGlkeEZpbGUgPSB0aGlzLnVybCArIFwiLnRiaVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9hZEJhbUluZGV4KGlkeEZpbGUsIHRoaXMuY29uZmlnLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghaWR4RmlsZSkgaWR4RmlsZSA9IHRoaXMudXJsICsgXCIuaWR4XCI7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2FkVHJpYmJsZUluZGV4KGlkeEZpbGUsIHRoaXMuY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEZlYXR1cmVzTm9JbmRleCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gc2VsZi5wYXJzZXIsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsICAgICAgICAgICAvLyBodHRwIGhlYWRlcnMsIG5vdCBmaWxlIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYubG9jYWxGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZ0Zyb21GaWxlKHNlbGYubG9jYWxGaWxlLCBvcHRpb25zKS50aGVuKHBhcnNlRGF0YSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHBhcnNlRGF0YSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlRGF0YShkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlciA9IHBhcnNlci5wYXJzZUhlYWRlcihkYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmhlYWRlciBpbnN0YW5jZW9mIFN0cmluZyAmJiBzZWxmLmhlYWRlci5zdGFydHNXaXRoKFwiIyNnZmYtdmVyc2lvbiAzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mb3JtYXQgPSAnZ2ZmMyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHBhcnNlci5wYXJzZUZlYXR1cmVzKGRhdGEpKTsgICAvLyA8PSBQQVJTSU5HIERPTkUgSEVSRVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBsb2FkRmVhdHVyZXNXaXRoSW5kZXgoY2hyLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleCxcclxuICAgICAgICAgICAgICAgIHRhYml4ID0gaW5kZXggJiYgaW5kZXgudGFiaXgsXHJcbiAgICAgICAgICAgICAgICByZWZJZCA9IHRhYml4ID8gaW5kZXguc2VxdWVuY2VJbmRleE1hcFtjaHJdIDogY2hyLFxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGJsb2NrcyA9IGluZGV4LmJsb2Nrc0ZvclJhbmdlKHJlZklkLCBzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghYmxvY2tzIHx8IGJsb2Nrcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7ICAgICAgIC8vIFRPRE8gLS0gaXMgdGhpcyBjb3JyZWN0PyAgU2hvdWxkIGl0IHJldHVybiBhbiBlbXB0eSBhcnJheT9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRQb3MgPSBibG9jay5taW52LmJsb2NrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBibG9jay5taW52Lm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFBvcyA9IGJsb2NrLm1heHYuYmxvY2sgKyAoaW5kZXgudGFiaXggPyBGX01BWF9HWklQX0JMT0NLX1NJWkUgOiAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc3RhcnRQb3MsIHNpemU6IGVuZFBvcyAtIHN0YXJ0UG9zICsgMX0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZmxhdGVkLCBzbGljZWREYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleC50YWJpeCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsYXRlZCA9IGlndnhoci5hcnJheUJ1ZmZlclRvU3RyaW5nKHVuYmd6ZihkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBkZWNvbXByZXNzIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxhdGVkID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZWREYXRhID0gc3RhcnRPZmZzZXQgPyBpbmZsYXRlZC5zbGljZShzdGFydE9mZnNldCkgOiBpbmZsYXRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc2VsZi5wYXJzZXIucGFyc2VGZWF0dXJlcyhzbGljZWREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXN5bmMgbG9hZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sb2NhbEZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nRnJvbUZpbGUoc2VsZi5sb2NhbEZpbGUsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcykuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleC50YWJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi51cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcykuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChmZWF0dXJlQXJyYXlzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBhbGxGZWF0dXJlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVBcnJheXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gZmVhdHVyZUFycmF5c1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGZlYXR1cmVBcnJheXNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgZmVhdHVyZUFycmF5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBhbGxGZWF0dXJlcy5jb25jYXQoZmVhdHVyZUFycmF5c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsbEZlYXR1cmVzKVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBpc0luZGVlZEluZGV4aWJsZSA9IHRoaXMuaXNJbmRleGFibGUoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaW5kZXhlZCA9PT0gdW5kZWZpbmVkICYmIGlzSW5kZWVkSW5kZXhpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRJbmRleCgpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5pbmRleCk7ICAgLy8gSXMgZWl0aGVyIGFscmVhZHkgbG9hZGVkLCBvciB0aGVyZSBpc24ndCBvbmVcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZWFkSGVhZGVyKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaGVhZGVyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgZm9yY2UgYSBsb2FkIG9mIHRoZSBpbmRleCBmaXJzdFxyXG5cclxuICAgICAgICAgICAgICAgc2VsZi4gZ2V0SW5kZXgoKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgZmlsZSBoZWFkZXIgKG5vdCBIVFRQIGhlYWRlcikgZm9yIGFuIGluZGV4ZWQgZmlsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBub3RlIHRoaXMgd2lsbCBmYWlsIGlmIHRoZSBmaWxlIGhlYWRlciBpcyA+IDY1a2IgaW4gc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLCAgICAgICAgICAgLy8gaHR0cCBoZWFkZXJzLCBub3QgZmlsZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ3o6IGluZGV4LnRhYml4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IDAsIHNpemU6IDY1MDAwfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyID0gc2VsZi5wYXJzZXIucGFyc2VIZWFkZXIoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubG9jYWxGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZ0Zyb21GaWxlKHNlbGYubG9jYWxGaWxlLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmcoc2VsZi51cmwsIG9wdGlvbnMpLnRoZW4oc3VjY2VzcykuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2FkRmVhdHVyZXNOb0luZGV4KHVuZGVmaW5lZCkudGhlbihmdW5jdGlvbiAoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBzZWxmLmhlYWRlciB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5mZWF0dXJlcyA9IGZlYXR1cmVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChoZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZnVsZmlsbFxyXG4gICAgICogQHBhcmFtIHJhbmdlIC0tIGdlbm9taWMgcmFuZ2UgdG8gbG9hZC4gIEZvciB1c2Ugd2l0aCBpbmRleGVkIHNvdXJjZSAob3B0aW9uYWwpXHJcbiAgICAgKi9cclxuICAgIHJlYWRGZWF0dXJlcyhjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGYuaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZEZlYXR1cmVzV2l0aEluZGV4KGNociwgc3RhcnQsIGVuZCkudGhlbihwYWNrRmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkRmVhdHVyZXNOb0luZGV4KCkudGhlbihwYWNrRmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwYWNrRmVhdHVyZXMoZmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gcGFja1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChmZWF0dXJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqanMvZmVhdHVyZS9GZWF0dXJlUGFyc2Vycy5qcyoqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgbWF4RmVhdHVyZUNvdW50ID0gTnVtYmVyLk1BWF9WQUxVRTsgICAgLy8gRm9yIGZ1dHVyZSB1c2UsICBjb250cm9scyBkb3duc2FtcGxpbmdcclxuXHJcbmNvbnN0IGdmZk5hbWVGaWVsZHMgPSBbXCJOYW1lXCIsIFwiZ2VuZV9uYW1lXCIsIFwiZ2VuZVwiLCBcImdlbmVfaWRcIiwgXCJhbGlhc1wiLCBcImxvY3VzXCJdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBmYWN0b3J5IGZ1bmN0aW9uLiAgUmV0dXJuIGEgcGFyc2VyIGZvciB0aGUgZ2l2ZW4gZmlsZSBmb3JtYXQuXHJcbiAgICAgKi9cclxuY2xhc3MgRmVhdHVyZVBhcnNlcntcclxuICAgIGNvbnN0cnVjdG9yKGZvcm1hdCwgZGVjb2RlLCBjb25maWcpIHtcclxuXHJcbiAgICAgICAgdmFyIGN1c3RvbUZvcm1hdDtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgdGhpcy5uYW1lRmllbGQgPSBjb25maWcgPyBjb25maWcubmFtZUZpZWxkIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc2tpcFJvd3MgPSAwOyAgIC8vIFRoZSBudW1iZXIgb2YgZml4ZWQgaGVhZGVyIHJvd3MgdG8gc2tpcC4gIE92ZXJyaWRlIGZvciBzcGVjaWZpYyB0eXBlcyBhcyBuZWVkZWRcclxuXHJcbiAgICAgICAgaWYgKGRlY29kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlY29kZSA9IGRlY29kZTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBjYXNlIFwibmFycm93cGVha1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiYnJvYWRwZWFrXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJwZWFrc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlY29kZVBlYWs7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmVkZ3JhcGhcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVCZWRHcmFwaDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3aWdcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVXaWc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ2ZmM1wiIDpcclxuICAgICAgICAgICAgY2FzZSBcImdmZlwiIDpcclxuICAgICAgICAgICAgY2FzZSBcImd0ZlwiIDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVHRkY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImFuZXVcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVBbmV1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmdXNpb25qdW5jc3BhblwiOlxyXG4gICAgICAgICAgICAgICAgLy8gYmhhYXMsIG5lZWRlZCBmb3IgRnVzaW9uSW5zcGVjdG9yIHZpZXdcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVGdXNpb25KdW5jU3BhbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJndGV4Z3dhc1wiOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwUm93cyA9IDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlR3RleEdXQVM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IFwiXFx0XCI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJlZmZsYXRcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVSZWZmbGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICAgICAvKiBjdXN0b21Gb3JtYXQgPSBpZ3YuYnJvd3Nlci5nZXRGb3JtYXQoZm9ybWF0KTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Gb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gZGVjb2RlQ3VzdG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gY3VzdG9tRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gY3VzdG9tRm9ybWF0LmRlbGltaXRlciB8fCBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gRmVhdHVyZVBhcnNlci5kZWNvZGVCZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcbiAgICAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgcGFyc2VIZWFkZXIoZGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpLFxyXG4gICAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGhlYWRlcjtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRyYWNrXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcIiNcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiYnJvd3NlclwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRyYWNrXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5wYXJzZVRyYWNrTGluZShsaW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcIiMjZ2ZmLXZlcnNpb24gM1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gXCJnZmYzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpIGhlYWRlciA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcltcImZvcm1hdFwiXSA9IFwiZ2ZmM1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyPXt9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcjtcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2VGZWF0dXJlcyhkYXRhKSB7XHJcblxyXG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIHZhciB3aWcsXHJcbiAgICAgICAgICAgIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKSxcclxuICAgICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICB0b2tlbnMsXHJcbiAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gW10sXHJcbiAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGNudCA9IDAsXHJcbiAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgIGRlY29kZSA9IHRoaXMuZGVjb2RlLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSB0aGlzLmZvcm1hdCxcclxuICAgICAgICAgICAgZGVsaW1pdGVyID0gdGhpcy5kZWxpbWl0ZXIgfHwgXCJcXHRcIjtcclxuXHJcblxyXG4gICAgICAgIGZvciAoaSA9IHRoaXMuc2tpcFJvd3M7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBsaW5lID0gbGluZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0cmFja1wiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCIjXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcImJyb3dzZXJcIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ3aWdcIiAmJiBsaW5lLnN0YXJ0c1dpdGgoXCJmaXhlZFN0ZXBcIikpIHtcclxuICAgICAgICAgICAgICAgIHdpZyA9IHRoaXMucGFyc2VGaXhlZFN0ZXAobGluZSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwid2lnXCIgJiYgbGluZS5zdGFydHNXaXRoKFwidmFyaWFibGVTdGVwXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB3aWcgPSB0aGlzLnBhcnNlVmFyaWFibGVTdGVwKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRva2VucyA9IGxpbmVzW2ldLnNwbGl0KGRlbGltaXRlcik7XHJcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMSkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0gdGhpcy5kZWNvZGUodG9rZW5zLCB3aWcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhbGxGZWF0dXJlcy5sZW5ndGggPCBtYXhGZWF0dXJlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXJ2b2lyIHNhbXBsaW5nLCAgY29uZGl0aW9uYWxseSByZXBsYWNlIGV4aXN0aW5nIGZlYXR1cmUgd2l0aCBuZXcgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgIGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbWF4RmVhdHVyZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzW2pdID0gZmVhdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFsbEZlYXR1cmVzO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgc3RhdGljIHBhcnNlRml4ZWRTdGVwKGxpbmUpIHtcclxuXHJcbiAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoL1xccysvKSxcclxuICAgICAgICAgICAgY2MgPSB0b2tlbnNbMV0uc3BsaXQoXCI9XCIpWzFdLFxyXG4gICAgICAgICAgICBzcyA9IHBhcnNlSW50KHRva2Vuc1syXS5zcGxpdChcIj1cIilbMV0sIDEwKSxcclxuICAgICAgICAgICAgc3RlcCA9IHBhcnNlSW50KHRva2Vuc1szXS5zcGxpdChcIj1cIilbMV0sIDEwKSxcclxuICAgICAgICAgICAgc3BhbiA9ICh0b2tlbnMubGVuZ3RoID4gNCkgPyBwYXJzZUludCh0b2tlbnNbNF0uc3BsaXQoXCI9XCIpWzFdLCAxMCkgOiAxO1xyXG5cclxuICAgICAgICByZXR1cm4ge2Zvcm1hdDogXCJmaXhlZFN0ZXBcIiwgY2hyb206IGNjLCBzdGFydDogc3MsIHN0ZXA6IHN0ZXAsIHNwYW46IHNwYW4sIGluZGV4OiAwfTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlVmFyaWFibGVTdGVwKGxpbmUpIHtcclxuXHJcbiAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoL1xccysvKSxcclxuICAgICAgICAgICAgY2MgPSB0b2tlbnNbMV0uc3BsaXQoXCI9XCIpWzFdLFxyXG4gICAgICAgICAgICBzcGFuID0gdG9rZW5zLmxlbmd0aCA+IDIgPyBwYXJzZUludCh0b2tlbnNbMl0uc3BsaXQoXCI9XCIpWzFdLCAxMCkgOiAxO1xyXG4gICAgICAgIHJldHVybiB7Zm9ybWF0OiBcInZhcmlhYmxlU3RlcFwiLCBjaHJvbTogY2MsIHNwYW46IHNwYW59XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZVRyYWNrTGluZShsaW5lKSB7XHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fSxcclxuICAgICAgICAgICAgdG9rZW5zID0gbGluZS5zcGxpdCgvKD86XCIpKFteXCJdKykoPzpcIil8KFteXFxzXCJdKykoPz1cXHMrfCQpL2cpLFxyXG4gICAgICAgICAgICB0bXAgPSBbXSxcclxuICAgICAgICAgICAgaSwgdGssIGN1cnI7XHJcblxyXG4gICAgICAgIC8vIENsZWFuIHVwIHRva2VucyBhcnJheVxyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCF0b2tlbnNbaV0gfHwgdG9rZW5zW2ldLnRyaW0oKS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgdGsgPSB0b2tlbnNbaV0udHJpbSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRrLmVuZHNXaXRoKFwiPVwiKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnIgPSB0aztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICB0bXAucHVzaChjdXJyICsgdGspO1xyXG4gICAgICAgICAgICAgICAgY3VyciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRtcC5wdXNoKHRrKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB0bXAuZm9yRWFjaChmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RyKSByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBrdiA9IHN0ci5zcGxpdCgnPScsIDIpO1xyXG4gICAgICAgICAgICBpZiAoa3YubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNba3ZbMF1dID0ga3ZbMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIHRoZSBcInN0YW5kYXJkXCIgVUNTQyBiZWQgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gdG9rZW5zXHJcbiAgICAgKiBAcGFyYW0gaWdub3JlXHJcbiAgICAgKiBAcmV0dXJucyBkZWNvZGVkIGZlYXR1cmUsIG9yIG51bGwgaWYgdGhpcyBpcyBub3QgYSB2YWxpZCByZWNvcmRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29kZUJlZCh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgY2hyLCBzdGFydCwgZW5kLCBpZCwgbmFtZSwgdG1wLCBpZE5hbWUsIGV4b25Db3VudCwgZXhvblNpemVzLCBleG9uU3RhcnRzLCBleG9ucywgZXhvbiwgZmVhdHVyZSxcclxuICAgICAgICAgICAgZVN0YXJ0LCBlRW5kO1xyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMV0pO1xyXG4gICAgICAgIGVuZCA9IHRva2Vucy5sZW5ndGggPiAyID8gcGFyc2VJbnQodG9rZW5zWzJdKSA6IHN0YXJ0ICsgMTtcclxuXHJcbiAgICAgICAgZmVhdHVyZSA9IHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgc2NvcmU6IDEwMDB9O1xyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgLy8gTm90ZTogdGhlc2UgYXJlIHZlcnkgc3BlY2lhbCBydWxlcyBmb3IgdGhlIGdlbmNvZGUgZ2VuZSBmaWxlcy5cclxuICAgICAgICAgICAgdG1wID0gdG9rZW5zWzNdLnJlcGxhY2UoL1wiL2csICcnKTtcclxuICAgICAgICAgICAgaWROYW1lID0gdG1wLnNwbGl0KCc7Jyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWROYW1lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga3YgPSBpZE5hbWVbaV0uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgICAgIGlmIChrdlswXSA9PSBcImdlbmVfaWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0ga3ZbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa3ZbMF0gPT0gXCJnZW5lX25hbWVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBrdlsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmZWF0dXJlLmlkID0gaWQgPyBpZCA6IHRtcDtcclxuICAgICAgICAgICAgZmVhdHVyZS5uYW1lID0gbmFtZSA/IG5hbWUgOiB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDQpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuc3RyYW5kID0gdG9rZW5zWzVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDYpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5jZFN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzZdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA3KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuY2RFbmQgPSBwYXJzZUludCh0b2tlbnNbN10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDgpIHtcclxuICAgICAgICAgICAgaWYgKHRva2Vuc1s4XSAhPT0gXCIuXCIgJiYgdG9rZW5zWzhdICE9PSBcIjBcIilcclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuY29sb3IgPSBpZ3YuY3JlYXRlQ29sb3JTdHJpbmcodG9rZW5zWzhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAxMSkge1xyXG4gICAgICAgICAgICBleG9uQ291bnQgPSBwYXJzZUludCh0b2tlbnNbOV0pO1xyXG4gICAgICAgICAgICBleG9uU2l6ZXMgPSB0b2tlbnNbMTBdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIGV4b25TdGFydHMgPSB0b2tlbnNbMTFdLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgIGV4b25zID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25Db3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlU3RhcnQgPSBzdGFydCArIHBhcnNlSW50KGV4b25TdGFydHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgZUVuZCA9IGVTdGFydCArIHBhcnNlSW50KGV4b25TaXplc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhvbiA9IHtzdGFydDogZVN0YXJ0LCBlbmQ6IGVFbmR9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmNkU3RhcnQgPiBlRW5kIHx8IGZlYXR1cmUuY2RFbmQgPCBmZWF0dXJlLmNkU3RhcnQpIGV4b24udXRyID0gdHJ1ZTsgICAvLyBFbnRpcmUgZXhvbiBpcyBVVFJcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmNkU3RhcnQgPj0gZVN0YXJ0ICYmIGZlYXR1cmUuY2RTdGFydCA8PSBlRW5kKSBleG9uLmNkU3RhcnQgPSBmZWF0dXJlLmNkU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5jZEVuZCA+PSBlU3RhcnQgJiYgZmVhdHVyZS5jZEVuZCA8PSBlRW5kKSBleG9uLmNkRW5kID0gZmVhdHVyZS5jZEVuZDtcclxuXHJcbiAgICAgICAgICAgICAgICBleG9ucy5wdXNoKGV4b24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlLmV4b25zID0gZXhvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmZWF0dXJlLnBvcHVwRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGZlYXR1cmUubmFtZSkgZGF0YS5wdXNoKHtuYW1lOiBcIk5hbWVcIiwgdmFsdWU6IGZlYXR1cmUubmFtZX0pO1xyXG4gICAgICAgICAgICBpZiAoXCIrXCIgPT09IGZlYXR1cmUuc3RyYW5kIHx8IFwiLVwiID09PSBmZWF0dXJlLnN0cmFuZCkgZGF0YS5wdXNoKHtuYW1lOiBcIlN0cmFuZFwiLCB2YWx1ZTogZmVhdHVyZS5zdHJhbmR9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlIGEgVUNTQyBcInJlZmZsYXRcIiByZWNvcmRcclxuICAgICAqIEBwYXJhbSB0b2tlbnNcclxuICAgICAqIEBwYXJhbSBpZ25vcmVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVjb2RlUmVmZmxhdCh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDEwKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB7XHJcbiAgICAgICAgICAgICAgICBjaHI6IHRva2Vuc1syXSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXJzZUludCh0b2tlbnNbNF0pLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBwYXJzZUludCh0b2tlbnNbNV0pLFxyXG4gICAgICAgICAgICAgICAgaWQ6IHRva2Vuc1sxXSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRva2Vuc1swXSxcclxuICAgICAgICAgICAgICAgIHN0cmFuZDogdG9rZW5zWzNdLFxyXG4gICAgICAgICAgICAgICAgY2RTdGFydDogcGFyc2VJbnQodG9rZW5zWzZdKSxcclxuICAgICAgICAgICAgICAgIGNkRW5kOiBwYXJzZUludCh0b2tlbnNbN10pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV4b25Db3VudCA9IHBhcnNlSW50KHRva2Vuc1s4XSksXHJcbiAgICAgICAgICAgIGV4b25TdGFydHMgPSB0b2tlbnNbOV0uc3BsaXQoJywnKSxcclxuICAgICAgICAgICAgZXhvbkVuZHMgPSB0b2tlbnNbMTBdLnNwbGl0KCcsJyksXHJcbiAgICAgICAgICAgIGV4b25zID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgZXhvbnMucHVzaCh7c3RhcnQ6IHBhcnNlSW50KGV4b25TdGFydHNbaV0pLCBlbmQ6IHBhcnNlSW50KGV4b25FbmRzW2ldKX0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG5cclxuICAgICAgICBmZWF0dXJlLnBvcHVwRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVBlYWsodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIHRva2VuQ291bnQsIGNociwgc3RhcnQsIGVuZCwgc3RyYW5kLCBuYW1lLCBzY29yZSwgcVZhbHVlLCBzaWduYWwsIHBWYWx1ZTtcclxuXHJcbiAgICAgICAgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRva2VuQ291bnQgPCA5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICBlbmQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG4gICAgICAgIG5hbWUgPSB0b2tlbnNbM107XHJcbiAgICAgICAgc2NvcmUgPSBwYXJzZUZsb2F0KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgc3RyYW5kID0gdG9rZW5zWzVdLnRyaW0oKTtcclxuICAgICAgICBzaWduYWwgPSBwYXJzZUZsb2F0KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgcFZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbN10pO1xyXG4gICAgICAgIHFWYWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzhdKTtcclxuXHJcbiAgICAgICAgaWYgKHNjb3JlID09PSAwKSBzY29yZSA9IHNpZ25hbDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIG5hbWU6IG5hbWUsIHNjb3JlOiBzY29yZSwgc3RyYW5kOiBzdHJhbmQsIHNpZ25hbDogc2lnbmFsLFxyXG4gICAgICAgICAgICBwVmFsdWU6IHBWYWx1ZSwgcVZhbHVlOiBxVmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVCZWRHcmFwaCh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgY2hyLCBzdGFydCwgZW5kLCB2YWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAzKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICBlbmQgPSBwYXJzZUludCh0b2tlbnNbMl0pO1xyXG5cclxuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzNdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgdmFsdWU6IHZhbHVlfTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlV2lnKHRva2Vucywgd2lnKSB7XHJcblxyXG4gICAgICAgIHZhciBzcyxcclxuICAgICAgICAgICAgZWUsXHJcbiAgICAgICAgICAgIHZhbHVlO1xyXG5cclxuICAgICAgICBpZiAod2lnLmZvcm1hdCA9PT0gXCJmaXhlZFN0ZXBcIikge1xyXG5cclxuICAgICAgICAgICAgc3MgPSAod2lnLmluZGV4ICogd2lnLnN0ZXApICsgd2lnLnN0YXJ0O1xyXG4gICAgICAgICAgICBlZSA9IHNzICsgd2lnLnNwYW47XHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbMF0pO1xyXG4gICAgICAgICAgICArKyh3aWcuaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpID8gbnVsbCA6IHtjaHI6IHdpZy5jaHJvbSwgc3RhcnQ6IHNzLCBlbmQ6IGVlLCB2YWx1ZTogdmFsdWV9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3aWcuZm9ybWF0ID09PSBcInZhcmlhYmxlU3RlcFwiKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDIpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgc3MgPSBwYXJzZUludCh0b2tlbnNbMF0sIDEwKTtcclxuICAgICAgICAgICAgZWUgPSBzcyArIHdpZy5zcGFuO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSA/IG51bGwgOiB7Y2hyOiB3aWcuY2hyb20sIHN0YXJ0OiBzcywgZW5kOiBlZSwgdmFsdWU6IHZhbHVlfTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlQmVkR3JhcGgodG9rZW5zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZUFuZXUodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGNociwgc3RhcnQsIGVuZCwgZmVhdHVyZTtcclxuXHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgNCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1sxXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1syXSk7XHJcbiAgICAgICAgZW5kID0gdG9rZW5zLmxlbmd0aCA+IDMgPyBwYXJzZUludCh0b2tlbnNbM10pIDogc3RhcnQgKyAxO1xyXG5cclxuICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kfTtcclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgIGZlYXR1cmUuc2NvcmUgPSBwYXJzZUZsb2F0KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgICAgIGZlYXR1cmUudmFsdWUgPSBmZWF0dXJlLnNjb3JlO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZlYXR1cmUucG9wdXBEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tuYW1lOiBcIk5hbWVcIiwgdmFsdWU6IGZlYXR1cmUubmFtZX1dO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlRnVzaW9uSnVuY1NwYW4odG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgRm9ybWF0OlxyXG5cclxuICAgICAgICAgMCAgICAgICAjc2NhZmZvbGRcclxuICAgICAgICAgMSAgICAgICBmdXNpb25fYnJlYWtfbmFtZVxyXG4gICAgICAgICAyICAgICAgIGJyZWFrX2xlZnRcclxuICAgICAgICAgMyAgICAgICBicmVha19yaWdodFxyXG4gICAgICAgICA0ICAgICAgIG51bV9qdW5jdGlvbl9yZWFkc1xyXG4gICAgICAgICA1ICAgICAgIG51bV9zcGFubmluZ19mcmFnc1xyXG4gICAgICAgICA2ICAgICAgIHNwYW5uaW5nX2ZyYWdfY29vcmRzXHJcblxyXG4gICAgICAgICAwICAgICAgIEIzR05UMS0tTlBTUjFcclxuICAgICAgICAgMSAgICAgICBCM0dOVDEtLU5QU1IxfDIyMDMtMTAxODJcclxuICAgICAgICAgMiAgICAgICAyMjAzXHJcbiAgICAgICAgIDMgICAgICAgMTAxODJcclxuICAgICAgICAgNCAgICAgICAxODlcclxuICAgICAgICAgNSAgICAgICAxMTM4XHJcbiAgICAgICAgIDYgICAgICAgMTg2MC0xMzc1NywxNzk4LTEzODE5LDEzOTEtMTgxMjcsMTQ0My0xNzE3NCwuLi5cclxuXHJcbiAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgIFxyXG5cclxuICAgICAgICB2YXIgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHZhciBmdXNpb25fbmFtZSA9IHRva2Vuc1sxXTtcclxuICAgICAgICB2YXIganVuY3Rpb25fbGVmdCA9IHBhcnNlSW50KHRva2Vuc1syXSk7XHJcbiAgICAgICAgdmFyIGp1bmN0aW9uX3JpZ2h0ID0gcGFyc2VJbnQodG9rZW5zWzNdKTtcclxuICAgICAgICB2YXIgbnVtX2p1bmN0aW9uX3JlYWRzID0gcGFyc2VJbnQodG9rZW5zWzRdKTtcclxuICAgICAgICB2YXIgbnVtX3NwYW5uaW5nX2ZyYWdzID0gcGFyc2VJbnQodG9rZW5zWzVdKTtcclxuXHJcbiAgICAgICAgdmFyIHNwYW5uaW5nX2ZyYWdfY29vcmRzX3RleHQgPSB0b2tlbnNbNl07XHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlID0ge1xyXG4gICAgICAgICAgICBjaHI6IGNocixcclxuICAgICAgICAgICAgbmFtZTogZnVzaW9uX25hbWUsXHJcbiAgICAgICAgICAgIGp1bmN0aW9uX2xlZnQ6IGp1bmN0aW9uX2xlZnQsXHJcbiAgICAgICAgICAgIGp1bmN0aW9uX3JpZ2h0OiBqdW5jdGlvbl9yaWdodCxcclxuICAgICAgICAgICAgbnVtX2p1bmN0aW9uX3JlYWRzOiBudW1fanVuY3Rpb25fcmVhZHMsXHJcbiAgICAgICAgICAgIG51bV9zcGFubmluZ19mcmFnczogbnVtX3NwYW5uaW5nX2ZyYWdzLFxyXG4gICAgICAgICAgICBzcGFubmluZ19mcmFnX2Nvb3JkczogW10sXHJcblxyXG4gICAgICAgICAgICBzdGFydDogLTEsXHJcbiAgICAgICAgICAgIGVuZDogLTFcclxuICAgICAgICB9OyAvLyBzZXQgc3RhcnQgYW5kIGVuZCBsYXRlciBiYXNlZCBvbiBtaW4vbWF4IG9mIHNwYW4gY29vcmRzXHJcblxyXG4gICAgICAgIHZhciBtaW5fY29vcmQgPSBqdW5jdGlvbl9sZWZ0O1xyXG4gICAgICAgIHZhciBtYXhfY29vcmQgPSBqdW5jdGlvbl9yaWdodDtcclxuXHJcbiAgICAgICAgaWYgKG51bV9zcGFubmluZ19mcmFncyA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjb29yZF9wYWlycyA9IHNwYW5uaW5nX2ZyYWdfY29vcmRzX3RleHQuc3BsaXQoJywnKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRfcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzcGxpdF9jb29yZHMgPSBjb29yZF9wYWlyc1tpXS5zcGxpdCgnLScpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzcGFuX2xlZnQgPSBzcGxpdF9jb29yZHNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Bhbl9yaWdodCA9IHNwbGl0X2Nvb3Jkc1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbl9sZWZ0IDwgbWluX2Nvb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluX2Nvb3JkID0gc3Bhbl9sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNwYW5fcmlnaHQgPiBtYXhfY29vcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhfY29vcmQgPSBzcGFuX3JpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5zcGFubmluZ19mcmFnX2Nvb3Jkcy5wdXNoKHtsZWZ0OiBzcGFuX2xlZnQsIHJpZ2h0OiBzcGFuX3JpZ2h0fSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmZWF0dXJlLnN0YXJ0ID0gbWluX2Nvb3JkO1xyXG4gICAgICAgIGZlYXR1cmUuZW5kID0gbWF4X2Nvb3JkO1xyXG5cclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe25hbWU6IFwiTmFtZVwiLCB2YWx1ZTogZmVhdHVyZS5uYW1lfV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVHdGV4R1dBUyh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHRva2VuQ291bnQsIGNociwgc3RhcnQsIGVuZCwgc3RyYW5kLCBuYW1lLCBzY29yZSwgcVZhbHVlLCBzaWduYWwsIHBWYWx1ZTtcclxuXHJcbiAgICAgICAgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRva2VuQ291bnQgPCA4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzFdKSAtIDE7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzNdLnNwbGl0KCc6JylbMV0pO1xyXG4gICAgICAgIC8vbmFtZSA9IHRva2Vuc1szXTtcclxuICAgICAgICAvL3Njb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIC8vc3RyYW5kID0gdG9rZW5zWzVdLnRyaW0oKTtcclxuICAgICAgICAvL3NpZ25hbCA9IHBhcnNlRmxvYXQodG9rZW5zWzZdKTtcclxuICAgICAgICBwVmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1s1XSk7XHJcbiAgICAgICAgLy9xVmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1s4XSk7XHJcblxyXG4gICAgICAgIC8vcmV0dXJuIHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgbmFtZTogbmFtZSwgc2NvcmU6IHNjb3JlLCBzdHJhbmQ6IHN0cmFuZCwgc2lnbmFsOiBzaWduYWwsXHJcbiAgICAgICAgLy8gICAgcFZhbHVlOiBwVmFsdWUsIHFWYWx1ZTogcVZhbHVlfTtcclxuICAgICAgICByZXR1cm4ge2NocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBwdmFsdWU6IHBWYWx1ZX07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgYSBzaW5nbGUgZ2ZmIHJlY29yZCAoMSBsaW5lIGluIGZpbGUpLiAgQWdncmVnYXRpb25zIHN1Y2ggYXMgZ2VuZSBtb2RlbHMgYXJlIGNvbnN0cnVjdGVkIGF0IGEgaGlnaGVyIGxldmVsLlxyXG4gICAgICogICAgICBjdGcxMjMgLiBtUk5BICAgICAgICAgICAgMTA1MCAgOTAwMCAgLiAgKyAgLiAgSUQ9bVJOQTAwMDAxO1BhcmVudD1nZW5lMDAwMDFcclxuICAgICAqIEBwYXJhbSB0b2tlbnNcclxuICAgICAqIEBwYXJhbSBpZ25vcmVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVjb2RlR0ZGKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbkNvdW50LCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgdHlwZSwgc2NvcmUsIHBoYXNlLCBhdHRyaWJ1dGVTdHJpbmcsIGlkLCBwYXJlbnQsIGNvbG9yLCBuYW1lLFxyXG4gICAgICAgICAgICB0cmFuc2NyaXB0X2lkLCBpLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSB0aGlzLmZvcm1hdDtcclxuXHJcbiAgICAgICAgdG9rZW5Db3VudCA9IHRva2Vucy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRva2VuQ291bnQgPCA5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAgICAgIC8vIE5vdCBhIHZhbGlkIGdmZiByZWNvcmRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICB0eXBlID0gdG9rZW5zWzJdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzNdKSAtIDE7XHJcbiAgICAgICAgZW5kID0gcGFyc2VJbnQodG9rZW5zWzRdKTtcclxuICAgICAgICBzY29yZSA9IFwiLlwiID09PSB0b2tlbnNbNV0gPyAwIDogcGFyc2VGbG9hdCh0b2tlbnNbNV0pO1xyXG4gICAgICAgIHN0cmFuZCA9IHRva2Vuc1s2XTtcclxuICAgICAgICBwaGFzZSA9IFwiLlwiID09PSB0b2tlbnNbN10gPyAwIDogcGFyc2VJbnQodG9rZW5zWzddKTtcclxuICAgICAgICBhdHRyaWJ1dGVTdHJpbmcgPSB0b2tlbnNbOF07XHJcblxyXG4gICAgICAgIC8vIEZpbmQgSUQgYW5kIFBhcmVudCwgb3IgdHJhbnNjcmlwdF9pZFxyXG4gICAgICAgIHZhciBkZWxpbSA9ICgnZ2ZmMycgPT09IGZvcm1hdCkgPyAnPScgOiAvXFxzKy87XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICBhdHRyaWJ1dGVTdHJpbmcuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChrdikge1xyXG4gICAgICAgICAgICB2YXIgdCA9IGt2LnRyaW0oKS5zcGxpdChkZWxpbSwgMiksIGtleSwgdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSB0WzBdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdFsxXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAvL1N0cmlwIG9mZiBxdW90ZXMsIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykgJiYgdmFsdWUuZW5kc1dpdGgoJ1wiJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChcIklEXCIgPT09IHRbMF0pIGlkID0gdFsxXTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiUGFyZW50XCIgPT09IHRbMF0pIHBhcmVudCA9IHRbMV07XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImNvbG9yXCIgPT09IHRbMF0udG9Mb3dlckNhc2UoKSkgY29sb3IgPSBpZ3YuY3JlYXRlQ29sb3JTdHJpbmcodFsxXSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInRyYW5zY3JpcHRfaWRcIiA9PT0gdFswXSkgaWQgPSB0WzFdOyAgICAgLy8gZ3RmIGZvcm1hdFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRmluZCBuYW1lIChsYWJlbCkgcHJvcGVydHlcclxuICAgICAgICBpZiAodGhpcy5uYW1lRmllbGQpIHtcclxuICAgICAgICAgICAgbmFtZSA9IGF0dHJpYnV0ZXNbdGhpcy5uYW1lRmllbGRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdmZk5hbWVGaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGdmZk5hbWVGaWVsZHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lRmllbGQgPSBnZmZOYW1lRmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGVzW3RoaXMubmFtZUZpZWxkXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGlkLFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgY2hyOiBjaHIsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmQsXHJcbiAgICAgICAgICAgIHNjb3JlOiBzY29yZSxcclxuICAgICAgICAgICAgc3RyYW5kOiBzdHJhbmQsXHJcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgYXR0cmlidXRlU3RyaW5nOiBhdHRyaWJ1dGVTdHJpbmcsXHJcbiAgICAgICAgICAgIHBvcHVwRGF0YTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGt2cyA9IHRoaXMuYXR0cmlidXRlU3RyaW5nLnNwbGl0KCc7JyksXHJcbiAgICAgICAgICAgICAgICAgICAgcGQgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBrZXksIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAga3ZzLmZvckVhY2goZnVuY3Rpb24gKGt2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrdi50cmltKCkuc3BsaXQoZGVsaW0sIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA9PT0gMiAmJiB0WzFdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdFswXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdFsxXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU3RyaXAgb2ZmIHF1b3RlcywgaWYgYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIHZhbHVlLmVuZHNXaXRoKCdcIicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZC5wdXNoKHtuYW1lOiBrZXksIHZhbHVlOiB2YWx1ZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgdGhlIFwic3RhbmRhcmRcIiBVQ1NDIGJlZCBmb3JtYXRcclxuICAgICAqIEBwYXJhbSB0b2tlbnNcclxuICAgICAqIEBwYXJhbSBpZ25vcmVcclxuICAgICAqIEByZXR1cm5zIGRlY29kZWQgZmVhdHVyZSwgb3IgbnVsbCBpZiB0aGlzIGlzIG5vdCBhIHZhbGlkIHJlY29yZFxyXG4gICAgICovXHJcbiAgICBkZWNvZGVDdXN0b20odG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGNociwgc3RhcnQsIGVuZCxcclxuICAgICAgICAgICAgZm9ybWF0ID0gdGhpcy5mb3JtYXQsICAgICAgICAgLy8gXCJ0aGlzXCIgcmVmZXJzIHRvIEZlYXR1cmVQYXJzZXIgaW5zdGFuY2VcclxuICAgICAgICAgICAgY29vcmRzID0gZm9ybWF0LmNvb3JkcyB8fCAwO1xyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbZm9ybWF0LmNocl07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbZm9ybWF0LnN0YXJ0XSkgLSBjb29yZHM7XHJcbiAgICAgICAgZW5kID0gZm9ybWF0LmVuZCAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQodG9rZW5zW2Zvcm1hdC5lbmRdKSA6IHN0YXJ0ICsgMTtcclxuXHJcbiAgICAgICAgZmVhdHVyZSA9IHtjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XHJcblxyXG4gICAgICAgIGlmIChmb3JtYXQuZmllbGRzKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdC5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT0gZm9ybWF0LmNociAmJiBpbmRleCAhPSBmb3JtYXQuc3RhcnQgJiYgaW5kZXggIT0gZm9ybWF0LmVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVbZmllbGRdID0gdG9rZW5zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbi8vKioqKioqKmpzL2ZlYXR1cmUvZmVhdHVyZUNhY2hlLmpzKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIE9iamVjdCBmb3IgY2FjaGluZyBsaXN0cyBvZiBmZWF0dXJlcy4gIFN1cHBvcnRzIGVmZmVjaWVudCBxdWVyaWVzIGZvciBzdWItcmFuZ2UgIChjaHIsIHN0YXJ0LCBlbmQpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVMaXN0XHJcbiAgICAgKiBAcGFyYW0gVGhlIGdlbm9taWMgcmFuZ2Ugc3Bhbm5lZCBieSBmZWF0dXJlTGlzdCAob3B0aW9uYWwpXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG5cclxuY2xhc3MgRmVhdHVyZUNhY2hle1xyXG4gICAgY29uc3RydWN0b3IoZmVhdHVyZUxpc3QsIHJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy50cmVlTWFwID0gRmVhdHVyZUNhY2hlLmJ1aWxkVHJlZU1hcChmZWF0dXJlTGlzdCk7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIHF1ZXJ5RmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgIFxyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZUxpc3QsIGludGVydmFsRmVhdHVyZXMsIGZlYXR1cmUsIGxlbiwgaSwgdHJlZSwgaW50ZXJ2YWxzO1xyXG5cclxuICAgICAgICB0cmVlID0gdGhpcy50cmVlTWFwW2Nocl07XHJcblxyXG4gICAgICAgIGlmICghdHJlZSkgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICBpbnRlcnZhbHMgPSB0cmVlLmZpbmRPdmVybGFwcGluZyhzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgaWYgKGludGVydmFscy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUcmltIHRoZSBsaXN0IG9mIGZlYXR1cmVzIGluIHRoZSBpbnRlcnZhbHMgdG8gdGhvc2VcclxuICAgICAgICAgICAgLy8gb3ZlcmxhcHBpbmcgdGhlIHJlcXVlc3RlZCByYW5nZS5cclxuICAgICAgICAgICAgLy8gQXNzdW1wdGlvbjogZmVhdHVyZXMgYXJlIHNvcnRlZCBieSBzdGFydCBwb3NpdGlvblxyXG5cclxuICAgICAgICAgICAgZmVhdHVyZUxpc3QgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGludGVydmFscy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxGZWF0dXJlcyA9IGludGVydmFsLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gaW50ZXJ2YWxGZWF0dXJlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gaW50ZXJ2YWxGZWF0dXJlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zdGFydCA+IGVuZCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVhdHVyZS5lbmQgPj0gc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxpc3QucHVzaChmZWF0dXJlKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlTGlzdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBhbGxGZWF0dXJlcygpIHtcclxuXHJcbiAgICAgICAgdmFyIGFsbEZlYXR1cmVzID0gW107XHJcbiAgICAgICAgdmFyIHRyZWVNYXAgPSB0aGlzLnRyZWVNYXA7XHJcbiAgICAgICAgaWYgKHRyZWVNYXApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRyZWVNYXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmVlTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyZWUgPSB0cmVlTWFwW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZS5tYXBJbnRlcnZhbHMoZnVuY3Rpb24gKGludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gYWxsRmVhdHVyZXMuY29uY2F0KGludGVydmFsLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsRmVhdHVyZXM7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBidWlsZFRyZWVNYXAoZmVhdHVyZUxpc3QpIHtcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmVDYWNoZSA9IHt9LFxyXG4gICAgICAgICAgICBjaHJvbW9zb21lcyA9IFtdLFxyXG4gICAgICAgICAgICB0cmVlTWFwID0ge30sXHJcbiAgICAgICAgICAgIGdlbm9tZSA9IG51bGw7XHJcblxyXG4gICAgICAgIGlmIChmZWF0dXJlTGlzdCkge1xyXG5cclxuICAgICAgICAgICAgZmVhdHVyZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjaHIgPSBmZWF0dXJlLmNocixcclxuICAgICAgICAgICAgICAgICAgICBnZW5lTGlzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gXCJvZmZpY2lhbFwiIG5hbWVcclxuICAgICAgICAgICAgICAgIGlmKGdlbm9tZSkgY2hyID0gZ2Vub21lLmdldENocm9tb3NvbWVOYW1lKGNocik7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2VuZUxpc3QgPSBmZWF0dXJlQ2FjaGVbY2hyXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWdlbmVMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21vc29tZXMucHVzaChjaHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdlbmVMaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUNhY2hlW2Nocl0gPSBnZW5lTGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBnZW5lTGlzdC5wdXNoKGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gTm93IGJ1aWxkIGludGVydmFsIHRyZWUgZm9yIGVhY2ggY2hyb21vc29tZVxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHJvbW9zb21lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNociA9IGNocm9tb3NvbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdHJlZU1hcFtjaHJdID1GZWF0dXJlQ2FjaGUuYnVpbGRJbnRlcnZhbFRyZWUoZmVhdHVyZUNhY2hlW2Nocl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJlZU1hcDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBhbiBpbnRlcnZhbCB0cmVlIGZyb20gdGhlIGZlYXR1cmUgbGlzdCBmb3IgZmFzdCBpbnRlcnZhbCBiYXNlZCBxdWVyaWVzLiAgIFdlIGx1bXAgZmVhdHVyZXMgaW4gZ3JvdXBzXHJcbiAgICAgKiBvZiAxMCwgb3IgdG90YWwgc2l6ZSAvIDEwMCwgICB0byByZWR1Y2Ugc2l6ZSBvZiB0aGUgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUxpc3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJ1aWxkSW50ZXJ2YWxUcmVlKGZlYXR1cmVMaXN0KSB7XHJcblxyXG4gICAgICAgIHZhciBpLCBlLCBpU3RhcnQsIGlFbmQsIHRyZWUsIGNodW5rU2l6ZSwgbGVuLCBzdWJBcnJheTtcclxuXHJcbiAgICAgICAgdHJlZSA9IG5ldyBJbnRlcnZhbFRyZWUoKTtcclxuICAgICAgICBsZW4gPSBmZWF0dXJlTGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgIGNodW5rU2l6ZSA9IE1hdGgubWF4KDEwLCBNYXRoLnJvdW5kKGxlbiAvIDEwMCkpO1xyXG5cclxuICAgICAgICBmZWF0dXJlTGlzdC5zb3J0KGZ1bmN0aW9uIChmMSwgZjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChmMS5zdGFydCA9PT0gZjIuc3RhcnQgPyAwIDogKGYxLnN0YXJ0ID4gZjIuc3RhcnQgPyAxIDogLTEpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSBjaHVua1NpemUpIHtcclxuICAgICAgICAgICAgZSA9IE1hdGgubWluKGxlbiwgaSArIGNodW5rU2l6ZSk7XHJcbiAgICAgICAgICAgIHN1YkFycmF5ID0gZmVhdHVyZUxpc3Quc2xpY2UoaSwgZSk7XHJcbiAgICAgICAgICAgIGlTdGFydCA9IHN1YkFycmF5WzBdLnN0YXJ0O1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBpRW5kID0gaVN0YXJ0O1xyXG4gICAgICAgICAgICBzdWJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBpRW5kID0gTWF0aC5tYXgoaUVuZCwgZmVhdHVyZS5lbmQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdHJlZS5pbnNlcnQoaVN0YXJ0LCBpRW5kLCBzdWJBcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG4vLyoqKioqanMvaW50ZXJ2YWxUcmVlLmpzKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgQkxBQ0sgPSAxO1xyXG5jb25zdCBSRUQgPSAyO1xyXG5cclxubGV0IE5JTCA9IHt9XHJcbk5JTC5jb2xvciA9IEJMQUNLO1xyXG5OSUwucGFyZW50ID0gTklMO1xyXG5OSUwubGVmdCA9IE5JTDtcclxuTklMLnJpZ2h0ID0gTklMO1xyXG5cclxuICBcclxuY2xhc3MgSW50ZXJ2YWxUcmVle1xyXG4gICAgY29uc3RydWN0b3IoKSB7ICAgIFxyXG4gICAgICAgIHRoaXMucm9vdCA9IE5JTDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaW5zZXJ0KHN0YXJ0LCBlbmQsIHZhbHVlKSB7XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydCwgZW5kLCB2YWx1ZSk7XHJcbiAgICAgICAgdmFyIHggPSBuZXcgTm9kZShpbnRlcnZhbCk7XHJcbiAgICAgICAgdGhpcy50cmVlSW5zZXJ0KHgpO1xyXG4gICAgICAgIHguY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgd2hpbGUgKHggIT0gdGhpcy5yb290ICYmIHgucGFyZW50LmNvbG9yID09IFJFRCkge1xyXG4gICAgICAgICAgICBpZiAoeC5wYXJlbnQgPT0geC5wYXJlbnQucGFyZW50LmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0geC5wYXJlbnQucGFyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkuY29sb3IgPT0gUkVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB5LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID09IHgucGFyZW50LnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0Um90YXRlKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Um90YXRlKHgucGFyZW50LnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHgucGFyZW50LnBhcmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkuY29sb3IgPT0gUkVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB5LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4LnBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID09IHgucGFyZW50LmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0Um90YXRlKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LnBhcmVudC5jb2xvciA9IFJFRDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnRSb3RhdGUoeC5wYXJlbnQucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJvb3QuY29sb3IgPSBCTEFDSztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXJ0IC0gcXVlcnkgaW50ZXJ2YWxcclxuICAgICAqIEBwYXJhbSBlbmQgLSBxdWVyeSBpbnRlcnZhbFxyXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgYWxsIGludGVydmFscyBvdmVybGFwcGluZyB0aGUgcXVlcnkgcmVnaW9uXHJcbiAgICAgKi9cclxuICAgIGZpbmRPdmVybGFwcGluZyhzdGFydCwgZW5kKSB7XHJcblxyXG5cclxuICAgICAgICB2YXIgc2VhcmNoSW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoc3RhcnQsIGVuZCwgMCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IE5JTCkgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICB2YXIgaW50ZXJ2YWxzID0gdGhpcy5zZWFyY2hBbGwoc2VhcmNoSW50ZXJ2YWwsIHRoaXMucm9vdCwgW10pO1xyXG5cclxuICAgICAgICBpZihpbnRlcnZhbHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBpbnRlcnZhbHMuc29ydChmdW5jdGlvbihpMSwgaTIpIHtcclxuICAgICAgICAgICAgICAgICByZXR1cm4gaTEubG93IC0gaTIubG93O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnRlcnZhbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEdW1wIGluZm8gb24gaW50ZXJ2YWxzIHRvIGNvbnNvbGUuICBGb3IgZGVidWdnaW5nLlxyXG4gICAgICovXHJcbiAgICBsb2dJbnRlcnZhbHMoKSB7XHJcblxyXG4gICAgICAgIGxvZ05vZGUodGhpcy5yb290LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9nTm9kZShub2RlLCBpbmRlbnQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzcGFjZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGluZGVudDsgaSsrKSBzcGFjZSArPSBcIiBcIjtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3BhY2UgKyBub2RlLmludGVydmFsLmxvdyArIFwiIFwiICsgbm9kZS5pbnRlcnZhbC5oaWdoKTsgLy8gKyBcIiBcIiArIChub2RlLmludGVydmFsLnZhbHVlID8gbm9kZS5pbnRlcnZhbC52YWx1ZSA6IFwiIG51bGxcIikpO1xyXG5cclxuICAgICAgICAgICAgaW5kZW50ICs9IDU7XHJcblxyXG4gICAgICAgICAgICBpZihub2RlLmxlZnQgIT0gTklMKSBsb2dOb2RlKG5vZGUubGVmdCwgaW5kZW50KTtcclxuICAgICAgICAgICAgaWYobm9kZS5yaWdodCAhPSBOSUwpIGxvZ05vZGUobm9kZS5yaWdodCwgaW5kZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBtYXBJbnRlcnZhbHMoZnVuYykge1xyXG5cclxuICAgICAgICBhcHBseUludGVydmFsKHRoaXMucm9vdCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5SW50ZXJ2YWwobm9kZSkge1xyXG5cclxuICAgICAgICAgICAgZnVuYyhub2RlLmludGVydmFsKTtcclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUubGVmdCAhPSBOSUwpIGFwcGx5SW50ZXJ2YWwobm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgaWYobm9kZS5yaWdodCAhPSBOSUwpIGFwcGx5SW50ZXJ2YWwobm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNlYXJjaEFsbChpbnRlcnZhbCwgbm9kZSwgcmVzdWx0cykge1xyXG5cclxuICAgICAgICBpZiAobm9kZS5pbnRlcnZhbC5vdmVybGFwcyhpbnRlcnZhbCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGUuaW50ZXJ2YWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vZGUubGVmdCAhPSBOSUwgJiYgbm9kZS5sZWZ0Lm1heCA+PSBpbnRlcnZhbC5sb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2hBbGwoaW50ZXJ2YWwsIG5vZGUubGVmdCwgcmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm9kZS5yaWdodCAhPSBOSUwgJiYgbm9kZS5yaWdodC5taW4gPD0gaW50ZXJ2YWwuaGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEFsbChpbnRlcnZhbCwgbm9kZS5yaWdodCwgcmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICBsZWZ0Um90YXRlKHgpIHtcclxuICAgICAgICB2YXIgeSA9IHgucmlnaHQ7XHJcbiAgICAgICAgeC5yaWdodCA9IHkubGVmdDtcclxuICAgICAgICBpZiAoeS5sZWZ0ICE9IE5JTCkge1xyXG4gICAgICAgICAgICB5LmxlZnQucGFyZW50ID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgeS5wYXJlbnQgPSB4LnBhcmVudDtcclxuICAgICAgICBpZiAoeC5wYXJlbnQgPT0gTklMKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHgucGFyZW50LmxlZnQgPT0geCkge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJlbnQubGVmdCA9IHk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5yaWdodCA9IHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeS5sZWZ0ID0geDtcclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcblxyXG4gICAgICAgIHRoaXMuYXBwbHlVcGRhdGUoeCk7XHJcbiAgICAgICAgLy8gbm8gbmVlZCB0byBhcHBseSB1cGRhdGUgb24geSwgc2luY2UgaXQnbGwgeSBpcyBhbiBhbmNlc3RvclxyXG4gICAgICAgIC8vIG9mIHgsIGFuZCB3aWxsIGJlIHRvdWNoZWQgYnkgYXBwbHlVcGRhdGUoKS5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcmlnaHRSb3RhdGUoeCkge1xyXG4gICAgICAgIHZhciB5ID0geC5sZWZ0O1xyXG4gICAgICAgIHgubGVmdCA9IHkucmlnaHQ7XHJcbiAgICAgICAgaWYgKHkucmlnaHQgIT0gTklMKSB7XHJcbiAgICAgICAgICAgIHkucmlnaHQucGFyZW50ID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgeS5wYXJlbnQgPSB4LnBhcmVudDtcclxuICAgICAgICBpZiAoeC5wYXJlbnQgPT0gTklMKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHgucGFyZW50LnJpZ2h0ID09IHgpIHtcclxuICAgICAgICAgICAgICAgIHgucGFyZW50LnJpZ2h0ID0geTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHgucGFyZW50LmxlZnQgPSB5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkucmlnaHQgPSB4O1xyXG4gICAgICAgIHgucGFyZW50ID0geTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuYXBwbHlVcGRhdGUoeCk7XHJcbiAgICAgICAgLy8gbm8gbmVlZCB0byBhcHBseSB1cGRhdGUgb24geSwgc2luY2UgaXQnbGwgeSBpcyBhbiBhbmNlc3RvclxyXG4gICAgICAgIC8vIG9mIHgsIGFuZCB3aWxsIGJlIHRvdWNoZWQgYnkgYXBwbHlVcGRhdGUoKS5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RlOiAgRG9lcyBub3QgbWFpbnRhaW4gUkIgY29uc3RyYWludHMsICB0aGlzIGlzIGRvbmUgcG9zdCBpbnNlcnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCAgYSBOb2RlXHJcbiAgICAgKi9cclxuICAgdHJlZUluc2VydCh4KSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgdmFyIHkgPSBOSUw7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUgIT0gTklMKSB7XHJcbiAgICAgICAgICAgIHkgPSBub2RlO1xyXG4gICAgICAgICAgICBpZiAoeC5pbnRlcnZhbC5sb3cgPD0gbm9kZS5pbnRlcnZhbC5sb3cpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB4LnBhcmVudCA9IHk7XHJcblxyXG4gICAgICAgIGlmICh5ID09IE5JTCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB4O1xyXG4gICAgICAgICAgICB4LmxlZnQgPSB4LnJpZ2h0ID0gTklMO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh4LmludGVydmFsLmxvdyA8PSB5LmludGVydmFsLmxvdykge1xyXG4gICAgICAgICAgICAgICAgeS5sZWZ0ID0geDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHkucmlnaHQgPSB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFwcGx5VXBkYXRlKHgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBBcHBsaWVzIHRoZSBzdGF0aXN0aWMgdXBkYXRlIG9uIHRoZSBub2RlIGFuZCBpdHMgYW5jZXN0b3JzLlxyXG4gICAgYXBwbHlVcGRhdGUgKG5vZGUpIHtcclxuICAgICAgICB3aGlsZSAobm9kZSAhPSBOSUwpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGVNYXggPSBub2RlLmxlZnQubWF4ID4gbm9kZS5yaWdodC5tYXggPyBub2RlLmxlZnQubWF4IDogbm9kZS5yaWdodC5tYXg7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbEhpZ2ggPSBub2RlLmludGVydmFsLmhpZ2g7XHJcbiAgICAgICAgICAgIG5vZGUubWF4ID0gbm9kZU1heCA+IGludGVydmFsSGlnaCA/IG5vZGVNYXggOiBpbnRlcnZhbEhpZ2g7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9kZU1pbiA9IG5vZGUubGVmdC5taW4gPCBub2RlLnJpZ2h0Lm1pbiA/IG5vZGUubGVmdC5taW4gOiBub2RlLnJpZ2h0Lm1pbjtcclxuICAgICAgICAgICAgdmFyIGludGVydmFsTG93ID0gbm9kZS5pbnRlcnZhbC5sb3c7XHJcbiAgICAgICAgICAgIG5vZGUubWluID0gbm9kZU1pbiA8IGludGVydmFsTG93ID8gbm9kZU1pbiA6IGludGVydmFsTG93O1xyXG5cclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5jbGFzcyBJbnRlcnZhbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihsb3csIGhpZ2gsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5sb3cgPSBsb3c7XHJcbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaDtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIGlmICghb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcyA9PSBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyA9PSBvdGhlckludGVydmFsLmxvdyAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT0gb3RoZXJJbnRlcnZhbC5oaWdoKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmxvdyA8IG90aGVyLmxvdylcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGlmICh0aGlzLmxvdyA+IG90aGVyLmxvdylcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhpZ2ggPCBvdGhlci5oaWdoKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKHRoaXMuaGlnaCA+IG90aGVyLmhpZ2gpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGludGVydmFsIG92ZXJsYXBzIHRoZSBvdGhlci5cclxuICAgICAqL1xyXG4gICAgb3ZlcmxhcHMob3RoZXIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMubG93IDw9IG90aGVyLmhpZ2ggJiYgb3RoZXIubG93IDw9IHRoaXMuaGlnaCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvL2FsZXJ0KGUpO1xyXG4gICAgICAgICAgICBpZ3YucHJlc2VudEFsZXJ0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgTm9kZXtcclxuICAgIGNvbnN0cnVjdG9yKGludGVydmFsKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBOSUw7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gTklMO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBOSUw7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBSRUQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEdlbm9taWNJbnRlcnZhbHtcclxuXHJcblx0Y29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kLCBmZWF0dXJlcykge1xyXG4gICAgICAgIHRoaXMuY2hyID0gY2hyO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnMgKGNociwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNociA9PSBjaHIgJiZcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA8PSBzdGFydCAmJlxyXG4gICAgICAgICAgICB0aGlzLmVuZCA+PSBlbmQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29udGFpbnNSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNociA9PT0gcmFuZ2UuY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gcmFuZ2Uuc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gcmFuZ2UuZW5kO1xyXG4gICAgfVxyXG4gICAgcmFuZ2VzVG9HZXQocmFuZ2Upe1xyXG4gICAgICAgIGxldCBuZWVkc19yYW5nZT1mYWxzZTtcclxuICAgICAgICBsZXQgcmFuZ2VzPXt9O1xyXG4gICAgICAgIGlmICh0aGlzLmNociAhPT0gcmFuZ2UuY2hyKXtcclxuICAgICAgICAgICAgcmFuZ2VzLmFsbD1bcmFuZ2Uuc3RhcnQscmFuZ2UuZW5kXTtcclxuICAgICAgICAgICAgbmVlZHNfcmFuZ2U9dHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydD1yYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgdGhpcy5lbmQ9cmFuZ2UuZW5kO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZXsgICBcclxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0PHRoaXMuc3RhcnQpe1xyXG4gICAgICAgICAgICAgICAgcmFuZ2VzLmxlZnQ9W3JhbmdlLnN0YXJ0LHRoaXMuc3RhcnRdO1xyXG4gICAgICAgICAgICAgICAgbmVlZHNfcmFuZ2U9dHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQ9cmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJhbmdlLmVuZD50aGlzLmVuZCl7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMucmlnaHQ9W3RoaXMuZW5kLHJhbmdlLmVuZF07XHJcbiAgICAgICAgICAgICAgICBuZWVkc19yYW5nZT10cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbmQ9cmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmVlZHNfcmFuZ2Upe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgRmFzdGFTZXF1ZW5jZXtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih1cmwpIHtcclxuXHJcbiAgICAgICAgdGhpcy5maWxlID0gdXJsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4RmlsZSA9IHRoaXMuZmlsZSArIFwiLmZhaVwiO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG5cclxuICAgIH1cclxuXHJcbiAgIGluaXQoKXtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoc2VsZi5pbmRleGVkKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0SW5kZXgoKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmRlciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGNock5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJwTGVuZ3RoID0gc2VsZi5pbmRleFtjaHJOYW1lXS5zaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVzW2Nock5hbWVdID0gbmV3IGlndi5DaHJvbW9zb21lKGNock5hbWUsIG9yZGVyKyssIGJwTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpbmRleCwgZ2V0dGluZyBjaHIgbmFtZXMgYXMgYSBzaWRlIGVmZmVjdC4gIFJlYWxseSBiYWQgcHJhY3RpY2VcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmxvYWRBbGwoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldFNlcXVlbmNlKGNociwgc3RhcnQsIGVuZCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5pbmRleGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlcXVlbmNlSW5kZXhlZChjaHIsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFNlcXVlbmNlTm9uSW5kZXhlZC50aGlzKGNociwgc3RhcnQsIGVuZCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2VxdWVuY2VJbmRleGVkKGNociwgc3RhcnQsIGVuZCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNlbGYuaW50ZXJ2YWw7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgaW50ZXJ2YWwuY29udGFpbnMoY2hyLCBzdGFydCwgZW5kKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoZ2V0U2VxdWVuY2VGcm9tSW50ZXJ2YWwoaW50ZXJ2YWwsIHN0YXJ0LCBlbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2FjaGUgbWlzczogXCIgKyAoaW50ZXJ2YWwgPT09IHVuZGVmaW5lZCA/IFwibmlsXCIgOiBpbnRlcnZhbC5jaHIgKyBcIjpcIiArIGludGVydmFsLnN0YXJ0ICsgXCItXCIgKyBpbnRlcnZhbC5lbmQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgcXVlcnksIHRvIG1pbmltdW0gb2YgMTAwa2JcclxuICAgICAgICAgICAgICAgIHZhciBxc3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBxZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgaWYgKChlbmQgLSBzdGFydCkgPCAxMDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IChlbmQgLSBzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IE1hdGgucm91bmQoc3RhcnQgKyB3IC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgcXN0YXJ0ID0gTWF0aC5tYXgoMCwgY2VudGVyIC0gNTAwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHFlbmQgPSBjZW50ZXIgKyA1MDAwMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5yZWFkU2VxdWVuY2UoY2hyLCBxc3RhcnQsIHFlbmQpLnRoZW4oZnVuY3Rpb24gKHNlcUJ5dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnRlcnZhbCA9IG5ldyBHZW5vbWljSW50ZXJ2YWwoY2hyLCBxc3RhcnQsIHFlbmQsIHNlcUJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGdldFNlcXVlbmNlRnJvbUludGVydmFsKHNlbGYuaW50ZXJ2YWwsIHN0YXJ0LCBlbmQpKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlcXVlbmNlRnJvbUludGVydmFsKGludGVydmFsLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgLSBpbnRlcnZhbC5zdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxID0gaW50ZXJ2YWwuZmVhdHVyZXMgPyBpbnRlcnZhbC5mZWF0dXJlcy5zdWJzdHIob2Zmc2V0LCBuKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldFNlcXVlbmNlTm9uSW5kZXhlZChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgc2VxID0gc2VsZi5zZXF1ZW5jZXNbY2hyXTtcclxuICAgICAgICAgICAgaWYgKHNlcSAmJiBzZXEubGVuZ3RoID4gZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlcS5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldEluZGV4KCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHNlbGYuaW5kZXhGaWxlLHt9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gZGF0YS5zcGxpdChcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTm8gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcyA9IFtdOyAgICAgLy8gVE9ETyAtLSBlbGltaW5hdGUgdGhpcyBzaWRlIGVmZmVjdCAhISEhXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleCA9IHt9OyAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gZGl0dG9cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGluZU5vIDwgbGVuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZXNbbGluZU5vKytdLnNwbGl0KFwiXFx0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgblRva2VucyA9IHRva2Vucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuVG9rZW5zID09IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbmRleCBsaW5lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQodG9rZW5zWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHBhcnNlSW50KHRva2Vuc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZXNQZXJMaW5lID0gcGFyc2VJbnQodG9rZW5zWzNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlc1BlckxpbmUgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleEVudHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHNpemUsIHBvc2l0aW9uOiBwb3NpdGlvbiwgYmFzZXNQZXJMaW5lOiBiYXNlc1BlckxpbmUsIGJ5dGVzUGVyTGluZTogYnl0ZXNQZXJMaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzLnB1c2goY2hyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhbY2hyXSA9IGluZGV4RW50cnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmdWxmaWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRBbGwoKXtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVzID0ge307XHJcbiAgICAgICAgICAgIHNlbGYuc2VxdWVuY2VzID0ge307XHJcblxyXG4gICAgICAgICAgICBpZ3Z4aHIubG9hZChzZWxmLmZpbGUsIHtcclxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi53aXRoQ3JlZGVudGlhbHNcclxuXHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0TGluZXMoKSxcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZU5vID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VxID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gMDtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGxpbmVObyA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbGluZXNbbGluZU5vKytdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExpbmUuc3RhcnRzV2l0aChcIiNcIikgfHwgbmV4dExpbmUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0TGluZS5zdGFydHNXaXRoKFwiPlwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlcSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMucHVzaChjdXJyZW50Q2hyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VxdWVuY2VzW2N1cnJlbnRDaHJdID0gY3VycmVudFNlcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXNbY3VycmVudENocl0gPSBuZXcgaWd2LkNocm9tb3NvbWUoY3VycmVudENociwgb3JkZXIrKywgY3VycmVudFNlcS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHIgPSBuZXh0TGluZS5zdWJzdHIoMSkuc3BsaXQoXCJcXFxccytcIilbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXEgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlcSArPSBuZXh0TGluZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZFNlcXVlbmNlKGNociwgcXN0YXJ0LCBxZW5kKSB7XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJSZWFkIHNlcXVlbmNlIFwiICsgY2hyICsgXCI6XCIgKyBxc3RhcnQgKyBcIi1cIiArIHFlbmQpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgc2VsZi5nZXRJbmRleCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpZHhFbnRyeSA9IHNlbGYuaW5kZXhbY2hyXTtcclxuICAgICAgICAgICAgICAgIGlmICghaWR4RW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGluZGV4IGVudHJ5IGZvciBjaHI6IFwiICsgY2hyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGFnIGludGVydmFsIHdpdGggbnVsbCBzbyB3ZSBkb24ndCB0cnkgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmludGVydmFsID0gbmV3IEdlbm9taWNJbnRlcnZhbChjaHIsIHFzdGFydCwgcWVuZCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgwLCBxc3RhcnQpOyAgICAvLyBxc3RhcnQgc2hvdWxkIG5ldmVyIGJlIDwgMFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBNYXRoLm1pbihpZHhFbnRyeS5zaXplLCBxZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZXNQZXJMaW5lID0gaWR4RW50cnkuYnl0ZXNQZXJMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlc1BlckxpbmUgPSBpZHhFbnRyeS5iYXNlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gaWR4RW50cnkucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5FbmRCeXRlcyA9IGJ5dGVzUGVyTGluZSAtIGJhc2VzUGVyTGluZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBiYXNlc1BlckxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lID0gTWF0aC5mbG9vcihlbmQgLyBiYXNlc1BlckxpbmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZTAgPSBzdGFydExpbmUgKiBiYXNlc1BlckxpbmU7ICAgLy8gQmFzZSBhdCBiZWdpbm5pbmcgb2Ygc3RhcnQgbGluZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgLSBiYXNlMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Qnl0ZSA9IHBvc2l0aW9uICsgc3RhcnRMaW5lICogYnl0ZXNQZXJMaW5lICsgb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZTEgPSBlbmRMaW5lICogYmFzZXNQZXJMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQxID0gZW5kIC0gYmFzZTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEJ5dGUgPSBwb3NpdGlvbiArIGVuZExpbmUgKiBieXRlc1BlckxpbmUgKyBvZmZzZXQxIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZUNvdW50ID0gZW5kQnl0ZSAtIHN0YXJ0Qnl0ZSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVDb3VudCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZChzZWxmLmZpbGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc3RhcnRCeXRlLCBzaXplOiBieXRlQ291bnR9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYWxsQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuQmFzZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXFCeXRlcyA9IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQb3MgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzUG9zID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEJ5dGVzTGVuZ3RoID0gYWxsQnl0ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5CYXNlcyA9IE1hdGgubWluKGVuZCAtIHN0YXJ0LCBiYXNlc1BlckxpbmUgLSBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VxQnl0ZXMgKz0gYWxsQnl0ZXMuc3Vic3RyKHNyY1BvcywgbkJhc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BvcyArPSAobkJhc2VzICsgbkVuZEJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc1BvcyArPSBuQmFzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmNQb3MgPCBhbGxCeXRlc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbkJhc2VzID0gTWF0aC5taW4oYmFzZXNQZXJMaW5lLCBhbGxCeXRlc0xlbmd0aCAtIHNyY1Bvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXFCeXRlcyArPSBhbGxCeXRlcy5zdWJzdHIoc3JjUG9zLCBuQmFzZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUG9zICs9IChuQmFzZXMgKyBuRW5kQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzUG9zICs9IG5CYXNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZXFCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQge0ZlYXR1cmVTb3VyY2UsRmFzdGFTZXF1ZW5jZSxCaWdCZWRGZWF0dXJlU291cmNlfSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/feature.js\n");

/***/ }),

/***/ "./src/igvxhr.js":
/*!***********************!*\
  !*** ./src/igvxhr.js ***!
  \***********************/
/*! exports provided: igvxhr, unbgzf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Zlib, XMLHttpRequest) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"igvxhr\", function() { return igvxhr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unbgzf\", function() { return unbgzf; });\n/* harmony import */ var _vendor_inflate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/inflate.js */ \"./src/vendor/inflate.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\nlet is_node=false;\r\ntry{\r\n    navigator;\r\n}catch(e){\r\n    is_node=true;\r\n}\r\n\r\nif (!Zlib.Zlib){\r\n\tZlib.Zlib=Zlib;\r\n}\r\n\r\nconst NONE = 0;\r\nconst GZIP = 1;\r\nconst BGZF = 2;\r\nclass igvxhr {\r\n   \r\n    // Compression types\r\n   \r\n\r\n    static load(url, options) {\r\n\r\n       \r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var xhr = new XMLHttpRequest(),\r\n                sendData = options.sendData,\r\n                method = options.method || (sendData ? \"POST\" : \"GET\"),\r\n                range = options.range,\r\n                responseType = options.responseType,\r\n                contentType = options.contentType,\r\n                mimeType = options.mimeType,\r\n                headers = options.headers,\r\n                isSafari = is_node?false:navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent),\r\n                withCredentials = options.withCredentials,\r\n                header_keys, key, value, i;\r\n\r\n            // Support for GCS paths.\r\n           //url = url.startsWith(\"gs://\") ? igv.Google.translateGoogleCloudURL(url) : url;\r\n        \r\n\r\n           /* if (igv.Google.isGoogleURL(url)) {\r\n\r\n                url = igv.Google.addApiKey(url);\r\n\r\n                // Add google headers (e.g. oAuth)\r\n                headers = headers || {};\r\n                igv.Google.addGoogleHeaders(headers);\r\n\r\n                // Hack to prevent caching for google storage files.  Get weird net:err-cache errors otherwise\r\n                if (range) {\r\n                    url += url.includes(\"?\") ? \"&\" : \"?\";\r\n                    url += \"someRandomSeed=\" + Math.random().toString(36);\r\n                }\r\n            }\r\n            */\r\n    \r\n\r\n            xhr.open(method, url);\r\n\r\n            if (range) {\r\n                var rangeEnd = range.size ? range.start + range.size - 1 : \"\";\r\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + range.start + \"-\" + rangeEnd);\r\n            }\r\n            if (contentType) {\r\n                xhr.setRequestHeader(\"Content-Type\", contentType);\r\n            }\r\n            if (mimeType) {\r\n                xhr.overrideMimeType(mimeType);\r\n            }\r\n            if (responseType) {\r\n                xhr.responseType = responseType;\r\n            }\r\n            if (headers) {\r\n                header_keys = Object.keys(headers);\r\n                for (i = 0; i < header_keys.length; i++) {\r\n                    key = header_keys[i];\r\n                    value = headers[key];\r\n                    // console.log(\"Adding to header: \" + key + \"=\" + value);\r\n                    xhr.setRequestHeader(key, value);\r\n                }\r\n            }\r\n\r\n            // NOTE: using withCredentials with servers that return \"*\" for access-allowed-origin will fail\r\n            if (withCredentials === true) {\r\n                xhr.withCredentials = true;\r\n            }\r\n            xhr.timeout=30000;\r\n\r\n            xhr.onload = function (event) {\r\n                // when the url points to a local file, the status is 0 but that is no error\r\n                if (xhr.status == 0 || (xhr.status >= 200 && xhr.status <= 300)) {\r\n\r\n                    if (range && xhr.status != 206) {\r\n                        handleError(\"ERROR: range-byte header was ignored for url: \" + url);\r\n                    }\r\n                    else {\r\n                      \r\n                        fulfill(xhr.response,xhr);\r\n                     \r\n                    }\r\n                }\r\n                else {\r\n\r\n                    //\r\n                    if (xhr.status === 416) {\r\n                        //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an\r\n                        handleError(\"Unsatisfiable range\");\r\n                    }\r\n                    else {// TODO -- better error handling\r\n                        handleError(\"Error accessing resource: \" + xhr.status);\r\n                    }\r\n\r\n                }\r\n\r\n            };\r\n\r\n            xhr.onerror = function (event) {\r\n               \r\n                if (false) {}\r\n                else {\r\n                    handleError(\"Error accessing resource: \" + url + \" Status: \" + xhr.status);\r\n                }\r\n            }\r\n\r\n\r\n            xhr.ontimeout = function (event) {\r\n                handleError(\"Timed out\");\r\n            };\r\n\r\n            xhr.onabort = function (event) {\r\n                console.log(\"Aborted\");\r\n                reject(new igv.AbortLoad());\r\n            };\r\n\r\n            try {\r\n               \r\n                xhr.send(sendData);\r\n                \r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n\r\n\r\n            function handleError(message) {\r\n                if (reject) {\r\n                    reject(message);\r\n                }\r\n                else {\r\n                    throw Error(message);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    static loadArrayBuffer (url, options) {\r\n\r\n        if (options === undefined) options = {};\r\n        options.responseType = \"arraybuffer\";\r\n        return igvxhr.load(url, options);\r\n    };\r\n\r\n    static loadJson (url, options) {\r\n\r\n        var method = options.method || (options.sendData ? \"POST\" : \"GET\");\r\n\r\n        if (method == \"POST\") options.contentType = \"application/json\";\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            igvxhr.load(url, options).then(\r\n                function (result) {\r\n                    if (result) {\r\n                        fulfill(JSON.parse(result));\r\n                    }\r\n                    else {\r\n                        fulfill(result);\r\n                    }\r\n                }).catch(reject);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Load a \"raw\" string.\r\n     */\r\n    static loadString(url, options) {\r\n\r\n        var compression, fn, idx;\r\n\r\n        if (options === undefined) options = {};\r\n\r\n        // Strip parameters from url\r\n        // TODO -- handle local files with ?\r\n        idx = url.indexOf(\"?\");\r\n        fn = idx > 0 ? url.substring(0, idx) : url;\r\n\r\n        if (options.bgz) {\r\n            compression = BGZF;\r\n        }\r\n        else if (fn.endsWith(\".gz\")) {\r\n            compression = GZIP;\r\n        }\r\n        else {\r\n            compression = NONE;\r\n        }\r\n\r\n        if (compression === NONE) {\r\n            options.mimeType = 'text/plain; charset=x-user-defined';\r\n            return igvxhr.load(url, options);\r\n        }\r\n        else {\r\n            options.responseType = \"arraybuffer\";\r\n\r\n            return new Promise(function (fulfill, reject) {\r\n\r\n                igvxhr.load(url, options).then(\r\n                    function (data) {\r\n                        var result = igvxhr.arrayBufferToString(data, compression);\r\n                        fulfill(result);\r\n                    }).catch(reject)\r\n            })\r\n        }\r\n\r\n    };\r\n\r\n    static loadStringFromFile(localfile, options) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var fileReader = new FileReader(),\r\n                range = options.range;\r\n\r\n\r\n            fileReader.onload = function (e) {\r\n\r\n                var compression, result;\r\n\r\n                if (options.bgz) {\r\n                    compression = BGZF;\r\n                }\r\n                else if (localfile.name.endsWith(\".gz\")) {\r\n\r\n                    compression = GZIP;\r\n                }\r\n                else {\r\n                    compression = NONE;\r\n                }\r\n\r\n                result = igvxhr.arrayBufferToString(fileReader.result, compression);\r\n\r\n                fulfill(result, localfile);\r\n\r\n            };\r\n\r\n            fileReader.onerror = function (e) {\r\n                console.log(\"reject uploading local file \" + localfile.name);\r\n                reject(null, fileReader);\r\n            };\r\n\r\n            fileReader.readAsArrayBuffer(localfile);\r\n\r\n        });\r\n    }\r\n\r\n    static isCrossDomain(url) {\r\n\r\n        var origin = window.location.origin;\r\n\r\n        return !url.startsWith(origin);\r\n\r\n    }\r\n\r\n    static arrayBufferToString (arraybuffer, compression) {\r\n\r\n        var plain, inflate;\r\n\r\n        if (compression === GZIP) {\r\n            inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arraybuffer));\r\n            plain = inflate.decompress();\r\n        }\r\n        else if (compression === BGZF) {\r\n            plain = new Uint8Array(unbgzf(arraybuffer));\r\n        }\r\n        else {\r\n            plain = new Uint8Array(arraybuffer);\r\n        }\r\n\r\n        var result = \"\";\r\n        for (var i = 0, len = plain.length; i < len; i++) {\r\n            result = result + String.fromCharCode(plain[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\n\r\n//**********js/bam/bgzf.js***************************************\r\n\r\n\r\nconst BLOCK_HEADER_LENGTH = 18;\r\nconst BLOCK_LENGTH_OFFSET = 16;  // Location in the gzip block of the total block size (actually total block size - 1)\r\nconst BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\r\nconst MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\r\nconst GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\r\nconst GZIP_ID1 = 31;   // Magic number\r\nconst GZIP_ID2 = 139;  // Magic number\r\nconst GZIP_FLG = 4; // FEXTRA flag means there are optional fields\r\n\r\n\r\n    // Uncompress data,  assumed to be series of bgzipped blocks\r\n    // Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\r\nlet unbgzf = function (data, lim) {\r\n\r\n        var oBlockList = [],\r\n            ptr = [0],\r\n            totalSize = 0;\r\n\r\n        lim = lim || data.byteLength - 18;\r\n\r\n        while (ptr[0] < lim) {\r\n\r\n            var ba = new Uint8Array(data, ptr[0], 18);\r\n\r\n            var xlen = (ba[11] << 8) | (ba[10]);\r\n            var si1 = ba[12];\r\n            var si2 = ba[13];\r\n            var slen = (ba[15] << 8) | (ba[14]);\r\n            var bsize = (ba[17] << 8) | (ba[16]) + 1;\r\n\r\n            var start = 12 + xlen + ptr[0];    // Start of CDATA\r\n            var length = data.byteLength - start;\r\n\r\n            if (length < (bsize + 8)) break;\r\n\r\n            var unc = Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_0__[\"jszlib_inflate_buffer\"])(data, start, length, ptr);\r\n\r\n            ptr[0] += 8;    // Skipping CRC-32 and size of uncompressed data\r\n\r\n            totalSize += unc.byteLength;\r\n            oBlockList.push(unc);\r\n        }\r\n\r\n        // Concatenate decompressed blocks\r\n        if (oBlockList.length == 1) {\r\n            return oBlockList[0];\r\n        } else {\r\n            var out = new Uint8Array(totalSize);\r\n            var cursor = 0;\r\n            for (var i = 0; i < oBlockList.length; ++i) {\r\n                var b = new Uint8Array(oBlockList[i]);\r\n                Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCopy\"])(b, 0, out, cursor, b.length);\r\n                cursor += b.length;\r\n            }\r\n            return out.buffer;\r\n        }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\"), __webpack_require__(/*! xhr2 */ \"xhr2\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaWd2eGhyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2lndnhoci5qcz8wZjQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuaW1wb3J0IHtqc3psaWJfaW5mbGF0ZV9idWZmZXIsYXJyYXlDb3B5fSBmcm9tIFwiLi92ZW5kb3IvaW5mbGF0ZS5qc1wiO1xyXG5cclxuXHJcbmxldCBpc19ub2RlPWZhbHNlO1xyXG50cnl7XHJcbiAgICBuYXZpZ2F0b3I7XHJcbn1jYXRjaChlKXtcclxuICAgIGlzX25vZGU9dHJ1ZTtcclxufVxyXG5cclxuaWYgKCFabGliLlpsaWIpe1xyXG5cdFpsaWIuWmxpYj1abGliO1xyXG59XHJcblxyXG5jb25zdCBOT05FID0gMDtcclxuY29uc3QgR1pJUCA9IDE7XHJcbmNvbnN0IEJHWkYgPSAyO1xyXG5jbGFzcyBpZ3Z4aHIge1xyXG4gICBcclxuICAgIC8vIENvbXByZXNzaW9uIHR5cGVzXHJcbiAgIFxyXG5cclxuICAgIHN0YXRpYyBsb2FkKHVybCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgIFxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXHJcbiAgICAgICAgICAgICAgICBzZW5kRGF0YSA9IG9wdGlvbnMuc2VuZERhdGEsXHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAoc2VuZERhdGEgPyBcIlBPU1RcIiA6IFwiR0VUXCIpLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBvcHRpb25zLnJhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IG9wdGlvbnMubWltZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgaXNTYWZhcmkgPSBpc19ub2RlP2ZhbHNlOm5hdmlnYXRvci52ZW5kb3IuaW5kZXhPZihcIkFwcGxlXCIpID09IDAgJiYgL1xcc1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcclxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyX2tleXMsIGtleSwgdmFsdWUsIGk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IGZvciBHQ1MgcGF0aHMuXHJcbiAgICAgICAgICAgLy91cmwgPSB1cmwuc3RhcnRzV2l0aChcImdzOi8vXCIpID8gaWd2Lkdvb2dsZS50cmFuc2xhdGVHb29nbGVDbG91ZFVSTCh1cmwpIDogdXJsO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAgICAvKiBpZiAoaWd2Lkdvb2dsZS5pc0dvb2dsZVVSTCh1cmwpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXJsID0gaWd2Lkdvb2dsZS5hZGRBcGlLZXkodXJsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgZ29vZ2xlIGhlYWRlcnMgKGUuZy4gb0F1dGgpXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGlndi5Hb29nbGUuYWRkR29vZ2xlSGVhZGVycyhoZWFkZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHByZXZlbnQgY2FjaGluZyBmb3IgZ29vZ2xlIHN0b3JhZ2UgZmlsZXMuICBHZXQgd2VpcmQgbmV0OmVyci1jYWNoZSBlcnJvcnMgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gdXJsLmluY2x1ZGVzKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwic29tZVJhbmRvbVNlZWQ9XCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgXHJcblxyXG4gICAgICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZUVuZCA9IHJhbmdlLnNpemUgPyByYW5nZS5zdGFydCArIHJhbmdlLnNpemUgLSAxIDogXCJcIjtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgXCJieXRlcz1cIiArIHJhbmdlLnN0YXJ0ICsgXCItXCIgKyByYW5nZUVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbWVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyX2tleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkZXJfa2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGhlYWRlcl9rZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaGVhZGVyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQWRkaW5nIHRvIGhlYWRlcjogXCIgKyBrZXkgKyBcIj1cIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTk9URTogdXNpbmcgd2l0aENyZWRlbnRpYWxzIHdpdGggc2VydmVycyB0aGF0IHJldHVybiBcIipcIiBmb3IgYWNjZXNzLWFsbG93ZWQtb3JpZ2luIHdpbGwgZmFpbFxyXG4gICAgICAgICAgICBpZiAod2l0aENyZWRlbnRpYWxzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4aHIudGltZW91dD0zMDAwMDtcclxuXHJcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVybCBwb2ludHMgdG8gYSBsb2NhbCBmaWxlLCB0aGUgc3RhdHVzIGlzIDAgYnV0IHRoYXQgaXMgbm8gZXJyb3JcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDAgfHwgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMzAwKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgeGhyLnN0YXR1cyAhPSAyMDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFUlJPUjogcmFuZ2UtYnl0ZSBoZWFkZXIgd2FzIGlnbm9yZWQgZm9yIHVybDogXCIgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHhoci5yZXNwb25zZSx4aHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gNDE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUcmllZCB0byByZWFkIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlLiAgIFRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMgcmV0dXJuIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiVW5zYXRpc2ZpYWJsZSByYW5nZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7Ly8gVE9ETyAtLSBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFcnJvciBhY2Nlc3NpbmcgcmVzb3VyY2U6IFwiICsgeGhyLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbF9yZXRyaWVzPjEwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0b3RhbF9yZXRyaWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgb3B0aW9ucy5yZXRyaWVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXRyaWVzPTBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXRyaWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9vcHRpb25zLnNlbmREYXRhID0gXCJ1cmw9XCIgKyB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9vcHRpb25zLmNyb3NzRG9tYWluUmV0cmllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLyppZiAob3B0aW9ucy5yZXRyaWVzPDMpe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcih1cmwsIG9wdGlvbnMpLnRoZW4oZnVsZmlsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFcnJvciBhY2Nlc3NpbmcgcmVzb3VyY2U6IFwiICsgdXJsICsgXCIgU3RhdHVzOiBcIiArIHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFcnJvciBhY2Nlc3NpbmcgcmVzb3VyY2U6IFwiICsgdXJsICsgXCIgU3RhdHVzOiBcIiArIHhoci5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJUaW1lZCBvdXRcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBYm9ydGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBpZ3YuQWJvcnRMb2FkKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChzZW5kRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxvYWRBcnJheUJ1ZmZlciAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICByZXR1cm4gaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvYWRKc29uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IChvcHRpb25zLnNlbmREYXRhID8gXCJQT1NUXCIgOiBcIkdFVFwiKTtcclxuXHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBcIlBPU1RcIikgb3B0aW9ucy5jb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChKU09OLnBhcnNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBcInJhd1wiIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxvYWRTdHJpbmcodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBjb21wcmVzc2lvbiwgZm4sIGlkeDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBTdHJpcCBwYXJhbWV0ZXJzIGZyb20gdXJsXHJcbiAgICAgICAgLy8gVE9ETyAtLSBoYW5kbGUgbG9jYWwgZmlsZXMgd2l0aCA/XHJcbiAgICAgICAgaWR4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xyXG4gICAgICAgIGZuID0gaWR4ID4gMCA/IHVybC5zdWJzdHJpbmcoMCwgaWR4KSA6IHVybDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmd6KSB7XHJcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm4uZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBHWklQO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBOT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBOT05FKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIHJldHVybiBpZ3Z4aHIubG9hZCh1cmwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHVybCwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaWd2eGhyLmFycmF5QnVmZmVyVG9TdHJpbmcoZGF0YSwgY29tcHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBsb2FkU3RyaW5nRnJvbUZpbGUobG9jYWxmaWxlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCksXHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XHJcblxyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiwgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJneikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsZmlsZS5uYW1lLmVuZHNXaXRoKFwiLmd6XCIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gR1pJUDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gTk9ORTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpZ3Z4aHIuYXJyYXlCdWZmZXJUb1N0cmluZyhmaWxlUmVhZGVyLnJlc3VsdCwgY29tcHJlc3Npb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0LCBsb2NhbGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlamVjdCB1cGxvYWRpbmcgbG9jYWwgZmlsZSBcIiArIGxvY2FsZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChudWxsLCBmaWxlUmVhZGVyKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobG9jYWxmaWxlKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzQ3Jvc3NEb21haW4odXJsKSB7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG5cclxuICAgICAgICByZXR1cm4gIXVybC5zdGFydHNXaXRoKG9yaWdpbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBhcnJheUJ1ZmZlclRvU3RyaW5nIChhcnJheWJ1ZmZlciwgY29tcHJlc3Npb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYWluLCBpbmZsYXRlO1xyXG5cclxuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IEdaSVApIHtcclxuICAgICAgICAgICAgaW5mbGF0ZSA9IG5ldyBabGliLlpsaWIuR3VuemlwKG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSk7XHJcbiAgICAgICAgICAgIHBsYWluID0gaW5mbGF0ZS5kZWNvbXByZXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXByZXNzaW9uID09PSBCR1pGKSB7XHJcbiAgICAgICAgICAgIHBsYWluID0gbmV3IFVpbnQ4QXJyYXkodW5iZ3pmKGFycmF5YnVmZmVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwbGFpbiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwbGFpbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBsYWluW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKioqKipqcy9iYW0vYmd6Zi5qcyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJMT0NLX0hFQURFUl9MRU5HVEggPSAxODtcclxuY29uc3QgQkxPQ0tfTEVOR1RIX09GRlNFVCA9IDE2OyAgLy8gTG9jYXRpb24gaW4gdGhlIGd6aXAgYmxvY2sgb2YgdGhlIHRvdGFsIGJsb2NrIHNpemUgKGFjdHVhbGx5IHRvdGFsIGJsb2NrIHNpemUgLSAxKVxyXG5jb25zdCBCTE9DS19GT09URVJfTEVOR1RIID0gODsgLy8gTnVtYmVyIG9mIGJ5dGVzIHRoYXQgZm9sbG93IHRoZSBkZWZsYXRlZCBkYXRhXHJcbmNvbnN0IE1BWF9DT01QUkVTU0VEX0JMT0NLX1NJWkUgPSA2NCAqIDEwMjQ7IC8vIFdlIHJlcXVpcmUgdGhhdCBhIGNvbXByZXNzZWQgYmxvY2sgKGluY2x1ZGluZyBoZWFkZXIgYW5kIGZvb3RlciwgYmUgPD0gdGhpcylcclxuY29uc3QgR1pJUF9PVkVSSEVBRCA9IEJMT0NLX0hFQURFUl9MRU5HVEggKyBCTE9DS19GT09URVJfTEVOR1RIICsgMjsgLy8gR3ppcCBvdmVyaGVhZCBpcyB0aGUgaGVhZGVyLCB0aGUgZm9vdGVyLCBhbmQgdGhlIGJsb2NrIHNpemUgKGVuY29kZWQgYXMgYSBzaG9ydCkuXHJcbmNvbnN0IEdaSVBfSUQxID0gMzE7ICAgLy8gTWFnaWMgbnVtYmVyXHJcbmNvbnN0IEdaSVBfSUQyID0gMTM5OyAgLy8gTWFnaWMgbnVtYmVyXHJcbmNvbnN0IEdaSVBfRkxHID0gNDsgLy8gRkVYVFJBIGZsYWcgbWVhbnMgdGhlcmUgYXJlIG9wdGlvbmFsIGZpZWxkc1xyXG5cclxuXHJcbiAgICAvLyBVbmNvbXByZXNzIGRhdGEsICBhc3N1bWVkIHRvIGJlIHNlcmllcyBvZiBiZ3ppcHBlZCBibG9ja3NcclxuICAgIC8vIENvZGUgaXMgYmFzZWQgaGVhdmlseSBvbiBiYW0uanMsIHBhcnQgb2YgdGhlIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXIsICAoYykgVGhvbWFzIERvd24gMjAwNi0yMDAxLlxyXG5sZXQgdW5iZ3pmID0gZnVuY3Rpb24gKGRhdGEsIGxpbSkge1xyXG5cclxuICAgICAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdLFxyXG4gICAgICAgICAgICBwdHIgPSBbMF0sXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIGxpbSA9IGxpbSB8fCBkYXRhLmJ5dGVMZW5ndGggLSAxODtcclxuXHJcbiAgICAgICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxOCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAxMiArIHhsZW4gKyBwdHJbMF07ICAgIC8vIFN0YXJ0IG9mIENEQVRBXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAoYnNpemUgKyA4KSkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIHN0YXJ0LCBsZW5ndGgsIHB0cik7XHJcblxyXG4gICAgICAgICAgICBwdHJbMF0gKz0gODsgICAgLy8gU2tpcHBpbmcgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGVjb21wcmVzc2VkIGJsb2Nrc1xyXG4gICAgICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XHJcbiAgICAgICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQge2lndnhocix1bmJnemZ9O1xyXG5cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/igvxhr.js\n");

/***/ }),

/***/ "./src/indexes/image_gen_index.js":
/*!****************************************!*\
  !*** ./src/indexes/image_gen_index.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_image_gen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/image_gen.js */ \"./src/node/image_gen.js\");\n\r\n\r\nvar file= process.argv[2];\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar contents = fs.readFileSync(file);\r\nvar json = JSON.parse(contents);\r\n\r\nif (!json.config.folder){\r\n\tjson.config.folder=\"images\";\r\n}\r\n\r\nif (!fs.existsSync(json.config.folder)){\r\n    fs.mkdirSync(json.config.folder);\r\n}\r\n\r\nlet ig = new _node_image_gen_js__WEBPACK_IMPORTED_MODULE_0__[\"MLVImageGen\"](json.tracks,json.config);\r\nig.drawImages();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXhlcy9pbWFnZV9nZW5faW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXhlcy9pbWFnZV9nZW5faW5kZXguanM/ODA5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01MVkltYWdlR2VufSBmcm9tIFwiLi4vbm9kZS9pbWFnZV9nZW4uanNcIjtcclxuXHJcbnZhciBmaWxlPSBwcm9jZXNzLmFyZ3ZbMl07XHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxudmFyIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGZpbGUpO1xyXG52YXIganNvbiA9IEpTT04ucGFyc2UoY29udGVudHMpO1xyXG5cclxuaWYgKCFqc29uLmNvbmZpZy5mb2xkZXIpe1xyXG5cdGpzb24uY29uZmlnLmZvbGRlcj1cImltYWdlc1wiO1xyXG59XHJcblxyXG5pZiAoIWZzLmV4aXN0c1N5bmMoanNvbi5jb25maWcuZm9sZGVyKSl7XHJcbiAgICBmcy5ta2RpclN5bmMoanNvbi5jb25maWcuZm9sZGVyKTtcclxufVxyXG5cclxubGV0IGlnID0gbmV3IE1MVkltYWdlR2VuKGpzb24udHJhY2tzLGpzb24uY29uZmlnKTtcclxuaWcuZHJhd0ltYWdlcygpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/indexes/image_gen_index.js\n");

/***/ }),

/***/ "./src/node/image_gen.js":
/*!*******************************!*\
  !*** ./src/node/image_gen.js ***!
  \*******************************/
/*! exports provided: MLVImageGen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVImageGen\", function() { return MLVImageGen; });\n/* harmony import */ var _tracks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tracks.js */ \"./src/tracks.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\n\r\nconst Canvas = __webpack_require__(/*! canvas */ \"canvas\");\r\nconst path = __webpack_require__(/*! path */ \"path\")\r\n\r\nclass MLVImageGen {\r\n   constructor (tracks,config) {\r\n           this.show_scale=true;\r\n\t\tif (!config){\r\n\t\t\tthis.config =config={};\r\n\t\t}\r\n\t\telse{\r\n\t\t\tthis.config=config;\r\n\t\t}\r\n\t\tthis.config.height=this.config.height?this.config.height:200;\r\n\t\tthis.config.width=this.config.width?this.config.width:300;\r\n\t\tif (!this.config.type){\r\n\t\t\tthis.config.type=\"png\";\r\n\t\t}\r\n\t\tthis.c_type=\"png\";\r\n\t\tthis.stream=\"createPNGStream\";\r\n\t\tif (config.type===\"svg\"){ \r\n\t\t\tthis.c_type=\"svg\";\r\n\r\n\t\t}\r\n           if (config.type===\"pdf\"){\r\n\t\t\tthis.stream=\"createPDFStream\";\r\n\t\t\tthis.c_type=\"pdf\";\r\n\t\t}\r\n\t\tthis.fixed_height_mode=false;\r\n\t\tif (config.fixed_height_mode){\r\n\t\t\tthis.fixed_height_mode=true;\r\n\t\t}\r\n        \t\r\n            \r\n           \r\n\t\t\r\n\r\n           \r\n\t\tthis.tracks={};\r\n\t\tthis.track_order=[];\r\n\t\tfor (let t_config of tracks){\r\n\t\t\tlet track=_tracks_js__WEBPACK_IMPORTED_MODULE_0__[\"MLVTrack\"].getTrack(t_config);\r\n\t\t\tthis.tracks[track.config.track_id]=track;\r\n\t\t\tthis.track_order.push(track.config.track_id);\r\n\t\t}\r\n\t\tfor (let t_id of this.track_order){\r\n    \t\t\tlet track = this.tracks[t_id];\r\n    \t\t\t//if this track is linked to the scale of another\r\n    \t\t\t//get pointer to the track\r\n    \t\t\tlet link_to = track.config['scale_link_to'];\r\n    \t\t\tif (link_to){\r\n\t\t\t\tlet other_track = this.tracks[link_to];\r\n\t\t\t\tif (other_track){\r\n\t\t\t\t\ttrack.scale_link_to=other_track;\r\n\t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n  \r\n       \tthis.index=0;\r\n    }\r\n\r\n\tgetTracksHeight(){\r\n    \t\tlet h =3;\r\n    \t\tfor (let t in this.tracks){\r\n\t\t\th+=this.tracks[t].config.height+3;\r\n    \t\t}\r\n    \t\treturn h;\r\n\t}\t\r\n\r\n\r\n\r\n    drawImages(){\r\n\t\tlet loc = this.config.images;\r\n\t\tif (this.index<loc.length){\r\n\t\t\tlet info=loc[this.index];\r\n\t\t\tlet h_region=null;\r\n\t\t\tif (info.highlight){\r\n\t\t\t\th_region={\r\n\t\t\t\t\tchr:info.loc[0],\r\n\t\t\t\t\tstart:info.highlight[1],\r\n\t\t\t\t\tend:info.highlight[2],\r\n\t\t\t\t\tcolor:info.highloght[3]?info.highlight[3]:\"blue\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet stub = info.stub;\r\n\t\t\tif (!stub){\r\n\t\t\t\tstub=info.loc[0]+\"_\"+info.loc[1]+\"_\"+info.loc[2];\r\n\t\t\t}\r\n\t\t\tlet file = path.resolve(this.config.folder,stub+\".\"+this.config.type);\t\r\n\t\t\tthis.drawImage(info.loc[0],info.loc[1],info.loc[2],file,h_region);\r\n\t\t\t\t\r\n\t\t}\r\n    \t}\r\n\r\n   \r\n    \r\n\tdrawImage(chr,start,end,file,region){\r\n\t\tconsole.log(file);\r\n        \tlet bpPerPixel=(end-start)/this.config.width;\r\n\t   \tlet self = this;\r\n\t\tlet height = this.fixed_height_mode?this.getTracksHeight():this.config.height;\r\n\t\tthis.canvas=Canvas.createCanvas(this.config.width,height,this.c_type);\r\n\t\tthis.ctx = this.canvas.getContext('2d');\r\n        \tthis.getAllFeatures(chr, start, end,{pixelWidth:this.config.width,bpPerPixel:bpPerPixel})\r\n                .then(function (all_features) {\r\n                    if (all_features) {             \r\n                        var options ={\r\n                             context: self.ctx,\r\n                             bpStart: start,\r\n                             bpPerPixel: bpPerPixel,\r\n                             pixelWidth:self.config.width,\r\n                             pixelHeight: height,\r\n                        };\r\n                        let top=3;\r\n                        self.groups={};\r\n\t\t\t\t\r\n\t\t\t\t  self.ctx.clearRect(0, 0, self.config.width, self.config.height)\r\n                        for (let i in all_features){\r\n                        \tlet track = self.tracks[self.track_order[i]];\r\n                        \toptions.features=all_features[i];\r\n                        \tlet group = track.config.group\r\n                        \tif (group){\r\n                        \t\tif (!self.groups[group]){\r\n                        \t\t\tself.groups[group]={top:top,height:track.config.height,label_offset:15}\r\n\t\t\t\t\t\t\ttop+=track.config.height;\r\n                        \t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tself.groups[group].label_offset+=15;\r\n\t\t\t\t\t\t}\r\n                        \t\toptions.top=self.groups[group].top;\r\n                        \t\toptions.height=self.groups[group].height;\r\n\r\n                        \t}\r\n                        \telse{\r\n                        \t\toptions.top =top\r\n                        \t}\r\n\t\t\t\t\tlet disc = self.fixed_height_mode || track.config.discrete || group;\r\n\t\t\t\t\tif (disc){\r\n\t\t\t\t\t\tself.ctx.save();\r\n\t\t\t\t\t\tself.ctx.rect(0,options.top,options.pixelWidth,track.config.height);\r\n\t\t\t\t\t\tself.ctx.clip();\r\n\t\t\t\t\t\tself.ctx.beginPath();\r\n\r\n\t\t\t\t\t}\r\n                           let offset=track.drawFeatures(options);\r\n\t\t\t\t\tif (track.config.type !== \"ruler\"){\r\n\t\t\t\t\t\tself.ctx.fillStyle = \"black\";\r\n\t\t\t\t\t\tself.ctx.font=\"10px Arial\";\r\n\t\t\t\t\t\tlet t_w= self.ctx.measureText(track.config.short_label).width+5;\r\n\t\t\t\t\t\tlet l_offset=15;\r\n\t\t\t\t\t\tif (group){\r\n\t\t\t\t\t\t\tl_offset=self.groups[group].label_offset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tself.ctx.fillText(track.config.short_label,self.config.width-t_w,options.top+l_offset,);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (disc){\r\n\t\t\t\t\t\tself.ctx.restore();\r\n\t\t\t\t\t\tif (!group){\r\n\t\t\t\t\t\t\ttop+=track.config.height+3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n                         \telse if (offset){\r\n                         \t  \ttop=offset+3;\r\n                           }\r\n                           if (self.show_scale){\r\n\t\t\t\t\t\tself.ctx.font=\"10px Arial\";\r\n                            \ttrack.drawScale(options.pixelHeight,self.ctx)\r\n                           }\r\n                                      \r\n                        }\r\n                        if (region){\r\n\t\t\t\t\tlet start= (region.start-options.bpStart)/options.bpPerPixel;\r\n    \t\t\t\t\tstart = start<0?0:start;\r\n\t\t\t\t\tlet width = (region.end-region.start)/options.bpPerPixel;\r\n    \t\t\t\t\twidth =width>options.pixelWidth?options.pixelWidth:width;\r\n\t\t\t\t\tself.ctx.globalAlpha=0.1;\r\n\t\t\t\t\tself.ctx.fillStyle=region.color;\r\n    \t\t\t\t\tself.ctx.fillRect(start,0,width,options.pixelHeight);\r\n    \t\t\t\t\tself.ctx.globalAlpha=1.0;\r\n                        }\r\n                        \r\n                    \r\n                    }\r\n\t\t                \r\n\t\t\t\t\r\n\t\t\t\tif (self.config.type===\"svg\"){\r\n\t\t\t\t\tfs.writeFileSync(file, self.canvas.toBuffer())\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tconst out = fs.createWriteStream(file);\r\n\t\t\t\t\tconst stream = self.canvas[self.stream]();\r\n\t\t\t\t\tstream.pipe(out);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\t\r\n\r\n\t\t\t\tself.index++;\r\n\t\t\t\tself.drawImages();\r\n                })\r\n                .catch(function (error) {\r\n                    console.log(error.toString());\r\n\t\t\t    self.index++;\r\n                    self.drawImages();\r\n                });\r\n     \t}\r\n\r\n\tgetAllFeatures(chr,bpStart,bpEnd,data) {\r\n      \tlet promises = [];\r\n        \tfor (let track_id  of this.track_order){\r\n        \t\tlet track = this.tracks[track_id];\r\n        \t\tpromises.push(track.getFeatures(chr,bpStart,bpEnd,false,data));       \r\n        \t}\r\n\r\n        \treturn Promise.all(promises);\r\n\r\n           \r\n    \t}\r\n\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbm9kZS9pbWFnZV9nZW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbm9kZS9pbWFnZV9nZW4uanM/OGIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuaW1wb3J0IHtNTFZUcmFja30gZnJvbSBcIi4uL3RyYWNrcy5qc1wiO1xyXG5jb25zdCBDYW52YXMgPSByZXF1aXJlKFwiY2FudmFzXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcclxuXHJcbmNsYXNzIE1MVkltYWdlR2VuIHtcclxuICAgY29uc3RydWN0b3IgKHRyYWNrcyxjb25maWcpIHtcclxuICAgICAgICAgICB0aGlzLnNob3dfc2NhbGU9dHJ1ZTtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0dGhpcy5jb25maWcgPWNvbmZpZz17fTtcclxuXHRcdH1cclxuXHRcdGVsc2V7XHJcblx0XHRcdHRoaXMuY29uZmlnPWNvbmZpZztcclxuXHRcdH1cclxuXHRcdHRoaXMuY29uZmlnLmhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ/dGhpcy5jb25maWcuaGVpZ2h0OjIwMDtcclxuXHRcdHRoaXMuY29uZmlnLndpZHRoPXRoaXMuY29uZmlnLndpZHRoP3RoaXMuY29uZmlnLndpZHRoOjMwMDtcclxuXHRcdGlmICghdGhpcy5jb25maWcudHlwZSl7XHJcblx0XHRcdHRoaXMuY29uZmlnLnR5cGU9XCJwbmdcIjtcclxuXHRcdH1cclxuXHRcdHRoaXMuY190eXBlPVwicG5nXCI7XHJcblx0XHR0aGlzLnN0cmVhbT1cImNyZWF0ZVBOR1N0cmVhbVwiO1xyXG5cdFx0aWYgKGNvbmZpZy50eXBlPT09XCJzdmdcIil7IFxyXG5cdFx0XHR0aGlzLmNfdHlwZT1cInN2Z1wiO1xyXG5cclxuXHRcdH1cclxuICAgICAgICAgICBpZiAoY29uZmlnLnR5cGU9PT1cInBkZlwiKXtcclxuXHRcdFx0dGhpcy5zdHJlYW09XCJjcmVhdGVQREZTdHJlYW1cIjtcclxuXHRcdFx0dGhpcy5jX3R5cGU9XCJwZGZcIjtcclxuXHRcdH1cclxuXHRcdHRoaXMuZml4ZWRfaGVpZ2h0X21vZGU9ZmFsc2U7XHJcblx0XHRpZiAoY29uZmlnLmZpeGVkX2hlaWdodF9tb2RlKXtcclxuXHRcdFx0dGhpcy5maXhlZF9oZWlnaHRfbW9kZT10cnVlO1xyXG5cdFx0fVxyXG4gICAgICAgIFx0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgIFxyXG5cdFx0XHJcblxyXG4gICAgICAgICAgIFxyXG5cdFx0dGhpcy50cmFja3M9e307XHJcblx0XHR0aGlzLnRyYWNrX29yZGVyPVtdO1xyXG5cdFx0Zm9yIChsZXQgdF9jb25maWcgb2YgdHJhY2tzKXtcclxuXHRcdFx0bGV0IHRyYWNrPU1MVlRyYWNrLmdldFRyYWNrKHRfY29uZmlnKTtcclxuXHRcdFx0dGhpcy50cmFja3NbdHJhY2suY29uZmlnLnRyYWNrX2lkXT10cmFjaztcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5wdXNoKHRyYWNrLmNvbmZpZy50cmFja19pZCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB0X2lkIG9mIHRoaXMudHJhY2tfb3JkZXIpe1xyXG4gICAgXHRcdFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdF9pZF07XHJcbiAgICBcdFx0XHQvL2lmIHRoaXMgdHJhY2sgaXMgbGlua2VkIHRvIHRoZSBzY2FsZSBvZiBhbm90aGVyXHJcbiAgICBcdFx0XHQvL2dldCBwb2ludGVyIHRvIHRoZSB0cmFja1xyXG4gICAgXHRcdFx0bGV0IGxpbmtfdG8gPSB0cmFjay5jb25maWdbJ3NjYWxlX2xpbmtfdG8nXTtcclxuICAgIFx0XHRcdGlmIChsaW5rX3RvKXtcclxuXHRcdFx0XHRsZXQgb3RoZXJfdHJhY2sgPSB0aGlzLnRyYWNrc1tsaW5rX3RvXTtcclxuXHRcdFx0XHRpZiAob3RoZXJfdHJhY2spe1xyXG5cdFx0XHRcdFx0dHJhY2suc2NhbGVfbGlua190bz1vdGhlcl90cmFjaztcclxuXHRcdFx0XHR9XHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gIFxyXG4gICAgICAgXHR0aGlzLmluZGV4PTA7XHJcbiAgICB9XHJcblxyXG5cdGdldFRyYWNrc0hlaWdodCgpe1xyXG4gICAgXHRcdGxldCBoID0zO1xyXG4gICAgXHRcdGZvciAobGV0IHQgaW4gdGhpcy50cmFja3Mpe1xyXG5cdFx0XHRoKz10aGlzLnRyYWNrc1t0XS5jb25maWcuaGVpZ2h0KzM7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHJldHVybiBoO1xyXG5cdH1cdFxyXG5cclxuXHJcblxyXG4gICAgZHJhd0ltYWdlcygpe1xyXG5cdFx0bGV0IGxvYyA9IHRoaXMuY29uZmlnLmltYWdlcztcclxuXHRcdGlmICh0aGlzLmluZGV4PGxvYy5sZW5ndGgpe1xyXG5cdFx0XHRsZXQgaW5mbz1sb2NbdGhpcy5pbmRleF07XHJcblx0XHRcdGxldCBoX3JlZ2lvbj1udWxsO1xyXG5cdFx0XHRpZiAoaW5mby5oaWdobGlnaHQpe1xyXG5cdFx0XHRcdGhfcmVnaW9uPXtcclxuXHRcdFx0XHRcdGNocjppbmZvLmxvY1swXSxcclxuXHRcdFx0XHRcdHN0YXJ0OmluZm8uaGlnaGxpZ2h0WzFdLFxyXG5cdFx0XHRcdFx0ZW5kOmluZm8uaGlnaGxpZ2h0WzJdLFxyXG5cdFx0XHRcdFx0Y29sb3I6aW5mby5oaWdobG9naHRbM10/aW5mby5oaWdobGlnaHRbM106XCJibHVlXCJcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHN0dWIgPSBpbmZvLnN0dWI7XHJcblx0XHRcdGlmICghc3R1Yil7XHJcblx0XHRcdFx0c3R1Yj1pbmZvLmxvY1swXStcIl9cIitpbmZvLmxvY1sxXStcIl9cIitpbmZvLmxvY1syXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgZmlsZSA9IHBhdGgucmVzb2x2ZSh0aGlzLmNvbmZpZy5mb2xkZXIsc3R1YitcIi5cIit0aGlzLmNvbmZpZy50eXBlKTtcdFxyXG5cdFx0XHR0aGlzLmRyYXdJbWFnZShpbmZvLmxvY1swXSxpbmZvLmxvY1sxXSxpbmZvLmxvY1syXSxmaWxlLGhfcmVnaW9uKTtcclxuXHRcdFx0XHRcclxuXHRcdH1cclxuICAgIFx0fVxyXG5cclxuICAgXHJcbiAgICBcclxuXHRkcmF3SW1hZ2UoY2hyLHN0YXJ0LGVuZCxmaWxlLHJlZ2lvbil7XHJcblx0XHRjb25zb2xlLmxvZyhmaWxlKTtcclxuICAgICAgICBcdGxldCBicFBlclBpeGVsPShlbmQtc3RhcnQpL3RoaXMuY29uZmlnLndpZHRoO1xyXG5cdCAgIFx0bGV0IHNlbGYgPSB0aGlzO1xyXG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZml4ZWRfaGVpZ2h0X21vZGU/dGhpcy5nZXRUcmFja3NIZWlnaHQoKTp0aGlzLmNvbmZpZy5oZWlnaHQ7XHJcblx0XHR0aGlzLmNhbnZhcz1DYW52YXMuY3JlYXRlQ2FudmFzKHRoaXMuY29uZmlnLndpZHRoLGhlaWdodCx0aGlzLmNfdHlwZSk7XHJcblx0XHR0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgXHR0aGlzLmdldEFsbEZlYXR1cmVzKGNociwgc3RhcnQsIGVuZCx7cGl4ZWxXaWR0aDp0aGlzLmNvbmZpZy53aWR0aCxicFBlclBpeGVsOmJwUGVyUGl4ZWx9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFsbF9mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxfZmVhdHVyZXMpIHsgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID17XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogc2VsZi5jdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnBTdGFydDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnBQZXJQaXhlbDogYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbFdpZHRoOnNlbGYuY29uZmlnLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsSGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b3A9MztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ncm91cHM9e307XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0ICBzZWxmLmN0eC5jbGVhclJlY3QoMCwgMCwgc2VsZi5jb25maWcud2lkdGgsIHNlbGYuY29uZmlnLmhlaWdodClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBhbGxfZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCB0cmFjayA9IHNlbGYudHJhY2tzW3NlbGYudHJhY2tfb3JkZXJbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdG9wdGlvbnMuZmVhdHVyZXM9YWxsX2ZlYXR1cmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCBncm91cCA9IHRyYWNrLmNvbmZpZy5ncm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGlmIChncm91cCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRpZiAoIXNlbGYuZ3JvdXBzW2dyb3VwXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdHNlbGYuZ3JvdXBzW2dyb3VwXT17dG9wOnRvcCxoZWlnaHQ6dHJhY2suY29uZmlnLmhlaWdodCxsYWJlbF9vZmZzZXQ6MTV9XHJcblx0XHRcdFx0XHRcdFx0dG9wKz10cmFjay5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYuZ3JvdXBzW2dyb3VwXS5sYWJlbF9vZmZzZXQrPTE1O1xyXG5cdFx0XHRcdFx0XHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRvcHRpb25zLnRvcD1zZWxmLmdyb3Vwc1tncm91cF0udG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0b3B0aW9ucy5oZWlnaHQ9c2VsZi5ncm91cHNbZ3JvdXBdLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRvcHRpb25zLnRvcCA9dG9wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG5cdFx0XHRcdFx0bGV0IGRpc2MgPSBzZWxmLmZpeGVkX2hlaWdodF9tb2RlIHx8IHRyYWNrLmNvbmZpZy5kaXNjcmV0ZSB8fCBncm91cDtcclxuXHRcdFx0XHRcdGlmIChkaXNjKXtcclxuXHRcdFx0XHRcdFx0c2VsZi5jdHguc2F2ZSgpO1xyXG5cdFx0XHRcdFx0XHRzZWxmLmN0eC5yZWN0KDAsb3B0aW9ucy50b3Asb3B0aW9ucy5waXhlbFdpZHRoLHRyYWNrLmNvbmZpZy5oZWlnaHQpO1xyXG5cdFx0XHRcdFx0XHRzZWxmLmN0eC5jbGlwKCk7XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldD10cmFjay5kcmF3RmVhdHVyZXMob3B0aW9ucyk7XHJcblx0XHRcdFx0XHRpZiAodHJhY2suY29uZmlnLnR5cGUgIT09IFwicnVsZXJcIil7XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcclxuXHRcdFx0XHRcdFx0c2VsZi5jdHguZm9udD1cIjEwcHggQXJpYWxcIjtcclxuXHRcdFx0XHRcdFx0bGV0IHRfdz0gc2VsZi5jdHgubWVhc3VyZVRleHQodHJhY2suY29uZmlnLnNob3J0X2xhYmVsKS53aWR0aCs1O1xyXG5cdFx0XHRcdFx0XHRsZXQgbF9vZmZzZXQ9MTU7XHJcblx0XHRcdFx0XHRcdGlmIChncm91cCl7XHJcblx0XHRcdFx0XHRcdFx0bF9vZmZzZXQ9c2VsZi5ncm91cHNbZ3JvdXBdLmxhYmVsX29mZnNldDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRzZWxmLmN0eC5maWxsVGV4dCh0cmFjay5jb25maWcuc2hvcnRfbGFiZWwsc2VsZi5jb25maWcud2lkdGgtdF93LG9wdGlvbnMudG9wK2xfb2Zmc2V0LCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoZGlzYyl7XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRcdFx0aWYgKCFncm91cCl7XHJcblx0XHRcdFx0XHRcdFx0dG9wKz10cmFjay5jb25maWcuaGVpZ2h0KzM7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgIFx0ZWxzZSBpZiAob2Zmc2V0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFx0ICBcdHRvcD1vZmZzZXQrMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaG93X3NjYWxlKXtcclxuXHRcdFx0XHRcdFx0c2VsZi5jdHguZm9udD1cIjEwcHggQXJpYWxcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0dHJhY2suZHJhd1NjYWxlKG9wdGlvbnMucGl4ZWxIZWlnaHQsc2VsZi5jdHgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVnaW9uKXtcclxuXHRcdFx0XHRcdGxldCBzdGFydD0gKHJlZ2lvbi5zdGFydC1vcHRpb25zLmJwU3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuICAgIFx0XHRcdFx0XHRzdGFydCA9IHN0YXJ0PDA/MDpzdGFydDtcclxuXHRcdFx0XHRcdGxldCB3aWR0aCA9IChyZWdpb24uZW5kLXJlZ2lvbi5zdGFydCkvb3B0aW9ucy5icFBlclBpeGVsO1xyXG4gICAgXHRcdFx0XHRcdHdpZHRoID13aWR0aD5vcHRpb25zLnBpeGVsV2lkdGg/b3B0aW9ucy5waXhlbFdpZHRoOndpZHRoO1xyXG5cdFx0XHRcdFx0c2VsZi5jdHguZ2xvYmFsQWxwaGE9MC4xO1xyXG5cdFx0XHRcdFx0c2VsZi5jdHguZmlsbFN0eWxlPXJlZ2lvbi5jb2xvcjtcclxuICAgIFx0XHRcdFx0XHRzZWxmLmN0eC5maWxsUmVjdChzdGFydCwwLHdpZHRoLG9wdGlvbnMucGl4ZWxIZWlnaHQpO1xyXG4gICAgXHRcdFx0XHRcdHNlbGYuY3R4Lmdsb2JhbEFscGhhPTEuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblx0XHQgICAgICAgICAgICAgICAgXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKHNlbGYuY29uZmlnLnR5cGU9PT1cInN2Z1wiKXtcclxuXHRcdFx0XHRcdGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc2VsZi5jYW52YXMudG9CdWZmZXIoKSlcclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0Y29uc3Qgb3V0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZmlsZSk7XHJcblx0XHRcdFx0XHRjb25zdCBzdHJlYW0gPSBzZWxmLmNhbnZhc1tzZWxmLnN0cmVhbV0oKTtcclxuXHRcdFx0XHRcdHN0cmVhbS5waXBlKG91dCk7XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRcdFxyXG5cclxuXHRcdFx0XHRzZWxmLmluZGV4Kys7XHJcblx0XHRcdFx0c2VsZi5kcmF3SW1hZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHQgICAgc2VsZi5pbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZHJhd0ltYWdlcygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgXHR9XHJcblxyXG5cdGdldEFsbEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGRhdGEpIHtcclxuICAgICAgXHRsZXQgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBcdGZvciAobGV0IHRyYWNrX2lkICBvZiB0aGlzLnRyYWNrX29yZGVyKXtcclxuICAgICAgICBcdFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdHJhY2tfaWRdO1xyXG4gICAgICAgIFx0XHRwcm9taXNlcy5wdXNoKHRyYWNrLmdldEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZhbHNlLGRhdGEpKTsgICAgICAgXHJcbiAgICAgICAgXHR9XHJcblxyXG4gICAgICAgIFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuXHJcbiAgICAgICAgICAgXHJcbiAgICBcdH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCB7TUxWSW1hZ2VHZW59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/node/image_gen.js\n");

/***/ }),

/***/ "./src/tracks.js":
/*!***********************!*\
  !*** ./src/tracks.js ***!
  \***********************/
/*! exports provided: MLVTrack, MLVWigTrack, MLVBedTrack, RulerTrack, MLVBigBedTrack, Graphics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(__webpack_provided_$_dot_extend) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVTrack\", function() { return MLVTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVWigTrack\", function() { return MLVWigTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVBedTrack\", function() { return MLVBedTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RulerTrack\", function() { return RulerTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVBigBedTrack\", function() { return MLVBigBedTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graphics\", function() { return Graphics; });\n/* harmony import */ var _bigwig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ \"./src/feature.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MLVTrack{\r\n\tconstructor(config){\r\n\t\tthis.config=config;\r\n\t}\r\n\r\n\t_setFeatureSource(){\r\n\t\t//overriden by tracks with feature sources\r\n\t}\r\n\r\n\tdrawScale(ctx){\r\n\t\t//overidden in tracks with scale\r\n\t}\r\n\r\n\tgetConfig(){\r\n\t\treturn __webpack_provided_$_dot_extend(true, {}, this.config);\r\n\t}\r\n\r\n\tsetConfigAttribute(attribute,value){\r\n\t\tthis.config[attribute]=value;\r\n    \tif (attribute===\"url\"){\r\n    \t\tthis._setFeatureSource();\r\n    \t}\r\n    }\r\n    getFeatureAt(genomicLocation, chr,yOffset, bpPerPixel){\r\n    \treturn null;\r\n    }\r\n\r\n    setConfig(config){\r\n    \tif (this.config.url !== config.url){\r\n    \t\tthis.config=config;\r\n    \t\tthis._setFeatureSource();\r\n    \t}\r\n    \telse{\r\n    \t\tthis._setFeatureSource();\r\n    \t}\r\n    }\r\n\t\r\n\tgetFeatures (chr, bpStart, bpEnd,force,data) {\r\n\t\treturn this.feature_source.getFeatures(chr,bpStart,bpEnd,force,data);\r\n\t}\r\n\r\n\r\n\tstatic calculateLabel(url){\r\n\t\tif (typeof url !== \"string\"){\r\n\t\t\turl = url[0];\r\n\t\t}\r\n\t\tlet arr =url.split(\"/\");\r\n\t\tlet label= arr[arr.length-1];\r\n\t\tarr= label.split(\".\");\r\n\t\tlabel = arr[0];\r\n\t\treturn label;\r\n\t}\r\n\r\n\taddExtraControls(div,panel){\r\n\t}\r\n\r\n\tstatic getTypeFromURL(url){\r\n\t\tlet config={}\r\n\t\tif (typeof url !== \"string\"){\r\n\t\t\treturn config;\r\n\t\t}\r\n\t\t\tif (url.endsWith(\"bw\")){\r\n\t\t\t\tconfig.type=\"bigwig\";\r\n\t\t\t\tconfig.format=\"wig\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".bed.gz\")){\r\n\t\t\t\tconfig.type=\"bed\";\r\n\t\t\t\tconfig.format=\"feature\"\r\n\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".bb\") && !(config.type)){\r\n\t\t\t\tconfig.type=\"bigbed\";\r\n\t\t\t\tconfig.format=\"feature\"\r\n\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".fasta\")){\r\n\t\t\t\tconfig.type=\"fasta\";\r\n\t\t\t\tconfig.format=\"sequence\";\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".bam\")){\r\n\t\t\t\tconfig.type=\"bam\";\r\n\t\t\t\tconfig.format=\"alignment\";\r\n\t\t\t}\r\n\t\treturn config;\r\n\r\n\t}\r\n\r\n\tstatic parseConfig(con){\r\n\t\tlet config = __webpack_provided_$_dot_extend(true, {},con);\r\n\t\t\r\n\t\tif ((!config.type || !config.format) && config.url){\r\n\t\t\tlet info = MLVTrack.getTypeFromURL(config.url);\r\n\t\t\tif (info.type){\r\n\t\t\t\tconfig.type=info.type;\r\n\t\t\t\tconfig.format=info.format;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!config.short_label && config.url){\r\n\t\t\tconfig.short_label=MLVTrack.calculateLabel(config.url);\r\n\t\t}\r\n\t\t\r\n\t\tif (!config.track_id){\r\n\t\t\tconfig.track_id=config.url;\r\n\t\t}\r\n\r\n\t\tif (config.format===\"feature\"){\r\n\t\t\tconfig.displayMode = config.displayMode || \"COLLAPSED\";    // COLLAPSED | EXPANDED | SQUISHED\r\n        \tconfig.labelDisplayMode = \"SLANT\";\r\n        \tconfig.squishedCallHeight = config.squishedCallHeight || 30;\r\n        \tconfig.expandedCallHeight = config.expandedCallHeight || 15;\r\n        \tconfig.featureHeight=config.featureHeight || 12;\r\n\t\t}\r\n\r\n\t\tif (config.format===\"wig\"){\r\n\t\t\tif (!config.scale){\r\n\t\t\t\tconfig.scale=\"automatic\";\r\n\t\t\t}\r\n\t\t\tif (!config.min_y){\r\n\t\t\t\tconfig.min_y=0;\r\n\t\t\t}\r\n\t\t\tif (!config.maxy_y){\r\n\t\t\t\tconfig.max_y=100;\r\n\t\t\t}\r\n\t\t\tif (!config.height){\r\n\t\t\t\tconfig.height=100;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (config.type===\"bam\"){\r\n\t\t\tif (!config.featureHeight){\r\n\t\t\t\tconfig.featureHeight=12;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!config.color){\r\n\t\t\tif (config.type===\"bam\"){\r\n\t\t\t\tconfig.color=\"#D3D3D3\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tconfig.color=\"black\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!config.opacity){\r\n\t\t\tconfig.opacity=1.0;\r\n\t\t}\r\n\t\treturn config;\r\n\t}\r\n\r\n\r\n\t\r\n\tstatic getTrack(config){\r\n\r\n\t\tconfig=MLVTrack.parseConfig(config);\r\n\t\t\r\n\t\tif (config.type===\"bigwig\"){\r\n\t\t\treturn new MLVWigTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"bed\"){\r\n\t\t\treturn new MLVBedTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"ucsc\"){\r\n\t\t\treturn new UCSCTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"line\"){\r\n\t\t\treturn new LineTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"bigbed\"){\r\n\t\t\treturn new MLVBigBedTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"ruler\"){\r\n\t\t\treturn new RulerTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"fasta\"){\r\n\t\t\treturn new SequenceTrack(config);\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t\tlet class_type = MLVTrack.custom_tracks[config.type];\r\n\t\t\tif (class_type){\r\n\t\t\t\treturn new class_type(config);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\t\t\r\n}\r\n\r\nMLVTrack.custom_tracks={};\r\n\r\n\r\n\r\n\r\n\r\n//*******************js/rulerTrack.js**********************\r\n\r\n\r\nclass RulerTrack extends MLVTrack{\r\n\tconstructor(config){\r\n\t\tif (!config){\r\n\t\t\tconfig={\"track_id\":\"ruler\"+RulerTrack.count,format:\"ruler\",short_label:\"Ruler\",type:\"ruler\"};\r\n\t\t}\r\n\t\tsuper(config);\r\n        this.height = 30;\r\n        this.config.height=30;\r\n        this.name = \"\";\r\n       \r\n        this.disableButtons = true;\r\n        this.ignoreTrackMenu = true;\r\n        this.order = -Number.MAX_VALUE;\r\n      \r\n        RulerTrack.count++;\r\n    }\r\n\r\n    getFeatures(chr, bpStart, bpEnd) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            fulfill([]);\r\n        });\r\n    }\r\n\r\n    drawFeatures(options) {\r\n\r\n        var fontStyle,\r\n            ctx = options.context,\r\n            range,\r\n            ts,\r\n            spacing,\r\n            nTick,\r\n            x;\r\n\r\n        fontStyle = { textAlign: 'center', font: '10px PT Sans', fillStyle: \"rgba(64, 64, 64, 1)\", strokeStyle: \"rgba(64, 64, 64, 1)\" };\r\n\r\n        range = Math.floor(1100 * options.bpPerPixel);\r\n        ts = RulerTrack.findSpacing(range);\r\n        spacing = ts.majorTick;\r\n\r\n        // Find starting point closest to the current origin\r\n        nTick = Math.floor(options.bpStart / spacing) - 1;\r\n        x = 0;\r\n\t\tlet y_pos=options.top+this.height;\r\n        //canvas.setProperties({textAlign: 'center'});\r\n        Graphics.setProperties(ctx, fontStyle );\r\n        while (x < options.pixelWidth) {\r\n\r\n            var l = Math.floor(nTick * spacing),\r\n                shim = 2;\r\n\r\n            x = Math.round(((l - 1) - options.bpStart + 0.5) / options.bpPerPixel);\r\n            var chrPosition = formatNumber(l / ts.unitMultiplier, 0) + \" \" + ts.majorUnit;\r\n\r\n            if (nTick % 1 == 0) {\r\n                Graphics.fillText(ctx, chrPosition, x, y_pos - 15);\r\n            }\r\n\r\n            Graphics.strokeLine(ctx, x, y_pos - 10, x, y_pos - shim);\r\n\r\n            nTick++;\r\n        }\r\n        Graphics.strokeLine(ctx, 0, y_pos - shim, options.pixelWidth, y_pos - shim);\r\n\r\n\r\n        function formatNumber(anynum, decimal) {\r\n            //decimal  - the number of decimals after the digit from 0 to 3\r\n            //-- Returns the passed number as a string in the xxx,xxx.xx format.\r\n            //anynum = eval(obj.value);\r\n            var divider = 10;\r\n            switch (decimal) {\r\n                case 0:\r\n                    divider = 1;\r\n                    break;\r\n                case 1:\r\n                    divider = 10;\r\n                    break;\r\n                case 2:\r\n                    divider = 100;\r\n                    break;\r\n                default:       //for 3 decimal places\r\n                    divider = 1000;\r\n            }\r\n\r\n            var workNum = Math.abs((Math.round(anynum * divider) / divider));\r\n\r\n            var workStr = \"\" + workNum\r\n\r\n            if (workStr.indexOf(\".\") == -1) {\r\n                workStr += \".\"\r\n            }\r\n\r\n            var dStr = workStr.substr(0, workStr.indexOf(\".\"));\r\n            var dNum = dStr - 0\r\n            var pStr = workStr.substr(workStr.indexOf(\".\"))\r\n\r\n            while (pStr.length - 1 < decimal) {\r\n                pStr += \"0\"\r\n            }\r\n\r\n            if (pStr == '.') pStr = '';\r\n\r\n            //--- Adds a comma in the thousands place.\r\n            if (dNum >= 1000) {\r\n                var dLen = dStr.length\r\n                dStr = parseInt(\"\" + (dNum / 1000)) + \",\" + dStr.substring(dLen - 3, dLen)\r\n            }\r\n\r\n            //-- Adds a comma in the millions place.\r\n            if (dNum >= 1000000) {\r\n                dLen = dStr.length\r\n                dStr = parseInt(\"\" + (dNum / 1000000)) + \",\" + dStr.substring(dLen - 7, dLen)\r\n            }\r\n            var retval = dStr + pStr\r\n            //-- Put numbers in parentheses if negative.\r\n            if (anynum < 0) {\r\n                retval = \"(\" + retval + \")\";\r\n            }\r\n\r\n            //You could include a dollar sign in the return value.\r\n            //retval =  \"$\"+retval\r\n            return retval;\r\n        }\r\n        return y_pos;\r\n\r\n\r\n    }\r\n    static findSpacing(maxValue) {\r\n\r\n        if (maxValue < 10) {\r\n            return new TickSpacing(1, \"\", 1);\r\n        }\r\n\r\n\r\n        // Now man zeroes?\r\n        var nZeroes = Math.floor(log10(maxValue));\r\n        var majorUnit = \"\";\r\n        var unitMultiplier = 1;\r\n        if (nZeroes > 9) {\r\n            majorUnit = \"gb\";\r\n            unitMultiplier = 1000000000;\r\n        }\r\n        if (nZeroes > 6) {\r\n            majorUnit = \"mb\";\r\n            unitMultiplier = 1000000;\r\n        } else if (nZeroes > 3) {\r\n            majorUnit = \"kb\";\r\n            unitMultiplier = 1000;\r\n        }\r\n\r\n        var nMajorTicks = maxValue / Math.pow(10, nZeroes - 1);\r\n        if (nMajorTicks < 25) {\r\n            return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);\r\n        } else {\r\n            return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);\r\n        }\r\n\r\n        function log10(x) {\r\n            var dn = Math.log(10);\r\n            return Math.log(x) / dn;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nRulerTrack.count=0;\r\n\r\nclass TickSpacing{\r\n\tconstructor(majorTick, majorUnit, unitMultiplier) {\r\n        this.majorTick = majorTick;\r\n        this.majorUnit = majorUnit;\r\n        this.unitMultiplier = unitMultiplier;\r\n    }\r\n\r\n}\r\n\r\n \r\nclass MLVBedTrack extends MLVTrack{\r\n\tconstructor(config){\r\n\t\tsuper(config);\r\n\t\tthis._setFeatureSource();\r\n\t\tthis.filter_function=null;\r\n\t\tthis.color_function=null;\r\n\t\t\r\n\t}\r\n\r\n\t_setFeatureSource(){\r\n\t\tthis.feature_source= new _feature_js__WEBPACK_IMPORTED_MODULE_1__[\"FeatureSource\"](this.config)\r\n\t}\r\n\r\n\tsetFilterFunction(func){\r\n\t\tthis.filter_function=func;\r\n\t}\r\n\tsetColorFunction(func){\r\n\t\tthis.color_function=func;\r\n\t}\r\n\r\n\tgetCurrentFeatures(chr,start,end){\r\n\t\treturn this.feature_source.featureCache.queryFeatures(chr,start,end);\r\n\t}\r\n\t\r\n\tdrawFeatures(options) {\r\n\t\tlet max_y_val=0;\r\n        var track = this,\r\n        \tpy,\r\n            featureList = options.features,\r\n            ctx = options.context,\r\n            bpPerPixel = options.bpPerPixel,\r\n            bpStart = options.bpStart,\r\n            pixelWidth = options.pixelWidth,\r\n            pixelHeight = options.pixelHeight,\r\n            offset=0,\r\n            bpEnd = bpStart + pixelWidth * bpPerPixel + 1;\r\n\t \tlet top=0;\r\n       \tif(options.top){\r\n           top=options.top;\r\n       \t}\r\n       \tthis.top=top;\r\n        let conf = this.config;\r\n        let windowX = 0;\r\n        let windowX1 = windowX + pixelWidth;\r\n\r\n        this.config.squishedCallHeight = this.config.featureHeight+10;\r\n        this.config.expandedCallHeight = (this.config.featureHeight/2)+2;\r\n        let ki=null;\r\n        if (featureList.length>50000){\r\n        \tki=Math.round(featureList.length/50000)+1;\r\n        }\r\n\r\n\r\n\r\n        if (featureList) {\r\n        \tlet opacity = this.config.opacity?this.config.opacity:1;\r\n        \tctx.globalAlpha=opacity;\r\n\r\n            for (var gene, i = 0, len = featureList.length; i < len; i++) {\r\n            \tif (ki && i%ki!==0){\r\n            \t\tcontinue;\r\n            \t}\r\n                gene = featureList[i];\r\n                if (this.filter_function && !this.filter_function(gene)){\r\n                \tgene.display=false;\r\n                \tcontinue;\r\n                }\r\n                gene.display=true;\r\n                if (gene.end < bpStart) continue;\r\n                if (gene.start > bpEnd) break;\r\n                let coord = this.calculateFeatureCoordinates(gene, bpStart,bpPerPixel);\r\n                let h = conf.featureHeight\r\n                if (conf.displayMode === \"SQUISHED\" && gene.row != undefined) {\r\n            \t\th = conf.featureHeight / 2;\r\n            \t\tpy = conf.expandedCallHeight * gene.row + 2;\r\n        \t\t} else if (conf.displayMode === \"EXPANDED\" && gene.row != undefined) {\r\n            \t\tpy = conf.squishedCallHeight * gene.row + 5;\r\n        \t\t} else {\r\n             // collapsed\r\n           \t\t\t py = 5;\r\n        \t\t}\r\n        \t\tpy+=top;\r\n        \t\tif (py+h>max_y_val){\r\n        \t\t\tmax_y_val=py+h;\r\n        \t\t}\r\n        \t\tcoord.py=py;\r\n        \t\tcoord.h=h;\r\n        \t\tlet info={bpPerPixel:bpPerPixel,bpStart:bpStart,pixelWidth:pixelWidth}\r\n        \t\tif (this.color_function){\r\n        \t\t\tgene.color=this.color_function(gene);\r\n        \t\t}\r\n        \t\t\r\n                this.renderFeature(gene,coord,ctx,info);\r\n                this.renderFeatureLabel(ctx, gene, coord.px, coord.px1, py, windowX, windowX1);\r\n            }\r\n            ctx.globalAlpha=1;\r\n        }\r\n        else {\r\n            console.log(\"No feature list\");\r\n        }\r\n        this.bottom=max_y_val;\r\n        if (this.config.displayMode===\"COLLAPSED\"){\r\n        \tmax_y_val+=25;\r\n        }\t\r\n    \treturn max_y_val;\r\n    }\r\n        \r\n           \r\n\r\n    \r\n  \r\n\t /**\r\n     * @param ctx       the canvas 2d context\r\n     * @param feature\r\n     * @param featureX  feature start x-coordinate\r\n     * @param featureX1 feature end x-coordinate\r\n     * @param featureY  feature y-coordinate\r\n     * @param windowX   visible window start x-coordinate\r\n     * @param windowX1  visible window end x-coordinate\r\n     */\r\n  \r\n\r\n\r\n\r\n\trenderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1) {\r\n\t\tlet info = this.config;\r\n        var geneColor, geneFontStyle, transform,\r\n            boxX, boxX1,    // label should be centered between these two x-coordinates\r\n            labelX, labelY,\r\n            textFitsInBox;\r\n\r\n        // feature outside of viewable window\r\n        if (featureX1 < windowX || featureX > windowX1) {\r\n            boxX = featureX;\r\n            boxX1 = featureX1;\r\n        } else {\r\n            // center label within visible portion of the feature\r\n            boxX = Math.max(featureX, windowX);\r\n            boxX1 = Math.min(featureX1, windowX1);\r\n        }\r\n       \r\n\r\n        //if (igv.browser.selection && \"genes\" === this.config.type && feature.name !== undefined) {\r\n            // TODO -- for gtex, figure out a better way to do this\r\n            //geneColor = igv.browser.selection.colorForGene(feature.name);\r\n      //  }\r\n\r\n        textFitsInBox = (boxX1 - boxX) > ctx.measureText(feature.name).width;\r\n        //geneColor=\"black\";\r\n\r\n        if ((textFitsInBox || geneColor) && info.displayMode != \"SQUISHED\" && feature.name !== undefined) {\r\n            geneFontStyle = {\r\n                font: '10px PT Sans',\r\n                textAlign: 'center',\r\n                fillStyle: geneColor || info.color,\r\n                strokeStyle: geneColor || info.color\r\n            };\r\n\r\n            if (info.displayMode === \"COLLAPSED\" && info.labelDisplayMode === \"SLANT\") {\r\n                transform = {rotate: {angle: 45}};\r\n                delete geneFontStyle.textAlign;\r\n            }\r\n\r\n            labelX = boxX + ((boxX1 - boxX) / 2);\r\n            labelY = getFeatureLabelY(featureY, transform);\r\n\r\n            Graphics.fillText(ctx, feature.name, labelX, labelY, geneFontStyle, transform);\r\n        }\r\n        function getFeatureLabelY(featureY, transform) {\r\n        \treturn transform ? featureY + info.featureHeight+14 : featureY + info.featureHeight+7;\r\n    \t}\r\n    }\r\n\r\n\r\n\r\n\tcalculateFeatureCoordinates(feature, bpStart, xScale) {\r\n    \tvar px = Math.round((feature.start - bpStart) / xScale),\r\n        px1 = Math.round((feature.end - bpStart) / xScale),\r\n        pw = px1 - px;\r\n\r\n        if (pw < 3) {\r\n        \tpw = 3;\r\n            px -= 1;\r\n        }\r\n\r\n        return {\r\n        \tpx: px,\r\n            px1: px1,\r\n            pw: pw\r\n        };\r\n\t}\r\n\r\n\t/**\r\n     * Renders the feature to the canvas\r\n     * @param feature - The feature itself\r\n     * @param coord An object containing information on where to draw the feature\r\n     * px1,px2 the left and right pixels - pw - the width\r\n     * py the top, h - the height\r\n     * @param ctx - The context to draw the feature\r\n     * @param info - An object containing information about the genomic location\r\n     * bpStart.bpPerPixel and pixelWidth\r\n     * \r\n     */\r\n\t\r\n\trenderFeature(feature, coord,ctx,info){\r\n\t\tvar e,x, cy, direction, exon, ePx, ePx1, ePxU, ePw, py2, h2, \r\n            step = 20,\r\n            color = this.config.color;\r\n        if (feature.color) {\r\n            color = feature.color;\r\n        }\r\n  \r\n        ctx.fillStyle = color;\r\n        ctx.strokeStyle = color;\r\n\r\n\r\n        cy = coord.py + coord.h / 2;\r\n        h2 = coord.h / 2;\r\n        py2 = cy - h2 / 2;\r\n\r\n\t\tlet exonCount = feature.exons ? feature.exons.length : 0;\r\n\t\t\tif (exonCount == 0) {\r\n            \t// single-exon transcript\r\n            \tctx.fillRect(coord.px, coord.py, coord.pw, coord.h);\r\n        \t}\r\n        else{\r\n            // multi-exon transcript\r\n            coord.px=Math.max(coord.px,0);\r\n            coord.px1=Math.min(coord.px1,info.pixelWidth);\r\n            Graphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns\r\n            direction = feature.strand == '+' ? 1 : -1;\r\n            \r\n           \r\n          \r\n            for ( x=coord.px + step / 2; x <  coord.px1; x += step) {\r\n\r\n                // draw arrowheads along central line indicating transcribed orientation\r\n                Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\r\n                Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\r\n            }\r\n            for (e = 0; e < exonCount; e++) {\r\n                // draw the exons\r\n                exon = feature.exons[e];\r\n                ePx = Math.round((exon.start - info.bpStart) / info.bpPerPixel);\r\n                ePx1 = Math.round((exon.end - info.bpStart) / info.bpPerPixel);\r\n                ePw = Math.max(1, ePx1 - ePx);\r\n\r\n                if (exon.utr) {\r\n                    ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR\r\n                }\r\n                else {\r\n                    if (exon.cdStart) {\r\n                        ePxU = Math.round((exon.cdStart - info.bpStart) / info.bpPerPixel);\r\n                        ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR\r\n                        ePw -= (ePxU - ePx);\r\n                        ePx = ePxU;\r\n\r\n                    }\r\n                    if (exon.cdEnd) {\r\n                        ePxU = Math.round((exon.cdEnd - info.bpStart) / info.bpPerPixel);\r\n                        ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR\r\n                        ePw -= (ePx1 - ePxU);\r\n                        ePx1 = ePxU;\r\n                    }\r\n\r\n                    ctx.fillRect(ePx, coord.py, ePw, coord.h);\r\n\r\n                    // Arrows\r\n                    if (ePw > step + 5) {\r\n                        ctx.fillStyle = \"white\";\r\n                        ctx.strokeStyle = \"white\";\r\n                        for (x = ePx + step / 2; x < ePx1; x += step) {\r\n                            // draw arrowheads along central line indicating transcribed orientation\r\n                            Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\r\n                            Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\r\n                        }\r\n                        ctx.fillStyle = color;\r\n                        ctx.strokeStyle = color;\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\t}\r\n\r\n\tgetFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\r\n\t\tlet yOffset=coord.y-this.top;\r\n        // We use the featureCache property rather than method to avoid async load.  If the\r\n        // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.\r\n        if (this.feature_source.featureCache) {\r\n\r\n          \r\n               var tolerance = 2 * bpPerPixel,  // We need some tolerance around genomicLocation, start with +/- 2 pixels\r\n                featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance),\r\n                row;\r\n\r\n            if (this.config.displayMode != \"COLLAPSED\") {\r\n                row = (Math.floor)(this.config.displayMode === \"SQUISHED\" ? yOffset / this.config.expandedCallHeight : yOffset / this.config.squishedCallHeight);\r\n            }\r\n\r\n\r\n            if (featureList && featureList.length > 0) {\r\n\r\n\r\n                var popupData = [];\r\n                for (let feature of featureList){\r\n                    if (feature.end >= genomicLocation - tolerance &&\r\n                        feature.start <= genomicLocation + tolerance) {\r\n\r\n                        // If row number is specified use it\r\n                        if ((row === undefined || feature.row === undefined || row === feature.row)&&  feature.display) {\r\n                        \tconsole.log(feature.name);\r\n                           return feature;\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n               \r\n            }\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n}\r\n\r\n\r\nclass MLVBigBedTrack extends MLVBedTrack{\r\n\tconstructor(config){\r\n\t\tsuper(config);\r\n\t\t\r\n\t}\r\n\t_setFeatureSource(){\r\n\t\tthis.feature_source=new _feature_js__WEBPACK_IMPORTED_MODULE_1__[\"BigBedFeatureSource\"](this.config);\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nclass MLVWigTrack extends MLVTrack{\r\n\tconstructor(config){\r\n\t\tsuper(config);\r\n\t\tthis._setFeatureSource();\r\n\t}\r\n\r\n\t_setFeatureSource(){\r\n\t\tthis.feature_source=new _bigwig_js__WEBPACK_IMPORTED_MODULE_0__[\"BWSource\"](this.config);\t\r\n\t}\r\n\r\n\r\n\tdrawScale(pixel_height,ctx){\r\n\t\tif (this.config.scale_link_to){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet bot= pixel_height;\r\n\t\tlet top = 0;\r\n\t\tif (this.scale_link_to){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (this.config.discrete){\r\n\t\t\ttop=this.top;\r\n\t\t\tbot = this.bottom;\r\n\t\t}\r\n\t\tlet range=this.max_y-this.min_y;\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(0,top);\r\n\t\tctx.lineTo(0,bot);\r\n\t\tctx.moveTo(0,top);\r\n\t\tctx.lineTo(20,top);\r\n\t\tctx.moveTo(0,bot);\r\n\t\tctx.lineTo(20,bot);\r\n\t\tctx.font=\"12px Arial\";\r\n\t\tctx.stroke();\r\n\t\tctx.textBaseline=\"top\";\r\n\t\tctx.fillText(this.max_y.toFixed(2),20,top);\r\n\t\tctx.textBaseline=\"alphabetic\";\r\n\t\tctx.fillText(this.min_y,20,bot);\r\n\r\n\t}\r\n\t\r\n\tdrawFeatures(options) {\r\n\t\tlet self = this,\r\n\t    features = options.features,\r\n\t    color=self.config.color,\r\n\t    ctx = options.context,\r\n\t    bpPerPixel = options.bpPerPixel,\r\n\t    bpStart = options.bpStart,\r\n\t    pixelWidth = options.pixelWidth,\r\n\t    pixelHeight =options.pixelHeight,\r\n\t    y_offset=this.config.discrete?options.top:0,\r\n\t    bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\r\n\t    featureValueMinimum,\r\n\t    featureValueMaximum,\r\n\t    featureValueRange,\r\n\t    $dataRangeTrackLabel,\r\n\t    str,\r\n\t    min,\r\n\t    max;\r\n\t    if(this.config.discrete){\r\n\t    \tif (this.config.group){\r\n\t    \t\tpixelHeight=options.height;\r\n\t    \t}\r\n\t    \telse{\r\n\t    \t\t pixelHeight=this.config.height;\r\n\t    \t}\r\n\t    \t\r\n\t    }\r\n\t          \r\n\t    if (!color){\r\n\t    \tcolor=\"black\";       \r\n\t    }\r\n\t    self.prev_coords={x:0,y:0};\r\n\t\t\r\n\t    if (features) {\r\n\t    \tif (self.scale_link_to){\r\n\t    \t\tlet t = self.scale_link_to.config;\r\n\t            if (t){\r\n\t            \tself.config.scale=t.scale;\r\n\t                self.max_y=self.scale_link_to.max_y;\r\n\t                self.min_y=self.scale_link_to.min_y;\r\n\t            }\r\n\t       }\r\n\t       else if ( (self.max_y === undefined && self.config.scale===\"automatic\") || self.config.scale===\"dynamic\"){\r\n\t                var s = autoscale(features);\r\n\t                self.min_y = s.min;\r\n\t                self.max_y = s.max;\r\n\t            }\r\n\t            else if (self.config.scale===\"fixed\") {\r\n\t                self.min_y = self.config.min_y;\r\n\t                self.max_y=self.config.max_y;\r\n\t            }\r\n\t          \r\n\t            featureValueRange = self.max_y - self.min_y;\r\n\r\n\t            //$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\r\n\t            //\r\n\t            //min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\r\n\t            //max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\r\n\t            //str = '[' + min + ' - ' + max + ']';\r\n\t            //\r\n\t            //$dataRangeTrackLabel.text(str);\r\n\t            let prev_x=0;\r\n\t            let prev_y=0;\r\n\t            ctx.globalAlpha   = this.config.opacity?this.config.opacity:1;\r\n\t            if (self.is_line){  \r\n\t                let y = (1.0 - self.config.value / featureValueRange)*pixelHeight;\r\n\t                Graphics.strokeLine(ctx,0,y,pixelWidth,y,{\"strokeStyle\":self.config.color,\"lineWidth\":self.config.width?self.config.width:1});\r\n\t             }\r\n\t            else{\r\n\t            \tfeatures.forEach(renderFeature);\r\n\t            }\r\n\t            ctx.globalAlpha=1\r\n\t        }\r\n\t         \r\n\t        function renderFeature(feature, index, featureList) {\r\n\r\n\t            var yUnitless,\r\n\t                heightUnitLess,\r\n\t                x,\r\n\t                y,\r\n\t                width,\r\n\t                height,\r\n\t                rectEnd,\r\n\t                rectBaseline;\r\n\r\n\t            if (feature.end < bpStart) return;\r\n\t            if (feature.start > bpEnd) return;\r\n\r\n\t            x = Math.floor((feature.start - bpStart) / bpPerPixel);\r\n\t            rectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\r\n\t            width = Math.max(0, rectEnd - x);\r\n\r\n\t            //height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\r\n\t            //rectBaseline = pixelHeight - height;\r\n\t            //canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\r\n\r\n\t            if (signsDiffer(self.min_y, self.max_y)) {\r\n\r\n\t                if (feature.value < 0) {\r\n\t                    yUnitless = self.max_y/ featureValueRange;\r\n\t                    heightUnitLess = -feature.value / featureValueRange;\r\n\t                } else {\r\n\t                    yUnitless = ((self.max_y - feature.value) / featureValueRange);\r\n\t                    heightUnitLess = feature.value / featureValueRange;\r\n\t                }\r\n\r\n\t            }\r\n\t            else if (self.min_y < 0) {\r\n\t                yUnitless = 0;\r\n\t                heightUnitLess = -feature.value / featureValueRange;\r\n\t            }\r\n\t            else {\r\n\t                yUnitless = 1.0 - ((feature.value-self.min_y) / featureValueRange);\r\n\t                heightUnitLess = (feature.value+self.min_y) / featureValueRange;\r\n\t            }\r\n\r\n\t           \ty = (yUnitless*pixelHeight)+y_offset;\r\n\t            y=y<y_offset?y_offset:y;\r\n\t            height=heightUnitLess * pixelHeight;\r\n\t            height=height>pixelHeight?pixelHeight:height\r\n\r\n\t            //canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\r\n\t            if (self.config.display==='line'){\r\n\t                 if (self.prev_coords.x){\r\n\t                    Graphics.strokeLine(ctx,x,y,self.prev_coords.x,self.prev_coords.y,{\"strokeStyle\":color,\"lineWidth\":3});\r\n\r\n\t                }\r\n\t                self.prev_coords.x=x;\r\n\t                self.prev_coords.y=y;\r\n\t            }\r\n\t            else{\r\n\t                Graphics.fillRect(ctx, x, y, width, height, {fillStyle: color});\r\n\t            }\r\n\t        }\r\n\t         function autoscale(features) {\r\n        var min = 0,\r\n            max = -Number.MAX_VALUE;\r\n\r\n        features.forEach(function (f) {\r\n            min = Math.min(min, f.value);\r\n            max = Math.max(max, f.value);\r\n        });\r\n\r\n        return {min: min, max: max};\r\n\r\n    }\r\n\r\n    function signsDiffer(a, b) {\r\n        return (a > 0 && b < 0 || a < 0 && b > 0);\r\n    }\r\n    this.top=y_offset;\r\n    this.bottom=y_offset+pixelHeight;\r\n    if (this.config.discrete){\r\n    \treturn this.bottom;\r\n    }\r\n    else{\r\n    \tthis.top=0;\r\n    \tthis.bottom=0;\r\n    }\r\n\r\n\t    \r\n}\r\n}\r\n class LineTrack extends MLVWigTrack{\r\n\t constructor(config){\r\n\t\t super(config);\r\n\t\t this.is_line=true;\r\n\t }\r\n\t \r\n\t getFeatures(chr, bpStart, bpEnd) {\r\n\t\t return new Promise(function (fulfill, reject) {\r\n\t\t\t fulfill([]);\r\n\t     });\r\n\t }\r\n\t \r\n\t \r\n }\r\n\r\n\r\n\r\n\r\nclass SequenceTrack extends MLVTrack{\r\n    constructor(config){\r\n\t\tsuper(config) \r\n        this._setFeatureSource(config);\r\n        this.sequenceType = config.sequenceType || \"dna\";  \r\n        this.height = 15;\r\n    }\r\n\r\n    _setFeatureSource(config){\r\n    \tthis.feature_source = new _feature_js__WEBPACK_IMPORTED_MODULE_1__[\"FastaSequence\"](config.url);\r\n    }\r\n\r\n\r\n\r\n    getFeatures(chr, bpStart, bpEnd,force,data) {\r\n\t\tlet self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n            if (data.bpPerPixel > 1/*igv.browser.trackViewportWidthBP() > 30000*/) {\r\n                fulfill(null);\r\n            }\r\n            else {\r\n                self.feature_source.getSequence(chr, bpStart, bpEnd).then(fulfill).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    drawFeatures(options) {\r\n\r\n        var sequence = options.features,\r\n            ctx = options.context,\r\n            bpPerPixel = options.bpPerPixel,\r\n            bpStart = options.bpStart,\r\n            pixelWidth = options.pixelWidth,\r\n            bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\r\n            len, w, y, pos, offset, b, p0, p1, pc, c;\r\n\r\n        let y_pos1=options.top;\r\n        let y_pos2=y_pos1+5;\r\n\r\n        if (sequence) {\r\n\r\n            len = sequence.length;\r\n            w = 1 / bpPerPixel;\r\n\r\n            y = y_pos1+this.height / 2;\r\n            for (pos = bpStart; pos <= bpEnd; pos++) {\r\n\r\n                offset = pos - bpStart;\r\n                if (offset < len) {\r\n//                            var b = sequence.charAt(offset);\r\n                    b = sequence[offset];\r\n                    p0 = Math.floor(offset * w);\r\n                    p1 = Math.floor((offset + 1) * w);\r\n                    pc = Math.round((p0 + p1) / 2);\r\n\r\n                    if (this.color) {\r\n                        c = this.color;\r\n                    }\r\n                    else if (\"dna\" === this.sequenceType) {\r\n                        c = Graphics.nucleotideColors[b];\r\n                    }\r\n                    else {\r\n                        c = \"rgb(0, 0, 150)\";\r\n                    }\r\n\r\n                    if (!c) c = \"gray\";\r\n\r\n                    if (bpPerPixel >0.15) {\r\n\r\n                        Graphics.fillRect(ctx, p0, y_pos1, p1 - p0, 10, {fillStyle: c});\r\n                    }\r\n                    else {\r\n\r\n                        Graphics.strokeText(ctx, b, pc, y, {\r\n                            strokeStyle: c,\r\n                            font: 'normal 10px Arial',\r\n                            textAlign: 'center'\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n      return y_pos1+10;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n//*******js/ifv-canvas.js***********************\r\n\r\n\r\nclass Graphics{\r\n\r\n\r\n       static setProperties(ctx, properties) {\r\n\r\n            for (var key in properties) {\r\n                if (properties.hasOwnProperty(key)) {\r\n                    var value = properties[key];\r\n                    ctx[key] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        static strokeLine (ctx, x1, y1, x2, y2, properties) {\r\n\r\n            x1 = Math.floor(x1) + 0.5;\r\n            y1 = Math.floor(y1) + 0.5;\r\n            x2 = Math.floor(x2) + 0.5;\r\n            y2 = Math.floor(y2) + 0.5;\r\n\r\n            //log(\"stroke line, prop: \" + properties);\r\n\r\n            ctx.save();\r\n            if (properties) Graphics.setProperties(ctx, properties);\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x1, y1);\r\n            ctx.lineTo(x2, y2);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n\r\n        static fillRect(ctx, x, y, w, h, properties) {\r\n\r\n            var c;\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n\r\n            if (properties) {\r\n                ctx.save();\r\n                Graphics.setProperties(ctx, properties);\r\n            }\r\n            \r\n            ctx.fillRect(x, y, w, h);\r\n\r\n            if (properties) ctx.restore();\r\n        }\r\n\r\n        static fillPolygon(ctx, x, y, properties) {\r\n            ctx.save();\r\n            if (properties)   Graphics.setProperties(ctx, properties);\r\n            Graphics.doPath(ctx, x, y);\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        static strokePolygon(ctx, x, y, properties) {\r\n            ctx.save();\r\n            if (properties)   Graphics.setProperties(ctx, properties);\r\n            Graphics.doPath(ctx, x, y);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n\r\n        static fillText(ctx, text, x, y, properties, transforms) {\r\n\r\n            if (properties) {\r\n                ctx.save();\r\n                Graphics.setProperties(ctx, properties);\r\n            }\r\n\r\n\r\n            ctx.save();\r\n\r\n            ctx.translate(x, y);\r\n            if (transforms) {\r\n\r\n                for (var transform in transforms) {\r\n                    var value = transforms[transform];\r\n\r\n                    // TODO: Add error checking for robustness\r\n                    if (transform == 'translate') {\r\n                        ctx.translate(value['x'], value['y']);\r\n                    }\r\n                    if (transform == 'rotate') {\r\n                        ctx.rotate(value['angle'] * Math.PI / 180);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            ctx.fillText(text, 0, 0);\r\n            ctx.restore();\r\n\r\n            if (properties) ctx.restore();\r\n\r\n        }\r\n\r\n        static strokeText(ctx, text, x, y, properties, transforms) {\r\n\r\n\r\n            ctx.save();\r\n            if (properties) {\r\n                Graphics.setProperties(ctx, properties);\r\n            }\r\n\r\n\r\n            ctx.translate(x, y);\r\n            if (transforms) {\r\n\r\n                for (var transform in transforms) {\r\n                    var value = transforms[transform];\r\n\r\n                    // TODO: Add error checking for robustness\r\n                    if (transform == 'translate') {\r\n                        ctx.translate(value['x'], value['y']);\r\n                    }\r\n                    if (transform == 'rotate') {\r\n                        ctx.rotate(value['angle'] * Math.PI / 180);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            ctx.strokeText(text, 0, 0);\r\n            ctx.restore();\r\n\r\n        }\r\n\r\n        static strokeCircle(ctx, x, y, radius) {\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\r\n            ctx.stroke();\r\n        }\r\n\r\n        static fillCircle (ctx, x, y, radius) {\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\r\n            ctx.fill();\r\n        }\r\n\r\n        static drawArrowhead(ctx, x, y, size, lineWidth) {\r\n\r\n            ctx.save();\r\n            if (!size) {\r\n                size = 5;\r\n            }\r\n            if (lineWidth) {\r\n                ctx.lineWidth = lineWidth;\r\n            }\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, y - size / 2);\r\n            ctx.lineTo(x, y + size / 2);\r\n            ctx.lineTo(x + size, y);\r\n            ctx.lineTo(x, y - size / 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        static dashedLine(ctx, x1, y1, x2, y2, dashLen, properties) {\r\n            ctx.save();\r\n            x1 = Math.round(x1);\r\n            y1 = Math.round(y1);\r\n            x2 = Math.round(x2);\r\n            y2 = Math.round(y2);\r\n            dashLen = Math.round(dashLen);\r\n            log(\"dashedLine\");\r\n            if (properties) Graphics.setProperties(ctx, properties);\r\n\r\n            if (dashLen == undefined) dashLen = 2;\r\n            ctx.moveTo(x1, y1);\r\n\r\n            var dX = x2 - x1;\r\n            var dY = y2 - y1;\r\n            var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\r\n            var dashX = dX / dashes;\r\n            var dashY = dY / dashes;\r\n\r\n            var q = 0;\r\n            while (q++ < dashes) {\r\n                x1 += dashX;\r\n                y1 += dashY;\r\n                ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x1, y1);\r\n            }\r\n            ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x2, y2);\r\n\r\n            ctx.restore();\r\n        }\r\n\r\n\r\n    \r\n\r\n        static doPath(ctx, x, y) {\r\n\r\n\r\n        \tvar i, len = x.length;\r\n        \tfor (i = 0; i < len; i++) {\r\n        \t\tx[i] = Math.round(x[i]);\r\n        \t\ty[i] = Math.round(y[i]);\r\n        \t}\r\n\r\n        \tctx.beginPath();\r\n        \tctx.moveTo(x[0], y[0]);\r\n        \tfor (i = 1; i < len; i++) {\r\n        \t\tctx.lineTo(x[i], y[i]);\r\n        \t}\r\n        \tctx.closePath();\r\n        }\r\n\r\n}\r\n\r\nGraphics.nucleotideColors={\r\n\t\"A\":\"green\",\r\n\t\"T\":\"red\",\r\n\t\"G\":\"black\",\r\n\t\"C\":\"blue\",\r\n\t\"a\":\"green\",\r\n\t\"t\":\"red\",\r\n\t\"c\":\"black\",\r\n\t\"g\":\"blue\"\r\n\r\n}\r\n\r\n\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! extend */ \"extend\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJhY2tzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3RyYWNrcy5qcz8yOWQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuXHJcblxyXG5pbXBvcnQge0JXU291cmNlfSBmcm9tIFwiLi9iaWd3aWcuanNcIjtcclxuaW1wb3J0IHtGZWF0dXJlU291cmNlLEZhc3RhU2VxdWVuY2UsQmlnQmVkRmVhdHVyZVNvdXJjZX0gZnJvbSBcIi4vZmVhdHVyZS5qc1wiO1xyXG5cclxuXHJcbmNsYXNzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHR0aGlzLmNvbmZpZz1jb25maWc7XHJcblx0fVxyXG5cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0Ly9vdmVycmlkZW4gYnkgdHJhY2tzIHdpdGggZmVhdHVyZSBzb3VyY2VzXHJcblx0fVxyXG5cclxuXHRkcmF3U2NhbGUoY3R4KXtcclxuXHRcdC8vb3ZlcmlkZGVuIGluIHRyYWNrcyB3aXRoIHNjYWxlXHJcblx0fVxyXG5cclxuXHRnZXRDb25maWcoKXtcclxuXHRcdHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5jb25maWcpO1xyXG5cdH1cclxuXHJcblx0c2V0Q29uZmlnQXR0cmlidXRlKGF0dHJpYnV0ZSx2YWx1ZSl7XHJcblx0XHR0aGlzLmNvbmZpZ1thdHRyaWJ1dGVdPXZhbHVlO1xyXG4gICAgXHRpZiAoYXR0cmlidXRlPT09XCJ1cmxcIil7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcbiAgICBnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIseU9mZnNldCwgYnBQZXJQaXhlbCl7XHJcbiAgICBcdHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHNldENvbmZpZyhjb25maWcpe1xyXG4gICAgXHRpZiAodGhpcy5jb25maWcudXJsICE9PSBjb25maWcudXJsKXtcclxuICAgIFx0XHR0aGlzLmNvbmZpZz1jb25maWc7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICBcdGVsc2V7XHJcbiAgICBcdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG4gICAgXHR9XHJcbiAgICB9XHJcblx0XHJcblx0Z2V0RmVhdHVyZXMgKGNociwgYnBTdGFydCwgYnBFbmQsZm9yY2UsZGF0YSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZ2V0RmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZm9yY2UsZGF0YSk7XHJcblx0fVxyXG5cclxuXHJcblx0c3RhdGljIGNhbGN1bGF0ZUxhYmVsKHVybCl7XHJcblx0XHRpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIil7XHJcblx0XHRcdHVybCA9IHVybFswXTtcclxuXHRcdH1cclxuXHRcdGxldCBhcnIgPXVybC5zcGxpdChcIi9cIik7XHJcblx0XHRsZXQgbGFiZWw9IGFyclthcnIubGVuZ3RoLTFdO1xyXG5cdFx0YXJyPSBsYWJlbC5zcGxpdChcIi5cIik7XHJcblx0XHRsYWJlbCA9IGFyclswXTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9XHJcblxyXG5cdGFkZEV4dHJhQ29udHJvbHMoZGl2LHBhbmVsKXtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXRUeXBlRnJvbVVSTCh1cmwpe1xyXG5cdFx0bGV0IGNvbmZpZz17fVxyXG5cdFx0aWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnO1xyXG5cdFx0fVxyXG5cdFx0XHRpZiAodXJsLmVuZHNXaXRoKFwiYndcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmlnd2lnXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cIndpZ1wiO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5iZWQuZ3pcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmVkXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIlxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh1cmwuZW5kc1dpdGgoXCIuYmJcIikgJiYgIShjb25maWcudHlwZSkpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmlnYmVkXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIlxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh1cmwuZW5kc1dpdGgoXCIuZmFzdGFcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiZmFzdGFcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwic2VxdWVuY2VcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh1cmwuZW5kc1dpdGgoXCIuYmFtXCIpKXtcclxuXHRcdFx0XHRjb25maWcudHlwZT1cImJhbVwiO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9XCJhbGlnbm1lbnRcIjtcclxuXHRcdFx0fVxyXG5cdFx0cmV0dXJuIGNvbmZpZztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgcGFyc2VDb25maWcoY29uKXtcclxuXHRcdGxldCBjb25maWcgPSAkLmV4dGVuZCh0cnVlLCB7fSxjb24pO1xyXG5cdFx0XHJcblx0XHRpZiAoKCFjb25maWcudHlwZSB8fCAhY29uZmlnLmZvcm1hdCkgJiYgY29uZmlnLnVybCl7XHJcblx0XHRcdGxldCBpbmZvID0gTUxWVHJhY2suZ2V0VHlwZUZyb21VUkwoY29uZmlnLnVybCk7XHJcblx0XHRcdGlmIChpbmZvLnR5cGUpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPWluZm8udHlwZTtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PWluZm8uZm9ybWF0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoIWNvbmZpZy5zaG9ydF9sYWJlbCAmJiBjb25maWcudXJsKXtcclxuXHRcdFx0Y29uZmlnLnNob3J0X2xhYmVsPU1MVlRyYWNrLmNhbGN1bGF0ZUxhYmVsKGNvbmZpZy51cmwpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZiAoIWNvbmZpZy50cmFja19pZCl7XHJcblx0XHRcdGNvbmZpZy50cmFja19pZD1jb25maWcudXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuZm9ybWF0PT09XCJmZWF0dXJlXCIpe1xyXG5cdFx0XHRjb25maWcuZGlzcGxheU1vZGUgPSBjb25maWcuZGlzcGxheU1vZGUgfHwgXCJDT0xMQVBTRURcIjsgICAgLy8gQ09MTEFQU0VEIHwgRVhQQU5ERUQgfCBTUVVJU0hFRFxyXG4gICAgICAgIFx0Y29uZmlnLmxhYmVsRGlzcGxheU1vZGUgPSBcIlNMQU5UXCI7XHJcbiAgICAgICAgXHRjb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0ID0gY29uZmlnLnNxdWlzaGVkQ2FsbEhlaWdodCB8fCAzMDtcclxuICAgICAgICBcdGNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgPSBjb25maWcuZXhwYW5kZWRDYWxsSGVpZ2h0IHx8IDE1O1xyXG4gICAgICAgIFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9Y29uZmlnLmZlYXR1cmVIZWlnaHQgfHwgMTI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5mb3JtYXQ9PT1cIndpZ1wiKXtcclxuXHRcdFx0aWYgKCFjb25maWcuc2NhbGUpe1xyXG5cdFx0XHRcdGNvbmZpZy5zY2FsZT1cImF1dG9tYXRpY1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghY29uZmlnLm1pbl95KXtcclxuXHRcdFx0XHRjb25maWcubWluX3k9MDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5tYXh5X3kpe1xyXG5cdFx0XHRcdGNvbmZpZy5tYXhfeT0xMDA7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFjb25maWcuaGVpZ2h0KXtcclxuXHRcdFx0XHRjb25maWcuaGVpZ2h0PTEwMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbmZpZy50eXBlPT09XCJiYW1cIil7XHJcblx0XHRcdGlmICghY29uZmlnLmZlYXR1cmVIZWlnaHQpe1xyXG5cdFx0XHRcdGNvbmZpZy5mZWF0dXJlSGVpZ2h0PTEyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjb25maWcuY29sb3Ipe1xyXG5cdFx0XHRpZiAoY29uZmlnLnR5cGU9PT1cImJhbVwiKXtcclxuXHRcdFx0XHRjb25maWcuY29sb3I9XCIjRDNEM0QzXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRjb25maWcuY29sb3I9XCJibGFja1wiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoIWNvbmZpZy5vcGFjaXR5KXtcclxuXHRcdFx0Y29uZmlnLm9wYWNpdHk9MS4wO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNvbmZpZztcclxuXHR9XHJcblxyXG5cclxuXHRcclxuXHRzdGF0aWMgZ2V0VHJhY2soY29uZmlnKXtcclxuXHJcblx0XHRjb25maWc9TUxWVHJhY2sucGFyc2VDb25maWcoY29uZmlnKTtcclxuXHRcdFxyXG5cdFx0aWYgKGNvbmZpZy50eXBlPT09XCJiaWd3aWdcIil7XHJcblx0XHRcdHJldHVybiBuZXcgTUxWV2lnVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbmZpZy50eXBlPT09XCJiZWRcIil7XHJcblx0XHRcdHJldHVybiBuZXcgTUxWQmVkVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbmZpZy50eXBlPT09XCJ1Y3NjXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IFVDU0NUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29uZmlnLnR5cGU9PT1cImxpbmVcIil7XHJcblx0XHRcdHJldHVybiBuZXcgTGluZVRyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChjb25maWcudHlwZT09PVwiYmlnYmVkXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IE1MVkJpZ0JlZFRyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChjb25maWcudHlwZT09PVwicnVsZXJcIil7XHJcblx0XHRcdHJldHVybiBuZXcgUnVsZXJUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29uZmlnLnR5cGU9PT1cImZhc3RhXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IFNlcXVlbmNlVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0ZWxzZXtcclxuXHRcdFx0XHJcblx0XHRcdGxldCBjbGFzc190eXBlID0gTUxWVHJhY2suY3VzdG9tX3RyYWNrc1tjb25maWcudHlwZV07XHJcblx0XHRcdGlmIChjbGFzc190eXBlKXtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IGNsYXNzX3R5cGUoY29uZmlnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblx0XHRcclxufVxyXG5cclxuTUxWVHJhY2suY3VzdG9tX3RyYWNrcz17fTtcclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyoqKioqKioqKioqKioqKioqKipqcy9ydWxlclRyYWNrLmpzKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNsYXNzIFJ1bGVyVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0aWYgKCFjb25maWcpe1xyXG5cdFx0XHRjb25maWc9e1widHJhY2tfaWRcIjpcInJ1bGVyXCIrUnVsZXJUcmFjay5jb3VudCxmb3JtYXQ6XCJydWxlclwiLHNob3J0X2xhYmVsOlwiUnVsZXJcIix0eXBlOlwicnVsZXJcIn07XHJcblx0XHR9XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMzA7XHJcbiAgICAgICAgdGhpcy5jb25maWcuaGVpZ2h0PTMwO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XHJcbiAgICAgICBcclxuICAgICAgICB0aGlzLmRpc2FibGVCdXR0b25zID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlnbm9yZVRyYWNrTWVudSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vcmRlciA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICBcclxuICAgICAgICBSdWxlclRyYWNrLmNvdW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdWxmaWxsKFtdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3RmVhdHVyZXMob3B0aW9ucykge1xyXG5cclxuICAgICAgICB2YXIgZm9udFN0eWxlLFxyXG4gICAgICAgICAgICBjdHggPSBvcHRpb25zLmNvbnRleHQsXHJcbiAgICAgICAgICAgIHJhbmdlLFxyXG4gICAgICAgICAgICB0cyxcclxuICAgICAgICAgICAgc3BhY2luZyxcclxuICAgICAgICAgICAgblRpY2ssXHJcbiAgICAgICAgICAgIHg7XHJcblxyXG4gICAgICAgIGZvbnRTdHlsZSA9IHsgdGV4dEFsaWduOiAnY2VudGVyJywgZm9udDogJzEwcHggUFQgU2FucycsIGZpbGxTdHlsZTogXCJyZ2JhKDY0LCA2NCwgNjQsIDEpXCIsIHN0cm9rZVN0eWxlOiBcInJnYmEoNjQsIDY0LCA2NCwgMSlcIiB9O1xyXG5cclxuICAgICAgICByYW5nZSA9IE1hdGguZmxvb3IoMTEwMCAqIG9wdGlvbnMuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgdHMgPSBSdWxlclRyYWNrLmZpbmRTcGFjaW5nKHJhbmdlKTtcclxuICAgICAgICBzcGFjaW5nID0gdHMubWFqb3JUaWNrO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHN0YXJ0aW5nIHBvaW50IGNsb3Nlc3QgdG8gdGhlIGN1cnJlbnQgb3JpZ2luXHJcbiAgICAgICAgblRpY2sgPSBNYXRoLmZsb29yKG9wdGlvbnMuYnBTdGFydCAvIHNwYWNpbmcpIC0gMTtcclxuICAgICAgICB4ID0gMDtcclxuXHRcdGxldCB5X3Bvcz1vcHRpb25zLnRvcCt0aGlzLmhlaWdodDtcclxuICAgICAgICAvL2NhbnZhcy5zZXRQcm9wZXJ0aWVzKHt0ZXh0QWxpZ246ICdjZW50ZXInfSk7XHJcbiAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIGZvbnRTdHlsZSApO1xyXG4gICAgICAgIHdoaWxlICh4IDwgb3B0aW9ucy5waXhlbFdpZHRoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbCA9IE1hdGguZmxvb3IoblRpY2sgKiBzcGFjaW5nKSxcclxuICAgICAgICAgICAgICAgIHNoaW0gPSAyO1xyXG5cclxuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoKChsIC0gMSkgLSBvcHRpb25zLmJwU3RhcnQgKyAwLjUpIC8gb3B0aW9ucy5icFBlclBpeGVsKTtcclxuICAgICAgICAgICAgdmFyIGNoclBvc2l0aW9uID0gZm9ybWF0TnVtYmVyKGwgLyB0cy51bml0TXVsdGlwbGllciwgMCkgKyBcIiBcIiArIHRzLm1ham9yVW5pdDtcclxuXHJcbiAgICAgICAgICAgIGlmIChuVGljayAlIDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3MuZmlsbFRleHQoY3R4LCBjaHJQb3NpdGlvbiwgeCwgeV9wb3MgLSAxNSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4LCB5X3BvcyAtIDEwLCB4LCB5X3BvcyAtIHNoaW0pO1xyXG5cclxuICAgICAgICAgICAgblRpY2srKztcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIDAsIHlfcG9zIC0gc2hpbSwgb3B0aW9ucy5waXhlbFdpZHRoLCB5X3BvcyAtIHNoaW0pO1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGFueW51bSwgZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAvL2RlY2ltYWwgIC0gdGhlIG51bWJlciBvZiBkZWNpbWFscyBhZnRlciB0aGUgZGlnaXQgZnJvbSAwIHRvIDNcclxuICAgICAgICAgICAgLy8tLSBSZXR1cm5zIHRoZSBwYXNzZWQgbnVtYmVyIGFzIGEgc3RyaW5nIGluIHRoZSB4eHgseHh4Lnh4IGZvcm1hdC5cclxuICAgICAgICAgICAgLy9hbnludW0gPSBldmFsKG9iai52YWx1ZSk7XHJcbiAgICAgICAgICAgIHZhciBkaXZpZGVyID0gMTA7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxMDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogICAgICAgLy9mb3IgMyBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZXIgPSAxMDAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgd29ya051bSA9IE1hdGguYWJzKChNYXRoLnJvdW5kKGFueW51bSAqIGRpdmlkZXIpIC8gZGl2aWRlcikpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHdvcmtTdHIgPSBcIlwiICsgd29ya051bVxyXG5cclxuICAgICAgICAgICAgaWYgKHdvcmtTdHIuaW5kZXhPZihcIi5cIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHdvcmtTdHIgKz0gXCIuXCJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRTdHIgPSB3b3JrU3RyLnN1YnN0cigwLCB3b3JrU3RyLmluZGV4T2YoXCIuXCIpKTtcclxuICAgICAgICAgICAgdmFyIGROdW0gPSBkU3RyIC0gMFxyXG4gICAgICAgICAgICB2YXIgcFN0ciA9IHdvcmtTdHIuc3Vic3RyKHdvcmtTdHIuaW5kZXhPZihcIi5cIikpXHJcblxyXG4gICAgICAgICAgICB3aGlsZSAocFN0ci5sZW5ndGggLSAxIDwgZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgcFN0ciArPSBcIjBcIlxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocFN0ciA9PSAnLicpIHBTdHIgPSAnJztcclxuXHJcbiAgICAgICAgICAgIC8vLS0tIEFkZHMgYSBjb21tYSBpbiB0aGUgdGhvdXNhbmRzIHBsYWNlLlxyXG4gICAgICAgICAgICBpZiAoZE51bSA+PSAxMDAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZExlbiA9IGRTdHIubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBkU3RyID0gcGFyc2VJbnQoXCJcIiArIChkTnVtIC8gMTAwMCkpICsgXCIsXCIgKyBkU3RyLnN1YnN0cmluZyhkTGVuIC0gMywgZExlbilcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8tLSBBZGRzIGEgY29tbWEgaW4gdGhlIG1pbGxpb25zIHBsYWNlLlxyXG4gICAgICAgICAgICBpZiAoZE51bSA+PSAxMDAwMDAwKSB7XHJcbiAgICAgICAgICAgICAgICBkTGVuID0gZFN0ci5sZW5ndGhcclxuICAgICAgICAgICAgICAgIGRTdHIgPSBwYXJzZUludChcIlwiICsgKGROdW0gLyAxMDAwMDAwKSkgKyBcIixcIiArIGRTdHIuc3Vic3RyaW5nKGRMZW4gLSA3LCBkTGVuKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXR2YWwgPSBkU3RyICsgcFN0clxyXG4gICAgICAgICAgICAvLy0tIFB1dCBudW1iZXJzIGluIHBhcmVudGhlc2VzIGlmIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBpZiAoYW55bnVtIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXCIoXCIgKyByZXR2YWwgKyBcIilcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9Zb3UgY291bGQgaW5jbHVkZSBhIGRvbGxhciBzaWduIGluIHRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICAgICAgICAgIC8vcmV0dmFsID0gIFwiJFwiK3JldHZhbFxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geV9wb3M7XHJcblxyXG5cclxuICAgIH1cclxuICAgIHN0YXRpYyBmaW5kU3BhY2luZyhtYXhWYWx1ZSkge1xyXG5cclxuICAgICAgICBpZiAobWF4VmFsdWUgPCAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpY2tTcGFjaW5nKDEsIFwiXCIsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vIE5vdyBtYW4gemVyb2VzP1xyXG4gICAgICAgIHZhciBuWmVyb2VzID0gTWF0aC5mbG9vcihsb2cxMChtYXhWYWx1ZSkpO1xyXG4gICAgICAgIHZhciBtYWpvclVuaXQgPSBcIlwiO1xyXG4gICAgICAgIHZhciB1bml0TXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgaWYgKG5aZXJvZXMgPiA5KSB7XHJcbiAgICAgICAgICAgIG1ham9yVW5pdCA9IFwiZ2JcIjtcclxuICAgICAgICAgICAgdW5pdE11bHRpcGxpZXIgPSAxMDAwMDAwMDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoblplcm9lcyA+IDYpIHtcclxuICAgICAgICAgICAgbWFqb3JVbml0ID0gXCJtYlwiO1xyXG4gICAgICAgICAgICB1bml0TXVsdGlwbGllciA9IDEwMDAwMDA7XHJcbiAgICAgICAgfSBlbHNlIGlmIChuWmVyb2VzID4gMykge1xyXG4gICAgICAgICAgICBtYWpvclVuaXQgPSBcImtiXCI7XHJcbiAgICAgICAgICAgIHVuaXRNdWx0aXBsaWVyID0gMTAwMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuTWFqb3JUaWNrcyA9IG1heFZhbHVlIC8gTWF0aC5wb3coMTAsIG5aZXJvZXMgLSAxKTtcclxuICAgICAgICBpZiAobk1ham9yVGlja3MgPCAyNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpY2tTcGFjaW5nKE1hdGgucG93KDEwLCBuWmVyb2VzIC0gMSksIG1ham9yVW5pdCwgdW5pdE11bHRpcGxpZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGlja1NwYWNpbmcoTWF0aC5wb3coMTAsIG5aZXJvZXMpIC8gMiwgbWFqb3JVbml0LCB1bml0TXVsdGlwbGllcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsb2cxMCh4KSB7XHJcbiAgICAgICAgICAgIHZhciBkbiA9IE1hdGgubG9nKDEwKTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gZG47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuUnVsZXJUcmFjay5jb3VudD0wO1xyXG5cclxuY2xhc3MgVGlja1NwYWNpbmd7XHJcblx0Y29uc3RydWN0b3IobWFqb3JUaWNrLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKSB7XHJcbiAgICAgICAgdGhpcy5tYWpvclRpY2sgPSBtYWpvclRpY2s7XHJcbiAgICAgICAgdGhpcy5tYWpvclVuaXQgPSBtYWpvclVuaXQ7XHJcbiAgICAgICAgdGhpcy51bml0TXVsdGlwbGllciA9IHVuaXRNdWx0aXBsaWVyO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuIFxyXG5jbGFzcyBNTFZCZWRUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG5cdFx0dGhpcy5maWx0ZXJfZnVuY3Rpb249bnVsbDtcclxuXHRcdHRoaXMuY29sb3JfZnVuY3Rpb249bnVsbDtcclxuXHRcdFxyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9IG5ldyBGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnKVxyXG5cdH1cclxuXHJcblx0c2V0RmlsdGVyRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmZpbHRlcl9mdW5jdGlvbj1mdW5jO1xyXG5cdH1cclxuXHRzZXRDb2xvckZ1bmN0aW9uKGZ1bmMpe1xyXG5cdFx0dGhpcy5jb2xvcl9mdW5jdGlvbj1mdW5jO1xyXG5cdH1cclxuXHJcblx0Z2V0Q3VycmVudEZlYXR1cmVzKGNocixzdGFydCxlbmQpe1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZmVhdHVyZUNhY2hlLnF1ZXJ5RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCk7XHJcblx0fVxyXG5cdFxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgbWF4X3lfdmFsPTA7XHJcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcyxcclxuICAgICAgICBcdHB5LFxyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdCA9IG9wdGlvbnMuZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuICAgICAgICAgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuICAgICAgICAgICAgcGl4ZWxIZWlnaHQgPSBvcHRpb25zLnBpeGVsSGVpZ2h0LFxyXG4gICAgICAgICAgICBvZmZzZXQ9MCxcclxuICAgICAgICAgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxO1xyXG5cdCBcdGxldCB0b3A9MDtcclxuICAgICAgIFx0aWYob3B0aW9ucy50b3Ape1xyXG4gICAgICAgICAgIHRvcD1vcHRpb25zLnRvcDtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHR0aGlzLnRvcD10b3A7XHJcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICBsZXQgd2luZG93WCA9IDA7XHJcbiAgICAgICAgbGV0IHdpbmRvd1gxID0gd2luZG93WCArIHBpeGVsV2lkdGg7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnLnNxdWlzaGVkQ2FsbEhlaWdodCA9IHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQrMTA7XHJcbiAgICAgICAgdGhpcy5jb25maWcuZXhwYW5kZWRDYWxsSGVpZ2h0ID0gKHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQvMikrMjtcclxuICAgICAgICBsZXQga2k9bnVsbDtcclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QubGVuZ3RoPjUwMDAwKXtcclxuICAgICAgICBcdGtpPU1hdGgucm91bmQoZmVhdHVyZUxpc3QubGVuZ3RoLzUwMDAwKSsxO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QpIHtcclxuICAgICAgICBcdGxldCBvcGFjaXR5ID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcbiAgICAgICAgXHRjdHguZ2xvYmFsQWxwaGE9b3BhY2l0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGdlbmUsIGkgPSAwLCBsZW4gPSBmZWF0dXJlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBcdGlmIChraSAmJiBpJWtpIT09MCl7XHJcbiAgICAgICAgICAgIFx0XHRjb250aW51ZTtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICBnZW5lID0gZmVhdHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJfZnVuY3Rpb24gJiYgIXRoaXMuZmlsdGVyX2Z1bmN0aW9uKGdlbmUpKXtcclxuICAgICAgICAgICAgICAgIFx0Z2VuZS5kaXNwbGF5PWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgXHRjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdlbmUuZGlzcGxheT10cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmUuZW5kIDwgYnBTdGFydCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZS5zdGFydCA+IGJwRW5kKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuY2FsY3VsYXRlRmVhdHVyZUNvb3JkaW5hdGVzKGdlbmUsIGJwU3RhcnQsYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGNvbmYuZmVhdHVyZUhlaWdodFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmYuZGlzcGxheU1vZGUgPT09IFwiU1FVSVNIRURcIiAmJiBnZW5lLnJvdyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgXHRcdGggPSBjb25mLmZlYXR1cmVIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBcdFx0cHkgPSBjb25mLmV4cGFuZGVkQ2FsbEhlaWdodCAqIGdlbmUucm93ICsgMjtcclxuICAgICAgICBcdFx0fSBlbHNlIGlmIChjb25mLmRpc3BsYXlNb2RlID09PSBcIkVYUEFOREVEXCIgJiYgZ2VuZS5yb3cgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIFx0XHRweSA9IGNvbmYuc3F1aXNoZWRDYWxsSGVpZ2h0ICogZ2VuZS5yb3cgKyA1O1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgICAgICAgLy8gY29sbGFwc2VkXHJcbiAgICAgICAgICAgXHRcdFx0IHB5ID0gNTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRweSs9dG9wO1xyXG4gICAgICAgIFx0XHRpZiAocHkraD5tYXhfeV92YWwpe1xyXG4gICAgICAgIFx0XHRcdG1heF95X3ZhbD1weStoO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGNvb3JkLnB5PXB5O1xyXG4gICAgICAgIFx0XHRjb29yZC5oPWg7XHJcbiAgICAgICAgXHRcdGxldCBpbmZvPXticFBlclBpeGVsOmJwUGVyUGl4ZWwsYnBTdGFydDpicFN0YXJ0LHBpeGVsV2lkdGg6cGl4ZWxXaWR0aH1cclxuICAgICAgICBcdFx0aWYgKHRoaXMuY29sb3JfZnVuY3Rpb24pe1xyXG4gICAgICAgIFx0XHRcdGdlbmUuY29sb3I9dGhpcy5jb2xvcl9mdW5jdGlvbihnZW5lKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZShnZW5lLGNvb3JkLGN0eCxpbmZvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZUxhYmVsKGN0eCwgZ2VuZSwgY29vcmQucHgsIGNvb3JkLnB4MSwgcHksIHdpbmRvd1gsIHdpbmRvd1gxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGE9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gZmVhdHVyZSBsaXN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdHRvbT1tYXhfeV92YWw7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRpc3BsYXlNb2RlPT09XCJDT0xMQVBTRURcIil7XHJcbiAgICAgICAgXHRtYXhfeV92YWwrPTI1O1xyXG4gICAgICAgIH1cdFxyXG4gICAgXHRyZXR1cm4gbWF4X3lfdmFsO1xyXG4gICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgIFxyXG5cclxuICAgIFxyXG4gIFxyXG5cdCAvKipcclxuICAgICAqIEBwYXJhbSBjdHggICAgICAgdGhlIGNhbnZhcyAyZCBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVYICBmZWF0dXJlIHN0YXJ0IHgtY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVYMSBmZWF0dXJlIGVuZCB4LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlWSAgZmVhdHVyZSB5LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aW5kb3dYICAgdmlzaWJsZSB3aW5kb3cgc3RhcnQgeC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gd2luZG93WDEgIHZpc2libGUgd2luZG93IGVuZCB4LWNvb3JkaW5hdGVcclxuICAgICAqL1xyXG4gIFxyXG5cclxuXHJcblxyXG5cdHJlbmRlckZlYXR1cmVMYWJlbChjdHgsIGZlYXR1cmUsIGZlYXR1cmVYLCBmZWF0dXJlWDEsIGZlYXR1cmVZLCB3aW5kb3dYLCB3aW5kb3dYMSkge1xyXG5cdFx0bGV0IGluZm8gPSB0aGlzLmNvbmZpZztcclxuICAgICAgICB2YXIgZ2VuZUNvbG9yLCBnZW5lRm9udFN0eWxlLCB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIGJveFgsIGJveFgxLCAgICAvLyBsYWJlbCBzaG91bGQgYmUgY2VudGVyZWQgYmV0d2VlbiB0aGVzZSB0d28geC1jb29yZGluYXRlc1xyXG4gICAgICAgICAgICBsYWJlbFgsIGxhYmVsWSxcclxuICAgICAgICAgICAgdGV4dEZpdHNJbkJveDtcclxuXHJcbiAgICAgICAgLy8gZmVhdHVyZSBvdXRzaWRlIG9mIHZpZXdhYmxlIHdpbmRvd1xyXG4gICAgICAgIGlmIChmZWF0dXJlWDEgPCB3aW5kb3dYIHx8IGZlYXR1cmVYID4gd2luZG93WDEpIHtcclxuICAgICAgICAgICAgYm94WCA9IGZlYXR1cmVYO1xyXG4gICAgICAgICAgICBib3hYMSA9IGZlYXR1cmVYMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjZW50ZXIgbGFiZWwgd2l0aGluIHZpc2libGUgcG9ydGlvbiBvZiB0aGUgZmVhdHVyZVxyXG4gICAgICAgICAgICBib3hYID0gTWF0aC5tYXgoZmVhdHVyZVgsIHdpbmRvd1gpO1xyXG4gICAgICAgICAgICBib3hYMSA9IE1hdGgubWluKGZlYXR1cmVYMSwgd2luZG93WDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG5cclxuICAgICAgICAvL2lmIChpZ3YuYnJvd3Nlci5zZWxlY3Rpb24gJiYgXCJnZW5lc1wiID09PSB0aGlzLmNvbmZpZy50eXBlICYmIGZlYXR1cmUubmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLS0gZm9yIGd0ZXgsIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcclxuICAgICAgICAgICAgLy9nZW5lQ29sb3IgPSBpZ3YuYnJvd3Nlci5zZWxlY3Rpb24uY29sb3JGb3JHZW5lKGZlYXR1cmUubmFtZSk7XHJcbiAgICAgIC8vICB9XHJcblxyXG4gICAgICAgIHRleHRGaXRzSW5Cb3ggPSAoYm94WDEgLSBib3hYKSA+IGN0eC5tZWFzdXJlVGV4dChmZWF0dXJlLm5hbWUpLndpZHRoO1xyXG4gICAgICAgIC8vZ2VuZUNvbG9yPVwiYmxhY2tcIjtcclxuXHJcbiAgICAgICAgaWYgKCh0ZXh0Rml0c0luQm94IHx8IGdlbmVDb2xvcikgJiYgaW5mby5kaXNwbGF5TW9kZSAhPSBcIlNRVUlTSEVEXCIgJiYgZmVhdHVyZS5uYW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZ2VuZUZvbnRTdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgIGZvbnQ6ICcxMHB4IFBUIFNhbnMnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogZ2VuZUNvbG9yIHx8IGluZm8uY29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogZ2VuZUNvbG9yIHx8IGluZm8uY29sb3JcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLmRpc3BsYXlNb2RlID09PSBcIkNPTExBUFNFRFwiICYmIGluZm8ubGFiZWxEaXNwbGF5TW9kZSA9PT0gXCJTTEFOVFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSB7cm90YXRlOiB7YW5nbGU6IDQ1fX07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2VuZUZvbnRTdHlsZS50ZXh0QWxpZ247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhYmVsWCA9IGJveFggKyAoKGJveFgxIC0gYm94WCkgLyAyKTtcclxuICAgICAgICAgICAgbGFiZWxZID0gZ2V0RmVhdHVyZUxhYmVsWShmZWF0dXJlWSwgdHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxUZXh0KGN0eCwgZmVhdHVyZS5uYW1lLCBsYWJlbFgsIGxhYmVsWSwgZ2VuZUZvbnRTdHlsZSwgdHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RmVhdHVyZUxhYmVsWShmZWF0dXJlWSwgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgXHRyZXR1cm4gdHJhbnNmb3JtID8gZmVhdHVyZVkgKyBpbmZvLmZlYXR1cmVIZWlnaHQrMTQgOiBmZWF0dXJlWSArIGluZm8uZmVhdHVyZUhlaWdodCs3O1xyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0Y2FsY3VsYXRlRmVhdHVyZUNvb3JkaW5hdGVzKGZlYXR1cmUsIGJwU3RhcnQsIHhTY2FsZSkge1xyXG4gICAgXHR2YXIgcHggPSBNYXRoLnJvdW5kKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyB4U2NhbGUpLFxyXG4gICAgICAgIHB4MSA9IE1hdGgucm91bmQoKGZlYXR1cmUuZW5kIC0gYnBTdGFydCkgLyB4U2NhbGUpLFxyXG4gICAgICAgIHB3ID0gcHgxIC0gcHg7XHJcblxyXG4gICAgICAgIGlmIChwdyA8IDMpIHtcclxuICAgICAgICBcdHB3ID0gMztcclxuICAgICAgICAgICAgcHggLT0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgXHRweDogcHgsXHJcbiAgICAgICAgICAgIHB4MTogcHgxLFxyXG4gICAgICAgICAgICBwdzogcHdcclxuICAgICAgICB9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBmZWF0dXJlIHRvIHRoZSBjYW52YXNcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgaXRzZWxmXHJcbiAgICAgKiBAcGFyYW0gY29vcmQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb24gd2hlcmUgdG8gZHJhdyB0aGUgZmVhdHVyZVxyXG4gICAgICogcHgxLHB4MiB0aGUgbGVmdCBhbmQgcmlnaHQgcGl4ZWxzIC0gcHcgLSB0aGUgd2lkdGhcclxuICAgICAqIHB5IHRoZSB0b3AsIGggLSB0aGUgaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdG8gZHJhdyB0aGUgZmVhdHVyZVxyXG4gICAgICogQHBhcmFtIGluZm8gLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2Vub21pYyBsb2NhdGlvblxyXG4gICAgICogYnBTdGFydC5icFBlclBpeGVsIGFuZCBwaXhlbFdpZHRoXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG5cdFxyXG5cdHJlbmRlckZlYXR1cmUoZmVhdHVyZSwgY29vcmQsY3R4LGluZm8pe1xyXG5cdFx0dmFyIGUseCwgY3ksIGRpcmVjdGlvbiwgZXhvbiwgZVB4LCBlUHgxLCBlUHhVLCBlUHcsIHB5MiwgaDIsIFxyXG4gICAgICAgICAgICBzdGVwID0gMjAsXHJcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb25maWcuY29sb3I7XHJcbiAgICAgICAgaWYgKGZlYXR1cmUuY29sb3IpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBmZWF0dXJlLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG5cclxuICAgICAgICBjeSA9IGNvb3JkLnB5ICsgY29vcmQuaCAvIDI7XHJcbiAgICAgICAgaDIgPSBjb29yZC5oIC8gMjtcclxuICAgICAgICBweTIgPSBjeSAtIGgyIC8gMjtcclxuXHJcblx0XHRsZXQgZXhvbkNvdW50ID0gZmVhdHVyZS5leG9ucyA/IGZlYXR1cmUuZXhvbnMubGVuZ3RoIDogMDtcclxuXHRcdFx0aWYgKGV4b25Db3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgIFx0Ly8gc2luZ2xlLWV4b24gdHJhbnNjcmlwdFxyXG4gICAgICAgICAgICBcdGN0eC5maWxsUmVjdChjb29yZC5weCwgY29vcmQucHksIGNvb3JkLnB3LCBjb29yZC5oKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAvLyBtdWx0aS1leG9uIHRyYW5zY3JpcHRcclxuICAgICAgICAgICAgY29vcmQucHg9TWF0aC5tYXgoY29vcmQucHgsMCk7XHJcbiAgICAgICAgICAgIGNvb3JkLnB4MT1NYXRoLm1pbihjb29yZC5weDEsaW5mby5waXhlbFdpZHRoKTtcclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIGNvb3JkLnB4ICsgMSwgY3ksIGNvb3JkLnB4MSAtIDEsIGN5KTsgLy8gY2VudGVyIGxpbmUgZm9yIGludHJvbnNcclxuICAgICAgICAgICAgZGlyZWN0aW9uID0gZmVhdHVyZS5zdHJhbmQgPT0gJysnID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICBcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKCB4PWNvb3JkLnB4ICsgc3RlcCAvIDI7IHggPCAgY29vcmQucHgxOyB4ICs9IHN0ZXApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGFycm93aGVhZHMgYWxvbmcgY2VudHJhbCBsaW5lIGluZGljYXRpbmcgdHJhbnNjcmliZWQgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgLSAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCAtIGRpcmVjdGlvbiAqIDIsIGN5ICsgMiwgeCwgY3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBleG9uQ291bnQ7IGUrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZXhvbnNcclxuICAgICAgICAgICAgICAgIGV4b24gPSBmZWF0dXJlLmV4b25zW2VdO1xyXG4gICAgICAgICAgICAgICAgZVB4ID0gTWF0aC5yb3VuZCgoZXhvbi5zdGFydCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgZVB4MSA9IE1hdGgucm91bmQoKGV4b24uZW5kIC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBlUHcgPSBNYXRoLm1heCgxLCBlUHgxIC0gZVB4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhvbi51dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBweTIsIGVQdywgaDIpOyAvLyBFbnRpcmUgZXhvbiBpcyBVVFJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleG9uLmNkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4VSA9IE1hdGgucm91bmQoKGV4b24uY2RTdGFydCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBweTIsIGVQeFUgLSBlUHgsIGgyKTsgLy8gc3RhcnQgaXMgVVRSXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQdyAtPSAoZVB4VSAtIGVQeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeCA9IGVQeFU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhvbi5jZEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHhVID0gTWF0aC5yb3VuZCgoZXhvbi5jZEVuZCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4VSwgcHkyLCBlUHgxIC0gZVB4VSwgaDIpOyAvLyBzdGFydCBpcyBVVFJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB3IC09IChlUHgxIC0gZVB4VSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeDEgPSBlUHhVO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGVQeCwgY29vcmQucHksIGVQdywgY29vcmQuaCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFycm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlUHcgPiBzdGVwICsgNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeCA9IGVQeCArIHN0ZXAgLyAyOyB4IDwgZVB4MTsgeCArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IGFycm93aGVhZHMgYWxvbmcgY2VudHJhbCBsaW5lIGluZGljYXRpbmcgdHJhbnNjcmliZWQgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgLSAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCAtIGRpcmVjdGlvbiAqIDIsIGN5ICsgMiwgeCwgY3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsKSB7XHJcblx0XHRsZXQgeU9mZnNldD1jb29yZC55LXRoaXMudG9wO1xyXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgZmVhdHVyZUNhY2hlIHByb3BlcnR5IHJhdGhlciB0aGFuIG1ldGhvZCB0byBhdm9pZCBhc3luYyBsb2FkLiAgSWYgdGhlXHJcbiAgICAgICAgLy8gZmVhdHVyZSBpcyBub3QgYWxyZWFkeSBsb2FkZWQgdGhpcyB3b24ndCB3b3JrLCAgYnV0IHRoZSB1c2VyIHdvdWxkbid0IGJlIG1vdXNpbmcgb3ZlciBpdCBlaXRoZXIuXHJcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZV9zb3VyY2UuZmVhdHVyZUNhY2hlKSB7XHJcblxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhciB0b2xlcmFuY2UgPSAyICogYnBQZXJQaXhlbCwgIC8vIFdlIG5lZWQgc29tZSB0b2xlcmFuY2UgYXJvdW5kIGdlbm9taWNMb2NhdGlvbiwgc3RhcnQgd2l0aCArLy0gMiBwaXhlbHNcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKSxcclxuICAgICAgICAgICAgICAgIHJvdztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZSAhPSBcIkNPTExBUFNFRFwiKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgPSAoTWF0aC5mbG9vcikodGhpcy5jb25maWcuZGlzcGxheU1vZGUgPT09IFwiU1FVSVNIRURcIiA/IHlPZmZzZXQgLyB0aGlzLmNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgOiB5T2Zmc2V0IC8gdGhpcy5jb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlTGlzdCAmJiBmZWF0dXJlTGlzdC5sZW5ndGggPiAwKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3B1cERhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmUgb2YgZmVhdHVyZUxpc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZCA+PSBnZW5vbWljTG9jYXRpb24gLSB0b2xlcmFuY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdyBudW1iZXIgaXMgc3BlY2lmaWVkIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmUucm93ID09PSB1bmRlZmluZWQgfHwgcm93ID09PSBmZWF0dXJlLnJvdykmJiAgZmVhdHVyZS5kaXNwbGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0Y29uc29sZS5sb2coZmVhdHVyZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcblxyXG59XHJcblxyXG5cclxuY2xhc3MgTUxWQmlnQmVkVHJhY2sgZXh0ZW5kcyBNTFZCZWRUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHRcdFxyXG5cdH1cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQmlnQmVkRmVhdHVyZVNvdXJjZSh0aGlzLmNvbmZpZyk7XHJcblx0fVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIE1MVldpZ1RyYWNrIGV4dGVuZHMgTUxWVHJhY2t7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHR0aGlzLl9zZXRGZWF0dXJlU291cmNlKCk7XHJcblx0fVxyXG5cclxuXHRfc2V0RmVhdHVyZVNvdXJjZSgpe1xyXG5cdFx0dGhpcy5mZWF0dXJlX3NvdXJjZT1uZXcgQldTb3VyY2UodGhpcy5jb25maWcpO1x0XHJcblx0fVxyXG5cclxuXHJcblx0ZHJhd1NjYWxlKHBpeGVsX2hlaWdodCxjdHgpe1xyXG5cdFx0aWYgKHRoaXMuY29uZmlnLnNjYWxlX2xpbmtfdG8pe1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRsZXQgYm90PSBwaXhlbF9oZWlnaHQ7XHJcblx0XHRsZXQgdG9wID0gMDtcclxuXHRcdGlmICh0aGlzLnNjYWxlX2xpbmtfdG8pe1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuY29uZmlnLmRpc2NyZXRlKXtcclxuXHRcdFx0dG9wPXRoaXMudG9wO1xyXG5cdFx0XHRib3QgPSB0aGlzLmJvdHRvbTtcclxuXHRcdH1cclxuXHRcdGxldCByYW5nZT10aGlzLm1heF95LXRoaXMubWluX3k7XHJcblxyXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLHRvcCk7XHJcblx0XHRjdHgubGluZVRvKDAsYm90KTtcclxuXHRcdGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0Y3R4LmxpbmVUbygyMCx0b3ApO1xyXG5cdFx0Y3R4Lm1vdmVUbygwLGJvdCk7XHJcblx0XHRjdHgubGluZVRvKDIwLGJvdCk7XHJcblx0XHRjdHguZm9udD1cIjEycHggQXJpYWxcIjtcclxuXHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIjtcclxuXHRcdGN0eC5maWxsVGV4dCh0aGlzLm1heF95LnRvRml4ZWQoMiksMjAsdG9wKTtcclxuXHRcdGN0eC50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCI7XHJcblx0XHRjdHguZmlsbFRleHQodGhpcy5taW5feSwyMCxib3QpO1xyXG5cclxuXHR9XHJcblx0XHJcblx0ZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHRcdGxldCBzZWxmID0gdGhpcyxcclxuXHQgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzLFxyXG5cdCAgICBjb2xvcj1zZWxmLmNvbmZpZy5jb2xvcixcclxuXHQgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG5cdCAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG5cdCAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG5cdCAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG5cdCAgICBwaXhlbEhlaWdodCA9b3B0aW9ucy5waXhlbEhlaWdodCxcclxuXHQgICAgeV9vZmZzZXQ9dGhpcy5jb25maWcuZGlzY3JldGU/b3B0aW9ucy50b3A6MCxcclxuXHQgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxLFxyXG5cdCAgICBmZWF0dXJlVmFsdWVNaW5pbXVtLFxyXG5cdCAgICBmZWF0dXJlVmFsdWVNYXhpbXVtLFxyXG5cdCAgICBmZWF0dXJlVmFsdWVSYW5nZSxcclxuXHQgICAgJGRhdGFSYW5nZVRyYWNrTGFiZWwsXHJcblx0ICAgIHN0cixcclxuXHQgICAgbWluLFxyXG5cdCAgICBtYXg7XHJcblx0ICAgIGlmKHRoaXMuY29uZmlnLmRpc2NyZXRlKXtcclxuXHQgICAgXHRpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIFx0fVxyXG5cdCAgICBcdGVsc2V7XHJcblx0ICAgIFx0XHQgcGl4ZWxIZWlnaHQ9dGhpcy5jb25maWcuaGVpZ2h0O1xyXG5cdCAgICBcdH1cclxuXHQgICAgXHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHRcdFxyXG5cdCAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHQgICAgXHRpZiAoc2VsZi5zY2FsZV9saW5rX3RvKXtcclxuXHQgICAgXHRcdGxldCB0ID0gc2VsZi5zY2FsZV9saW5rX3RvLmNvbmZpZztcclxuXHQgICAgICAgICAgICBpZiAodCl7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLmNvbmZpZy5zY2FsZT10LnNjYWxlO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuc2NhbGVfbGlua190by5tYXhfeTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feT1zZWxmLnNjYWxlX2xpbmtfdG8ubWluX3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICB9XHJcblx0ICAgICAgIGVsc2UgaWYgKCAoc2VsZi5tYXhfeSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuY29uZmlnLnNjYWxlPT09XCJhdXRvbWF0aWNcIikgfHwgc2VsZi5jb25maWcuc2NhbGU9PT1cImR5bmFtaWNcIil7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBzID0gYXV0b3NjYWxlKGZlYXR1cmVzKTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feSA9IHMubWluO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95ID0gcy5tYXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLnNjYWxlPT09XCJmaXhlZFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWluX3kgPSBzZWxmLmNvbmZpZy5taW5feTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5tYXhfeT1zZWxmLmNvbmZpZy5tYXhfeTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGZlYXR1cmVWYWx1ZVJhbmdlID0gc2VsZi5tYXhfeSAtIHNlbGYubWluX3k7XHJcblxyXG5cdCAgICAgICAgICAgIC8vJGRhdGFSYW5nZVRyYWNrTGFiZWwgPSAkKHRoaXMudHJhY2tWaWV3LnRyYWNrRGl2KS5maW5kKCcuaWd2LWRhdGEtcmFuZ2UtdHJhY2stbGFiZWwnKTtcclxuXHQgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgIC8vbWluID0gKE1hdGguZmxvb3IodHJhY2suZGF0YVJhbmdlLm1pbikgPT09IHRyYWNrLmRhdGFSYW5nZS5taW4pID8gdHJhY2suZGF0YVJhbmdlLm1pbiA6IHRyYWNrLmRhdGFSYW5nZS5taW4udG9GaXhlZCgyKTtcclxuXHQgICAgICAgICAgICAvL21heCA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5tYXgpID09PSB0cmFjay5kYXRhUmFuZ2UubWF4KSA/IHRyYWNrLmRhdGFSYW5nZS5tYXggOiB0cmFjay5kYXRhUmFuZ2UubWF4LnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9zdHIgPSAnWycgKyBtaW4gKyAnIC0gJyArIG1heCArICddJztcclxuXHQgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgIC8vJGRhdGFSYW5nZVRyYWNrTGFiZWwudGV4dChzdHIpO1xyXG5cdCAgICAgICAgICAgIGxldCBwcmV2X3g9MDtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl95PTA7XHJcblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhICAgPSB0aGlzLmNvbmZpZy5vcGFjaXR5P3RoaXMuY29uZmlnLm9wYWNpdHk6MTtcclxuXHQgICAgICAgICAgICBpZiAoc2VsZi5pc19saW5lKXsgIFxyXG5cdCAgICAgICAgICAgICAgICBsZXQgeSA9ICgxLjAgLSBzZWxmLmNvbmZpZy52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlKSpwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsMCx5LHBpeGVsV2lkdGgseSx7XCJzdHJva2VTdHlsZVwiOnNlbGYuY29uZmlnLmNvbG9yLFwibGluZVdpZHRoXCI6c2VsZi5jb25maWcud2lkdGg/c2VsZi5jb25maWcud2lkdGg6MX0pO1xyXG5cdCAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZXtcclxuXHQgICAgICAgICAgICBcdGZlYXR1cmVzLmZvckVhY2gocmVuZGVyRmVhdHVyZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAgXHJcblx0ICAgICAgICBmdW5jdGlvbiByZW5kZXJGZWF0dXJlKGZlYXR1cmUsIGluZGV4LCBmZWF0dXJlTGlzdCkge1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgeVVuaXRsZXNzLFxyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyxcclxuXHQgICAgICAgICAgICAgICAgeCxcclxuXHQgICAgICAgICAgICAgICAgeSxcclxuXHQgICAgICAgICAgICAgICAgd2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodCxcclxuXHQgICAgICAgICAgICAgICAgcmVjdEVuZCxcclxuXHQgICAgICAgICAgICAgICAgcmVjdEJhc2VsaW5lO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoZmVhdHVyZS5lbmQgPCBicFN0YXJ0KSByZXR1cm47XHJcblx0ICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3RhcnQgPiBicEVuZCkgcmV0dXJuO1xyXG5cclxuXHQgICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoZmVhdHVyZS5zdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCk7XHJcblx0ICAgICAgICAgICAgcmVjdEVuZCA9IE1hdGguZmxvb3IoKGZlYXR1cmUuZW5kIC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHJlY3RFbmQgLSB4KTtcclxuXHJcblx0ICAgICAgICAgICAgLy9oZWlnaHQgPSAoKGZlYXR1cmUudmFsdWUgLSBmZWF0dXJlVmFsdWVNaW5pbXVtKSAvIGZlYXR1cmVWYWx1ZVJhbmdlKSAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIC8vcmVjdEJhc2VsaW5lID0gcGl4ZWxIZWlnaHQgLSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9jYW52YXMuZmlsbFJlY3QocmVjdE9yaWdpbiwgcmVjdEJhc2VsaW5lLCByZWN0V2lkdGgsIHJlY3RIZWlnaHQsIHtmaWxsU3R5bGU6IHRyYWNrLmNvbG9yfSk7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChzaWduc0RpZmZlcihzZWxmLm1pbl95LCBzZWxmLm1heF95KSkge1xyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUudmFsdWUgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB5VW5pdGxlc3MgPSBzZWxmLm1heF95LyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzID0gLWZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9ICgoc2VsZi5tYXhfeSAtIGZlYXR1cmUudmFsdWUpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSBmZWF0dXJlLnZhbHVlIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYubWluX3kgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IDA7XHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzID0gLWZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IDEuMCAtICgoZmVhdHVyZS52YWx1ZS1zZWxmLm1pbl95KSAvIGZlYXR1cmVWYWx1ZVJhbmdlKTtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAoZmVhdHVyZS52YWx1ZStzZWxmLm1pbl95KSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICBcdHkgPSAoeVVuaXRsZXNzKnBpeGVsSGVpZ2h0KSt5X29mZnNldDtcclxuXHQgICAgICAgICAgICB5PXk8eV9vZmZzZXQ/eV9vZmZzZXQ6eTtcclxuXHQgICAgICAgICAgICBoZWlnaHQ9aGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICBoZWlnaHQ9aGVpZ2h0PnBpeGVsSGVpZ2h0P3BpeGVsSGVpZ2h0OmhlaWdodFxyXG5cclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdCh4LCB5VW5pdGxlc3MgKiBwaXhlbEhlaWdodCwgd2lkdGgsIGhlaWdodFVuaXRMZXNzICogcGl4ZWxIZWlnaHQsIHsgZmlsbFN0eWxlOiBpZ3YucmFuZG9tUkdCKDY0LCAyNTUpIH0pO1xyXG5cdCAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kaXNwbGF5PT09J2xpbmUnKXtcclxuXHQgICAgICAgICAgICAgICAgIGlmIChzZWxmLnByZXZfY29vcmRzLngpe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgseCx5LHNlbGYucHJldl9jb29yZHMueCxzZWxmLnByZXZfY29vcmRzLnkse1wic3Ryb2tlU3R5bGVcIjpjb2xvcixcImxpbmVXaWR0aFwiOjN9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy54PXg7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYucHJldl9jb29yZHMueT15O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNle1xyXG5cdCAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHtmaWxsU3R5bGU6IGNvbG9yfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgIGZ1bmN0aW9uIGF1dG9zY2FsZShmZWF0dXJlcykge1xyXG4gICAgICAgIHZhciBtaW4gPSAwLFxyXG4gICAgICAgICAgICBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGYudmFsdWUpO1xyXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGYudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge21pbjogbWluLCBtYXg6IG1heH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGEgPiAwICYmIGIgPCAwIHx8IGEgPCAwICYmIGIgPiAwKTtcclxuICAgIH1cclxuICAgIHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgdGhpcy5ib3R0b209eV9vZmZzZXQrcGl4ZWxIZWlnaHQ7XHJcbiAgICBpZiAodGhpcy5jb25maWcuZGlzY3JldGUpe1xyXG4gICAgXHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgXHR0aGlzLnRvcD0wO1xyXG4gICAgXHR0aGlzLmJvdHRvbT0wO1xyXG4gICAgfVxyXG5cclxuXHQgICAgXHJcbn1cclxufVxyXG4gY2xhc3MgTGluZVRyYWNrIGV4dGVuZHMgTUxWV2lnVHJhY2t7XHJcblx0IGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHQgc3VwZXIoY29uZmlnKTtcclxuXHRcdCB0aGlzLmlzX2xpbmU9dHJ1ZTtcclxuXHQgfVxyXG5cdCBcclxuXHQgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cdFx0IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdCBmdWxmaWxsKFtdKTtcclxuXHQgICAgIH0pO1xyXG5cdCB9XHJcblx0IFxyXG5cdCBcclxuIH1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlcXVlbmNlVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpIFxyXG4gICAgICAgIHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlVHlwZSA9IGNvbmZpZy5zZXF1ZW5jZVR5cGUgfHwgXCJkbmFcIjsgIFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTU7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKXtcclxuICAgIFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy51cmwpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuYnBQZXJQaXhlbCA+IDEvKmlndi5icm93c2VyLnRyYWNrVmlld3BvcnRXaWR0aEJQKCkgPiAzMDAwMCovKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlX3NvdXJjZS5nZXRTZXF1ZW5jZShjaHIsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgIGxlbiwgdywgeSwgcG9zLCBvZmZzZXQsIGIsIHAwLCBwMSwgcGMsIGM7XHJcblxyXG4gICAgICAgIGxldCB5X3BvczE9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgbGV0IHlfcG9zMj15X3BvczErNTtcclxuXHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICBsZW4gPSBzZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHcgPSAxIC8gYnBQZXJQaXhlbDtcclxuXHJcbiAgICAgICAgICAgIHkgPSB5X3BvczErdGhpcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBmb3IgKHBvcyA9IGJwU3RhcnQ7IHBvcyA8PSBicEVuZDsgcG9zKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBicFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNlcXVlbmNlLmNoYXJBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzZXF1ZW5jZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAwID0gTWF0aC5mbG9vcihvZmZzZXQgKiB3KTtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IE1hdGguZmxvb3IoKG9mZnNldCArIDEpICogdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGMgPSBNYXRoLnJvdW5kKChwMCArIHAxKSAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkbmFcIiA9PT0gdGhpcy5zZXF1ZW5jZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gXCJyZ2IoMCwgMCwgMTUwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjKSBjID0gXCJncmF5XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsID4wLjE1KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHAwLCB5X3BvczEsIHAxIC0gcDAsIDEwLCB7ZmlsbFN0eWxlOiBjfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIGIsIHBjLCB5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICdub3JtYWwgMTBweCBBcmlhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgcmV0dXJuIHlfcG9zMSsxMDtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqanMvaWZ2LWNhbnZhcy5qcyoqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY2xhc3MgR3JhcGhpY3N7XHJcblxyXG5cclxuICAgICAgIHN0YXRpYyBzZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIHN0cm9rZUxpbmUgKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcih4MSkgKyAwLjU7XHJcbiAgICAgICAgICAgIHkxID0gTWF0aC5mbG9vcih5MSkgKyAwLjU7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5mbG9vcih4MikgKyAwLjU7XHJcbiAgICAgICAgICAgIHkyID0gTWF0aC5mbG9vcih5MikgKyAwLjU7XHJcblxyXG4gICAgICAgICAgICAvL2xvZyhcInN0cm9rZSBsaW5lLCBwcm9wOiBcIiArIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsUmVjdChjdHgsIHgsIHksIHcsIGgsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcclxuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZmlsbFBvbHlnb24oY3R4LCB4LCB5LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgR3JhcGhpY3MuZG9QYXRoKGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlUG9seWdvbihjdHgsIHgsIHksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5kb1BhdGgoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxUZXh0KGN0eCwgdGV4dCwgeCwgeSwgcHJvcGVydGllcywgdHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm0gaW4gdHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRkIGVycm9yIGNoZWNraW5nIGZvciByb2J1c3RuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHZhbHVlWyd4J10sIHZhbHVlWyd5J10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICdyb3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodmFsdWVbJ2FuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlVGV4dChjdHgsIHRleHQsIHgsIHksIHByb3BlcnRpZXMsIHRyYW5zZm9ybXMpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm0gaW4gdHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRkIGVycm9yIGNoZWNraW5nIGZvciByb2J1c3RuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHZhbHVlWyd4J10sIHZhbHVlWyd5J10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICdyb3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodmFsdWVbJ2FuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlQ2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKSB7XHJcblxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsQ2lyY2xlIChjdHgsIHgsIHksIHJhZGl1cykge1xyXG5cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGRyYXdBcnJvd2hlYWQoY3R4LCB4LCB5LCBzaXplLCBsaW5lV2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSAtIHNpemUgLyAyKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBzaXplLCB5KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZGFzaGVkTGluZShjdHgsIHgxLCB5MSwgeDIsIHkyLCBkYXNoTGVuLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5yb3VuZCh4MSk7XHJcbiAgICAgICAgICAgIHkxID0gTWF0aC5yb3VuZCh5MSk7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5yb3VuZCh4Mik7XHJcbiAgICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh5Mik7XHJcbiAgICAgICAgICAgIGRhc2hMZW4gPSBNYXRoLnJvdW5kKGRhc2hMZW4pO1xyXG4gICAgICAgICAgICBsb2coXCJkYXNoZWRMaW5lXCIpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhc2hMZW4gPT0gdW5kZWZpbmVkKSBkYXNoTGVuID0gMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRYID0geDIgLSB4MTtcclxuICAgICAgICAgICAgdmFyIGRZID0geTIgLSB5MTtcclxuICAgICAgICAgICAgdmFyIGRhc2hlcyA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKSAvIGRhc2hMZW4pO1xyXG4gICAgICAgICAgICB2YXIgZGFzaFggPSBkWCAvIGRhc2hlcztcclxuICAgICAgICAgICAgdmFyIGRhc2hZID0gZFkgLyBkYXNoZXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChxKysgPCBkYXNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHgxICs9IGRhc2hYO1xyXG4gICAgICAgICAgICAgICAgeTEgKz0gZGFzaFk7XHJcbiAgICAgICAgICAgICAgICBjdHhbcSAlIDIgPT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4W3EgJSAyID09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXSh4MiwgeTIpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIFxyXG5cclxuICAgICAgICBzdGF0aWMgZG9QYXRoKGN0eCwgeCwgeSkge1xyXG5cclxuXHJcbiAgICAgICAgXHR2YXIgaSwgbGVuID0geC5sZW5ndGg7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBcdFx0eFtpXSA9IE1hdGgucm91bmQoeFtpXSk7XHJcbiAgICAgICAgXHRcdHlbaV0gPSBNYXRoLnJvdW5kKHlbaV0pO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBcdGN0eC5tb3ZlVG8oeFswXSwgeVswXSk7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBcdFx0Y3R4LmxpbmVUbyh4W2ldLCB5W2ldKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcblxyXG59XHJcblxyXG5HcmFwaGljcy5udWNsZW90aWRlQ29sb3JzPXtcclxuXHRcIkFcIjpcImdyZWVuXCIsXHJcblx0XCJUXCI6XCJyZWRcIixcclxuXHRcIkdcIjpcImJsYWNrXCIsXHJcblx0XCJDXCI6XCJibHVlXCIsXHJcblx0XCJhXCI6XCJncmVlblwiLFxyXG5cdFwidFwiOlwicmVkXCIsXHJcblx0XCJjXCI6XCJibGFja1wiLFxyXG5cdFwiZ1wiOlwiYmx1ZVwiXHJcblxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCB7TUxWVHJhY2ssTUxWV2lnVHJhY2ssTUxWQmVkVHJhY2ssUnVsZXJUcmFjayxNTFZCaWdCZWRUcmFjayxHcmFwaGljc30iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/tracks.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: Utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($, XMLHttpRequest) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\nlet parseUri_options = {\r\n        strictMode: false,\r\n        key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\r\n        q: {\r\n            name: \"queryKey\",\r\n            parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n        },\r\n        parser: {\r\n            strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n            loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n        }\r\n    };\r\n\r\n\r\n\r\nclass Utils{\r\n\r\n    \r\n    static addAlphaToRGB(rgbString, alpha) {\r\n\r\n        if (rgbString.startsWith(\"rgb\")) {\r\n            return rgbString.replace(\"rgb\", \"rgba\").replace(\")\", \", \" + alpha + \")\");\r\n        } else {\r\n            console.log(rgbString + \" is not an rgb style string\");\r\n            return rgbString;\r\n        }\r\n\r\n    }\r\n\r\n    static presentAlert(track_div,error){\r\n        let div= $(\"<div>\").css({\"position\":\"absolute\",\"background-color\":\"white\"}).attr(\"class\",\"mlv-alert\").appendTo(track_div);\r\n        let div1= $(\"<div>\").css({\"display\":\"flex\",\"justify-content\":\"center\"}).appendTo(div);\r\n        div1.append($('<i class=\"fas fa-exclamation-circle\"></i>').css({color:\"red\",\"font-size\":\"16px\",\"text-align\":\"center\",}));\r\n        div.append($(\"<div>\"+error+\"</div>\").css({color:\"red\",\"font-size\":\"14px\",\"text-align\":\"center\"}));\r\n        let left = Math.round((track_div.width()/2)-(div.width()/2));\r\n        let top =Math.round((track_div.height()/2)-(div.height()/2));\r\n        div.css({\"left\":left+\"px\",top:top+\"px\"});\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n   \r\n\r\n    static spinner(size) {\r\n\r\n        // spinner\r\n        var $container,\r\n            $spinner;\r\n\r\n        $spinner = $('<i class=\"fa fa-lg fa-spinner fa-spin igv-spinner\">').css({position:\"absolute\",top:\"50%\",left:\"50%\"});\r\n        if (size) {\r\n            $spinner.css(\"font-size\", size);\r\n        }\r\n\r\n    \r\n\r\n        return $spinner[0];\r\n    }\r\n\r\n    /**\r\n     * Find spinner\r\n     */\r\n    static getSpinnerObjectWithParentElement(parentElement) {\r\n        return parentElement.find(\"div.igv-spinner-container\");\r\n    };\r\n\r\n    /**\r\n     * Start the spinner for the parent element, if it has one\r\n     */\r\n    static startSpinnerAtParentElement(parentElement) {\r\n       parentElement.children(\".fa-spinner\").show();  \r\n\r\n    };\r\n\r\n    /**\r\n     * Stop the spinner for the parent element, if it has one\r\n     * @param parentElement\r\n     */\r\n    static stopSpinnerAtParentElement (parentElement) {\r\n        parentElement.children(\".fa-spinner\").hide();\r\n       \r\n\r\n    }\r\n\r\n    static parseUri(str) {\r\n\r\n        var o = parseUri_options,\r\n            m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str),\r\n            uri = {},\r\n            i = 14;\r\n\r\n        while (i--) uri[o.key[i]] = m[i] || \"\";\r\n\r\n        uri[o.q.name] = {};\r\n        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n            if ($1) uri[o.q.name][$1] = $2;\r\n        });\r\n\r\n        return uri;\r\n    }\r\n    \r\n    \r\n    \r\n  \r\n    static domElementRectAsString(element) {\r\n        return \" x \" + element.clientLeft + \" y \" + element.clientTop + \" w \" + element.clientWidth + \" h \" + element.clientHeight;\r\n    };\r\n\r\n    static isNumber(n) {\r\n\r\n        if (\"\" === n) {\r\n\r\n            return false\r\n        } else if (undefined === n) {\r\n\r\n            return false;\r\n        } else {\r\n\r\n            return !isNaN(parseFloat(n)) && isFinite(n);\r\n        }\r\n\r\n    };\r\n\r\n    static guid  () {\r\n        return (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\r\n    };\r\n\r\n    // Returns a random number between min (inclusive) and max (exclusive)\r\n    static random(min, max) {\r\n        return Math.random() * (max - min) + min;\r\n    };\r\n\r\n    // StackOverflow: http://stackoverflow.com/a/10810674/116169\r\n    static numberFormatter(rawNumber) {\r\n\r\n        var dec = String(rawNumber).split(/[.,]/),\r\n            sep = ',',\r\n            decsep = '.';\r\n\r\n        return dec[0].split('').reverse().reduce(function (prev, now, i) {\r\n                return i % 3 === 0 ? prev + sep + now : prev + now;\r\n            }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');\r\n    };\r\n\r\n    static numberUnFormatter (formatedNumber) {\r\n\r\n        return formatedNumber.split(\",\").join().replace(\",\", \"\", \"g\");\r\n    };\r\n\r\n    /**\r\n     * Translate the mouse coordinates for the event to the coordinates for the given target element\r\n     * @param e\r\n     * @param target\r\n     * @returns {{x: number, y: number}}\r\n     */\r\n    static translateMouseCoordinates(e, target) {\r\n\r\n        var eFixed = $.event.fix(e),   // Sets pageX and pageY for browsers that don't support them\r\n            posx = eFixed.pageX - $(target).offset().left,\r\n            posy = eFixed.pageY - $(target).offset().top;\r\n\r\n        return {x: posx, y: posy}\r\n\r\n    };\r\n\r\n    /**\r\n     * Format markup for popover text from an array of name value pairs [{name, value}]\r\n     */\r\n    static formatPopoverText (nameValueArray) {\r\n\r\n        var markup = \"<table class=\\\"igv-popover-table\\\">\";\r\n\r\n        nameValueArray.forEach(function (nameValue) {\r\n\r\n            if (nameValue.name) {\r\n                //markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</td></tr>\";\r\n                markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<div class=\\\"igv-popoverNameValue\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</div>\" + \"</td></tr>\";\r\n            }\r\n            else {\r\n                // not a name/value pair\r\n                markup += \"<tr><td>\" + nameValue.toString() + \"</td></tr>\";\r\n            }\r\n        });\r\n\r\n        markup += \"</table>\";\r\n        return markup;\r\n\r\n\r\n    };\r\n\r\n    static throttle(fn, threshhold, scope) {\r\n        threshhold || (threshhold = 200);\r\n        var last, deferTimer;\r\n\r\n        return function () {\r\n            var context = scope || this;\r\n\r\n            var now = +new Date,\r\n                args = arguments;\r\n            if (last && now < last + threshhold) {\r\n                // hold on to it\r\n                clearTimeout(deferTimer);\r\n                deferTimer = setTimeout(function () {\r\n                    last = now;\r\n                    fn.apply(context, args);\r\n                }, threshhold);\r\n            } else {\r\n                last = now;\r\n                fn.apply(context, args);\r\n            }\r\n        }\r\n    };\r\n\r\n    static splitStringRespectingQuotes(string, delim) {\r\n\r\n        var tokens = [],\r\n            len = string.length,\r\n            i,\r\n            n = 0,\r\n            quote = false,\r\n            c;\r\n\r\n        if (len > 0) {\r\n\r\n            tokens[n] = string.charAt(0);\r\n            for (i = 1; i < len; i++) {\r\n                c = string.charAt(i);\r\n                if (c === '\"') {\r\n                    quote = !quote;\r\n                }\r\n                else if (!quote && c === delim) {\r\n                    n++;\r\n                    tokens[n] = \"\";\r\n                }\r\n                else {\r\n                    tokens[n] += c;\r\n                }\r\n            }\r\n        }\r\n        return tokens;\r\n    };\r\n\r\n    /**\r\n     * Extend jQuery's ajax function to handle binary requests.   Credit to Henry Algus:\r\n     *\r\n     * http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/\r\n     */\r\n   static addAjaxExtensions () {\r\n\r\n        // use this transport for \"binary\" data type\r\n        $.ajaxTransport(\"+binary\", function (options, originalOptions, jqXHR) {\r\n\r\n            return {\r\n                // create new XMLHttpRequest\r\n                send: function (_, callback) {\r\n                    // setup all variables\r\n                    var xhr = new XMLHttpRequest(),\r\n                        url = options.url,\r\n                        type = options.type,\r\n                        responseType = \"arraybuffer\",\r\n                        data = options.data || null;\r\n\r\n                    xhr.addEventListener('load', function () {\r\n                        var data = {};\r\n                        data[options.dataType] = xhr.response;\r\n                        // make callback and send data\r\n                        callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());\r\n                    });\r\n\r\n                    xhr.open(type, url);\r\n                    xhr.responseType = responseType;\r\n\r\n                    if (options.headers) {\r\n                        for (var prop in options.headers) {\r\n                            if (options.headers.hasOwnProperty(prop)) {\r\n                                xhr.setRequestHeader(prop, options.headers[prop]);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // TODO -- set any other options values\r\n                },\r\n                abort: function () {\r\n                    jqXHR.abort();\r\n                }\r\n            };\r\n\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.\r\n     *\r\n     * @param value\r\n     * @returns boolean\r\n     */\r\n    static isStringOrNumber(value) {\r\n        return (value.substring || value.toFixed) ? true : false\r\n    };\r\n\r\n    static constrainBBox($child, $parent) {\r\n\r\n        var delta,\r\n            topLeft,\r\n            bboxChild = {},\r\n            bboxParent = {};\r\n\r\n        bboxParent.left = bboxParent.top = 0;\r\n        bboxParent.right = $parent.outerWidth();\r\n        bboxParent.bottom = $parent.outerHeight();\r\n\r\n        topLeft = $child.offset();\r\n\r\n        bboxChild.left = topLeft.left - $parent.offset().left;\r\n        bboxChild.top = topLeft.top - $parent.offset().top;\r\n        bboxChild.right = bboxChild.left + $child.outerWidth();\r\n        bboxChild.bottom = bboxChild.top + $child.outerHeight();\r\n\r\n        delta = bboxChild.bottom - bboxParent.bottom;\r\n        if (delta > 0) {\r\n\r\n            // clamp to trackContainer bottom\r\n            topLeft.top -= delta;\r\n\r\n            bboxChild.top -= delta;\r\n            bboxChild.bottom -= delta;\r\n\r\n            delta = bboxChild.top - bboxParent.top;\r\n            if (delta < 0) {\r\n                topLeft.top -= delta;\r\n            }\r\n\r\n        }\r\n\r\n        return topLeft;\r\n\r\n    };\r\n\r\n    static log(message) {\r\n        if (igv.enableLogging && console && console.log) {\r\n            console.log(message);\r\n        }\r\n    };\r\n\r\n\r\n}\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! xhr2 */ \"xhr2\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanM/MDI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxubGV0IHBhcnNlVXJpX29wdGlvbnMgPSB7XHJcbiAgICAgICAgc3RyaWN0TW9kZTogZmFsc2UsXHJcbiAgICAgICAga2V5OiBbXCJzb3VyY2VcIiwgXCJwcm90b2NvbFwiLCBcImF1dGhvcml0eVwiLCBcInVzZXJJbmZvXCIsIFwidXNlclwiLCBcInBhc3N3b3JkXCIsIFwiaG9zdFwiLCBcInBvcnRcIiwgXCJyZWxhdGl2ZVwiLCBcInBhdGhcIiwgXCJkaXJlY3RvcnlcIiwgXCJmaWxlXCIsIFwicXVlcnlcIiwgXCJhbmNob3JcIl0sXHJcbiAgICAgICAgcToge1xyXG4gICAgICAgICAgICBuYW1lOiBcInF1ZXJ5S2V5XCIsXHJcbiAgICAgICAgICAgIHBhcnNlcjogLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJzZXI6IHtcclxuICAgICAgICAgICAgc3RyaWN0OiAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCgoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxyXG4gICAgICAgICAgICBsb29zZTogL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG5cclxuY2xhc3MgVXRpbHN7XHJcblxyXG4gICAgXHJcbiAgICBzdGF0aWMgYWRkQWxwaGFUb1JHQihyZ2JTdHJpbmcsIGFscGhhKSB7XHJcblxyXG4gICAgICAgIGlmIChyZ2JTdHJpbmcuc3RhcnRzV2l0aChcInJnYlwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmdiU3RyaW5nLnJlcGxhY2UoXCJyZ2JcIiwgXCJyZ2JhXCIpLnJlcGxhY2UoXCIpXCIsIFwiLCBcIiArIGFscGhhICsgXCIpXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJnYlN0cmluZyArIFwiIGlzIG5vdCBhbiByZ2Igc3R5bGUgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmdiU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHByZXNlbnRBbGVydCh0cmFja19kaXYsZXJyb3Ipe1xyXG4gICAgICAgIGxldCBkaXY9ICQoXCI8ZGl2PlwiKS5jc3Moe1wicG9zaXRpb25cIjpcImFic29sdXRlXCIsXCJiYWNrZ3JvdW5kLWNvbG9yXCI6XCJ3aGl0ZVwifSkuYXR0cihcImNsYXNzXCIsXCJtbHYtYWxlcnRcIikuYXBwZW5kVG8odHJhY2tfZGl2KTtcclxuICAgICAgICBsZXQgZGl2MT0gJChcIjxkaXY+XCIpLmNzcyh7XCJkaXNwbGF5XCI6XCJmbGV4XCIsXCJqdXN0aWZ5LWNvbnRlbnRcIjpcImNlbnRlclwifSkuYXBwZW5kVG8oZGl2KTtcclxuICAgICAgICBkaXYxLmFwcGVuZCgkKCc8aSBjbGFzcz1cImZhcyBmYS1leGNsYW1hdGlvbi1jaXJjbGVcIj48L2k+JykuY3NzKHtjb2xvcjpcInJlZFwiLFwiZm9udC1zaXplXCI6XCIxNnB4XCIsXCJ0ZXh0LWFsaWduXCI6XCJjZW50ZXJcIix9KSk7XHJcbiAgICAgICAgZGl2LmFwcGVuZCgkKFwiPGRpdj5cIitlcnJvcitcIjwvZGl2PlwiKS5jc3Moe2NvbG9yOlwicmVkXCIsXCJmb250LXNpemVcIjpcIjE0cHhcIixcInRleHQtYWxpZ25cIjpcImNlbnRlclwifSkpO1xyXG4gICAgICAgIGxldCBsZWZ0ID0gTWF0aC5yb3VuZCgodHJhY2tfZGl2LndpZHRoKCkvMiktKGRpdi53aWR0aCgpLzIpKTtcclxuICAgICAgICBsZXQgdG9wID1NYXRoLnJvdW5kKCh0cmFja19kaXYuaGVpZ2h0KCkvMiktKGRpdi5oZWlnaHQoKS8yKSk7XHJcbiAgICAgICAgZGl2LmNzcyh7XCJsZWZ0XCI6bGVmdCtcInB4XCIsdG9wOnRvcCtcInB4XCJ9KTtcclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICBcclxuXHJcbiAgICBzdGF0aWMgc3Bpbm5lcihzaXplKSB7XHJcblxyXG4gICAgICAgIC8vIHNwaW5uZXJcclxuICAgICAgICB2YXIgJGNvbnRhaW5lcixcclxuICAgICAgICAgICAgJHNwaW5uZXI7XHJcblxyXG4gICAgICAgICRzcGlubmVyID0gJCgnPGkgY2xhc3M9XCJmYSBmYS1sZyBmYS1zcGlubmVyIGZhLXNwaW4gaWd2LXNwaW5uZXJcIj4nKS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCI1MCVcIixsZWZ0OlwiNTAlXCJ9KTtcclxuICAgICAgICBpZiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAkc3Bpbm5lci5jc3MoXCJmb250LXNpemVcIiwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIFxyXG5cclxuICAgICAgICByZXR1cm4gJHNwaW5uZXJbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHNwaW5uZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNwaW5uZXJPYmplY3RXaXRoUGFyZW50RWxlbWVudChwYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudEVsZW1lbnQuZmluZChcImRpdi5pZ3Ytc3Bpbm5lci1jb250YWluZXJcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgdGhlIHNwaW5uZXIgZm9yIHRoZSBwYXJlbnQgZWxlbWVudCwgaWYgaXQgaGFzIG9uZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3RhcnRTcGlubmVyQXRQYXJlbnRFbGVtZW50KHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4oXCIuZmEtc3Bpbm5lclwiKS5zaG93KCk7ICBcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0aGUgc3Bpbm5lciBmb3IgdGhlIHBhcmVudCBlbGVtZW50LCBpZiBpdCBoYXMgb25lXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbWVudFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3RvcFNwaW5uZXJBdFBhcmVudEVsZW1lbnQgKHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuKFwiLmZhLXNwaW5uZXJcIikuaGlkZSgpO1xyXG4gICAgICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZVVyaShzdHIpIHtcclxuXHJcbiAgICAgICAgdmFyIG8gPSBwYXJzZVVyaV9vcHRpb25zLFxyXG4gICAgICAgICAgICBtID0gby5wYXJzZXJbby5zdHJpY3RNb2RlID8gXCJzdHJpY3RcIiA6IFwibG9vc2VcIl0uZXhlYyhzdHIpLFxyXG4gICAgICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICAgICAgaSA9IDE0O1xyXG5cclxuICAgICAgICB3aGlsZSAoaS0tKSB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCBcIlwiO1xyXG5cclxuICAgICAgICB1cmlbby5xLm5hbWVdID0ge307XHJcbiAgICAgICAgdXJpW28ua2V5WzEyXV0ucmVwbGFjZShvLnEucGFyc2VyLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xyXG4gICAgICAgICAgICBpZiAoJDEpIHVyaVtvLnEubmFtZV1bJDFdID0gJDI7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB1cmk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgXHJcbiAgICBzdGF0aWMgZG9tRWxlbWVudFJlY3RBc1N0cmluZyhlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiIHggXCIgKyBlbGVtZW50LmNsaWVudExlZnQgKyBcIiB5IFwiICsgZWxlbWVudC5jbGllbnRUb3AgKyBcIiB3IFwiICsgZWxlbWVudC5jbGllbnRXaWR0aCArIFwiIGggXCIgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGlzTnVtYmVyKG4pIHtcclxuXHJcbiAgICAgICAgaWYgKFwiXCIgPT09IG4pIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSBpZiAodW5kZWZpbmVkID09PSBuKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGd1aWQgICgpIHtcclxuICAgICAgICByZXR1cm4gKFwiMDAwMFwiICsgKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygzNiwgNCkgPDwgMCkudG9TdHJpbmcoMzYpKS5zbGljZSgtNCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSlcclxuICAgIHN0YXRpYyByYW5kb20obWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdGFja092ZXJmbG93OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDgxMDY3NC8xMTYxNjlcclxuICAgIHN0YXRpYyBudW1iZXJGb3JtYXR0ZXIocmF3TnVtYmVyKSB7XHJcblxyXG4gICAgICAgIHZhciBkZWMgPSBTdHJpbmcocmF3TnVtYmVyKS5zcGxpdCgvWy4sXS8pLFxyXG4gICAgICAgICAgICBzZXAgPSAnLCcsXHJcbiAgICAgICAgICAgIGRlY3NlcCA9ICcuJztcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlY1swXS5zcGxpdCgnJykucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbm93LCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAlIDMgPT09IDAgPyBwcmV2ICsgc2VwICsgbm93IDogcHJldiArIG5vdztcclxuICAgICAgICAgICAgfSkuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSArIChkZWNbMV0gPyBkZWNzZXAgKyBkZWNbMV0gOiAnJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBudW1iZXJVbkZvcm1hdHRlciAoZm9ybWF0ZWROdW1iZXIpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdGVkTnVtYmVyLnNwbGl0KFwiLFwiKS5qb2luKCkucmVwbGFjZShcIixcIiwgXCJcIiwgXCJnXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgZm9yIHRoZSBldmVudCB0byB0aGUgY29vcmRpbmF0ZXMgZm9yIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIGVcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNsYXRlTW91c2VDb29yZGluYXRlcyhlLCB0YXJnZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIGVGaXhlZCA9ICQuZXZlbnQuZml4KGUpLCAgIC8vIFNldHMgcGFnZVggYW5kIHBhZ2VZIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlbVxyXG4gICAgICAgICAgICBwb3N4ID0gZUZpeGVkLnBhZ2VYIC0gJCh0YXJnZXQpLm9mZnNldCgpLmxlZnQsXHJcbiAgICAgICAgICAgIHBvc3kgPSBlRml4ZWQucGFnZVkgLSAkKHRhcmdldCkub2Zmc2V0KCkudG9wO1xyXG5cclxuICAgICAgICByZXR1cm4ge3g6IHBvc3gsIHk6IHBvc3l9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdCBtYXJrdXAgZm9yIHBvcG92ZXIgdGV4dCBmcm9tIGFuIGFycmF5IG9mIG5hbWUgdmFsdWUgcGFpcnMgW3tuYW1lLCB2YWx1ZX1dXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JtYXRQb3BvdmVyVGV4dCAobmFtZVZhbHVlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIG1hcmt1cCA9IFwiPHRhYmxlIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlci10YWJsZVxcXCI+XCI7XHJcblxyXG4gICAgICAgIG5hbWVWYWx1ZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKG5hbWVWYWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKG5hbWVWYWx1ZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvL21hcmt1cCArPSBcIjx0cj48dGQgY2xhc3M9XFxcImlndi1wb3BvdmVyLXRkXFxcIj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyTmFtZVxcXCI+XCIgKyBuYW1lVmFsdWUubmFtZSArIFwiPC9zcGFuPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJWYWx1ZVxcXCI+XCIgKyBuYW1lVmFsdWUudmFsdWUgKyBcIjwvc3Bhbj5cIiArIFwiPC90ZD48L3RyPlwiO1xyXG4gICAgICAgICAgICAgICAgbWFya3VwICs9IFwiPHRyPjx0ZCBjbGFzcz1cXFwiaWd2LXBvcG92ZXItdGRcXFwiPlwiICsgXCI8ZGl2IGNsYXNzPVxcXCJpZ3YtcG9wb3Zlck5hbWVWYWx1ZVxcXCI+XCIgKyBcIjxzcGFuIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlck5hbWVcXFwiPlwiICsgbmFtZVZhbHVlLm5hbWUgKyBcIjwvc3Bhbj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyVmFsdWVcXFwiPlwiICsgbmFtZVZhbHVlLnZhbHVlICsgXCI8L3NwYW4+XCIgKyBcIjwvZGl2PlwiICsgXCI8L3RkPjwvdHI+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBuYW1lL3ZhbHVlIHBhaXJcclxuICAgICAgICAgICAgICAgIG1hcmt1cCArPSBcIjx0cj48dGQ+XCIgKyBuYW1lVmFsdWUudG9TdHJpbmcoKSArIFwiPC90ZD48L3RyPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1hcmt1cCArPSBcIjwvdGFibGU+XCI7XHJcbiAgICAgICAgcmV0dXJuIG1hcmt1cDtcclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgdGhyb3R0bGUoZm4sIHRocmVzaGhvbGQsIHNjb3BlKSB7XHJcbiAgICAgICAgdGhyZXNoaG9sZCB8fCAodGhyZXNoaG9sZCA9IDIwMCk7XHJcbiAgICAgICAgdmFyIGxhc3QsIGRlZmVyVGltZXI7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gc2NvcGUgfHwgdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBub3cgPSArbmV3IERhdGUsXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICBpZiAobGFzdCAmJiBub3cgPCBsYXN0ICsgdGhyZXNoaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaG9sZCBvbiB0byBpdFxyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgZGVmZXJUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aHJlc2hob2xkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhc3QgPSBub3c7XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIHNwbGl0U3RyaW5nUmVzcGVjdGluZ1F1b3RlcyhzdHJpbmcsIGRlbGltKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBbXSxcclxuICAgICAgICAgICAgbGVuID0gc3RyaW5nLmxlbmd0aCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgbiA9IDAsXHJcbiAgICAgICAgICAgIHF1b3RlID0gZmFsc2UsXHJcbiAgICAgICAgICAgIGM7XHJcblxyXG4gICAgICAgIGlmIChsZW4gPiAwKSB7XHJcblxyXG4gICAgICAgICAgICB0b2tlbnNbbl0gPSBzdHJpbmcuY2hhckF0KDApO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGMgPSBzdHJpbmcuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICFxdW90ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFxdW90ZSAmJiBjID09PSBkZWxpbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbbl0gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW25dICs9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgalF1ZXJ5J3MgYWpheCBmdW5jdGlvbiB0byBoYW5kbGUgYmluYXJ5IHJlcXVlc3RzLiAgIENyZWRpdCB0byBIZW5yeSBBbGd1czpcclxuICAgICAqXHJcbiAgICAgKiBodHRwOi8vd3d3LmhlbnJ5YWxndXMuY29tL3JlYWRpbmctYmluYXJ5LWZpbGVzLXVzaW5nLWpxdWVyeS1hamF4L1xyXG4gICAgICovXHJcbiAgIHN0YXRpYyBhZGRBamF4RXh0ZW5zaW9ucyAoKSB7XHJcblxyXG4gICAgICAgIC8vIHVzZSB0aGlzIHRyYW5zcG9ydCBmb3IgXCJiaW5hcnlcIiBkYXRhIHR5cGVcclxuICAgICAgICAkLmFqYXhUcmFuc3BvcnQoXCIrYmluYXJ5XCIsIGZ1bmN0aW9uIChvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0dXAgYWxsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gb3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBvcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvcHRpb25zLmRhdGFUeXBlXSA9IHhoci5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBjYWxsYmFjayBhbmQgc2VuZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0LCBkYXRhLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aHIub3Blbih0eXBlLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihwcm9wLCBvcHRpb25zLmhlYWRlcnNbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0tIHNldCBhbnkgb3RoZXIgb3B0aW9ucyB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nIG9yIG51bWJlci4gIE5vdCB1c2luZyB0eXBlb2YgYXMgaXQgZmFpbHMgb24gYm94ZWQgcHJpbWl0aXZlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzU3RyaW5nT3JOdW1iZXIodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlLnN1YnN0cmluZyB8fCB2YWx1ZS50b0ZpeGVkKSA/IHRydWUgOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgY29uc3RyYWluQkJveCgkY2hpbGQsICRwYXJlbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIGRlbHRhLFxyXG4gICAgICAgICAgICB0b3BMZWZ0LFxyXG4gICAgICAgICAgICBiYm94Q2hpbGQgPSB7fSxcclxuICAgICAgICAgICAgYmJveFBhcmVudCA9IHt9O1xyXG5cclxuICAgICAgICBiYm94UGFyZW50LmxlZnQgPSBiYm94UGFyZW50LnRvcCA9IDA7XHJcbiAgICAgICAgYmJveFBhcmVudC5yaWdodCA9ICRwYXJlbnQub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgIGJib3hQYXJlbnQuYm90dG9tID0gJHBhcmVudC5vdXRlckhlaWdodCgpO1xyXG5cclxuICAgICAgICB0b3BMZWZ0ID0gJGNoaWxkLm9mZnNldCgpO1xyXG5cclxuICAgICAgICBiYm94Q2hpbGQubGVmdCA9IHRvcExlZnQubGVmdCAtICRwYXJlbnQub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICBiYm94Q2hpbGQudG9wID0gdG9wTGVmdC50b3AgLSAkcGFyZW50Lm9mZnNldCgpLnRvcDtcclxuICAgICAgICBiYm94Q2hpbGQucmlnaHQgPSBiYm94Q2hpbGQubGVmdCArICRjaGlsZC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgYmJveENoaWxkLmJvdHRvbSA9IGJib3hDaGlsZC50b3AgKyAkY2hpbGQub3V0ZXJIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgZGVsdGEgPSBiYm94Q2hpbGQuYm90dG9tIC0gYmJveFBhcmVudC5ib3R0b207XHJcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gY2xhbXAgdG8gdHJhY2tDb250YWluZXIgYm90dG9tXHJcbiAgICAgICAgICAgIHRvcExlZnQudG9wIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgYmJveENoaWxkLnRvcCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYmJveENoaWxkLmJvdHRvbSAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGRlbHRhID0gYmJveENoaWxkLnRvcCAtIGJib3hQYXJlbnQudG9wO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BMZWZ0LnRvcCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0b3BMZWZ0O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvZyhtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlndi5lbmFibGVMb2dnaW5nICYmIGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQge1V0aWxzfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ }),

/***/ "./src/vendor/inflate.js":
/*!*******************************!*\
  !*** ./src/vendor/inflate.js ***!
  \*******************************/
/*! exports provided: jszlib_inflate_buffer, arrayCopy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jszlib_inflate_buffer\", function() { return jszlib_inflate_buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayCopy\", function() { return arrayCopy; });\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS=15; // 32K LZ77 window\nvar DEF_WBITS=MAX_WBITS;\nvar MAX_MEM_LEVEL=9;\nvar MANY=1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT=0x20;\n\nvar Z_NO_FLUSH=0;\nvar Z_PARTIAL_FLUSH=1;\nvar Z_SYNC_FLUSH=2;\nvar Z_FULL_FLUSH=3;\nvar Z_FINISH=4;\n\nvar Z_DEFLATED=8;\n\nvar Z_OK=0;\nvar Z_STREAM_END=1;\nvar Z_NEED_DICT=2;\nvar Z_ERRNO=-1;\nvar Z_STREAM_ERROR=-2;\nvar Z_DATA_ERROR=-3;\nvar Z_MEM_ERROR=-4;\nvar Z_BUF_ERROR=-5;\nvar Z_VERSION_ERROR=-6;\n\nvar METHOD=0;   // waiting for method byte\nvar FLAG=1;     // waiting for flag byte\nvar DICT4=2;    // four dictionary check bytes to go\nvar DICT3=3;    // three dictionary check bytes to go\nvar DICT2=4;    // two dictionary check bytes to go\nvar DICT1=5;    // one dictionary check byte to go\nvar DICT0=6;    // waiting for inflateSetDictionary\nvar BLOCKS=7;   // decompressing blocks\nvar CHECK4=8;   // four check bytes to go\nvar CHECK3=9;   // three check bytes to go\nvar CHECK2=10;  // two check bytes to go\nvar CHECK1=11;  // one check byte to go\nvar DONE=12;    // finished check, done\nvar BAD=13;     // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE=0;  // get type bits (3, including end bit)\nvar IB_LENS=1;  // get lengths for stored\nvar IB_STORED=2;// processing stored block\nvar IB_TABLE=3; // get table lengths\nvar IB_BTREE=4; // get bit lengths tree for a dynamic block\nvar IB_DTREE=5; // get length, distance trees for a dynamic block\nvar IB_CODES=6; // processing fixed or dynamic block\nvar IB_DRY=7;   // output remaining window bytes\nvar IB_DONE=8;  // finished last block, done\nvar IB_BAD=9;   // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,192,\n    80,7,10, 0,8,96, 0,8,32, 0,9,160,\n    0,8,0, 0,8,128, 0,8,64, 0,9,224,\n    80,7,6, 0,8,88, 0,8,24, 0,9,144,\n    83,7,59, 0,8,120, 0,8,56, 0,9,208,\n    81,7,17, 0,8,104, 0,8,40, 0,9,176,\n    0,8,8, 0,8,136, 0,8,72, 0,9,240,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,200,\n    81,7,13, 0,8,100, 0,8,36, 0,9,168,\n    0,8,4, 0,8,132, 0,8,68, 0,9,232,\n    80,7,8, 0,8,92, 0,8,28, 0,9,152,\n    84,7,83, 0,8,124, 0,8,60, 0,9,216,\n    82,7,23, 0,8,108, 0,8,44, 0,9,184,\n    0,8,12, 0,8,140, 0,8,76, 0,9,248,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,196,\n    81,7,11, 0,8,98, 0,8,34, 0,9,164,\n    0,8,2, 0,8,130, 0,8,66, 0,9,228,\n    80,7,7, 0,8,90, 0,8,26, 0,9,148,\n    84,7,67, 0,8,122, 0,8,58, 0,9,212,\n    82,7,19, 0,8,106, 0,8,42, 0,9,180,\n    0,8,10, 0,8,138, 0,8,74, 0,9,244,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,204,\n    81,7,15, 0,8,102, 0,8,38, 0,9,172,\n    0,8,6, 0,8,134, 0,8,70, 0,9,236,\n    80,7,9, 0,8,94, 0,8,30, 0,9,156,\n    84,7,99, 0,8,126, 0,8,62, 0,9,220,\n    82,7,27, 0,8,110, 0,8,46, 0,9,188,\n    0,8,14, 0,8,142, 0,8,78, 0,9,252,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,194,\n    80,7,10, 0,8,97, 0,8,33, 0,9,162,\n    0,8,1, 0,8,129, 0,8,65, 0,9,226,\n    80,7,6, 0,8,89, 0,8,25, 0,9,146,\n    83,7,59, 0,8,121, 0,8,57, 0,9,210,\n    81,7,17, 0,8,105, 0,8,41, 0,9,178,\n    0,8,9, 0,8,137, 0,8,73, 0,9,242,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,202,\n    81,7,13, 0,8,101, 0,8,37, 0,9,170,\n    0,8,5, 0,8,133, 0,8,69, 0,9,234,\n    80,7,8, 0,8,93, 0,8,29, 0,9,154,\n    84,7,83, 0,8,125, 0,8,61, 0,9,218,\n    82,7,23, 0,8,109, 0,8,45, 0,9,186,\n    0,8,13, 0,8,141, 0,8,77, 0,9,250,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,198,\n    81,7,11, 0,8,99, 0,8,35, 0,9,166,\n    0,8,3, 0,8,131, 0,8,67, 0,9,230,\n    80,7,7, 0,8,91, 0,8,27, 0,9,150,\n    84,7,67, 0,8,123, 0,8,59, 0,9,214,\n    82,7,19, 0,8,107, 0,8,43, 0,9,182,\n    0,8,11, 0,8,139, 0,8,75, 0,9,246,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,206,\n    81,7,15, 0,8,103, 0,8,39, 0,9,174,\n    0,8,7, 0,8,135, 0,8,71, 0,9,238,\n    80,7,9, 0,8,95, 0,8,31, 0,9,158,\n    84,7,99, 0,8,127, 0,8,63, 0,9,222,\n    82,7,27, 0,8,111, 0,8,47, 0,9,190,\n    0,8,15, 0,8,143, 0,8,79, 0,9,254,\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,193,\n\n    80,7,10, 0,8,96, 0,8,32, 0,9,161,\n    0,8,0, 0,8,128, 0,8,64, 0,9,225,\n    80,7,6, 0,8,88, 0,8,24, 0,9,145,\n    83,7,59, 0,8,120, 0,8,56, 0,9,209,\n    81,7,17, 0,8,104, 0,8,40, 0,9,177,\n    0,8,8, 0,8,136, 0,8,72, 0,9,241,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,201,\n    81,7,13, 0,8,100, 0,8,36, 0,9,169,\n    0,8,4, 0,8,132, 0,8,68, 0,9,233,\n    80,7,8, 0,8,92, 0,8,28, 0,9,153,\n    84,7,83, 0,8,124, 0,8,60, 0,9,217,\n    82,7,23, 0,8,108, 0,8,44, 0,9,185,\n    0,8,12, 0,8,140, 0,8,76, 0,9,249,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,197,\n    81,7,11, 0,8,98, 0,8,34, 0,9,165,\n    0,8,2, 0,8,130, 0,8,66, 0,9,229,\n    80,7,7, 0,8,90, 0,8,26, 0,9,149,\n    84,7,67, 0,8,122, 0,8,58, 0,9,213,\n    82,7,19, 0,8,106, 0,8,42, 0,9,181,\n    0,8,10, 0,8,138, 0,8,74, 0,9,245,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,205,\n    81,7,15, 0,8,102, 0,8,38, 0,9,173,\n    0,8,6, 0,8,134, 0,8,70, 0,9,237,\n    80,7,9, 0,8,94, 0,8,30, 0,9,157,\n    84,7,99, 0,8,126, 0,8,62, 0,9,221,\n    82,7,27, 0,8,110, 0,8,46, 0,9,189,\n    0,8,14, 0,8,142, 0,8,78, 0,9,253,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,195,\n    80,7,10, 0,8,97, 0,8,33, 0,9,163,\n    0,8,1, 0,8,129, 0,8,65, 0,9,227,\n    80,7,6, 0,8,89, 0,8,25, 0,9,147,\n    83,7,59, 0,8,121, 0,8,57, 0,9,211,\n    81,7,17, 0,8,105, 0,8,41, 0,9,179,\n    0,8,9, 0,8,137, 0,8,73, 0,9,243,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,203,\n    81,7,13, 0,8,101, 0,8,37, 0,9,171,\n    0,8,5, 0,8,133, 0,8,69, 0,9,235,\n    80,7,8, 0,8,93, 0,8,29, 0,9,155,\n    84,7,83, 0,8,125, 0,8,61, 0,9,219,\n    82,7,23, 0,8,109, 0,8,45, 0,9,187,\n    0,8,13, 0,8,141, 0,8,77, 0,9,251,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,199,\n    81,7,11, 0,8,99, 0,8,35, 0,9,167,\n    0,8,3, 0,8,131, 0,8,67, 0,9,231,\n    80,7,7, 0,8,91, 0,8,27, 0,9,151,\n    84,7,67, 0,8,123, 0,8,59, 0,9,215,\n    82,7,19, 0,8,107, 0,8,43, 0,9,183,\n    0,8,11, 0,8,139, 0,8,75, 0,9,247,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,207,\n    81,7,15, 0,8,103, 0,8,39, 0,9,175,\n    0,8,7, 0,8,135, 0,8,71, 0,9,239,\n    80,7,9, 0,8,95, 0,8,31, 0,9,159,\n    84,7,99, 0,8,127, 0,8,63, 0,9,223,\n    82,7,27, 0,8,111, 0,8,47, 0,9,191,\n    0,8,15, 0,8,143, 0,8,79, 0,9,255\n];\nvar fixed_td = [\n    80,5,1, 87,5,257, 83,5,17, 91,5,4097,\n    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,\n    80,5,3, 88,5,513, 84,5,33, 92,5,8193,\n    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,\n    80,5,2, 87,5,385, 83,5,25, 91,5,6145,\n    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,\n    80,5,4, 88,5,769, 84,5,49, 92,5,12289,\n    82,5,13, 90,5,3073, 86,5,193, 192,5,24577\n];\n\n  // Tables for deflate from PKZIP's appnote.txt.\n  var cplens = [ // Copy lengths for literal codes 257..285\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n  ];\n\n  // see note #13 above about 258\n  var cplext = [ // Extra bits for literal codes 257..285\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid\n  ];\n\n var cpdist = [ // Copy offsets for distance codes 0..29\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n  ];\n\n  var cpdext = [ // Extra bits for distance codes\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {\n}\n\n\nZStream.prototype.inflateInit = function(w, nowrap) {\n    if (!w) {\n\tw = DEF_WBITS;\n    }\n    if (nowrap) {\n\tnowrap = false;\n    }\n    this.istate = new Inflate();\n    return this.istate.inflateInit(this, nowrap?-w:w);\n}\n\nZStream.prototype.inflate = function(f) {\n    if(this.istate==null) return Z_STREAM_ERROR;\n    return this.istate.inflate(this, f);\n}\n\nZStream.prototype.inflateEnd = function(){\n    if(this.istate==null) return Z_STREAM_ERROR;\n    var ret=istate.inflateEnd(this);\n    this.istate = null;\n    return ret;\n}\nZStream.prototype.inflateSync = function(){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSync(this);\n}\nZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSetDictionary(this, dictionary, dictLength);\n}\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n    this.was = [0];\n}\n\nInflate.prototype.inflateReset = function(z) {\n    if(z == null || z.istate == null) return Z_STREAM_ERROR;\n    \n    z.total_in = z.total_out = 0;\n    z.msg = null;\n    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;\n    z.istate.blocks.reset(z, null);\n    return Z_OK;\n}\n\nInflate.prototype.inflateEnd = function(z){\n    if(this.blocks != null)\n      this.blocks.free(z);\n    this.blocks=null;\n    return Z_OK;\n}\n\nInflate.prototype.inflateInit = function(z, w){\n    z.msg = null;\n    this.blocks = null;\n\n    // handle undocumented nowrap option (no zlib header or check)\n    let nowrap = 0;\n    if(w < 0){\n      w = - w;\n      nowrap = 1;\n    }\n\n    // set window size\n    if(w<8 ||w>15){\n      this.inflateEnd(z);\n      return Z_STREAM_ERROR;\n    }\n    this.wbits=w;\n\n    z.istate.blocks=new InfBlocks(z, \n\t\t\t\t  z.istate.nowrap!=0 ? null : this,\n\t\t\t\t  1<<w);\n\n    // reset state\n    this.inflateReset(z);\n    return Z_OK;\n  }\n\nInflate.prototype.inflate = function(z, f){\n    var r, b;\n\n    if(z == null || z.istate == null || z.next_in == null)\n      return Z_STREAM_ERROR;\n    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n    r = Z_BUF_ERROR;\n    while (true){\n      switch (z.istate.mode){\n      case METHOD:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){\n          z.istate.mode = BAD;\n          z.msg=\"unknown compression method\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        if((z.istate.method>>4)+8>z.istate.wbits){\n          z.istate.mode = BAD;\n          z.msg=\"invalid window size\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        z.istate.mode=FLAG;\n      case FLAG:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        b = (z.next_in[z.next_in_index++])&0xff;\n\n        if((((z.istate.method << 8)+b) % 31)!=0){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        if((b&PRESET_DICT)==0){\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=DICT3;\n      case DICT3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode=DICT2;\n      case DICT2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode=DICT1;\n      case DICT1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++]&0xff);\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0;       // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if(r == Z_DATA_ERROR){\n          z.istate.mode = BAD;\n          z.istate.marker = 0;     // can try inflateSync\n          break;\n        }\n        if(r == Z_OK){\n          r = f;\n        }\n        if(r != Z_STREAM_END){\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if(z.istate.nowrap!=0){\n          z.istate.mode=DONE;\n          break;\n        }\n        z.istate.mode=CHECK4;\n      case CHECK4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=CHECK3;\n      case CHECK3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);\n\n        if(((z.istate.was[0])) != ((z.istate.need))){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n      }\n    }\n  }\n\n\nInflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {\n    var index=0;\n    var length = dictLength;\n    if(z==null || z.istate == null|| z.istate.mode != DICT0)\n      return Z_STREAM_ERROR;\n\n    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){\n      return Z_DATA_ERROR;\n    }\n\n    z.adler = z._adler.adler32(0, null, 0, 0);\n\n    if(length >= (1<<z.istate.wbits)){\n      length = (1<<z.istate.wbits)-1;\n      index=dictLength - length;\n    }\n    z.istate.blocks.set_dictionary(dictionary, index, length);\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n  }\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255]\n\nInflate.prototype.inflateSync = function(z){\n    var n;       // number of bytes to look at\n    var p;       // pointer to bytes\n    var m;       // number of marker bytes found in a row\n    var r, w;   // temporaries to save total_in and total_out\n\n    // set up\n    if(z == null || z.istate == null)\n      return Z_STREAM_ERROR;\n    if(z.istate.mode != BAD){\n      z.istate.mode = BAD;\n      z.istate.marker = 0;\n    }\n    if((n=z.avail_in)==0)\n      return Z_BUF_ERROR;\n    p=z.next_in_index;\n    m=z.istate.marker;\n\n    // search\n    while (n!=0 && m < 4){\n      if(z.next_in[p] == mark[m]){\n        m++;\n      }\n      else if(z.next_in[p]!=0){\n        m = 0;\n      }\n      else{\n        m = 4 - m;\n      }\n      p++; n--;\n    }\n\n    // restore\n    z.total_in += p-z.next_in_index;\n    z.next_in_index = p;\n    z.avail_in = n;\n    z.istate.marker = m;\n\n    // return no joy or set up to restart on a new block\n    if(m != 4){\n      return Z_DATA_ERROR;\n    }\n    r=z.total_in;  w=z.total_out;\n    this.inflateReset(z);\n    z.total_in=r;  z.total_out = w;\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n  // but removes the length bytes of the resulting empty stored block. When\n  // decompressing, PPP checks that at the end of input packet, inflate is\n  // waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function(z){\n    if(z == null || z.istate == null || z.istate.blocks == null)\n      return Z_STREAM_ERROR;\n    return z.istate.blocks.sync_point();\n}\n\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n    this.hufts=new Int32Array(MANY*3);\n    this.window=new Uint8Array(w);\n    this.end=w;\n    this.checkfn = checkfn;\n    this.mode = IB_TYPE;\n    this.reset(z, null);\n\n    this.left = 0;            // if STORED, bytes left to copy \n\n    this.table = 0;           // table lengths (14 bits) \n    this.index = 0;           // index into blens (or border) \n    this.blens = null;         // bit lengths of codes \n    this.bb=new Int32Array(1); // bit length tree depth \n    this.tb=new Int32Array(1); // bit length decoding tree \n\n    this.codes = new InfCodes();\n\n    this.last = 0;            // true if this block is the last block \n\n  // mode independent information \n    this.bitk = 0;            // bits in bit buffer \n    this.bitb = 0;            // bit buffer \n    this.read = 0;            // window read pointer \n    this.write = 0;           // window write pointer \n    this.check = 0;          // check on output \n\n    this.inftree=new InfTree();\n}\n\n\n\n\nInfBlocks.prototype.reset = function(z, c){\n    if(c) c[0]=this.check;\n    if(this.mode==IB_CODES){\n      this.codes.free(z);\n    }\n    this.mode=IB_TYPE;\n    this.bitk=0;\n    this.bitb=0;\n    this.read=this.write=0;\n\n    if(this.checkfn)\n      z.adler=this.check=z._adler.adler32(0, null, 0, 0);\n  }\n\n InfBlocks.prototype.proc = function(z, r){\n    var t;              // temporary storage\n    var b;              // bit buffer\n    var k;              // bits in bit buffer\n    var p;              // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n\n    // copy input/output information to locals (UPDATE macro restores)\n    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}\n    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}\n\n    // process input based on current state\n    while(true){\n      switch (this.mode){\n      case IB_TYPE:\n\n\twhile(k<(3)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\tt = (b & 7);\n\tthis.last = t & 1;\n\n\tswitch (t >>> 1){\n        case 0:                         // stored \n          {b>>>=(3);k-=(3);}\n          t = k & 7;                    // go to byte boundary\n\n          {b>>>=(t);k-=(t);}\n          this.mode = IB_LENS;                  // get length of stored block\n          break;\n        case 1:                         // fixed\n          {\n              var bl=new Int32Array(1);\n\t      var bd=new Int32Array(1);\n              var tl=[];\n\t      var td=[];\n\n\t      inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n          }\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_CODES;\n          break;\n        case 2:                         // dynamic\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_TABLE;\n          break;\n        case 3:                         // illegal\n\n          {b>>>=(3);k-=(3);}\n          this.mode = BAD;\n          z.msg = \"invalid block type\";\n          r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tbreak;\n      case IB_LENS:\n\twhile(k<(32)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){\n\t  this.mode = BAD;\n\t  z.msg = \"invalid stored block lengths\";\n\t  r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tthis.left = (b & 0xffff);\n\tb = k = 0;                       // dump bits\n\tthis.mode = left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_STORED:\n\tif (n == 0){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tif(m==0){\n\t  if(q==end&&read!=0){\n\t    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);\n\t  }\n\t  if(m==0){\n\t    this.write=q; \n\t    r=this.inflate_flush(z,r);\n\t    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    if(q==this.end && this.read != 0){\n\t      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    }\n\t    if(m==0){\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\tt = this.left;\n\tif(t>n) t = n;\n\tif(t>m) t = m;\n\tarrayCopy(z.next_in, p, window, q, t);\n\tp += t;  n -= t;\n\tq += t;  m -= t;\n\tif ((this.left -= t) != 0)\n\t  break;\n\tthis.mode = (this.last != 0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_TABLE:\n\n\twhile(k<(14)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.table = t = (b & 0x3fff);\n\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n\t  {\n\t    this.mode = IB_BAD;\n\t    z.msg = \"too many length or distance symbols\";\n\t    r = Z_DATA_ERROR;\n\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  }\n\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\tif(this.blens==null || this.blens.length<t){\n\t    this.blens=new Int32Array(t);\n\t}\n\telse{\n\t  for(var i=0; i<t; i++){\n              this.blens[i]=0;\n          }\n\t}\n\n\t{b>>>=(14);k-=(14);}\n\n\tthis.index = 0;\n\tthis.mode = IB_BTREE;\n      case IB_BTREE:\n\twhile (this.index < 4 + (this.table >>> 10)){\n\t  while(k<(3)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;\n\n\t  {b>>>=(3);k-=(3);}\n\t}\n\n\twhile(this.index < 19){\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n\t}\n\n\tthis.bb[0] = 7;\n\tt = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n\tif (t != Z_OK){\n\t  r = t;\n\t  if (r == Z_DATA_ERROR){\n\t    this.blens=null;\n\t    this.mode = IB_BAD;\n\t  }\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tthis.index = 0;\n\tthis.mode = IB_DTREE;\n      case IB_DTREE:\n\twhile (true){\n\t  t = this.table;\n\t  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){\n\t    break;\n\t  }\n\n\t  var h; //int[]\n\t  var i, j, c;\n\n\t  t = this.bb[0];\n\n\t  while(k<(t)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n//\t  if (this.tb[0]==-1){\n//            dlog(\"null...\");\n//\t  }\n\n\t  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];\n\t  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];\n\n\t  if (c < 16){\n\t    b>>>=(t);k-=(t);\n\t    this.blens[this.index++] = c;\n\t  }\n\t  else { // c == 16..18\n\t    i = c == 18 ? 7 : c - 14;\n\t    j = c == 18 ? 11 : 3;\n\n\t    while(k<(t+i)){\n\t      if(n!=0){\n\t\tr=Z_OK;\n\t      }\n\t      else{\n\t\tthis.bitb=b; this.bitk=k; \n\t\tz.avail_in=n;\n\t\tz.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\tthis.write=q;\n\t\treturn this.inflate_flush(z,r);\n\t      };\n\t      n--;\n\t      b|=(z.next_in[p++]&0xff)<<k;\n\t      k+=8;\n\t    }\n\n\t    b>>>=(t);k-=(t);\n\n\t    j += (b & inflate_mask[i]);\n\n\t    b>>>=(i);k-=(i);\n\n\t    i = this.index;\n\t    t = this.table;\n\t    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n\t\t(c == 16 && i < 1)){\n\t      this.blens=null;\n\t      this.mode = IB_BAD;\n\t      z.msg = \"invalid bit length repeat\";\n\t      r = Z_DATA_ERROR;\n\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\n\t    c = c == 16 ? this.blens[i-1] : 0;\n\t    do{\n\t      this.blens[i++] = c;\n\t    }\n\t    while (--j!=0);\n\t    this.index = i;\n\t  }\n\t}\n\n\tthis.tb[0]=-1;\n\t{\n\t    var bl=new Int32Array(1);\n\t    var bd=new Int32Array(1);\n\t    var tl=new Int32Array(1);\n\t    var td=new Int32Array(1);\n\t    bl[0] = 9;         // must be <= 9 for lookahead assumptions\n\t    bd[0] = 6;         // must be <= 9 for lookahead assumptions\n\n\t    t = this.table;\n\t    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), \n\t\t\t\t\t      1 + ((t >> 5) & 0x1f),\n\t\t\t\t\t      this.blens, bl, bd, tl, td, this.hufts, z);\n\n\t    if (t != Z_OK){\n\t        if (t == Z_DATA_ERROR){\n\t            this.blens=null;\n\t            this.mode = BAD;\n\t        }\n\t        r = t;\n\n\t        this.bitb=b; this.bitk=k; \n\t        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t        this.write=q;\n\t        return this.inflate_flush(z,r);\n\t    }\n\t    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n\t}\n\tthis.mode = IB_CODES;\n      case IB_CODES:\n\tthis.bitb=b; this.bitk=k;\n\tz.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\n\tif ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){\n\t  return this.inflate_flush(z, r);\n\t}\n\tr = Z_OK;\n\tthis.codes.free(z);\n\n\tp=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;\n\tq=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);\n\n\tif (this.last==0){\n\t  this.mode = IB_TYPE;\n\t  break;\n\t}\n\tthis.mode = IB_DRY;\n      case IB_DRY:\n\tthis.write=q; \n\tr = this.inflate_flush(z, r); \n\tq=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\tif (this.read != this.write){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z, r);\n\t}\n\tthis.mode = DONE;\n      case IB_DONE:\n\tr = Z_STREAM_END;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      case IB_BAD:\n\tr = Z_DATA_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      }\n    }\n  }\n\nInfBlocks.prototype.free = function(z){\n    this.reset(z, null);\n    this.window=null;\n    this.hufts=null;\n}\n\nInfBlocks.prototype.set_dictionary = function(d, start, n){\n    arrayCopy(d, start, window, 0, n);\n    this.read = this.write = n;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function(){\n    return this.mode == IB_LENS;\n}\n\n  // copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function(z, r){\n    var n;\n    var p;\n    var q;\n\n    // local copies of source and destination pointers\n    p = z.next_out_index;\n    q = this.read;\n\n    // compute number of bytes to copy as far as end of window\n    n = ((q <= this.write ? this.write : this.end) - q);\n    if (n > z.avail_out) n = z.avail_out;\n    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if(this.checkfn != null)\n      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n    // copy as far as end of window\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n\n    // see if more to copy at beginning of window\n    if (q == this.end){\n      // wrap pointers\n      q = 0;\n      if (this.write == this.end)\n        this.write = 0;\n\n      // compute bytes to copy\n      n = this.write - q;\n      if (n > z.avail_out) n = z.avail_out;\n      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n      // update counters\n      z.avail_out -= n;\n      z.total_out += n;\n\n      // update check information\n      if(this.checkfn != null)\n\tz.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n      // copy\n      arrayCopy(this.window, q, z.next_out, p, n);\n      p += n;\n      q += n;\n    }\n\n    // update pointers\n    z.next_out_index = p;\n    this.read = q;\n\n    // done\n    return r;\n  }\n\n//\n// InfCodes.java\n//\n\nvar IC_START=0;  // x: set up for LEN\nvar IC_LEN=1;    // i: get length/literal/eob next\nvar IC_LENEXT=2; // i: getting length extra (have base)\nvar IC_DIST=3;   // i: get distance next\nvar IC_DISTEXT=4;// i: getting distance extra\nvar IC_COPY=5;   // o: copying bytes in window, waiting for space\nvar IC_LIT=6;    // o: got literal, waiting for output space\nvar IC_WASH=7;   // o: got eob, possibly still output waiting\nvar IC_END=8;    // x: got eob and all data flushed\nvar IC_BADCODE=9;// x: got error\n\nfunction InfCodes() {\n}\n\nInfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {\n    this.mode=IC_START;\n    this.lbits=bl;\n    this.dbits=bd;\n    this.ltree=tl;\n    this.ltree_index=tl_index;\n    this.dtree = td;\n    this.dtree_index=td_index;\n    this.tree=null;\n}\n\nInfCodes.prototype.proc = function(s, z, r){ \n    var j;              // temporary storage\n    var t;              // temporary pointer (int[])\n    var tindex;         // temporary pointer\n    var e;              // extra bits or operation\n    var b=0;            // bit buffer\n    var k=0;            // bits in bit buffer\n    var p=0;            // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n    var f;              // pointer to copy strings from\n\n    // copy input/output information to locals (UPDATE macro restores)\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // process input and output based on current state\n    while (true){\n      switch (this.mode){\n\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:         // x: set up for LEN\n\tif (m >= 258 && n >= 10){\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  r = this.inflate_fast(this.lbits, this.dbits, \n\t\t\t   this.ltree, this.ltree_index, \n\t\t\t   this.dtree, this.dtree_index,\n\t\t\t   s, z);\n\n\t  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n\t  q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t  if (r != Z_OK){\n\t    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n\t    break;\n\t  }\n\t}\n\tthis.need = this.lbits;\n\tthis.tree = this.ltree;\n\tthis.tree_index=this.ltree_index;\n\n\tthis.mode = IC_LEN;\n      case IC_LEN:           // i: get length/literal/eob next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b&inflate_mask[j]))*3;\n\n\tb>>>=(this.tree[tindex+1]);\n\tk-=(this.tree[tindex+1]);\n\n\te=this.tree[tindex];\n\n\tif(e == 0){               // literal\n\t  this.lit = this.tree[tindex+2];\n\t  this.mode = IC_LIT;\n\t  break;\n\t}\n\tif((e & 16)!=0 ){          // length\n\t  this.get = e & 15;\n\t  this.len = this.tree[tindex+2];\n\t  this.mode = IC_LENEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tif ((e & 32)!=0){               // end of block\n\t  this.mode = IC_WASH;\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid literal/length code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_LENEXT:        // i: getting length extra (have base)\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.len += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.need = this.dbits;\n\tthis.tree = this.dtree;\n\tthis.tree_index = this.dtree_index;\n\tthis.mode = IC_DIST;\n      case IC_DIST:          // i: get distance next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b & inflate_mask[j]))*3;\n\n\tb>>=this.tree[tindex+1];\n\tk-=this.tree[tindex+1];\n\n\te = (this.tree[tindex]);\n\tif((e & 16)!=0){               // distance\n\t  this.get = e & 15;\n\t  this.dist = this.tree[tindex+2];\n\t  this.mode = IC_DISTEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid distance code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_DISTEXT:       // i: getting distance extra\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.dist += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.mode = IC_COPY;\n      case IC_COPY:          // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while(f < 0){     // modulo window size-\"while\" instead\n          f += s.end;     // of \"if\" handles invalid distances\n\t}\n\twhile (this.len!=0){\n\n\t  if(m==0){\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.write=q; r=s.inflate_flush(z,r);\n\t      q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\n\t      if(m==0){\n\t\ts.bitb=b;s.bitk=k;\n\t\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\ts.write=q;\n\t\treturn s.inflate_flush(z,r);\n\t      }  \n\t    }\n\t  }\n\n\t  s.window[q++]=s.window[f++]; m--;\n\n\t  if (f == s.end)\n            f = 0;\n\t  this.len--;\n\t}\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_LIT:           // o: got literal, waiting for output space\n\tif(m==0){\n\t  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t  if(m==0){\n\t    s.write=q; r=s.inflate_flush(z,r);\n\t    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\t      return s.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\ts.window[q++]=this.lit; m--;\n\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_WASH:           // o: got eob, possibly more output\n\tif (k > 7){        // return unused byte, if any\n\t  k -= 8;\n\t  n++;\n\t  p--;             // can always return one\n\t}\n\n\ts.write=q; r=s.inflate_flush(z,r);\n\tq=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\tif (s.read != s.write){\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  return s.inflate_flush(z,r);\n\t}\n\tthis.mode = IC_END;\n      case IC_END:\n\tr = Z_STREAM_END;\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_BADCODE:       // x: got error\n\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n      }\n    }\n  }\n\nInfCodes.prototype.free = function(z){\n    //  ZFREE(z, c);\n}\n\n  // Called with number of bytes left to write in window at least 258\n  // (the maximum string length) and number of input bytes available\n  // at least ten.  The ten bytes are six bytes for the longest length/\n  // distance pair plus four bytes for overloading the bit buffer.\n\nInfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {\n    var t;                // temporary pointer\n    var   tp;             // temporary pointer (int[])\n    var tp_index;         // temporary pointer\n    var e;                // extra bits or operation\n    var b;                // bit buffer\n    var k;                // bits in bit buffer\n    var p;                // input data pointer\n    var n;                // bytes available there\n    var q;                // output window write pointer\n    var m;                // bytes to end of window or read pointer\n    var ml;               // mask for literal/length tree\n    var md;               // mask for distance tree\n    var c;                // bytes to copy\n    var d;                // distance back to copy from\n    var r;                // copy source pointer\n\n    var tp_index_t_3;     // (tp_index+t)*3\n\n    // load input, output, bit values\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // initialize masks\n    ml = inflate_mask[bl];\n    md = inflate_mask[bd];\n\n    // do until not enough input or output space for fast loop\n    do {                          // assume called with m >= 258 && n >= 10\n      // get literal/length code\n      while(k<(20)){              // max bits for literal/length code\n\tn--;\n\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n      }\n\n      t= b&ml;\n      tp=tl; \n      tp_index=tl_index;\n      tp_index_t_3=(tp_index+t)*3;\n      if ((e = tp[tp_index_t_3]) == 0){\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\ts.window[q++] = tp[tp_index_t_3+2];\n\tm--;\n\tcontinue;\n      }\n      do {\n\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\tif((e&16)!=0){\n\t  e &= 15;\n\t  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);\n\n\t  b>>=e; k-=e;\n\n\t  // decode distance base of block to copy\n\t  while(k<(15)){           // max bits for distance code\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t  }\n\n\t  t= b&md;\n\t  tp=td;\n\t  tp_index=td_index;\n          tp_index_t_3=(tp_index+t)*3;\n\t  e = tp[tp_index_t_3];\n\n\t  do {\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    if((e&16)!=0){\n\t      // get extra bits to add to distance base\n\t      e &= 15;\n\t      while(k<(e)){         // get extra bits (up to 13)\n\t\tn--;\n\t\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t      }\n\n\t      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);\n\n\t      b>>=(e); k-=(e);\n\n\t      // do the copy\n\t      m -= c;\n\t      if (q >= d){                // offset before dest\n\t\t//  just copy\n\t\tr=q-d;\n\t\tif(q-r>0 && 2>(q-r)){           \n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t\telse{\n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t      }\n\t      else{                  // else offset after destination\n                r=q-d;\n                do{\n                  r+=s.end;          // force pointer in window\n                }while(r<0);         // covers invalid distances\n\t\te=s.end-r;\n\t\tif(c>e){             // if source crosses,\n\t\t  c-=e;              // wrapped copy\n\t\t  if(q-r>0 && e>(q-r)){           \n\t\t    do{s.window[q++] = s.window[r++];}\n\t\t    while(--e!=0);\n\t\t  }\n\t\t  else{\n\t\t    arrayCopy(s.window, r, s.window, q, e);\n\t\t    q+=e; r+=e; e=0;\n\t\t  }\n\t\t  r = 0;                  // copy rest from start of window\n\t\t}\n\n\t      }\n\n\t      // copy all or what's left\n              do{s.window[q++] = s.window[r++];}\n\t\twhile(--c!=0);\n\t      break;\n\t    }\n\t    else if((e&64)==0){\n\t      t+=tp[tp_index_t_3+2];\n\t      t+=(b&inflate_mask[e]);\n\t      tp_index_t_3=(tp_index+t)*3;\n\t      e=tp[tp_index_t_3];\n\t    }\n\t    else{\n\t      z.msg = \"invalid distance code\";\n\n\t      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\n\t      return Z_DATA_ERROR;\n\t    }\n\t  }\n\t  while(true);\n\t  break;\n\t}\n\n\tif((e&64)==0){\n\t  t+=tp[tp_index_t_3+2];\n\t  t+=(b&inflate_mask[e]);\n\t  tp_index_t_3=(tp_index+t)*3;\n\t  if((e=tp[tp_index_t_3])==0){\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    s.window[q++]=tp[tp_index_t_3+2];\n\t    m--;\n\t    break;\n\t  }\n\t}\n\telse if((e&32)!=0){\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n \n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_STREAM_END;\n\t}\n\telse{\n\t  z.msg=\"invalid literal/length code\";\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_DATA_ERROR;\n\t}\n      } \n      while(true);\n    } \n    while(m>=258 && n>= 10);\n\n    // not enough input or output--restore pointers and return\n    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n    s.bitb=b;s.bitk=k;\n    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n    s.write=q;\n\n    return Z_OK;\n}\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {\n}\n\nInfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n    // Given a list of code lengths and a maximum table size, make a set of\n    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n    // if the given code set is incomplete (the tables are still built in this\n    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n    // lengths), or Z_MEM_ERROR if not enough memory.\n\n    var a;                       // counter for codes of length k\n    var f;                       // i repeats in table every f entries\n    var g;                       // maximum code length\n    var h;                       // table level\n    var i;                       // counter, current code\n    var j;                       // counter\n    var k;                       // number of bits in current code\n    var l;                       // bits per table (returned in m)\n    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP\n    var p;                       // pointer into c[], b[], or v[]\n    var q;                       // points to current table\n    var w;                       // bits before this table == (l * h)\n    var xp;                      // pointer into x\n    var y;                       // number of dummy codes added\n    var z;                       // number of entries in current table\n\n    // Generate counts for each bit length\n\n    p = 0; i = n;\n    do {\n      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX\n    }while(i!=0);\n\n    if(this.c[0] == n){                // null input--all zero length codes\n      t[0] = -1;\n      m[0] = 0;\n      return Z_OK;\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    l = m[0];\n    for (j = 1; j <= BMAX; j++)\n      if(this.c[j]!=0) break;\n    k = j;                        // minimum code length\n    if(l < j){\n      l = j;\n    }\n    for (i = BMAX; i!=0; i--){\n      if(this.c[i]!=0) break;\n    }\n    g = i;                        // maximum code length\n    if(l > i){\n      l = i;\n    }\n    m[0] = l;\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1){\n      if ((y -= this.c[j]) < 0){\n        return Z_DATA_ERROR;\n      }\n    }\n    if ((y -= this.c[i]) < 0){\n      return Z_DATA_ERROR;\n    }\n    this.c[i] += y;\n\n    // Generate starting offsets into the value table for each length\n    this.x[1] = j = 0;\n    p = 1;  xp = 2;\n    while (--i!=0) {                 // note that i == g from above\n      this.x[xp] = (j += this.c[p]);\n      xp++;\n      p++;\n    }\n\n    // Make a table of values in order of bit lengths\n    i = 0; p = 0;\n    do {\n      if ((j = b[bindex+p]) != 0){\n        this.v[this.x[j]++] = i;\n      }\n      p++;\n    }\n    while (++i < n);\n    n = this.x[g];                     // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    this.x[0] = i = 0;                 // first Huffman code is zero\n    p = 0;                        // grab values in bit order\n    h = -1;                       // no tables yet--level -1\n    w = -l;                       // bits decoded == (l * h)\n    this.u[0] = 0;                     // just to keep compilers happy\n    q = 0;                        // ditto\n    z = 0;                        // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (; k <= g; k++){\n      a = this.c[k];\n      while (a--!=0){\n\t// here i is the Huffman code of length k bits for value *p\n\t// make tables up to required level\n        while (k > w + l){\n          h++;\n          w += l;                 // previous table always l bits\n\t  // compute minimum size table less than or equal to l bits\n          z = g - w;\n          z = (z > l) ? l : z;        // table size upper limit\n          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table\n                                      // too few codes for k-w bit table\n            f -= a + 1;               // deduct codes from patterns left\n            xp = k;\n            if(j < z){\n              while (++j < z){        // try smaller tables up to z bits\n                if((f <<= 1) <= this.c[++xp])\n                  break;              // enough codes to use up j bits\n                f -= this.c[xp];           // else deduct codes from patterns\n              }\n\t    }\n          }\n          z = 1 << j;                 // table entries for j-bit table\n\n\t  // allocate new table\n          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)\n            return Z_DATA_ERROR;       // overflow of MANY\n          }\n          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG\n          this.hn[0] += z;\n \n\t  // connect to last table, if there is one\n\t  if(h!=0){\n            this.x[h]=i;           // save pattern for backing up\n            this.r[0]=j;     // bits in this table\n            this.r[1]=l;     // bits to dump before this table\n            j=i>>>(w - l);\n            this.r[2] = (q - this.u[h-1] - j);               // offset to this table\n            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table\n          }\n          else{\n            t[0] = q;               // first table is returned result\n\t  }\n        }\n\n\t// set up table entry in r\n        this.r[1] = (k - w);\n        if (p >= n){\n          this.r[0] = 128 + 64;      // out of values--invalid code\n\t}\n        else if (v[p] < s){\n          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block\n          this.r[2] = this.v[p++];          // simple code is just the value\n        }\n        else{\n          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists\n          this.r[2]=d[this.v[p++] - s];\n        }\n\n        // fill code-like entries with r\n        f=1<<(k-w);\n        for (j=i>>>w;j<z;j+=f){\n          arrayCopy(this.r, 0, hp, (q+j)*3, 3);\n\t}\n\n\t// backwards increment the k-bit code i\n        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){\n          i ^= j;\n\t}\n        i ^= j;\n\n\t// backup over finished tables\n        mask = (1 << w) - 1;      // needed on HP, cc -O bug\n        while ((i & mask) != this.x[h]){\n          h--;                    // don't need to update q\n          w -= l;\n          mask = (1 << w) - 1;\n        }\n      }\n    }\n    // Return Z_BUF_ERROR if we were given an incomplete table\n    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\nInfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {\n    var result;\n    this.initWorkArea(19);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n    if(result == Z_DATA_ERROR){\n      z.msg = \"oversubscribed dynamic bit lengths tree\";\n    }\n    else if(result == Z_BUF_ERROR || bb[0] == 0){\n      z.msg = \"incomplete dynamic bit lengths tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n}\n\nInfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {\n    var result;\n\n    // build literal/length tree\n    this.initWorkArea(288);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n    if (result != Z_OK || bl[0] == 0){\n      if(result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed literal/length tree\";\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"incomplete literal/length tree\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    // build distance tree\n    this.initWorkArea(288);\n    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n    if (result != Z_OK || (bd[0] == 0 && nl > 257)){\n      if (result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed distance tree\";\n      }\n      else if (result == Z_BUF_ERROR) {\n        z.msg = \"incomplete distance tree\";\n        result = Z_DATA_ERROR;\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"empty distance tree with lengths\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    return Z_OK;\n}\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n    bl[0]=fixed_bl;\n    bd[0]=fixed_bd;\n    tl[0]=fixed_tl;\n    td[0]=fixed_td;\n    return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function(vsize){\n    if(this.hn==null){\n        this.hn=new Int32Array(1);\n        this.v=new Int32Array(vsize);\n        this.c=new Int32Array(BMAX+1);\n        this.r=new Int32Array(3);\n        this.u=new Int32Array(BMAX);\n        this.x=new Int32Array(BMAX+1);\n    }\n    if(this.v.length<vsize){ \n        this.v=new Int32Array(vsize); \n    }\n    for(var i=0; i<vsize; i++){this.v[i]=0;}\n    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}\n    for(var i=0; i<3; i++){this.r[i]=0;}\n//  for(int i=0; i<BMAX; i++){u[i]=0;}\n    arrayCopy(this.c, 0, this.u, 0, BMAX);\n//  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n    arrayCopy(this.c, 0, this.x, 0, BMAX+1);\n}\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = (typeof testArray.subarray === 'function');\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n    if (count == 0) {\n        return;\n    } \n    if (!src) {\n        throw \"Undef src\";\n    } else if (!dest) {\n        throw \"Undef dest\";\n    }\n\n    if (srcOffset == 0 && count == src.length) {\n        arrayCopy_fast(src, dest, destOffset);\n    } else if (hasSubarray) {\n        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); \n    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n    } else { \n        arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n    }\n\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n     for (var i = 0; i < count; ++i) {\n        dest[destOffset + i] = src[srcOffset + i];\n    }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n    dest.set(src, destOffset);\n}\n\n\n  // largest prime smaller than 65536\nvar ADLER_BASE=65521; \n  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX=5552;\n\nfunction adler32(adler, /* byte[] */ buf,  index, len){\n    if(buf == null){ return 1; }\n\n    var s1=adler&0xffff;\n    var s2=(adler>>16)&0xffff;\n    var k;\n\n    while(len > 0) {\n      k=len<ADLER_NMAX?len:ADLER_NMAX;\n      len-=k;\n      while(k>=16){\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        k-=16;\n      }\n      if(k!=0){\n        do{\n          s1+=buf[index++]&0xff; s2+=s1;\n        }\n        while(--k!=0);\n      }\n      s1%=ADLER_BASE;\n      s2%=ADLER_BASE;\n    }\n    return (s2<<16)|s1;\n}\n\n\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n    if (!start) {\n        buffer = new Uint8Array(buffer);\n    } else {\n        buffer = new Uint8Array(buffer, start, length);\n    }\n\n    var z = new ZStream();\n    z.inflateInit(DEF_WBITS, true);\n    z.next_in = buffer;\n    z.next_in_index = 0;\n    z.avail_in = buffer.length;\n\n    var oBlockList = [];\n    var totalSize = 0;\n    while (true) {\n        var obuf = new Uint8Array(32000);\n        z.next_out = obuf;\n        z.next_out_index = 0;\n        z.avail_out = obuf.length;\n        var status = z.inflate(Z_NO_FLUSH);\n        if (status != Z_OK && status != Z_STREAM_END) {\n            throw z.msg;\n        }\n        if (z.avail_out != 0) {\n            var newob = new Uint8Array(obuf.length - z.avail_out);\n            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));\n            obuf = newob;\n        }\n        oBlockList.push(obuf);\n        totalSize += obuf.length;\n        if (status == Z_STREAM_END) {\n            break;\n        }\n    }\n\n    if (afterUncOffset) {\n        afterUncOffset[0] = (start || 0) + z.next_in_index;\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0].buffer;\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = oBlockList[i];\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL2luZmxhdGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL2luZmxhdGUuanM/ODMyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBKYXZhc2NyaXB0IFpMaWJcbi8vIEJ5IFRob21hcyBEb3duIDIwMTAtMjAxMVxuLy9cbi8vIEJhc2VkIHZlcnkgaGVhdmlseSBvbiBwb3J0aW9ucyBvZiBqemxpYiAoYnkgeW1ua0BqY3JhZnQuY29tKSwgd2hvIGluXG4vLyB0dXJuIGNyZWRpdHMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlciBmb3IgdGhlIG9yaWdpbmFsIHpsaWIgY29kZS5cbi8vXG4vLyBpbmZsYXRlLmpzOiBaTGliIGluZmxhdGUgY29kZVxuLy9cblxuLy9cbi8vIFNoYXJlZCBjb25zdGFudHNcbi8vXG5cbnZhciBNQVhfV0JJVFM9MTU7IC8vIDMySyBMWjc3IHdpbmRvd1xudmFyIERFRl9XQklUUz1NQVhfV0JJVFM7XG52YXIgTUFYX01FTV9MRVZFTD05O1xudmFyIE1BTlk9MTQ0MDtcbnZhciBCTUFYID0gMTU7XG5cbi8vIHByZXNldCBkaWN0aW9uYXJ5IGZsYWcgaW4gemxpYiBoZWFkZXJcbnZhciBQUkVTRVRfRElDVD0weDIwO1xuXG52YXIgWl9OT19GTFVTSD0wO1xudmFyIFpfUEFSVElBTF9GTFVTSD0xO1xudmFyIFpfU1lOQ19GTFVTSD0yO1xudmFyIFpfRlVMTF9GTFVTSD0zO1xudmFyIFpfRklOSVNIPTQ7XG5cbnZhciBaX0RFRkxBVEVEPTg7XG5cbnZhciBaX09LPTA7XG52YXIgWl9TVFJFQU1fRU5EPTE7XG52YXIgWl9ORUVEX0RJQ1Q9MjtcbnZhciBaX0VSUk5PPS0xO1xudmFyIFpfU1RSRUFNX0VSUk9SPS0yO1xudmFyIFpfREFUQV9FUlJPUj0tMztcbnZhciBaX01FTV9FUlJPUj0tNDtcbnZhciBaX0JVRl9FUlJPUj0tNTtcbnZhciBaX1ZFUlNJT05fRVJST1I9LTY7XG5cbnZhciBNRVRIT0Q9MDsgICAvLyB3YWl0aW5nIGZvciBtZXRob2QgYnl0ZVxudmFyIEZMQUc9MTsgICAgIC8vIHdhaXRpbmcgZm9yIGZsYWcgYnl0ZVxudmFyIERJQ1Q0PTI7ICAgIC8vIGZvdXIgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QzPTM7ICAgIC8vIHRocmVlIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBESUNUMj00OyAgICAvLyB0d28gZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QxPTU7ICAgIC8vIG9uZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGUgdG8gZ29cbnZhciBESUNUMD02OyAgICAvLyB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeVxudmFyIEJMT0NLUz03OyAgIC8vIGRlY29tcHJlc3NpbmcgYmxvY2tzXG52YXIgQ0hFQ0s0PTg7ICAgLy8gZm91ciBjaGVjayBieXRlcyB0byBnb1xudmFyIENIRUNLMz05OyAgIC8vIHRocmVlIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0syPTEwOyAgLy8gdHdvIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0sxPTExOyAgLy8gb25lIGNoZWNrIGJ5dGUgdG8gZ29cbnZhciBET05FPTEyOyAgICAvLyBmaW5pc2hlZCBjaGVjaywgZG9uZVxudmFyIEJBRD0xMzsgICAgIC8vIGdvdCBhbiBlcnJvci0tc3RheSBoZXJlXG5cbnZhciBpbmZsYXRlX21hc2sgPSBbMHgwMDAwMDAwMCwgMHgwMDAwMDAwMSwgMHgwMDAwMDAwMywgMHgwMDAwMDAwNywgMHgwMDAwMDAwZiwgMHgwMDAwMDAxZiwgMHgwMDAwMDAzZiwgMHgwMDAwMDA3ZiwgMHgwMDAwMDBmZiwgMHgwMDAwMDFmZiwgMHgwMDAwMDNmZiwgMHgwMDAwMDdmZiwgMHgwMDAwMGZmZiwgMHgwMDAwMWZmZiwgMHgwMDAwM2ZmZiwgMHgwMDAwN2ZmZiwgMHgwMDAwZmZmZl07XG5cbnZhciBJQl9UWVBFPTA7ICAvLyBnZXQgdHlwZSBiaXRzICgzLCBpbmNsdWRpbmcgZW5kIGJpdClcbnZhciBJQl9MRU5TPTE7ICAvLyBnZXQgbGVuZ3RocyBmb3Igc3RvcmVkXG52YXIgSUJfU1RPUkVEPTI7Ly8gcHJvY2Vzc2luZyBzdG9yZWQgYmxvY2tcbnZhciBJQl9UQUJMRT0zOyAvLyBnZXQgdGFibGUgbGVuZ3Roc1xudmFyIElCX0JUUkVFPTQ7IC8vIGdldCBiaXQgbGVuZ3RocyB0cmVlIGZvciBhIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9EVFJFRT01OyAvLyBnZXQgbGVuZ3RoLCBkaXN0YW5jZSB0cmVlcyBmb3IgYSBkeW5hbWljIGJsb2NrXG52YXIgSUJfQ09ERVM9NjsgLy8gcHJvY2Vzc2luZyBmaXhlZCBvciBkeW5hbWljIGJsb2NrXG52YXIgSUJfRFJZPTc7ICAgLy8gb3V0cHV0IHJlbWFpbmluZyB3aW5kb3cgYnl0ZXNcbnZhciBJQl9ET05FPTg7ICAvLyBmaW5pc2hlZCBsYXN0IGJsb2NrLCBkb25lXG52YXIgSUJfQkFEPTk7ICAgLy8gb3QgYSBkYXRhIGVycm9yLS1zdHVjayBoZXJlXG5cbnZhciBmaXhlZF9ibCA9IDk7XG52YXIgZml4ZWRfYmQgPSA1O1xuXG52YXIgZml4ZWRfdGwgPSBbXG4gICAgOTYsNywyNTYsIDAsOCw4MCwgMCw4LDE2LCA4NCw4LDExNSxcbiAgICA4Miw3LDMxLCAwLDgsMTEyLCAwLDgsNDgsIDAsOSwxOTIsXG4gICAgODAsNywxMCwgMCw4LDk2LCAwLDgsMzIsIDAsOSwxNjAsXG4gICAgMCw4LDAsIDAsOCwxMjgsIDAsOCw2NCwgMCw5LDIyNCxcbiAgICA4MCw3LDYsIDAsOCw4OCwgMCw4LDI0LCAwLDksMTQ0LFxuICAgIDgzLDcsNTksIDAsOCwxMjAsIDAsOCw1NiwgMCw5LDIwOCxcbiAgICA4MSw3LDE3LCAwLDgsMTA0LCAwLDgsNDAsIDAsOSwxNzYsXG4gICAgMCw4LDgsIDAsOCwxMzYsIDAsOCw3MiwgMCw5LDI0MCxcbiAgICA4MCw3LDQsIDAsOCw4NCwgMCw4LDIwLCA4NSw4LDIyNyxcbiAgICA4Myw3LDQzLCAwLDgsMTE2LCAwLDgsNTIsIDAsOSwyMDAsXG4gICAgODEsNywxMywgMCw4LDEwMCwgMCw4LDM2LCAwLDksMTY4LFxuICAgIDAsOCw0LCAwLDgsMTMyLCAwLDgsNjgsIDAsOSwyMzIsXG4gICAgODAsNyw4LCAwLDgsOTIsIDAsOCwyOCwgMCw5LDE1MixcbiAgICA4NCw3LDgzLCAwLDgsMTI0LCAwLDgsNjAsIDAsOSwyMTYsXG4gICAgODIsNywyMywgMCw4LDEwOCwgMCw4LDQ0LCAwLDksMTg0LFxuICAgIDAsOCwxMiwgMCw4LDE0MCwgMCw4LDc2LCAwLDksMjQ4LFxuICAgIDgwLDcsMywgMCw4LDgyLCAwLDgsMTgsIDg1LDgsMTYzLFxuICAgIDgzLDcsMzUsIDAsOCwxMTQsIDAsOCw1MCwgMCw5LDE5NixcbiAgICA4MSw3LDExLCAwLDgsOTgsIDAsOCwzNCwgMCw5LDE2NCxcbiAgICAwLDgsMiwgMCw4LDEzMCwgMCw4LDY2LCAwLDksMjI4LFxuICAgIDgwLDcsNywgMCw4LDkwLCAwLDgsMjYsIDAsOSwxNDgsXG4gICAgODQsNyw2NywgMCw4LDEyMiwgMCw4LDU4LCAwLDksMjEyLFxuICAgIDgyLDcsMTksIDAsOCwxMDYsIDAsOCw0MiwgMCw5LDE4MCxcbiAgICAwLDgsMTAsIDAsOCwxMzgsIDAsOCw3NCwgMCw5LDI0NCxcbiAgICA4MCw3LDUsIDAsOCw4NiwgMCw4LDIyLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTgsIDAsOCw1NCwgMCw5LDIwNCxcbiAgICA4MSw3LDE1LCAwLDgsMTAyLCAwLDgsMzgsIDAsOSwxNzIsXG4gICAgMCw4LDYsIDAsOCwxMzQsIDAsOCw3MCwgMCw5LDIzNixcbiAgICA4MCw3LDksIDAsOCw5NCwgMCw4LDMwLCAwLDksMTU2LFxuICAgIDg0LDcsOTksIDAsOCwxMjYsIDAsOCw2MiwgMCw5LDIyMCxcbiAgICA4Miw3LDI3LCAwLDgsMTEwLCAwLDgsNDYsIDAsOSwxODgsXG4gICAgMCw4LDE0LCAwLDgsMTQyLCAwLDgsNzgsIDAsOSwyNTIsXG4gICAgOTYsNywyNTYsIDAsOCw4MSwgMCw4LDE3LCA4NSw4LDEzMSxcbiAgICA4Miw3LDMxLCAwLDgsMTEzLCAwLDgsNDksIDAsOSwxOTQsXG4gICAgODAsNywxMCwgMCw4LDk3LCAwLDgsMzMsIDAsOSwxNjIsXG4gICAgMCw4LDEsIDAsOCwxMjksIDAsOCw2NSwgMCw5LDIyNixcbiAgICA4MCw3LDYsIDAsOCw4OSwgMCw4LDI1LCAwLDksMTQ2LFxuICAgIDgzLDcsNTksIDAsOCwxMjEsIDAsOCw1NywgMCw5LDIxMCxcbiAgICA4MSw3LDE3LCAwLDgsMTA1LCAwLDgsNDEsIDAsOSwxNzgsXG4gICAgMCw4LDksIDAsOCwxMzcsIDAsOCw3MywgMCw5LDI0MixcbiAgICA4MCw3LDQsIDAsOCw4NSwgMCw4LDIxLCA4MCw4LDI1OCxcbiAgICA4Myw3LDQzLCAwLDgsMTE3LCAwLDgsNTMsIDAsOSwyMDIsXG4gICAgODEsNywxMywgMCw4LDEwMSwgMCw4LDM3LCAwLDksMTcwLFxuICAgIDAsOCw1LCAwLDgsMTMzLCAwLDgsNjksIDAsOSwyMzQsXG4gICAgODAsNyw4LCAwLDgsOTMsIDAsOCwyOSwgMCw5LDE1NCxcbiAgICA4NCw3LDgzLCAwLDgsMTI1LCAwLDgsNjEsIDAsOSwyMTgsXG4gICAgODIsNywyMywgMCw4LDEwOSwgMCw4LDQ1LCAwLDksMTg2LFxuICAgIDAsOCwxMywgMCw4LDE0MSwgMCw4LDc3LCAwLDksMjUwLFxuICAgIDgwLDcsMywgMCw4LDgzLCAwLDgsMTksIDg1LDgsMTk1LFxuICAgIDgzLDcsMzUsIDAsOCwxMTUsIDAsOCw1MSwgMCw5LDE5OCxcbiAgICA4MSw3LDExLCAwLDgsOTksIDAsOCwzNSwgMCw5LDE2NixcbiAgICAwLDgsMywgMCw4LDEzMSwgMCw4LDY3LCAwLDksMjMwLFxuICAgIDgwLDcsNywgMCw4LDkxLCAwLDgsMjcsIDAsOSwxNTAsXG4gICAgODQsNyw2NywgMCw4LDEyMywgMCw4LDU5LCAwLDksMjE0LFxuICAgIDgyLDcsMTksIDAsOCwxMDcsIDAsOCw0MywgMCw5LDE4MixcbiAgICAwLDgsMTEsIDAsOCwxMzksIDAsOCw3NSwgMCw5LDI0NixcbiAgICA4MCw3LDUsIDAsOCw4NywgMCw4LDIzLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTksIDAsOCw1NSwgMCw5LDIwNixcbiAgICA4MSw3LDE1LCAwLDgsMTAzLCAwLDgsMzksIDAsOSwxNzQsXG4gICAgMCw4LDcsIDAsOCwxMzUsIDAsOCw3MSwgMCw5LDIzOCxcbiAgICA4MCw3LDksIDAsOCw5NSwgMCw4LDMxLCAwLDksMTU4LFxuICAgIDg0LDcsOTksIDAsOCwxMjcsIDAsOCw2MywgMCw5LDIyMixcbiAgICA4Miw3LDI3LCAwLDgsMTExLCAwLDgsNDcsIDAsOSwxOTAsXG4gICAgMCw4LDE1LCAwLDgsMTQzLCAwLDgsNzksIDAsOSwyNTQsXG4gICAgOTYsNywyNTYsIDAsOCw4MCwgMCw4LDE2LCA4NCw4LDExNSxcbiAgICA4Miw3LDMxLCAwLDgsMTEyLCAwLDgsNDgsIDAsOSwxOTMsXG5cbiAgICA4MCw3LDEwLCAwLDgsOTYsIDAsOCwzMiwgMCw5LDE2MSxcbiAgICAwLDgsMCwgMCw4LDEyOCwgMCw4LDY0LCAwLDksMjI1LFxuICAgIDgwLDcsNiwgMCw4LDg4LCAwLDgsMjQsIDAsOSwxNDUsXG4gICAgODMsNyw1OSwgMCw4LDEyMCwgMCw4LDU2LCAwLDksMjA5LFxuICAgIDgxLDcsMTcsIDAsOCwxMDQsIDAsOCw0MCwgMCw5LDE3NyxcbiAgICAwLDgsOCwgMCw4LDEzNiwgMCw4LDcyLCAwLDksMjQxLFxuICAgIDgwLDcsNCwgMCw4LDg0LCAwLDgsMjAsIDg1LDgsMjI3LFxuICAgIDgzLDcsNDMsIDAsOCwxMTYsIDAsOCw1MiwgMCw5LDIwMSxcbiAgICA4MSw3LDEzLCAwLDgsMTAwLCAwLDgsMzYsIDAsOSwxNjksXG4gICAgMCw4LDQsIDAsOCwxMzIsIDAsOCw2OCwgMCw5LDIzMyxcbiAgICA4MCw3LDgsIDAsOCw5MiwgMCw4LDI4LCAwLDksMTUzLFxuICAgIDg0LDcsODMsIDAsOCwxMjQsIDAsOCw2MCwgMCw5LDIxNyxcbiAgICA4Miw3LDIzLCAwLDgsMTA4LCAwLDgsNDQsIDAsOSwxODUsXG4gICAgMCw4LDEyLCAwLDgsMTQwLCAwLDgsNzYsIDAsOSwyNDksXG4gICAgODAsNywzLCAwLDgsODIsIDAsOCwxOCwgODUsOCwxNjMsXG4gICAgODMsNywzNSwgMCw4LDExNCwgMCw4LDUwLCAwLDksMTk3LFxuICAgIDgxLDcsMTEsIDAsOCw5OCwgMCw4LDM0LCAwLDksMTY1LFxuICAgIDAsOCwyLCAwLDgsMTMwLCAwLDgsNjYsIDAsOSwyMjksXG4gICAgODAsNyw3LCAwLDgsOTAsIDAsOCwyNiwgMCw5LDE0OSxcbiAgICA4NCw3LDY3LCAwLDgsMTIyLCAwLDgsNTgsIDAsOSwyMTMsXG4gICAgODIsNywxOSwgMCw4LDEwNiwgMCw4LDQyLCAwLDksMTgxLFxuICAgIDAsOCwxMCwgMCw4LDEzOCwgMCw4LDc0LCAwLDksMjQ1LFxuICAgIDgwLDcsNSwgMCw4LDg2LCAwLDgsMjIsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOCwgMCw4LDU0LCAwLDksMjA1LFxuICAgIDgxLDcsMTUsIDAsOCwxMDIsIDAsOCwzOCwgMCw5LDE3MyxcbiAgICAwLDgsNiwgMCw4LDEzNCwgMCw4LDcwLCAwLDksMjM3LFxuICAgIDgwLDcsOSwgMCw4LDk0LCAwLDgsMzAsIDAsOSwxNTcsXG4gICAgODQsNyw5OSwgMCw4LDEyNiwgMCw4LDYyLCAwLDksMjIxLFxuICAgIDgyLDcsMjcsIDAsOCwxMTAsIDAsOCw0NiwgMCw5LDE4OSxcbiAgICAwLDgsMTQsIDAsOCwxNDIsIDAsOCw3OCwgMCw5LDI1MyxcbiAgICA5Niw3LDI1NiwgMCw4LDgxLCAwLDgsMTcsIDg1LDgsMTMxLFxuICAgIDgyLDcsMzEsIDAsOCwxMTMsIDAsOCw0OSwgMCw5LDE5NSxcbiAgICA4MCw3LDEwLCAwLDgsOTcsIDAsOCwzMywgMCw5LDE2MyxcbiAgICAwLDgsMSwgMCw4LDEyOSwgMCw4LDY1LCAwLDksMjI3LFxuICAgIDgwLDcsNiwgMCw4LDg5LCAwLDgsMjUsIDAsOSwxNDcsXG4gICAgODMsNyw1OSwgMCw4LDEyMSwgMCw4LDU3LCAwLDksMjExLFxuICAgIDgxLDcsMTcsIDAsOCwxMDUsIDAsOCw0MSwgMCw5LDE3OSxcbiAgICAwLDgsOSwgMCw4LDEzNywgMCw4LDczLCAwLDksMjQzLFxuICAgIDgwLDcsNCwgMCw4LDg1LCAwLDgsMjEsIDgwLDgsMjU4LFxuICAgIDgzLDcsNDMsIDAsOCwxMTcsIDAsOCw1MywgMCw5LDIwMyxcbiAgICA4MSw3LDEzLCAwLDgsMTAxLCAwLDgsMzcsIDAsOSwxNzEsXG4gICAgMCw4LDUsIDAsOCwxMzMsIDAsOCw2OSwgMCw5LDIzNSxcbiAgICA4MCw3LDgsIDAsOCw5MywgMCw4LDI5LCAwLDksMTU1LFxuICAgIDg0LDcsODMsIDAsOCwxMjUsIDAsOCw2MSwgMCw5LDIxOSxcbiAgICA4Miw3LDIzLCAwLDgsMTA5LCAwLDgsNDUsIDAsOSwxODcsXG4gICAgMCw4LDEzLCAwLDgsMTQxLCAwLDgsNzcsIDAsOSwyNTEsXG4gICAgODAsNywzLCAwLDgsODMsIDAsOCwxOSwgODUsOCwxOTUsXG4gICAgODMsNywzNSwgMCw4LDExNSwgMCw4LDUxLCAwLDksMTk5LFxuICAgIDgxLDcsMTEsIDAsOCw5OSwgMCw4LDM1LCAwLDksMTY3LFxuICAgIDAsOCwzLCAwLDgsMTMxLCAwLDgsNjcsIDAsOSwyMzEsXG4gICAgODAsNyw3LCAwLDgsOTEsIDAsOCwyNywgMCw5LDE1MSxcbiAgICA4NCw3LDY3LCAwLDgsMTIzLCAwLDgsNTksIDAsOSwyMTUsXG4gICAgODIsNywxOSwgMCw4LDEwNywgMCw4LDQzLCAwLDksMTgzLFxuICAgIDAsOCwxMSwgMCw4LDEzOSwgMCw4LDc1LCAwLDksMjQ3LFxuICAgIDgwLDcsNSwgMCw4LDg3LCAwLDgsMjMsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOSwgMCw4LDU1LCAwLDksMjA3LFxuICAgIDgxLDcsMTUsIDAsOCwxMDMsIDAsOCwzOSwgMCw5LDE3NSxcbiAgICAwLDgsNywgMCw4LDEzNSwgMCw4LDcxLCAwLDksMjM5LFxuICAgIDgwLDcsOSwgMCw4LDk1LCAwLDgsMzEsIDAsOSwxNTksXG4gICAgODQsNyw5OSwgMCw4LDEyNywgMCw4LDYzLCAwLDksMjIzLFxuICAgIDgyLDcsMjcsIDAsOCwxMTEsIDAsOCw0NywgMCw5LDE5MSxcbiAgICAwLDgsMTUsIDAsOCwxNDMsIDAsOCw3OSwgMCw5LDI1NVxuXTtcbnZhciBmaXhlZF90ZCA9IFtcbiAgICA4MCw1LDEsIDg3LDUsMjU3LCA4Myw1LDE3LCA5MSw1LDQwOTcsXG4gICAgODEsNSw1LCA4OSw1LDEwMjUsIDg1LDUsNjUsIDkzLDUsMTYzODUsXG4gICAgODAsNSwzLCA4OCw1LDUxMywgODQsNSwzMywgOTIsNSw4MTkzLFxuICAgIDgyLDUsOSwgOTAsNSwyMDQ5LCA4Niw1LDEyOSwgMTkyLDUsMjQ1NzcsXG4gICAgODAsNSwyLCA4Nyw1LDM4NSwgODMsNSwyNSwgOTEsNSw2MTQ1LFxuICAgIDgxLDUsNywgODksNSwxNTM3LCA4NSw1LDk3LCA5Myw1LDI0NTc3LFxuICAgIDgwLDUsNCwgODgsNSw3NjksIDg0LDUsNDksIDkyLDUsMTIyODksXG4gICAgODIsNSwxMywgOTAsNSwzMDczLCA4Niw1LDE5MywgMTkyLDUsMjQ1Nzdcbl07XG5cbiAgLy8gVGFibGVzIGZvciBkZWZsYXRlIGZyb20gUEtaSVAncyBhcHBub3RlLnR4dC5cbiAgdmFyIGNwbGVucyA9IFsgLy8gQ29weSBsZW5ndGhzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XG4gICAgICAgIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gICAgICAgIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG4gIF07XG5cbiAgLy8gc2VlIG5vdGUgIzEzIGFib3ZlIGFib3V0IDI1OFxuICB2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XG4gICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsXG4gICAgICAgIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIDExMiwgMTEyICAvLyAxMTI9PWludmFsaWRcbiAgXTtcblxuIHZhciBjcGRpc3QgPSBbIC8vIENvcHkgb2Zmc2V0cyBmb3IgZGlzdGFuY2UgY29kZXMgMC4uMjlcbiAgICAgICAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAgICAgICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gICAgICAgIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzdcbiAgXTtcblxuICB2YXIgY3BkZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBkaXN0YW5jZSBjb2Rlc1xuICAgICAgICAwLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LFxuICAgICAgICA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSxcbiAgICAgICAgMTIsIDEyLCAxMywgMTNdO1xuXG4vL1xuLy8gWlN0cmVhbS5qYXZhXG4vL1xuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xufVxuXG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVJbml0ID0gZnVuY3Rpb24odywgbm93cmFwKSB7XG4gICAgaWYgKCF3KSB7XG5cdHcgPSBERUZfV0JJVFM7XG4gICAgfVxuICAgIGlmIChub3dyYXApIHtcblx0bm93cmFwID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXN0YXRlID0gbmV3IEluZmxhdGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc3RhdGUuaW5mbGF0ZUluaXQodGhpcywgbm93cmFwPy13OncpO1xufVxuXG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlID0gZnVuY3Rpb24oZikge1xuICAgIGlmKHRoaXMuaXN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIHRoaXMuaXN0YXRlLmluZmxhdGUodGhpcywgZik7XG59XG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVFbmQgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuaXN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgdmFyIHJldD1pc3RhdGUuaW5mbGF0ZUVuZCh0aGlzKTtcbiAgICB0aGlzLmlzdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIHJldDtcbn1cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oKXtcbiAgICAvLyBpZihpc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBpc3RhdGUuaW5mbGF0ZVN5bmModGhpcyk7XG59XG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpe1xuICAgIC8vIGlmKGlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGlzdGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcbn1cblxuLypcblxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBNQVhfV0JJVFMpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBib29sZWFuIG5vd3JhcCl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBNQVhfV0JJVFMsIG5vd3JhcCk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGludCBiaXRzKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIGJpdHMsIGZhbHNlKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgaW50IGJpdHMsIGJvb2xlYW4gbm93cmFwKXtcbiAgICBkc3RhdGU9bmV3IERlZmxhdGUoKTtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVJbml0KHRoaXMsIGxldmVsLCBub3dyYXA/LWJpdHM6Yml0cyk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlKGludCBmbHVzaCl7XG4gICAgaWYoZHN0YXRlPT1udWxsKXtcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlKHRoaXMsIGZsdXNoKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVFbmQoKXtcbiAgICBpZihkc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBpbnQgcmV0PWRzdGF0ZS5kZWZsYXRlRW5kKCk7XG4gICAgZHN0YXRlPW51bGw7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVQYXJhbXMoaW50IGxldmVsLCBpbnQgc3RyYXRlZ3kpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZVBhcmFtcyh0aGlzLCBsZXZlbCwgc3RyYXRlZ3kpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZVNldERpY3Rpb25hcnkgKGJ5dGVbXSBkaWN0aW9uYXJ5LCBpbnQgZGljdExlbmd0aCl7XG4gICAgaWYoZHN0YXRlID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcbiAgfVxuXG4qL1xuXG4vKlxuICAvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gIC8vIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAgLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfb3V0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICAvLyAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gIHZvaWQgZmx1c2hfcGVuZGluZygpe1xuICAgIGludCBsZW49ZHN0YXRlLnBlbmRpbmc7XG5cbiAgICBpZihsZW4+YXZhaWxfb3V0KSBsZW49YXZhaWxfb3V0O1xuICAgIGlmKGxlbj09MCkgcmV0dXJuO1xuXG4gICAgaWYoZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aDw9ZHN0YXRlLnBlbmRpbmdfb3V0IHx8XG4gICAgICAgbmV4dF9vdXQubGVuZ3RoPD1uZXh0X291dF9pbmRleCB8fFxuICAgICAgIGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGg8KGRzdGF0ZS5wZW5kaW5nX291dCtsZW4pIHx8XG4gICAgICAgbmV4dF9vdXQubGVuZ3RoPChuZXh0X291dF9pbmRleCtsZW4pKXtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoK1wiLCBcIitkc3RhdGUucGVuZGluZ19vdXQrXG5cdFx0XHQgXCIsIFwiK25leHRfb3V0Lmxlbmd0aCtcIiwgXCIrbmV4dF9vdXRfaW5kZXgrXCIsIFwiK2xlbik7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4oXCJhdmFpbF9vdXQ9XCIrYXZhaWxfb3V0KTtcbiAgICB9XG5cbiAgICBTeXN0ZW0uYXJyYXljb3B5KGRzdGF0ZS5wZW5kaW5nX2J1ZiwgZHN0YXRlLnBlbmRpbmdfb3V0LFxuXHRcdCAgICAgbmV4dF9vdXQsIG5leHRfb3V0X2luZGV4LCBsZW4pO1xuXG4gICAgbmV4dF9vdXRfaW5kZXgrPWxlbjtcbiAgICBkc3RhdGUucGVuZGluZ19vdXQrPWxlbjtcbiAgICB0b3RhbF9vdXQrPWxlbjtcbiAgICBhdmFpbF9vdXQtPWxlbjtcbiAgICBkc3RhdGUucGVuZGluZy09bGVuO1xuICAgIGlmKGRzdGF0ZS5wZW5kaW5nPT0wKXtcbiAgICAgIGRzdGF0ZS5wZW5kaW5nX291dD0wO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAgLy8gYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAgLy8gdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAgLy8gYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfaW4gYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gIC8vIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICBpbnQgcmVhZF9idWYoYnl0ZVtdIGJ1ZiwgaW50IHN0YXJ0LCBpbnQgc2l6ZSkge1xuICAgIGludCBsZW49YXZhaWxfaW47XG5cbiAgICBpZihsZW4+c2l6ZSkgbGVuPXNpemU7XG4gICAgaWYobGVuPT0wKSByZXR1cm4gMDtcblxuICAgIGF2YWlsX2luLT1sZW47XG5cbiAgICBpZihkc3RhdGUubm9oZWFkZXI9PTApIHtcbiAgICAgIGFkbGVyPV9hZGxlci5hZGxlcjMyKGFkbGVyLCBuZXh0X2luLCBuZXh0X2luX2luZGV4LCBsZW4pO1xuICAgIH1cbiAgICBTeXN0ZW0uYXJyYXljb3B5KG5leHRfaW4sIG5leHRfaW5faW5kZXgsIGJ1Ziwgc3RhcnQsIGxlbik7XG4gICAgbmV4dF9pbl9pbmRleCAgKz0gbGVuO1xuICAgIHRvdGFsX2luICs9IGxlbjtcbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgcHVibGljIHZvaWQgZnJlZSgpe1xuICAgIG5leHRfaW49bnVsbDtcbiAgICBuZXh0X291dD1udWxsO1xuICAgIG1zZz1udWxsO1xuICAgIF9hZGxlcj1udWxsO1xuICB9XG59XG4qL1xuXG5cbi8vXG4vLyBJbmZsYXRlLmphdmFcbi8vXG5cbmZ1bmN0aW9uIEluZmxhdGUoKSB7XG4gICAgdGhpcy53YXMgPSBbMF07XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVSZXNldCA9IGZ1bmN0aW9uKHopIHtcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIFxuICAgIHoudG90YWxfaW4gPSB6LnRvdGFsX291dCA9IDA7XG4gICAgei5tc2cgPSBudWxsO1xuICAgIHouaXN0YXRlLm1vZGUgPSB6LmlzdGF0ZS5ub3dyYXAhPTAgPyBCTE9DS1MgOiBNRVRIT0Q7XG4gICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIG51bGwpO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlRW5kID0gZnVuY3Rpb24oeil7XG4gICAgaWYodGhpcy5ibG9ja3MgIT0gbnVsbClcbiAgICAgIHRoaXMuYmxvY2tzLmZyZWUoeik7XG4gICAgdGhpcy5ibG9ja3M9bnVsbDtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbih6LCB3KXtcbiAgICB6Lm1zZyA9IG51bGw7XG4gICAgdGhpcy5ibG9ja3MgPSBudWxsO1xuXG4gICAgLy8gaGFuZGxlIHVuZG9jdW1lbnRlZCBub3dyYXAgb3B0aW9uIChubyB6bGliIGhlYWRlciBvciBjaGVjaylcbiAgICBsZXQgbm93cmFwID0gMDtcbiAgICBpZih3IDwgMCl7XG4gICAgICB3ID0gLSB3O1xuICAgICAgbm93cmFwID0gMTtcbiAgICB9XG5cbiAgICAvLyBzZXQgd2luZG93IHNpemVcbiAgICBpZih3PDggfHx3PjE1KXtcbiAgICAgIHRoaXMuaW5mbGF0ZUVuZCh6KTtcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gICAgdGhpcy53Yml0cz13O1xuXG4gICAgei5pc3RhdGUuYmxvY2tzPW5ldyBJbmZCbG9ja3MoeiwgXG5cdFx0XHRcdCAgei5pc3RhdGUubm93cmFwIT0wID8gbnVsbCA6IHRoaXMsXG5cdFx0XHRcdCAgMTw8dyk7XG5cbiAgICAvLyByZXNldCBzdGF0ZVxuICAgIHRoaXMuaW5mbGF0ZVJlc2V0KHopO1xuICAgIHJldHVybiBaX09LO1xuICB9XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbih6LCBmKXtcbiAgICB2YXIgciwgYjtcblxuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsIHx8IHoubmV4dF9pbiA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGYgPSBmID09IFpfRklOSVNIID8gWl9CVUZfRVJST1IgOiBaX09LO1xuICAgIHIgPSBaX0JVRl9FUlJPUjtcbiAgICB3aGlsZSAodHJ1ZSl7XG4gICAgICBzd2l0Y2ggKHouaXN0YXRlLm1vZGUpe1xuICAgICAgY2FzZSBNRVRIT0Q6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIGlmKCgoei5pc3RhdGUubWV0aG9kID0gei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSkmMHhmKSE9Wl9ERUZMQVRFRCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZz1cInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoKHouaXN0YXRlLm1ldGhvZD4+NCkrOD56LmlzdGF0ZS53Yml0cyl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZz1cImludmFsaWQgd2luZG93IHNpemVcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB6LmlzdGF0ZS5tb2RlPUZMQUc7XG4gICAgICBjYXNlIEZMQUc6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIGIgPSAoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSkmMHhmZjtcblxuICAgICAgICBpZigoKCh6LmlzdGF0ZS5tZXRob2QgPDwgOCkrYikgJSAzMSkhPTApe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2cgPSBcImluY29ycmVjdCBoZWFkZXIgY2hlY2tcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKChiJlBSRVNFVF9ESUNUKT09MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDQ7XG4gICAgICBjYXNlIERJQ1Q0OlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MjQpJjB4ZmYwMDAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDM7XG4gICAgICBjYXNlIERJQ1QzOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDE2KSYweGZmMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMjtcbiAgICAgIGNhc2UgRElDVDI6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8OCkmMHhmZjAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QxO1xuICAgICAgY2FzZSBESUNUMTpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCArPSAoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTtcbiAgICAgICAgei5hZGxlciA9IHouaXN0YXRlLm5lZWQ7XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUMDtcbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgY2FzZSBESUNUMDpcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgei5tc2cgPSBcIm5lZWQgZGljdGlvbmFyeVwiO1xuICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAgICAgICAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIGNhc2UgQkxPQ0tTOlxuXG4gICAgICAgIHIgPSB6LmlzdGF0ZS5ibG9ja3MucHJvYyh6LCByKTtcbiAgICAgICAgaWYociA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gMDsgICAgIC8vIGNhbiB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihyID09IFpfT0spe1xuICAgICAgICAgIHIgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIgIT0gWl9TVFJFQU1fRU5EKXtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICByID0gZjtcbiAgICAgICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIHouaXN0YXRlLndhcyk7XG4gICAgICAgIGlmKHouaXN0YXRlLm5vd3JhcCE9MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZT1ET05FO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGU9Q0hFQ0s0O1xuICAgICAgY2FzZSBDSEVDSzQ6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQ9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwyNCkmMHhmZjAwMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1DSEVDSzM7XG4gICAgICBjYXNlIENIRUNLMzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwxNikmMHhmZjAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBDSEVDSzI7XG4gICAgICBjYXNlIENIRUNLMjpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDw4KSYweGZmMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBDSEVDSzE7XG4gICAgICBjYXNlIENIRUNLMTpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik7XG5cbiAgICAgICAgaWYoKCh6LmlzdGF0ZS53YXNbMF0pKSAhPSAoKHouaXN0YXRlLm5lZWQpKSl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW5jb3JyZWN0IGRhdGEgY2hlY2tcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRU5EO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbih6LCAgZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xuICAgIHZhciBpbmRleD0wO1xuICAgIHZhciBsZW5ndGggPSBkaWN0TGVuZ3RoO1xuICAgIGlmKHo9PW51bGwgfHwgei5pc3RhdGUgPT0gbnVsbHx8IHouaXN0YXRlLm1vZGUgIT0gRElDVDApXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG5cbiAgICBpZih6Ll9hZGxlci5hZGxlcjMyKDEsIGRpY3Rpb25hcnksIDAsIGRpY3RMZW5ndGgpIT16LmFkbGVyKXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuXG4gICAgei5hZGxlciA9IHouX2FkbGVyLmFkbGVyMzIoMCwgbnVsbCwgMCwgMCk7XG5cbiAgICBpZihsZW5ndGggPj0gKDE8PHouaXN0YXRlLndiaXRzKSl7XG4gICAgICBsZW5ndGggPSAoMTw8ei5pc3RhdGUud2JpdHMpLTE7XG4gICAgICBpbmRleD1kaWN0TGVuZ3RoIC0gbGVuZ3RoO1xuICAgIH1cbiAgICB6LmlzdGF0ZS5ibG9ja3Muc2V0X2RpY3Rpb25hcnkoZGljdGlvbmFyeSwgaW5kZXgsIGxlbmd0aCk7XG4gICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICByZXR1cm4gWl9PSztcbiAgfVxuXG4vLyAgc3RhdGljIHByaXZhdGUgYnl0ZVtdIG1hcmsgPSB7KGJ5dGUpMCwgKGJ5dGUpMCwgKGJ5dGUpMHhmZiwgKGJ5dGUpMHhmZn07XG52YXIgbWFyayA9IFswLCAwLCAyNTUsIDI1NV1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbih6KXtcbiAgICB2YXIgbjsgICAgICAgLy8gbnVtYmVyIG9mIGJ5dGVzIHRvIGxvb2sgYXRcbiAgICB2YXIgcDsgICAgICAgLy8gcG9pbnRlciB0byBieXRlc1xuICAgIHZhciBtOyAgICAgICAvLyBudW1iZXIgb2YgbWFya2VyIGJ5dGVzIGZvdW5kIGluIGEgcm93XG4gICAgdmFyIHIsIHc7ICAgLy8gdGVtcG9yYXJpZXMgdG8gc2F2ZSB0b3RhbF9pbiBhbmQgdG90YWxfb3V0XG5cbiAgICAvLyBzZXQgdXBcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBpZih6LmlzdGF0ZS5tb2RlICE9IEJBRCl7XG4gICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgei5pc3RhdGUubWFya2VyID0gMDtcbiAgICB9XG4gICAgaWYoKG49ei5hdmFpbF9pbik9PTApXG4gICAgICByZXR1cm4gWl9CVUZfRVJST1I7XG4gICAgcD16Lm5leHRfaW5faW5kZXg7XG4gICAgbT16LmlzdGF0ZS5tYXJrZXI7XG5cbiAgICAvLyBzZWFyY2hcbiAgICB3aGlsZSAobiE9MCAmJiBtIDwgNCl7XG4gICAgICBpZih6Lm5leHRfaW5bcF0gPT0gbWFya1ttXSl7XG4gICAgICAgIG0rKztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoei5uZXh0X2luW3BdIT0wKXtcbiAgICAgICAgbSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICBtID0gNCAtIG07XG4gICAgICB9XG4gICAgICBwKys7IG4tLTtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JlXG4gICAgei50b3RhbF9pbiArPSBwLXoubmV4dF9pbl9pbmRleDtcbiAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xuICAgIHouYXZhaWxfaW4gPSBuO1xuICAgIHouaXN0YXRlLm1hcmtlciA9IG07XG5cbiAgICAvLyByZXR1cm4gbm8gam95IG9yIHNldCB1cCB0byByZXN0YXJ0IG9uIGEgbmV3IGJsb2NrXG4gICAgaWYobSAhPSA0KXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHI9ei50b3RhbF9pbjsgIHc9ei50b3RhbF9vdXQ7XG4gICAgdGhpcy5pbmZsYXRlUmVzZXQoeik7XG4gICAgei50b3RhbF9pbj1yOyAgei50b3RhbF9vdXQgPSB3O1xuICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIGluZmxhdGUgaXMgY3VycmVudGx5IGF0IHRoZSBlbmQgb2YgYSBibG9jayBnZW5lcmF0ZWRcbiAgLy8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG9uZSBQUFBcbiAgLy8gaW1wbGVtZW50YXRpb24gdG8gcHJvdmlkZSBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay4gUFBQIHVzZXMgWl9TWU5DX0ZMVVNIXG4gIC8vIGJ1dCByZW1vdmVzIHRoZSBsZW5ndGggYnl0ZXMgb2YgdGhlIHJlc3VsdGluZyBlbXB0eSBzdG9yZWQgYmxvY2suIFdoZW5cbiAgLy8gZGVjb21wcmVzc2luZywgUFBQIGNoZWNrcyB0aGF0IGF0IHRoZSBlbmQgb2YgaW5wdXQgcGFja2V0LCBpbmZsYXRlIGlzXG4gIC8vIHdhaXRpbmcgZm9yIHRoZXNlIGxlbmd0aCBieXRlcy5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVTeW5jUG9pbnQgPSBmdW5jdGlvbih6KXtcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCB8fCB6LmlzdGF0ZS5ibG9ja3MgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gei5pc3RhdGUuYmxvY2tzLnN5bmNfcG9pbnQoKTtcbn1cblxuXG4vL1xuLy8gSW5mQmxvY2tzLmphdmFcbi8vXG5cbnZhciBJTkZCTE9DS1NfQk9SREVSID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdO1xuXG5mdW5jdGlvbiBJbmZCbG9ja3MoeiwgY2hlY2tmbiwgdykge1xuICAgIHRoaXMuaHVmdHM9bmV3IEludDMyQXJyYXkoTUFOWSozKTtcbiAgICB0aGlzLndpbmRvdz1uZXcgVWludDhBcnJheSh3KTtcbiAgICB0aGlzLmVuZD13O1xuICAgIHRoaXMuY2hlY2tmbiA9IGNoZWNrZm47XG4gICAgdGhpcy5tb2RlID0gSUJfVFlQRTtcbiAgICB0aGlzLnJlc2V0KHosIG51bGwpO1xuXG4gICAgdGhpcy5sZWZ0ID0gMDsgICAgICAgICAgICAvLyBpZiBTVE9SRUQsIGJ5dGVzIGxlZnQgdG8gY29weSBcblxuICAgIHRoaXMudGFibGUgPSAwOyAgICAgICAgICAgLy8gdGFibGUgbGVuZ3RocyAoMTQgYml0cykgXG4gICAgdGhpcy5pbmRleCA9IDA7ICAgICAgICAgICAvLyBpbmRleCBpbnRvIGJsZW5zIChvciBib3JkZXIpIFxuICAgIHRoaXMuYmxlbnMgPSBudWxsOyAgICAgICAgIC8vIGJpdCBsZW5ndGhzIG9mIGNvZGVzIFxuICAgIHRoaXMuYmI9bmV3IEludDMyQXJyYXkoMSk7IC8vIGJpdCBsZW5ndGggdHJlZSBkZXB0aCBcbiAgICB0aGlzLnRiPW5ldyBJbnQzMkFycmF5KDEpOyAvLyBiaXQgbGVuZ3RoIGRlY29kaW5nIHRyZWUgXG5cbiAgICB0aGlzLmNvZGVzID0gbmV3IEluZkNvZGVzKCk7XG5cbiAgICB0aGlzLmxhc3QgPSAwOyAgICAgICAgICAgIC8vIHRydWUgaWYgdGhpcyBibG9jayBpcyB0aGUgbGFzdCBibG9jayBcblxuICAvLyBtb2RlIGluZGVwZW5kZW50IGluZm9ybWF0aW9uIFxuICAgIHRoaXMuYml0ayA9IDA7ICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyIFxuICAgIHRoaXMuYml0YiA9IDA7ICAgICAgICAgICAgLy8gYml0IGJ1ZmZlciBcbiAgICB0aGlzLnJlYWQgPSAwOyAgICAgICAgICAgIC8vIHdpbmRvdyByZWFkIHBvaW50ZXIgXG4gICAgdGhpcy53cml0ZSA9IDA7ICAgICAgICAgICAvLyB3aW5kb3cgd3JpdGUgcG9pbnRlciBcbiAgICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgLy8gY2hlY2sgb24gb3V0cHV0IFxuXG4gICAgdGhpcy5pbmZ0cmVlPW5ldyBJbmZUcmVlKCk7XG59XG5cblxuXG5cbkluZkJsb2Nrcy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbih6LCBjKXtcbiAgICBpZihjKSBjWzBdPXRoaXMuY2hlY2s7XG4gICAgaWYodGhpcy5tb2RlPT1JQl9DT0RFUyl7XG4gICAgICB0aGlzLmNvZGVzLmZyZWUoeik7XG4gICAgfVxuICAgIHRoaXMubW9kZT1JQl9UWVBFO1xuICAgIHRoaXMuYml0az0wO1xuICAgIHRoaXMuYml0Yj0wO1xuICAgIHRoaXMucmVhZD10aGlzLndyaXRlPTA7XG5cbiAgICBpZih0aGlzLmNoZWNrZm4pXG4gICAgICB6LmFkbGVyPXRoaXMuY2hlY2s9ei5fYWRsZXIuYWRsZXIzMigwLCBudWxsLCAwLCAwKTtcbiAgfVxuXG4gSW5mQmxvY2tzLnByb3RvdHlwZS5wcm9jID0gZnVuY3Rpb24oeiwgcil7XG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgIHZhciBiOyAgICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyXG4gICAgdmFyIHA7ICAgICAgICAgICAgICAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcbiAgICB2YXIgbjsgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXG4gICAgdmFyIG07ICAgICAgICAgICAgICAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxuXG4gICAgLy8gY29weSBpbnB1dC9vdXRwdXQgaW5mb3JtYXRpb24gdG8gbG9jYWxzIChVUERBVEUgbWFjcm8gcmVzdG9yZXMpXG4gICAge3A9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXRoaXMuYml0YjtrPXRoaXMuYml0azt9XG4gICAge3E9dGhpcy53cml0ZTttPShxPHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTt9XG5cbiAgICAvLyBwcm9jZXNzIGlucHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKXtcbiAgICAgIGNhc2UgSUJfVFlQRTpcblxuXHR3aGlsZShrPCgzKSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblx0dCA9IChiICYgNyk7XG5cdHRoaXMubGFzdCA9IHQgJiAxO1xuXG5cdHN3aXRjaCAodCA+Pj4gMSl7XG4gICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmVkIFxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuICAgICAgICAgIHQgPSBrICYgNzsgICAgICAgICAgICAgICAgICAgIC8vIGdvIHRvIGJ5dGUgYm91bmRhcnlcblxuICAgICAgICAgIHtiPj4+PSh0KTtrLT0odCk7fVxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX0xFTlM7ICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxlbmd0aCBvZiBzdG9yZWQgYmxvY2tcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXhlZFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGJsPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgICB2YXIgYmQ9bmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgIHZhciB0bD1bXTtcblx0ICAgICAgdmFyIHRkPVtdO1xuXG5cdCAgICAgIGluZmxhdGVfdHJlZXNfZml4ZWQoYmwsIGJkLCB0bCwgdGQsIHopO1xuICAgICAgICAgICAgICB0aGlzLmNvZGVzLmluaXQoYmxbMF0sIGJkWzBdLCB0bFswXSwgMCwgdGRbMF0sIDAsIHopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuXG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfQ09ERVM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pY1xuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG5cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9UQUJMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsXG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cbiAgICAgICAgICB0aGlzLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2cgPSBcImludmFsaWQgYmxvY2sgdHlwZVwiO1xuICAgICAgICAgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQl9MRU5TOlxuXHR3aGlsZShrPCgzMikpe1xuXHQgIGlmKG4hPTApe1xuXHQgICAgcj1aX09LO1xuXHQgIH1cblx0ICBlbHNle1xuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjtcblx0ICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH07XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0aWYgKCgoKH5iKSA+Pj4gMTYpICYgMHhmZmZmKSAhPSAoYiAmIDB4ZmZmZikpe1xuXHQgIHRoaXMubW9kZSA9IEJBRDtcblx0ICB6Lm1zZyA9IFwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1wiO1xuXHQgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdHRoaXMubGVmdCA9IChiICYgMHhmZmZmKTtcblx0YiA9IGsgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgLy8gZHVtcCBiaXRzXG5cdHRoaXMubW9kZSA9IGxlZnQhPTAgPyBJQl9TVE9SRUQgOiAodGhpcy5sYXN0IT0wID8gSUJfRFJZIDogSUJfVFlQRSk7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQl9TVE9SRUQ6XG5cdGlmIChuID09IDApe1xuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHdyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cblx0aWYobT09MCl7XG5cdCAgaWYocT09ZW5kJiZyZWFkIT0wKXtcblx0ICAgIHE9MDsgbT0ocTx0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgfVxuXHQgIGlmKG09PTApe1xuXHQgICAgdGhpcy53cml0ZT1xOyBcblx0ICAgIHI9dGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICBxPXRoaXMud3JpdGU7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICAgIGlmKHE9PXRoaXMuZW5kICYmIHRoaXMucmVhZCAhPSAwKXtcblx0ICAgICAgcT0wOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgICB9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0cj1aX09LO1xuXG5cdHQgPSB0aGlzLmxlZnQ7XG5cdGlmKHQ+bikgdCA9IG47XG5cdGlmKHQ+bSkgdCA9IG07XG5cdGFycmF5Q29weSh6Lm5leHRfaW4sIHAsIHdpbmRvdywgcSwgdCk7XG5cdHAgKz0gdDsgIG4gLT0gdDtcblx0cSArPSB0OyAgbSAtPSB0O1xuXHRpZiAoKHRoaXMubGVmdCAtPSB0KSAhPSAwKVxuXHQgIGJyZWFrO1xuXHR0aGlzLm1vZGUgPSAodGhpcy5sYXN0ICE9IDAgPyBJQl9EUlkgOiBJQl9UWVBFKTtcblx0YnJlYWs7XG4gICAgICBjYXNlIElCX1RBQkxFOlxuXG5cdHdoaWxlKGs8KDE0KSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLnRhYmxlID0gdCA9IChiICYgMHgzZmZmKTtcblx0aWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KVxuXHQgIHtcblx0ICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICAgIHoubXNnID0gXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1wiO1xuXHQgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdHQgPSAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZik7XG5cdGlmKHRoaXMuYmxlbnM9PW51bGwgfHwgdGhpcy5ibGVucy5sZW5ndGg8dCl7XG5cdCAgICB0aGlzLmJsZW5zPW5ldyBJbnQzMkFycmF5KHQpO1xuXHR9XG5cdGVsc2V7XG5cdCAgZm9yKHZhciBpPTA7IGk8dDsgaSsrKXtcbiAgICAgICAgICAgICAgdGhpcy5ibGVuc1tpXT0wO1xuICAgICAgICAgIH1cblx0fVxuXG5cdHtiPj4+PSgxNCk7ay09KDE0KTt9XG5cblx0dGhpcy5pbmRleCA9IDA7XG5cdHRoaXMubW9kZSA9IElCX0JUUkVFO1xuICAgICAgY2FzZSBJQl9CVFJFRTpcblx0d2hpbGUgKHRoaXMuaW5kZXggPCA0ICsgKHRoaXMudGFibGUgPj4+IDEwKSl7XG5cdCAgd2hpbGUoazwoMykpe1xuXHQgICAgaWYobiE9MCl7XG5cdCAgICAgIHI9Wl9PSztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjtcblx0ICAgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfTtcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgIGsrPTg7XG5cdCAgfVxuXG5cdCAgdGhpcy5ibGVuc1tJTkZCTE9DS1NfQk9SREVSW3RoaXMuaW5kZXgrK11dID0gYiY3O1xuXG5cdCAge2I+Pj49KDMpO2stPSgzKTt9XG5cdH1cblxuXHR3aGlsZSh0aGlzLmluZGV4IDwgMTkpe1xuXHQgIHRoaXMuYmxlbnNbSU5GQkxPQ0tTX0JPUkRFUlt0aGlzLmluZGV4KytdXSA9IDA7XG5cdH1cblxuXHR0aGlzLmJiWzBdID0gNztcblx0dCA9IHRoaXMuaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2JpdHModGhpcy5ibGVucywgdGhpcy5iYiwgdGhpcy50YiwgdGhpcy5odWZ0cywgeik7XG5cdGlmICh0ICE9IFpfT0spe1xuXHQgIHIgPSB0O1xuXHQgIGlmIChyID09IFpfREFUQV9FUlJPUil7XG5cdCAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICB0aGlzLm1vZGUgPSBJQl9CQUQ7XG5cdCAgfVxuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgd3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblxuXHR0aGlzLmluZGV4ID0gMDtcblx0dGhpcy5tb2RlID0gSUJfRFRSRUU7XG4gICAgICBjYXNlIElCX0RUUkVFOlxuXHR3aGlsZSAodHJ1ZSl7XG5cdCAgdCA9IHRoaXMudGFibGU7XG5cdCAgaWYoISh0aGlzLmluZGV4IDwgMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSl7XG5cdCAgICBicmVhaztcblx0ICB9XG5cblx0ICB2YXIgaDsgLy9pbnRbXVxuXHQgIHZhciBpLCBqLCBjO1xuXG5cdCAgdCA9IHRoaXMuYmJbMF07XG5cblx0ICB3aGlsZShrPCh0KSl7XG5cdCAgICBpZihuIT0wKXtcblx0ICAgICAgcj1aX09LO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9O1xuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgays9ODtcblx0ICB9XG5cbi8vXHQgIGlmICh0aGlzLnRiWzBdPT0tMSl7XG4vLyAgICAgICAgICAgIGRsb2coXCJudWxsLi4uXCIpO1xuLy9cdCAgfVxuXG5cdCAgdD10aGlzLmh1ZnRzWyh0aGlzLnRiWzBdKyhiICYgaW5mbGF0ZV9tYXNrW3RdKSkqMysxXTtcblx0ICBjPXRoaXMuaHVmdHNbKHRoaXMudGJbMF0rKGIgJiBpbmZsYXRlX21hc2tbdF0pKSozKzJdO1xuXG5cdCAgaWYgKGMgPCAxNil7XG5cdCAgICBiPj4+PSh0KTtrLT0odCk7XG5cdCAgICB0aGlzLmJsZW5zW3RoaXMuaW5kZXgrK10gPSBjO1xuXHQgIH1cblx0ICBlbHNlIHsgLy8gYyA9PSAxNi4uMThcblx0ICAgIGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcblx0ICAgIGogPSBjID09IDE4ID8gMTEgOiAzO1xuXG5cdCAgICB3aGlsZShrPCh0K2kpKXtcblx0ICAgICAgaWYobiE9MCl7XG5cdFx0cj1aX09LO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2V7XG5cdFx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0XHR6LmF2YWlsX2luPW47XG5cdFx0ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdFx0dGhpcy53cml0ZT1xO1xuXHRcdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgfTtcblx0ICAgICAgbi0tO1xuXHQgICAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICAgIGsrPTg7XG5cdCAgICB9XG5cblx0ICAgIGI+Pj49KHQpO2stPSh0KTtcblxuXHQgICAgaiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XG5cblx0ICAgIGI+Pj49KGkpO2stPShpKTtcblxuXHQgICAgaSA9IHRoaXMuaW5kZXg7XG5cdCAgICB0ID0gdGhpcy50YWJsZTtcblx0ICAgIGlmIChpICsgaiA+IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSB8fFxuXHRcdChjID09IDE2ICYmIGkgPCAxKSl7XG5cdCAgICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFwiO1xuXHQgICAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cblx0ICAgIGMgPSBjID09IDE2ID8gdGhpcy5ibGVuc1tpLTFdIDogMDtcblx0ICAgIGRve1xuXHQgICAgICB0aGlzLmJsZW5zW2krK10gPSBjO1xuXHQgICAgfVxuXHQgICAgd2hpbGUgKC0taiE9MCk7XG5cdCAgICB0aGlzLmluZGV4ID0gaTtcblx0ICB9XG5cdH1cblxuXHR0aGlzLnRiWzBdPS0xO1xuXHR7XG5cdCAgICB2YXIgYmw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgYmQ9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgdGw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgdGQ9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICBibFswXSA9IDk7ICAgICAgICAgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcblx0ICAgIGJkWzBdID0gNjsgICAgICAgICAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xuXG5cdCAgICB0ID0gdGhpcy50YWJsZTtcblx0ICAgIHQgPSB0aGlzLmluZnRyZWUuaW5mbGF0ZV90cmVlc19keW5hbWljKDI1NyArICh0ICYgMHgxZiksIFxuXHRcdFx0XHRcdCAgICAgIDEgKyAoKHQgPj4gNSkgJiAweDFmKSxcblx0XHRcdFx0XHQgICAgICB0aGlzLmJsZW5zLCBibCwgYmQsIHRsLCB0ZCwgdGhpcy5odWZ0cywgeik7XG5cblx0ICAgIGlmICh0ICE9IFpfT0spe1xuXHQgICAgICAgIGlmICh0ID09IFpfREFUQV9FUlJPUil7XG5cdCAgICAgICAgICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5tb2RlID0gQkFEO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByID0gdDtcblxuXHQgICAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNvZGVzLmluaXQoYmxbMF0sIGJkWzBdLCB0aGlzLmh1ZnRzLCB0bFswXSwgdGhpcy5odWZ0cywgdGRbMF0sIHopO1xuXHR9XG5cdHRoaXMubW9kZSA9IElCX0NPREVTO1xuICAgICAgY2FzZSBJQl9DT0RFUzpcblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rO1xuXHR6LmF2YWlsX2luPW47IHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cblx0aWYgKChyID0gdGhpcy5jb2Rlcy5wcm9jKHRoaXMsIHosIHIpKSAhPSBaX1NUUkVBTV9FTkQpe1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cdH1cblx0ciA9IFpfT0s7XG5cdHRoaXMuY29kZXMuZnJlZSh6KTtcblxuXHRwPXoubmV4dF9pbl9pbmRleDsgbj16LmF2YWlsX2luO2I9dGhpcy5iaXRiO2s9dGhpcy5iaXRrO1xuXHRxPXRoaXMud3JpdGU7bSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXG5cdGlmICh0aGlzLmxhc3Q9PTApe1xuXHQgIHRoaXMubW9kZSA9IElCX1RZUEU7XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUJfRFJZO1xuICAgICAgY2FzZSBJQl9EUlk6XG5cdHRoaXMud3JpdGU9cTsgXG5cdHIgPSB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7IFxuXHRxPXRoaXMud3JpdGU7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0aWYgKHRoaXMucmVhZCAhPSB0aGlzLndyaXRlKXtcblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblx0fVxuXHR0aGlzLm1vZGUgPSBET05FO1xuICAgICAgY2FzZSBJQl9ET05FOlxuXHRyID0gWl9TVFJFQU1fRU5EO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuICAgICAgY2FzZSBJQl9CQUQ6XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cbiAgICAgIGRlZmF1bHQ6XG5cdHIgPSBaX1NUUkVBTV9FUlJPUjtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24oeil7XG4gICAgdGhpcy5yZXNldCh6LCBudWxsKTtcbiAgICB0aGlzLndpbmRvdz1udWxsO1xuICAgIHRoaXMuaHVmdHM9bnVsbDtcbn1cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5zZXRfZGljdGlvbmFyeSA9IGZ1bmN0aW9uKGQsIHN0YXJ0LCBuKXtcbiAgICBhcnJheUNvcHkoZCwgc3RhcnQsIHdpbmRvdywgMCwgbik7XG4gICAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IG47XG59XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIGluZmxhdGUgaXMgY3VycmVudGx5IGF0IHRoZSBlbmQgb2YgYSBibG9jayBnZW5lcmF0ZWRcbiAgLy8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC4gXG5JbmZCbG9ja3MucHJvdG90eXBlLnN5bmNfcG9pbnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm1vZGUgPT0gSUJfTEVOUztcbn1cblxuICAvLyBjb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgc2xpZGluZyB3aW5kb3cgdG8gdGhlIG91dHB1dCBhcmVhXG5JbmZCbG9ja3MucHJvdG90eXBlLmluZmxhdGVfZmx1c2ggPSBmdW5jdGlvbih6LCByKXtcbiAgICB2YXIgbjtcbiAgICB2YXIgcDtcbiAgICB2YXIgcTtcblxuICAgIC8vIGxvY2FsIGNvcGllcyBvZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHBvaW50ZXJzXG4gICAgcCA9IHoubmV4dF9vdXRfaW5kZXg7XG4gICAgcSA9IHRoaXMucmVhZDtcblxuICAgIC8vIGNvbXB1dGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcbiAgICBuID0gKChxIDw9IHRoaXMud3JpdGUgPyB0aGlzLndyaXRlIDogdGhpcy5lbmQpIC0gcSk7XG4gICAgaWYgKG4gPiB6LmF2YWlsX291dCkgbiA9IHouYXZhaWxfb3V0O1xuICAgIGlmIChuIT0wICYmIHIgPT0gWl9CVUZfRVJST1IpIHIgPSBaX09LO1xuXG4gICAgLy8gdXBkYXRlIGNvdW50ZXJzXG4gICAgei5hdmFpbF9vdXQgLT0gbjtcbiAgICB6LnRvdGFsX291dCArPSBuO1xuXG4gICAgLy8gdXBkYXRlIGNoZWNrIGluZm9ybWF0aW9uXG4gICAgaWYodGhpcy5jaGVja2ZuICE9IG51bGwpXG4gICAgICB6LmFkbGVyPXRoaXMuY2hlY2s9ei5fYWRsZXIuYWRsZXIzMih0aGlzLmNoZWNrLCB0aGlzLndpbmRvdywgcSwgbik7XG5cbiAgICAvLyBjb3B5IGFzIGZhciBhcyBlbmQgb2Ygd2luZG93XG4gICAgYXJyYXlDb3B5KHRoaXMud2luZG93LCBxLCB6Lm5leHRfb3V0LCBwLCBuKTtcbiAgICBwICs9IG47XG4gICAgcSArPSBuO1xuXG4gICAgLy8gc2VlIGlmIG1vcmUgdG8gY29weSBhdCBiZWdpbm5pbmcgb2Ygd2luZG93XG4gICAgaWYgKHEgPT0gdGhpcy5lbmQpe1xuICAgICAgLy8gd3JhcCBwb2ludGVyc1xuICAgICAgcSA9IDA7XG4gICAgICBpZiAodGhpcy53cml0ZSA9PSB0aGlzLmVuZClcbiAgICAgICAgdGhpcy53cml0ZSA9IDA7XG5cbiAgICAgIC8vIGNvbXB1dGUgYnl0ZXMgdG8gY29weVxuICAgICAgbiA9IHRoaXMud3JpdGUgLSBxO1xuICAgICAgaWYgKG4gPiB6LmF2YWlsX291dCkgbiA9IHouYXZhaWxfb3V0O1xuICAgICAgaWYgKG4hPTAgJiYgciA9PSBaX0JVRl9FUlJPUikgciA9IFpfT0s7XG5cbiAgICAgIC8vIHVwZGF0ZSBjb3VudGVyc1xuICAgICAgei5hdmFpbF9vdXQgLT0gbjtcbiAgICAgIHoudG90YWxfb3V0ICs9IG47XG5cbiAgICAgIC8vIHVwZGF0ZSBjaGVjayBpbmZvcm1hdGlvblxuICAgICAgaWYodGhpcy5jaGVja2ZuICE9IG51bGwpXG5cdHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKHRoaXMuY2hlY2ssIHRoaXMud2luZG93LCBxLCBuKTtcblxuICAgICAgLy8gY29weVxuICAgICAgYXJyYXlDb3B5KHRoaXMud2luZG93LCBxLCB6Lm5leHRfb3V0LCBwLCBuKTtcbiAgICAgIHAgKz0gbjtcbiAgICAgIHEgKz0gbjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcG9pbnRlcnNcbiAgICB6Lm5leHRfb3V0X2luZGV4ID0gcDtcbiAgICB0aGlzLnJlYWQgPSBxO1xuXG4gICAgLy8gZG9uZVxuICAgIHJldHVybiByO1xuICB9XG5cbi8vXG4vLyBJbmZDb2Rlcy5qYXZhXG4vL1xuXG52YXIgSUNfU1RBUlQ9MDsgIC8vIHg6IHNldCB1cCBmb3IgTEVOXG52YXIgSUNfTEVOPTE7ICAgIC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxudmFyIElDX0xFTkVYVD0yOyAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxudmFyIElDX0RJU1Q9MzsgICAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxudmFyIElDX0RJU1RFWFQ9NDsvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXG52YXIgSUNfQ09QWT01OyAgIC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nIGZvciBzcGFjZVxudmFyIElDX0xJVD02OyAgICAvLyBvOiBnb3QgbGl0ZXJhbCwgd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlXG52YXIgSUNfV0FTSD03OyAgIC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IHN0aWxsIG91dHB1dCB3YWl0aW5nXG52YXIgSUNfRU5EPTg7ICAgIC8vIHg6IGdvdCBlb2IgYW5kIGFsbCBkYXRhIGZsdXNoZWRcbnZhciBJQ19CQURDT0RFPTk7Ly8geDogZ290IGVycm9yXG5cbmZ1bmN0aW9uIEluZkNvZGVzKCkge1xufVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgsIHopIHtcbiAgICB0aGlzLm1vZGU9SUNfU1RBUlQ7XG4gICAgdGhpcy5sYml0cz1ibDtcbiAgICB0aGlzLmRiaXRzPWJkO1xuICAgIHRoaXMubHRyZWU9dGw7XG4gICAgdGhpcy5sdHJlZV9pbmRleD10bF9pbmRleDtcbiAgICB0aGlzLmR0cmVlID0gdGQ7XG4gICAgdGhpcy5kdHJlZV9pbmRleD10ZF9pbmRleDtcbiAgICB0aGlzLnRyZWU9bnVsbDtcbn1cblxuSW5mQ29kZXMucHJvdG90eXBlLnByb2MgPSBmdW5jdGlvbihzLCB6LCByKXsgXG4gICAgdmFyIGo7ICAgICAgICAgICAgICAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgIHZhciB0OyAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXIgKGludFtdKVxuICAgIHZhciB0aW5kZXg7ICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgZTsgICAgICAgICAgICAgIC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXG4gICAgdmFyIGI9MDsgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs9MDsgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcD0wOyAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG4gICAgdmFyIGY7ICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIGNvcHkgc3RyaW5ncyBmcm9tXG5cbiAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcbiAgICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG4gICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG4gICAgLy8gcHJvY2VzcyBpbnB1dCBhbmQgb3V0cHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcbiAgICB3aGlsZSAodHJ1ZSl7XG4gICAgICBzd2l0Y2ggKHRoaXMubW9kZSl7XG5cdC8vIHdhaXRpbmcgZm9yIFwiaTpcIj1pbnB1dCwgXCJvOlwiPW91dHB1dCwgXCJ4OlwiPW5vdGhpbmdcbiAgICAgIGNhc2UgSUNfU1RBUlQ6ICAgICAgICAgLy8geDogc2V0IHVwIGZvciBMRU5cblx0aWYgKG0gPj0gMjU4ICYmIG4gPj0gMTApe1xuXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblx0ICByID0gdGhpcy5pbmZsYXRlX2Zhc3QodGhpcy5sYml0cywgdGhpcy5kYml0cywgXG5cdFx0XHQgICB0aGlzLmx0cmVlLCB0aGlzLmx0cmVlX2luZGV4LCBcblx0XHRcdCAgIHRoaXMuZHRyZWUsIHRoaXMuZHRyZWVfaW5kZXgsXG5cdFx0XHQgICBzLCB6KTtcblxuXHQgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcblx0ICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0ICBpZiAociAhPSBaX09LKXtcblx0ICAgIHRoaXMubW9kZSA9IHIgPT0gWl9TVFJFQU1fRU5EID8gSUNfV0FTSCA6IElDX0JBRENPREU7XG5cdCAgICBicmVhaztcblx0ICB9XG5cdH1cblx0dGhpcy5uZWVkID0gdGhpcy5sYml0cztcblx0dGhpcy50cmVlID0gdGhpcy5sdHJlZTtcblx0dGhpcy50cmVlX2luZGV4PXRoaXMubHRyZWVfaW5kZXg7XG5cblx0dGhpcy5tb2RlID0gSUNfTEVOO1xuICAgICAgY2FzZSBJQ19MRU46ICAgICAgICAgICAvLyBpOiBnZXQgbGVuZ3RoL2xpdGVyYWwvZW9iIG5leHRcblx0aiA9IHRoaXMubmVlZDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRpbmRleD0odGhpcy50cmVlX2luZGV4KyhiJmluZmxhdGVfbWFza1tqXSkpKjM7XG5cblx0Yj4+Pj0odGhpcy50cmVlW3RpbmRleCsxXSk7XG5cdGstPSh0aGlzLnRyZWVbdGluZGV4KzFdKTtcblxuXHRlPXRoaXMudHJlZVt0aW5kZXhdO1xuXG5cdGlmKGUgPT0gMCl7ICAgICAgICAgICAgICAgLy8gbGl0ZXJhbFxuXHQgIHRoaXMubGl0ID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19MSVQ7XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYoKGUgJiAxNikhPTAgKXsgICAgICAgICAgLy8gbGVuZ3RoXG5cdCAgdGhpcy5nZXQgPSBlICYgMTU7XG5cdCAgdGhpcy5sZW4gPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0xFTkVYVDtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiA2NCkgPT0gMCl7ICAgICAgICAvLyBuZXh0IHRhYmxlXG5cdCAgdGhpcy5uZWVkID0gZTtcblx0ICB0aGlzLnRyZWVfaW5kZXggPSB0aW5kZXgvMyArIHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYgKChlICYgMzIpIT0wKXsgICAgICAgICAgICAgICAvLyBlbmQgb2YgYmxvY2tcblx0ICB0aGlzLm1vZGUgPSBJQ19XQVNIO1xuXHQgIGJyZWFrO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0JBRENPREU7ICAgICAgICAvLyBpbnZhbGlkIGNvZGVcblx0ei5tc2cgPSBcImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiO1xuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBjYXNlIElDX0xFTkVYVDogICAgICAgIC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXG5cdGogPSB0aGlzLmdldDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLmxlbiArPSAoYiAmIGluZmxhdGVfbWFza1tqXSk7XG5cblx0Yj4+PWo7XG5cdGstPWo7XG5cblx0dGhpcy5uZWVkID0gdGhpcy5kYml0cztcblx0dGhpcy50cmVlID0gdGhpcy5kdHJlZTtcblx0dGhpcy50cmVlX2luZGV4ID0gdGhpcy5kdHJlZV9pbmRleDtcblx0dGhpcy5tb2RlID0gSUNfRElTVDtcbiAgICAgIGNhc2UgSUNfRElTVDogICAgICAgICAgLy8gaTogZ2V0IGRpc3RhbmNlIG5leHRcblx0aiA9IHRoaXMubmVlZDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aW5kZXg9KHRoaXMudHJlZV9pbmRleCsoYiAmIGluZmxhdGVfbWFza1tqXSkpKjM7XG5cblx0Yj4+PXRoaXMudHJlZVt0aW5kZXgrMV07XG5cdGstPXRoaXMudHJlZVt0aW5kZXgrMV07XG5cblx0ZSA9ICh0aGlzLnRyZWVbdGluZGV4XSk7XG5cdGlmKChlICYgMTYpIT0wKXsgICAgICAgICAgICAgICAvLyBkaXN0YW5jZVxuXHQgIHRoaXMuZ2V0ID0gZSAmIDE1O1xuXHQgIHRoaXMuZGlzdCA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfRElTVEVYVDtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiA2NCkgPT0gMCl7ICAgICAgICAvLyBuZXh0IHRhYmxlXG5cdCAgdGhpcy5uZWVkID0gZTtcblx0ICB0aGlzLnRyZWVfaW5kZXggPSB0aW5kZXgvMyArIHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfQkFEQ09ERTsgICAgICAgIC8vIGludmFsaWQgY29kZVxuXHR6Lm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCI7XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfRElTVEVYVDogICAgICAgLy8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxuXHRqID0gdGhpcy5nZXQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07IGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGhpcy5kaXN0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcblxuXHRiPj49ajtcblx0ay09ajtcblxuXHR0aGlzLm1vZGUgPSBJQ19DT1BZO1xuICAgICAgY2FzZSBJQ19DT1BZOiAgICAgICAgICAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcbiAgICAgICAgZiA9IHEgLSB0aGlzLmRpc3Q7XG4gICAgICAgIHdoaWxlKGYgPCAwKXsgICAgIC8vIG1vZHVsbyB3aW5kb3cgc2l6ZS1cIndoaWxlXCIgaW5zdGVhZFxuICAgICAgICAgIGYgKz0gcy5lbmQ7ICAgICAvLyBvZiBcImlmXCIgaGFuZGxlcyBpbnZhbGlkIGRpc3RhbmNlc1xuXHR9XG5cdHdoaWxlICh0aGlzLmxlbiE9MCl7XG5cblx0ICBpZihtPT0wKXtcblx0ICAgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgcy53cml0ZT1xOyByPXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0ICAgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblxuXHQgICAgICBpZihtPT0wKXtcblx0XHRzLmJpdGI9YjtzLmJpdGs9aztcblx0XHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdFx0cy53cml0ZT1xO1xuXHRcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgfSAgXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tmKytdOyBtLS07XG5cblx0ICBpZiAoZiA9PSBzLmVuZClcbiAgICAgICAgICAgIGYgPSAwO1xuXHQgIHRoaXMubGVuLS07XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfU1RBUlQ7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQ19MSVQ6ICAgICAgICAgICAvLyBvOiBnb3QgbGl0ZXJhbCwgd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlXG5cdGlmKG09PTApe1xuXHQgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cdCAgaWYobT09MCl7XG5cdCAgICBzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0ICAgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdHI9Wl9PSztcblxuXHRzLndpbmRvd1txKytdPXRoaXMubGl0OyBtLS07XG5cblx0dGhpcy5tb2RlID0gSUNfU1RBUlQ7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQ19XQVNIOiAgICAgICAgICAgLy8gbzogZ290IGVvYiwgcG9zc2libHkgbW9yZSBvdXRwdXRcblx0aWYgKGsgPiA3KXsgICAgICAgIC8vIHJldHVybiB1bnVzZWQgYnl0ZSwgaWYgYW55XG5cdCAgayAtPSA4O1xuXHQgIG4rKztcblx0ICBwLS07ICAgICAgICAgICAgIC8vIGNhbiBhbHdheXMgcmV0dXJuIG9uZVxuXHR9XG5cblx0cy53cml0ZT1xOyByPXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHRxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0aWYgKHMucmVhZCAhPSBzLndyaXRlKXtcblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXHQgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19FTkQ7XG4gICAgICBjYXNlIElDX0VORDpcblx0ciA9IFpfU1RSRUFNX0VORDtcblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfQkFEQ09ERTogICAgICAgLy8geDogZ290IGVycm9yXG5cblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgZGVmYXVsdDpcblx0ciA9IFpfU1RSRUFNX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uKHope1xuICAgIC8vICBaRlJFRSh6LCBjKTtcbn1cblxuICAvLyBDYWxsZWQgd2l0aCBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byB3cml0ZSBpbiB3aW5kb3cgYXQgbGVhc3QgMjU4XG4gIC8vICh0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoKSBhbmQgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIGF2YWlsYWJsZVxuICAvLyBhdCBsZWFzdCB0ZW4uICBUaGUgdGVuIGJ5dGVzIGFyZSBzaXggYnl0ZXMgZm9yIHRoZSBsb25nZXN0IGxlbmd0aC9cbiAgLy8gZGlzdGFuY2UgcGFpciBwbHVzIGZvdXIgYnl0ZXMgZm9yIG92ZXJsb2FkaW5nIHRoZSBiaXQgYnVmZmVyLlxuXG5JbmZDb2Rlcy5wcm90b3R5cGUuaW5mbGF0ZV9mYXN0ID0gZnVuY3Rpb24oYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgcywgeikge1xuICAgIHZhciB0OyAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciAgIHRwOyAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlciAoaW50W10pXG4gICAgdmFyIHRwX2luZGV4OyAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyIGU7ICAgICAgICAgICAgICAgIC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXG4gICAgdmFyIGI7ICAgICAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgazsgICAgICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyXG4gICAgdmFyIHA7ICAgICAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgICAgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXG4gICAgdmFyIG07ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG4gICAgdmFyIG1sOyAgICAgICAgICAgICAgIC8vIG1hc2sgZm9yIGxpdGVyYWwvbGVuZ3RoIHRyZWVcbiAgICB2YXIgbWQ7ICAgICAgICAgICAgICAgLy8gbWFzayBmb3IgZGlzdGFuY2UgdHJlZVxuICAgIHZhciBjOyAgICAgICAgICAgICAgICAvLyBieXRlcyB0byBjb3B5XG4gICAgdmFyIGQ7ICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIGJhY2sgdG8gY29weSBmcm9tXG4gICAgdmFyIHI7ICAgICAgICAgICAgICAgIC8vIGNvcHkgc291cmNlIHBvaW50ZXJcblxuICAgIHZhciB0cF9pbmRleF90XzM7ICAgICAvLyAodHBfaW5kZXgrdCkqM1xuXG4gICAgLy8gbG9hZCBpbnB1dCwgb3V0cHV0LCBiaXQgdmFsdWVzXG4gICAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuICAgIC8vIGluaXRpYWxpemUgbWFza3NcbiAgICBtbCA9IGluZmxhdGVfbWFza1tibF07XG4gICAgbWQgPSBpbmZsYXRlX21hc2tbYmRdO1xuXG4gICAgLy8gZG8gdW50aWwgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgc3BhY2UgZm9yIGZhc3QgbG9vcFxuICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBjYWxsZWQgd2l0aCBtID49IDI1OCAmJiBuID49IDEwXG4gICAgICAvLyBnZXQgbGl0ZXJhbC9sZW5ndGggY29kZVxuICAgICAgd2hpbGUoazwoMjApKXsgICAgICAgICAgICAgIC8vIG1heCBiaXRzIGZvciBsaXRlcmFsL2xlbmd0aCBjb2RlXG5cdG4tLTtcblx0Ynw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG4gICAgICB9XG5cbiAgICAgIHQ9IGImbWw7XG4gICAgICB0cD10bDsgXG4gICAgICB0cF9pbmRleD10bF9pbmRleDtcbiAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcbiAgICAgIGlmICgoZSA9IHRwW3RwX2luZGV4X3RfM10pID09IDApe1xuXHRiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdHMud2luZG93W3ErK10gPSB0cFt0cF9pbmRleF90XzMrMl07XG5cdG0tLTtcblx0Y29udGludWU7XG4gICAgICB9XG4gICAgICBkbyB7XG5cblx0Yj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHRpZigoZSYxNikhPTApe1xuXHQgIGUgJj0gMTU7XG5cdCAgYyA9IHRwW3RwX2luZGV4X3RfMysyXSArIChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcblxuXHQgIGI+Pj1lOyBrLT1lO1xuXG5cdCAgLy8gZGVjb2RlIGRpc3RhbmNlIGJhc2Ugb2YgYmxvY2sgdG8gY29weVxuXHQgIHdoaWxlKGs8KDE1KSl7ICAgICAgICAgICAvLyBtYXggYml0cyBmb3IgZGlzdGFuY2UgY29kZVxuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG5cdCAgfVxuXG5cdCAgdD0gYiZtZDtcblx0ICB0cD10ZDtcblx0ICB0cF9pbmRleD10ZF9pbmRleDtcbiAgICAgICAgICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG5cdCAgZSA9IHRwW3RwX2luZGV4X3RfM107XG5cblx0ICBkbyB7XG5cblx0ICAgIGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0ICAgIGlmKChlJjE2KSE9MCl7XG5cdCAgICAgIC8vIGdldCBleHRyYSBiaXRzIHRvIGFkZCB0byBkaXN0YW5jZSBiYXNlXG5cdCAgICAgIGUgJj0gMTU7XG5cdCAgICAgIHdoaWxlKGs8KGUpKXsgICAgICAgICAvLyBnZXQgZXh0cmEgYml0cyAodXAgdG8gMTMpXG5cdFx0bi0tO1xuXHRcdGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztrKz04O1xuXHQgICAgICB9XG5cblx0ICAgICAgZCA9IHRwW3RwX2luZGV4X3RfMysyXSArIChiJmluZmxhdGVfbWFza1tlXSk7XG5cblx0ICAgICAgYj4+PShlKTsgay09KGUpO1xuXG5cdCAgICAgIC8vIGRvIHRoZSBjb3B5XG5cdCAgICAgIG0gLT0gYztcblx0ICAgICAgaWYgKHEgPj0gZCl7ICAgICAgICAgICAgICAgIC8vIG9mZnNldCBiZWZvcmUgZGVzdFxuXHRcdC8vICBqdXN0IGNvcHlcblx0XHRyPXEtZDtcblx0XHRpZihxLXI+MCAmJiAyPihxLXIpKXsgICAgICAgICAgIFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBtaW5pbXVtIGNvdW50IGlzIHRocmVlLFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGwgbG9vcCBhIGxpdHRsZVxuXHRcdCAgYy09Mjtcblx0XHR9XG5cdFx0ZWxzZXtcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gbWluaW11bSBjb3VudCBpcyB0aHJlZSxcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gc28gdW5yb2xsIGxvb3AgYSBsaXR0bGVcblx0XHQgIGMtPTI7XG5cdFx0fVxuXHQgICAgICB9XG5cdCAgICAgIGVsc2V7ICAgICAgICAgICAgICAgICAgLy8gZWxzZSBvZmZzZXQgYWZ0ZXIgZGVzdGluYXRpb25cbiAgICAgICAgICAgICAgICByPXEtZDtcbiAgICAgICAgICAgICAgICBkb3tcbiAgICAgICAgICAgICAgICAgIHIrPXMuZW5kOyAgICAgICAgICAvLyBmb3JjZSBwb2ludGVyIGluIHdpbmRvd1xuICAgICAgICAgICAgICAgIH13aGlsZShyPDApOyAgICAgICAgIC8vIGNvdmVycyBpbnZhbGlkIGRpc3RhbmNlc1xuXHRcdGU9cy5lbmQtcjtcblx0XHRpZihjPmUpeyAgICAgICAgICAgICAvLyBpZiBzb3VyY2UgY3Jvc3Nlcyxcblx0XHQgIGMtPWU7ICAgICAgICAgICAgICAvLyB3cmFwcGVkIGNvcHlcblx0XHQgIGlmKHEtcj4wICYmIGU+KHEtcikpeyAgICAgICAgICAgXG5cdFx0ICAgIGRve3Mud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO31cblx0XHQgICAgd2hpbGUoLS1lIT0wKTtcblx0XHQgIH1cblx0XHQgIGVsc2V7XG5cdFx0ICAgIGFycmF5Q29weShzLndpbmRvdywgciwgcy53aW5kb3csIHEsIGUpO1xuXHRcdCAgICBxKz1lOyByKz1lOyBlPTA7XG5cdFx0ICB9XG5cdFx0ICByID0gMDsgICAgICAgICAgICAgICAgICAvLyBjb3B5IHJlc3QgZnJvbSBzdGFydCBvZiB3aW5kb3dcblx0XHR9XG5cblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGNvcHkgYWxsIG9yIHdoYXQncyBsZWZ0XG4gICAgICAgICAgICAgIGRve3Mud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO31cblx0XHR3aGlsZSgtLWMhPTApO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYoKGUmNjQpPT0wKXtcblx0ICAgICAgdCs9dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgICAgICB0Kz0oYiZpbmZsYXRlX21hc2tbZV0pO1xuXHQgICAgICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG5cdCAgICAgIGU9dHBbdHBfaW5kZXhfdF8zXTtcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHoubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIjtcblxuXHQgICAgICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcblxuXHQgICAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICBzLndyaXRlPXE7XG5cblx0ICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcblx0ICAgIH1cblx0ICB9XG5cdCAgd2hpbGUodHJ1ZSk7XG5cdCAgYnJlYWs7XG5cdH1cblxuXHRpZigoZSY2NCk9PTApe1xuXHQgIHQrPXRwW3RwX2luZGV4X3RfMysyXTtcblx0ICB0Kz0oYiZpbmZsYXRlX21hc2tbZV0pO1xuXHQgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICBpZigoZT10cFt0cF9pbmRleF90XzNdKT09MCl7XG5cblx0ICAgIGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0ICAgIHMud2luZG93W3ErK109dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgICAgbS0tO1xuXHQgICAgYnJlYWs7XG5cdCAgfVxuXHR9XG5cdGVsc2UgaWYoKGUmMzIpIT0wKXtcblxuXHQgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuIFxuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cblx0ICByZXR1cm4gWl9TVFJFQU1fRU5EO1xuXHR9XG5cdGVsc2V7XG5cdCAgei5tc2c9XCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIjtcblxuXHQgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblxuXHQgIHJldHVybiBaX0RBVEFfRVJST1I7XG5cdH1cbiAgICAgIH0gXG4gICAgICB3aGlsZSh0cnVlKTtcbiAgICB9IFxuICAgIHdoaWxlKG0+PTI1OCAmJiBuPj0gMTApO1xuXG4gICAgLy8gbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQtLXJlc3RvcmUgcG9pbnRlcnMgYW5kIHJldHVyblxuICAgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG4gICAgcy5iaXRiPWI7cy5iaXRrPWs7XG4gICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuICAgIHMud3JpdGU9cTtcblxuICAgIHJldHVybiBaX09LO1xufVxuXG4vL1xuLy8gSW5mVHJlZS5qYXZhXG4vL1xuXG5mdW5jdGlvbiBJbmZUcmVlKCkge1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5odWZ0X2J1aWxkID0gZnVuY3Rpb24oYiwgYmluZGV4LCBuLCBzLCBkLCBlLCB0LCBtLCBocCwgaG4sIHYpIHtcblxuICAgIC8vIEdpdmVuIGEgbGlzdCBvZiBjb2RlIGxlbmd0aHMgYW5kIGEgbWF4aW11bSB0YWJsZSBzaXplLCBtYWtlIGEgc2V0IG9mXG4gICAgLy8gdGFibGVzIHRvIGRlY29kZSB0aGF0IHNldCBvZiBjb2Rlcy4gIFJldHVybiBaX09LIG9uIHN1Y2Nlc3MsIFpfQlVGX0VSUk9SXG4gICAgLy8gaWYgdGhlIGdpdmVuIGNvZGUgc2V0IGlzIGluY29tcGxldGUgKHRoZSB0YWJsZXMgYXJlIHN0aWxsIGJ1aWx0IGluIHRoaXNcbiAgICAvLyBjYXNlKSwgWl9EQVRBX0VSUk9SIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkIChhbiBvdmVyLXN1YnNjcmliZWQgc2V0IG9mXG4gICAgLy8gbGVuZ3RocyksIG9yIFpfTUVNX0VSUk9SIGlmIG5vdCBlbm91Z2ggbWVtb3J5LlxuXG4gICAgdmFyIGE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyIGZvciBjb2RlcyBvZiBsZW5ndGgga1xuICAgIHZhciBmOyAgICAgICAgICAgICAgICAgICAgICAgLy8gaSByZXBlYXRzIGluIHRhYmxlIGV2ZXJ5IGYgZW50cmllc1xuICAgIHZhciBnOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxuICAgIHZhciBoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFibGUgbGV2ZWxcbiAgICB2YXIgaTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIsIGN1cnJlbnQgY29kZVxuICAgIHZhciBqOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGJpdHMgaW4gY3VycmVudCBjb2RlXG4gICAgdmFyIGw7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHBlciB0YWJsZSAocmV0dXJuZWQgaW4gbSlcbiAgICB2YXIgbWFzazsgICAgICAgICAgICAgICAgICAgIC8vICgxIDw8IHcpIC0gMSwgdG8gYXZvaWQgY2MgLU8gYnVnIG9uIEhQXG4gICAgdmFyIHA7ICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIGludG8gY1tdLCBiW10sIG9yIHZbXVxuICAgIHZhciBxOyAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzIHRvIGN1cnJlbnQgdGFibGVcbiAgICB2YXIgdzsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgYmVmb3JlIHRoaXMgdGFibGUgPT0gKGwgKiBoKVxuICAgIHZhciB4cDsgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciBpbnRvIHhcbiAgICB2YXIgeTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBkdW1teSBjb2RlcyBhZGRlZFxuICAgIHZhciB6OyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgaW4gY3VycmVudCB0YWJsZVxuXG4gICAgLy8gR2VuZXJhdGUgY291bnRzIGZvciBlYWNoIGJpdCBsZW5ndGhcblxuICAgIHAgPSAwOyBpID0gbjtcbiAgICBkbyB7XG4gICAgICB0aGlzLmNbYltiaW5kZXgrcF1dKys7IHArKzsgaS0tOyAgIC8vIGFzc3VtZSBhbGwgZW50cmllcyA8PSBCTUFYXG4gICAgfXdoaWxlKGkhPTApO1xuXG4gICAgaWYodGhpcy5jWzBdID09IG4peyAgICAgICAgICAgICAgICAvLyBudWxsIGlucHV0LS1hbGwgemVybyBsZW5ndGggY29kZXNcbiAgICAgIHRbMF0gPSAtMTtcbiAgICAgIG1bMF0gPSAwO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLy8gRmluZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCwgYm91bmQgKm0gYnkgdGhvc2VcbiAgICBsID0gbVswXTtcbiAgICBmb3IgKGogPSAxOyBqIDw9IEJNQVg7IGorKylcbiAgICAgIGlmKHRoaXMuY1tqXSE9MCkgYnJlYWs7XG4gICAgayA9IGo7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWluaW11bSBjb2RlIGxlbmd0aFxuICAgIGlmKGwgPCBqKXtcbiAgICAgIGwgPSBqO1xuICAgIH1cbiAgICBmb3IgKGkgPSBCTUFYOyBpIT0wOyBpLS0pe1xuICAgICAgaWYodGhpcy5jW2ldIT0wKSBicmVhaztcbiAgICB9XG4gICAgZyA9IGk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxuICAgIGlmKGwgPiBpKXtcbiAgICAgIGwgPSBpO1xuICAgIH1cbiAgICBtWzBdID0gbDtcblxuICAgIC8vIEFkanVzdCBsYXN0IGxlbmd0aCBjb3VudCB0byBmaWxsIG91dCBjb2RlcywgaWYgbmVlZGVkXG4gICAgZm9yICh5ID0gMSA8PCBqOyBqIDwgaTsgaisrLCB5IDw8PSAxKXtcbiAgICAgIGlmICgoeSAtPSB0aGlzLmNbal0pIDwgMCl7XG4gICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoeSAtPSB0aGlzLmNbaV0pIDwgMCl7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgICB0aGlzLmNbaV0gKz0geTtcblxuICAgIC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXG4gICAgdGhpcy54WzFdID0gaiA9IDA7XG4gICAgcCA9IDE7ICB4cCA9IDI7XG4gICAgd2hpbGUgKC0taSE9MCkgeyAgICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IGkgPT0gZyBmcm9tIGFib3ZlXG4gICAgICB0aGlzLnhbeHBdID0gKGogKz0gdGhpcy5jW3BdKTtcbiAgICAgIHhwKys7XG4gICAgICBwKys7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIHRhYmxlIG9mIHZhbHVlcyBpbiBvcmRlciBvZiBiaXQgbGVuZ3Roc1xuICAgIGkgPSAwOyBwID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoKGogPSBiW2JpbmRleCtwXSkgIT0gMCl7XG4gICAgICAgIHRoaXMudlt0aGlzLnhbal0rK10gPSBpO1xuICAgICAgfVxuICAgICAgcCsrO1xuICAgIH1cbiAgICB3aGlsZSAoKytpIDwgbik7XG4gICAgbiA9IHRoaXMueFtnXTsgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgbiB0byBsZW5ndGggb2YgdlxuXG4gICAgLy8gR2VuZXJhdGUgdGhlIEh1ZmZtYW4gY29kZXMgYW5kIGZvciBlYWNoLCBtYWtlIHRoZSB0YWJsZSBlbnRyaWVzXG4gICAgdGhpcy54WzBdID0gaSA9IDA7ICAgICAgICAgICAgICAgICAvLyBmaXJzdCBIdWZmbWFuIGNvZGUgaXMgemVyb1xuICAgIHAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYWIgdmFsdWVzIGluIGJpdCBvcmRlclxuICAgIGggPSAtMTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHRhYmxlcyB5ZXQtLWxldmVsIC0xXG4gICAgdyA9IC1sOyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBkZWNvZGVkID09IChsICogaClcbiAgICB0aGlzLnVbMF0gPSAwOyAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgdG8ga2VlcCBjb21waWxlcnMgaGFwcHlcbiAgICBxID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXR0b1xuICAgIHogPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdHRvXG5cbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBiaXQgbGVuZ3RocyAoayBhbHJlYWR5IGlzIGJpdHMgaW4gc2hvcnRlc3QgY29kZSlcbiAgICBmb3IgKDsgayA8PSBnOyBrKyspe1xuICAgICAgYSA9IHRoaXMuY1trXTtcbiAgICAgIHdoaWxlIChhLS0hPTApe1xuXHQvLyBoZXJlIGkgaXMgdGhlIEh1ZmZtYW4gY29kZSBvZiBsZW5ndGggayBiaXRzIGZvciB2YWx1ZSAqcFxuXHQvLyBtYWtlIHRhYmxlcyB1cCB0byByZXF1aXJlZCBsZXZlbFxuICAgICAgICB3aGlsZSAoayA+IHcgKyBsKXtcbiAgICAgICAgICBoKys7XG4gICAgICAgICAgdyArPSBsOyAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgdGFibGUgYWx3YXlzIGwgYml0c1xuXHQgIC8vIGNvbXB1dGUgbWluaW11bSBzaXplIHRhYmxlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBsIGJpdHNcbiAgICAgICAgICB6ID0gZyAtIHc7XG4gICAgICAgICAgeiA9ICh6ID4gbCkgPyBsIDogejsgICAgICAgIC8vIHRhYmxlIHNpemUgdXBwZXIgbGltaXRcbiAgICAgICAgICBpZigoZj0xPDwoaj1rLXcpKT5hKzEpeyAgICAgLy8gdHJ5IGEgay13IGJpdCB0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b28gZmV3IGNvZGVzIGZvciBrLXcgYml0IHRhYmxlXG4gICAgICAgICAgICBmIC09IGEgKyAxOyAgICAgICAgICAgICAgIC8vIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zIGxlZnRcbiAgICAgICAgICAgIHhwID0gaztcbiAgICAgICAgICAgIGlmKGogPCB6KXtcbiAgICAgICAgICAgICAgd2hpbGUgKCsraiA8IHopeyAgICAgICAgLy8gdHJ5IHNtYWxsZXIgdGFibGVzIHVwIHRvIHogYml0c1xuICAgICAgICAgICAgICAgIGlmKChmIDw8PSAxKSA8PSB0aGlzLmNbKyt4cF0pXG4gICAgICAgICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgIC8vIGVub3VnaCBjb2RlcyB0byB1c2UgdXAgaiBiaXRzXG4gICAgICAgICAgICAgICAgZiAtPSB0aGlzLmNbeHBdOyAgICAgICAgICAgLy8gZWxzZSBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJuc1xuICAgICAgICAgICAgICB9XG5cdCAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHogPSAxIDw8IGo7ICAgICAgICAgICAgICAgICAvLyB0YWJsZSBlbnRyaWVzIGZvciBqLWJpdCB0YWJsZVxuXG5cdCAgLy8gYWxsb2NhdGUgbmV3IHRhYmxlXG4gICAgICAgICAgaWYgKHRoaXMuaG5bMF0gKyB6ID4gTUFOWSl7ICAgICAgIC8vIChub3RlOiBkb2Vzbid0IG1hdHRlciBmb3IgZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOyAgICAgICAvLyBvdmVyZmxvdyBvZiBNQU5ZXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudVtoXSA9IHEgPSAvKmhwKyovIHRoaXMuaG5bMF07ICAgLy8gREVCVUdcbiAgICAgICAgICB0aGlzLmhuWzBdICs9IHo7XG4gXG5cdCAgLy8gY29ubmVjdCB0byBsYXN0IHRhYmxlLCBpZiB0aGVyZSBpcyBvbmVcblx0ICBpZihoIT0wKXtcbiAgICAgICAgICAgIHRoaXMueFtoXT1pOyAgICAgICAgICAgLy8gc2F2ZSBwYXR0ZXJuIGZvciBiYWNraW5nIHVwXG4gICAgICAgICAgICB0aGlzLnJbMF09ajsgICAgIC8vIGJpdHMgaW4gdGhpcyB0YWJsZVxuICAgICAgICAgICAgdGhpcy5yWzFdPWw7ICAgICAvLyBiaXRzIHRvIGR1bXAgYmVmb3JlIHRoaXMgdGFibGVcbiAgICAgICAgICAgIGo9aT4+Pih3IC0gbCk7XG4gICAgICAgICAgICB0aGlzLnJbMl0gPSAocSAtIHRoaXMudVtoLTFdIC0gaik7ICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHRvIHRoaXMgdGFibGVcbiAgICAgICAgICAgIGFycmF5Q29weSh0aGlzLnIsIDAsIGhwLCAodGhpcy51W2gtMV0raikqMywgMyk7IC8vIGNvbm5lY3QgdG8gbGFzdCB0YWJsZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgdFswXSA9IHE7ICAgICAgICAgICAgICAgLy8gZmlyc3QgdGFibGUgaXMgcmV0dXJuZWQgcmVzdWx0XG5cdCAgfVxuICAgICAgICB9XG5cblx0Ly8gc2V0IHVwIHRhYmxlIGVudHJ5IGluIHJcbiAgICAgICAgdGhpcy5yWzFdID0gKGsgLSB3KTtcbiAgICAgICAgaWYgKHAgPj0gbil7XG4gICAgICAgICAgdGhpcy5yWzBdID0gMTI4ICsgNjQ7ICAgICAgLy8gb3V0IG9mIHZhbHVlcy0taW52YWxpZCBjb2RlXG5cdH1cbiAgICAgICAgZWxzZSBpZiAodltwXSA8IHMpe1xuICAgICAgICAgIHRoaXMuclswXSA9ICh0aGlzLnZbcF0gPCAyNTYgPyAwIDogMzIgKyA2NCk7ICAvLyAyNTYgaXMgZW5kLW9mLWJsb2NrXG4gICAgICAgICAgdGhpcy5yWzJdID0gdGhpcy52W3ArK107ICAgICAgICAgIC8vIHNpbXBsZSBjb2RlIGlzIGp1c3QgdGhlIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICB0aGlzLnJbMF09KGVbdGhpcy52W3BdLXNdKzE2KzY0KTsgLy8gbm9uLXNpbXBsZS0tbG9vayB1cCBpbiBsaXN0c1xuICAgICAgICAgIHRoaXMuclsyXT1kW3RoaXMudltwKytdIC0gc107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWxsIGNvZGUtbGlrZSBlbnRyaWVzIHdpdGggclxuICAgICAgICBmPTE8PChrLXcpO1xuICAgICAgICBmb3IgKGo9aT4+Pnc7ajx6O2orPWYpe1xuICAgICAgICAgIGFycmF5Q29weSh0aGlzLnIsIDAsIGhwLCAocStqKSozLCAzKTtcblx0fVxuXG5cdC8vIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGstYml0IGNvZGUgaVxuICAgICAgICBmb3IgKGogPSAxIDw8IChrIC0gMSk7IChpICYgaikhPTA7IGogPj4+PSAxKXtcbiAgICAgICAgICBpIF49IGo7XG5cdH1cbiAgICAgICAgaSBePSBqO1xuXG5cdC8vIGJhY2t1cCBvdmVyIGZpbmlzaGVkIHRhYmxlc1xuICAgICAgICBtYXNrID0gKDEgPDwgdykgLSAxOyAgICAgIC8vIG5lZWRlZCBvbiBIUCwgY2MgLU8gYnVnXG4gICAgICAgIHdoaWxlICgoaSAmIG1hc2spICE9IHRoaXMueFtoXSl7XG4gICAgICAgICAgaC0tOyAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgcVxuICAgICAgICAgIHcgLT0gbDtcbiAgICAgICAgICBtYXNrID0gKDEgPDwgdykgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiBaX0JVRl9FUlJPUiBpZiB3ZSB3ZXJlIGdpdmVuIGFuIGluY29tcGxldGUgdGFibGVcbiAgICByZXR1cm4geSAhPSAwICYmIGcgIT0gMSA/IFpfQlVGX0VSUk9SIDogWl9PSztcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5mbGF0ZV90cmVlc19iaXRzID0gZnVuY3Rpb24oYywgYmIsIHRiLCBocCwgeikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdGhpcy5pbml0V29ya0FyZWEoMTkpO1xuICAgIHRoaXMuaG5bMF09MDtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgMCwgMTksIDE5LCBudWxsLCBudWxsLCB0YiwgYmIsIGhwLCB0aGlzLmhuLCB0aGlzLnYpO1xuXG4gICAgaWYocmVzdWx0ID09IFpfREFUQV9FUlJPUil7XG4gICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYocmVzdWx0ID09IFpfQlVGX0VSUk9SIHx8IGJiWzBdID09IDApe1xuICAgICAgei5tc2cgPSBcImluY29tcGxldGUgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXCI7XG4gICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmluZmxhdGVfdHJlZXNfZHluYW1pYyA9IGZ1bmN0aW9uKG5sLCBuZCwgYywgYmwsIGJkLCB0bCwgdGQsIGhwLCB6KSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGJ1aWxkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgyODgpO1xuICAgIHRoaXMuaG5bMF09MDtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgMCwgbmwsIDI1NywgY3BsZW5zLCBjcGxleHQsIHRsLCBibCwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG4gICAgaWYgKHJlc3VsdCAhPSBaX09LIHx8IGJsWzBdID09IDApe1xuICAgICAgaWYocmVzdWx0ID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBsaXRlcmFsL2xlbmd0aCB0cmVlXCI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBsaXRlcmFsL2xlbmd0aCB0cmVlXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgZGlzdGFuY2UgdHJlZVxuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDI4OCk7XG4gICAgcmVzdWx0ID0gdGhpcy5odWZ0X2J1aWxkKGMsIG5sLCBuZCwgMCwgY3BkaXN0LCBjcGRleHQsIHRkLCBiZCwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG5cbiAgICBpZiAocmVzdWx0ICE9IFpfT0sgfHwgKGJkWzBdID09IDAgJiYgbmwgPiAyNTcpKXtcbiAgICAgIGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGRpc3RhbmNlIHRyZWVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCA9PSBaX0JVRl9FUlJPUikge1xuICAgICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBkaXN0YW5jZSB0cmVlXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJlbXB0eSBkaXN0YW5jZSB0cmVlIHdpdGggbGVuZ3Roc1wiO1xuICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBaX09LO1xufVxuLypcbiAgc3RhdGljIGludCBpbmZsYXRlX3RyZWVzX2ZpeGVkKGludFtdIGJsLCAgLy9saXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W10gYmQsICAvL2Rpc3RhbmNlIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W11bXSB0bCwvL2xpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXVtdIHRkLC8vZGlzdGFuY2UgdHJlZSByZXN1bHQgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBaU3RyZWFtIHogIC8vZm9yIG1lbW9yeSBhbGxvY2F0aW9uXG5cdFx0XHRcdCApe1xuXG4qL1xuXG5mdW5jdGlvbiBpbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkLCB6KSB7XG4gICAgYmxbMF09Zml4ZWRfYmw7XG4gICAgYmRbMF09Zml4ZWRfYmQ7XG4gICAgdGxbMF09Zml4ZWRfdGw7XG4gICAgdGRbMF09Zml4ZWRfdGQ7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmluaXRXb3JrQXJlYSA9IGZ1bmN0aW9uKHZzaXplKXtcbiAgICBpZih0aGlzLmhuPT1udWxsKXtcbiAgICAgICAgdGhpcy5obj1uZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgdGhpcy52PW5ldyBJbnQzMkFycmF5KHZzaXplKTtcbiAgICAgICAgdGhpcy5jPW5ldyBJbnQzMkFycmF5KEJNQVgrMSk7XG4gICAgICAgIHRoaXMucj1uZXcgSW50MzJBcnJheSgzKTtcbiAgICAgICAgdGhpcy51PW5ldyBJbnQzMkFycmF5KEJNQVgpO1xuICAgICAgICB0aGlzLng9bmV3IEludDMyQXJyYXkoQk1BWCsxKTtcbiAgICB9XG4gICAgaWYodGhpcy52Lmxlbmd0aDx2c2l6ZSl7IFxuICAgICAgICB0aGlzLnY9bmV3IEludDMyQXJyYXkodnNpemUpOyBcbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8dnNpemU7IGkrKyl7dGhpcy52W2ldPTA7fVxuICAgIGZvcih2YXIgaT0wOyBpPEJNQVgrMTsgaSsrKXt0aGlzLmNbaV09MDt9XG4gICAgZm9yKHZhciBpPTA7IGk8MzsgaSsrKXt0aGlzLnJbaV09MDt9XG4vLyAgZm9yKGludCBpPTA7IGk8Qk1BWDsgaSsrKXt1W2ldPTA7fVxuICAgIGFycmF5Q29weSh0aGlzLmMsIDAsIHRoaXMudSwgMCwgQk1BWCk7XG4vLyAgZm9yKGludCBpPTA7IGk8Qk1BWCsxOyBpKyspe3hbaV09MDt9XG4gICAgYXJyYXlDb3B5KHRoaXMuYywgMCwgdGhpcy54LCAwLCBCTUFYKzEpO1xufVxuXG52YXIgdGVzdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG52YXIgaGFzU3ViYXJyYXkgPSAodHlwZW9mIHRlc3RBcnJheS5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyk7XG52YXIgaGFzU2xpY2UgPSBmYWxzZTsgLyogKHR5cGVvZiB0ZXN0QXJyYXkuc2xpY2UgPT09ICdmdW5jdGlvbicpOyAqLyAvLyBDaHJvbWUgc2xpY2UgcGVyZm9ybWFuY2UgaXMgc28gZGlyZSB0aGF0IHdlJ3JlIGN1cnJlbnRseSBub3QgdXNpbmcgaXQuLi5cblxuZnVuY3Rpb24gYXJyYXlDb3B5KHNyYywgc3JjT2Zmc2V0LCBkZXN0LCBkZXN0T2Zmc2V0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IFxuICAgIGlmICghc3JjKSB7XG4gICAgICAgIHRocm93IFwiVW5kZWYgc3JjXCI7XG4gICAgfSBlbHNlIGlmICghZGVzdCkge1xuICAgICAgICB0aHJvdyBcIlVuZGVmIGRlc3RcIjtcbiAgICB9XG5cbiAgICBpZiAoc3JjT2Zmc2V0ID09IDAgJiYgY291bnQgPT0gc3JjLmxlbmd0aCkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChzcmMsIGRlc3QsIGRlc3RPZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoaGFzU3ViYXJyYXkpIHtcbiAgICAgICAgYXJyYXlDb3B5X2Zhc3Qoc3JjLnN1YmFycmF5KHNyY09mZnNldCwgc3JjT2Zmc2V0ICsgY291bnQpLCBkZXN0LCBkZXN0T2Zmc2V0KTsgXG4gICAgfSBlbHNlIGlmIChzcmMuQllURVNfUEVSX0VMRU1FTlQgPT0gMSAmJiBjb3VudCA+IDEwMCkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChuZXcgVWludDhBcnJheShzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCArIHNyY09mZnNldCwgY291bnQpLCBkZXN0LCBkZXN0T2Zmc2V0KTtcbiAgICB9IGVsc2UgeyBcbiAgICAgICAgYXJyYXlDb3B5X3Nsb3coc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KTtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlDb3B5X3Nsb3coc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KSB7XG5cbiAgICAvLyBkbG9nKCdfc2xvdyBjYWxsOiBzcmNPZmZzZXQ9JyArIHNyY09mZnNldCArICc7IGRlc3RPZmZzZXQ9JyArIGRlc3RPZmZzZXQgKyAnOyBjb3VudD0nICsgY291bnQpO1xuXG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyBpXSA9IHNyY1tzcmNPZmZzZXQgKyBpXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5Q29weV9mYXN0KHNyYywgZGVzdCwgZGVzdE9mZnNldCkge1xuICAgIGRlc3Quc2V0KHNyYywgZGVzdE9mZnNldCk7XG59XG5cblxuICAvLyBsYXJnZXN0IHByaW1lIHNtYWxsZXIgdGhhbiA2NTUzNlxudmFyIEFETEVSX0JBU0U9NjU1MjE7IFxuICAvLyBOTUFYIGlzIHRoZSBsYXJnZXN0IG4gc3VjaCB0aGF0IDI1NW4obisxKS8yICsgKG4rMSkoQkFTRS0xKSA8PSAyXjMyLTFcbnZhciBBRExFUl9OTUFYPTU1NTI7XG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIC8qIGJ5dGVbXSAqLyBidWYsICBpbmRleCwgbGVuKXtcbiAgICBpZihidWYgPT0gbnVsbCl7IHJldHVybiAxOyB9XG5cbiAgICB2YXIgczE9YWRsZXImMHhmZmZmO1xuICAgIHZhciBzMj0oYWRsZXI+PjE2KSYweGZmZmY7XG4gICAgdmFyIGs7XG5cbiAgICB3aGlsZShsZW4gPiAwKSB7XG4gICAgICBrPWxlbjxBRExFUl9OTUFYP2xlbjpBRExFUl9OTUFYO1xuICAgICAgbGVuLT1rO1xuICAgICAgd2hpbGUoaz49MTYpe1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgay09MTY7XG4gICAgICB9XG4gICAgICBpZihrIT0wKXtcbiAgICAgICAgZG97XG4gICAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoLS1rIT0wKTtcbiAgICAgIH1cbiAgICAgIHMxJT1BRExFUl9CQVNFO1xuICAgICAgczIlPUFETEVSX0JBU0U7XG4gICAgfVxuICAgIHJldHVybiAoczI8PDE2KXxzMTtcbn1cblxuXG5cbmZ1bmN0aW9uIGpzemxpYl9pbmZsYXRlX2J1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgsIGFmdGVyVW5jT2Zmc2V0KSB7XG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHogPSBuZXcgWlN0cmVhbSgpO1xuICAgIHouaW5mbGF0ZUluaXQoREVGX1dCSVRTLCB0cnVlKTtcbiAgICB6Lm5leHRfaW4gPSBidWZmZXI7XG4gICAgei5uZXh0X2luX2luZGV4ID0gMDtcbiAgICB6LmF2YWlsX2luID0gYnVmZmVyLmxlbmd0aDtcblxuICAgIHZhciBvQmxvY2tMaXN0ID0gW107XG4gICAgdmFyIHRvdGFsU2l6ZSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIG9idWYgPSBuZXcgVWludDhBcnJheSgzMjAwMCk7XG4gICAgICAgIHoubmV4dF9vdXQgPSBvYnVmO1xuICAgICAgICB6Lm5leHRfb3V0X2luZGV4ID0gMDtcbiAgICAgICAgei5hdmFpbF9vdXQgPSBvYnVmLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHouaW5mbGF0ZShaX05PX0ZMVVNIKTtcbiAgICAgICAgaWYgKHN0YXR1cyAhPSBaX09LICYmIHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgICAgICAgIHRocm93IHoubXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6LmF2YWlsX291dCAhPSAwKSB7XG4gICAgICAgICAgICB2YXIgbmV3b2IgPSBuZXcgVWludDhBcnJheShvYnVmLmxlbmd0aCAtIHouYXZhaWxfb3V0KTtcbiAgICAgICAgICAgIGFycmF5Q29weShvYnVmLCAwLCBuZXdvYiwgMCwgKG9idWYubGVuZ3RoIC0gei5hdmFpbF9vdXQpKTtcbiAgICAgICAgICAgIG9idWYgPSBuZXdvYjtcbiAgICAgICAgfVxuICAgICAgICBvQmxvY2tMaXN0LnB1c2gob2J1Zik7XG4gICAgICAgIHRvdGFsU2l6ZSArPSBvYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFmdGVyVW5jT2Zmc2V0KSB7XG4gICAgICAgIGFmdGVyVW5jT2Zmc2V0WzBdID0gKHN0YXJ0IHx8IDApICsgei5uZXh0X2luX2luZGV4O1xuICAgIH1cblxuICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb0Jsb2NrTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGIgPSBvQmxvY2tMaXN0W2ldO1xuICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XG4gICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XG4gICAgfVxufVxuXG5leHBvcnQge2pzemxpYl9pbmZsYXRlX2J1ZmZlcixhcnJheUNvcHl9Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vendor/inflate.js\n");

/***/ }),

/***/ "./src/vendor/zlib_and_gzip.min.js":
/*!*****************************************!*\
  !*** ./src/vendor/zlib_and_gzip.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function q(b){throw b;}var t=void 0,u=!0,aa=this;function A(b,a){var c=b.split(\".\"),d=aa;!(c[0]in d)&&d.execScript&&d.execScript(\"var \"+c[0]);for(var f;c.length&&(f=c.shift());)!c.length&&a!==t?d[f]=a:d=d[f]?d[f]:d[f]={}};var B=\"undefined\"!==typeof Uint8Array&&\"undefined\"!==typeof Uint16Array&&\"undefined\"!==typeof Uint32Array;function F(b,a){this.index=\"number\"===typeof a?a:0;this.m=0;this.buffer=b instanceof(B?Uint8Array:Array)?b:new (B?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&q(Error(\"invalid index\"));this.buffer.length<=this.index&&this.f()}F.prototype.f=function(){var b=this.buffer,a,c=b.length,d=new (B?Uint8Array:Array)(c<<1);if(B)d.set(b);else for(a=0;a<c;++a)d[a]=b[a];return this.buffer=d};\nF.prototype.d=function(b,a,c){var d=this.buffer,f=this.index,e=this.m,g=d[f],k;c&&1<a&&(b=8<a?(H[b&255]<<24|H[b>>>8&255]<<16|H[b>>>16&255]<<8|H[b>>>24&255])>>32-a:H[b]>>8-a);if(8>a+e)g=g<<a|b,e+=a;else for(k=0;k<a;++k)g=g<<1|b>>a-k-1&1,8===++e&&(e=0,d[f++]=H[g],g=0,f===d.length&&(d=this.f()));d[f]=g;this.buffer=d;this.m=e;this.index=f};F.prototype.finish=function(){var b=this.buffer,a=this.index,c;0<this.m&&(b[a]<<=8-this.m,b[a]=H[b[a]],a++);B?c=b.subarray(0,a):(b.length=a,c=b);return c};\nvar ba=new (B?Uint8Array:Array)(256),ca;for(ca=0;256>ca;++ca){for(var K=ca,da=K,ea=7,K=K>>>1;K;K>>>=1)da<<=1,da|=K&1,--ea;ba[ca]=(da<<ea&255)>>>0}var H=ba;function ja(b,a,c){var d,f=\"number\"===typeof a?a:a=0,e=\"number\"===typeof c?c:b.length;d=-1;for(f=e&7;f--;++a)d=d>>>8^O[(d^b[a])&255];for(f=e>>3;f--;a+=8)d=d>>>8^O[(d^b[a])&255],d=d>>>8^O[(d^b[a+1])&255],d=d>>>8^O[(d^b[a+2])&255],d=d>>>8^O[(d^b[a+3])&255],d=d>>>8^O[(d^b[a+4])&255],d=d>>>8^O[(d^b[a+5])&255],d=d>>>8^O[(d^b[a+6])&255],d=d>>>8^O[(d^b[a+7])&255];return(d^4294967295)>>>0}\nvar ka=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,\n2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,\n2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,\n2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,\n3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,\n936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],O=B?new Uint32Array(ka):ka;function P(){}P.prototype.getName=function(){return this.name};P.prototype.getData=function(){return this.data};P.prototype.X=function(){return this.Y};A(\"Zlib.GunzipMember\",P);A(\"Zlib.GunzipMember.prototype.getName\",P.prototype.getName);A(\"Zlib.GunzipMember.prototype.getData\",P.prototype.getData);A(\"Zlib.GunzipMember.prototype.getMtime\",P.prototype.X);function la(b){this.buffer=new (B?Uint16Array:Array)(2*b);this.length=0}la.prototype.getParent=function(b){return 2*((b-2)/4|0)};la.prototype.push=function(b,a){var c,d,f=this.buffer,e;c=this.length;f[this.length++]=a;for(f[this.length++]=b;0<c;)if(d=this.getParent(c),f[c]>f[d])e=f[c],f[c]=f[d],f[d]=e,e=f[c+1],f[c+1]=f[d+1],f[d+1]=e,c=d;else break;return this.length};\nla.prototype.pop=function(){var b,a,c=this.buffer,d,f,e;a=c[0];b=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(e=0;;){f=2*e+2;if(f>=this.length)break;f+2<this.length&&c[f+2]>c[f]&&(f+=2);if(c[f]>c[e])d=c[e],c[e]=c[f],c[f]=d,d=c[e+1],c[e+1]=c[f+1],c[f+1]=d;else break;e=f}return{index:b,value:a,length:this.length}};function ma(b){var a=b.length,c=0,d=Number.POSITIVE_INFINITY,f,e,g,k,h,l,s,n,m;for(n=0;n<a;++n)b[n]>c&&(c=b[n]),b[n]<d&&(d=b[n]);f=1<<c;e=new (B?Uint32Array:Array)(f);g=1;k=0;for(h=2;g<=c;){for(n=0;n<a;++n)if(b[n]===g){l=0;s=k;for(m=0;m<g;++m)l=l<<1|s&1,s>>=1;for(m=l;m<f;m+=h)e[m]=g<<16|n;++k}++g;k<<=1;h<<=1}return[e,c,d]};function na(b,a){this.k=qa;this.I=0;this.input=B&&b instanceof Array?new Uint8Array(b):b;this.b=0;a&&(a.lazy&&(this.I=a.lazy),\"number\"===typeof a.compressionType&&(this.k=a.compressionType),a.outputBuffer&&(this.a=B&&a.outputBuffer instanceof Array?new Uint8Array(a.outputBuffer):a.outputBuffer),\"number\"===typeof a.outputIndex&&(this.b=a.outputIndex));this.a||(this.a=new (B?Uint8Array:Array)(32768))}var qa=2,ra={NONE:0,v:1,o:qa,aa:3},sa=[],S;\nfor(S=0;288>S;S++)switch(u){case 143>=S:sa.push([S+48,8]);break;case 255>=S:sa.push([S-144+400,9]);break;case 279>=S:sa.push([S-256+0,7]);break;case 287>=S:sa.push([S-280+192,8]);break;default:q(\"invalid literal: \"+S)}\nna.prototype.g=function(){var b,a,c,d,f=this.input;switch(this.k){case 0:c=0;for(d=f.length;c<d;){a=B?f.subarray(c,c+65535):f.slice(c,c+65535);c+=a.length;var e=a,g=c===d,k=t,h=t,l=t,s=t,n=t,m=this.a,p=this.b;if(B){for(m=new Uint8Array(this.a.buffer);m.length<=p+e.length+5;)m=new Uint8Array(m.length<<1);m.set(this.a)}k=g?1:0;m[p++]=k|0;h=e.length;l=~h+65536&65535;m[p++]=h&255;m[p++]=h>>>8&255;m[p++]=l&255;m[p++]=l>>>8&255;if(B)m.set(e,p),p+=e.length,m=m.subarray(0,p);else{s=0;for(n=e.length;s<n;++s)m[p++]=\ne[s];m.length=p}this.b=p;this.a=m}break;case 1:var r=new F(B?new Uint8Array(this.a.buffer):this.a,this.b);r.d(1,1,u);r.d(1,2,u);var v=ta(this,f),x,Q,y;x=0;for(Q=v.length;x<Q;x++)if(y=v[x],F.prototype.d.apply(r,sa[y]),256<y)r.d(v[++x],v[++x],u),r.d(v[++x],5),r.d(v[++x],v[++x],u);else if(256===y)break;this.a=r.finish();this.b=this.a.length;break;case qa:var E=new F(B?new Uint8Array(this.a.buffer):this.a,this.b),Ja,R,X,Y,Z,pb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa,Ka,ga,La,oa,wa=Array(19),\nMa,$,pa,C,Na;Ja=qa;E.d(1,1,u);E.d(Ja,2,u);R=ta(this,f);fa=ua(this.V,15);Ka=va(fa);ga=ua(this.U,7);La=va(ga);for(X=286;257<X&&0===fa[X-1];X--);for(Y=30;1<Y&&0===ga[Y-1];Y--);var Oa=X,Pa=Y,J=new (B?Uint32Array:Array)(Oa+Pa),w,L,z,ha,I=new (B?Uint32Array:Array)(316),G,D,M=new (B?Uint8Array:Array)(19);for(w=L=0;w<Oa;w++)J[L++]=fa[w];for(w=0;w<Pa;w++)J[L++]=ga[w];if(!B){w=0;for(ha=M.length;w<ha;++w)M[w]=0}w=G=0;for(ha=J.length;w<ha;w+=L){for(L=1;w+L<ha&&J[w+L]===J[w];++L);z=L;if(0===J[w])if(3>z)for(;0<\nz--;)I[G++]=0,M[0]++;else for(;0<z;)D=138>z?z:138,D>z-3&&D<z&&(D=z-3),10>=D?(I[G++]=17,I[G++]=D-3,M[17]++):(I[G++]=18,I[G++]=D-11,M[18]++),z-=D;else if(I[G++]=J[w],M[J[w]]++,z--,3>z)for(;0<z--;)I[G++]=J[w],M[J[w]]++;else for(;0<z;)D=6>z?z:6,D>z-3&&D<z&&(D=z-3),I[G++]=16,I[G++]=D-3,M[16]++,z-=D}b=B?I.subarray(0,G):I.slice(0,G);oa=ua(M,7);for(C=0;19>C;C++)wa[C]=oa[pb[C]];for(Z=19;4<Z&&0===wa[Z-1];Z--);Ma=va(oa);E.d(X-257,5,u);E.d(Y-1,5,u);E.d(Z-4,4,u);for(C=0;C<Z;C++)E.d(wa[C],3,u);C=0;for(Na=b.length;C<\nNa;C++)if($=b[C],E.d(Ma[$],oa[$],u),16<=$){C++;switch($){case 16:pa=2;break;case 17:pa=3;break;case 18:pa=7;break;default:q(\"invalid code: \"+$)}E.d(b[C],pa,u)}var Qa=[Ka,fa],Ra=[La,ga],N,Sa,ia,za,Ta,Ua,Va,Wa;Ta=Qa[0];Ua=Qa[1];Va=Ra[0];Wa=Ra[1];N=0;for(Sa=R.length;N<Sa;++N)if(ia=R[N],E.d(Ta[ia],Ua[ia],u),256<ia)E.d(R[++N],R[++N],u),za=R[++N],E.d(Va[za],Wa[za],u),E.d(R[++N],R[++N],u);else if(256===ia)break;this.a=E.finish();this.b=this.a.length;break;default:q(\"invalid compression type\")}return this.a};\nfunction xa(b,a){this.length=b;this.P=a}\nvar ya=function(){function b(a){switch(u){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,\na-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:q(\"invalid length: \"+a)}}var a=[],c,d;for(c=3;258>=c;c++)d=b(c),a[c]=d[2]<<24|d[1]<<\n16|d[0];return a}(),Aa=B?new Uint32Array(ya):ya;\nfunction ta(b,a){function c(a,c){var b=a.P,d=[],e=0,f;f=Aa[a.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(u){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===b:g=[3,b-4,0];break;case 6>=b:g=[4,b-5,1];break;case 8>=b:g=[5,b-7,1];break;case 12>=b:g=[6,b-9,2];break;case 16>=b:g=[7,b-13,2];break;case 24>=b:g=[8,b-17,3];break;case 32>=b:g=[9,b-25,3];break;case 48>=b:g=[10,b-33,4];break;case 64>=b:g=[11,b-49,4];break;case 96>=b:g=[12,b-\n65,5];break;case 128>=b:g=[13,b-97,5];break;case 192>=b:g=[14,b-129,6];break;case 256>=b:g=[15,b-193,6];break;case 384>=b:g=[16,b-257,7];break;case 512>=b:g=[17,b-385,7];break;case 768>=b:g=[18,b-513,8];break;case 1024>=b:g=[19,b-769,8];break;case 1536>=b:g=[20,b-1025,9];break;case 2048>=b:g=[21,b-1537,9];break;case 3072>=b:g=[22,b-2049,10];break;case 4096>=b:g=[23,b-3073,10];break;case 6144>=b:g=[24,b-4097,11];break;case 8192>=b:g=[25,b-6145,11];break;case 12288>=b:g=[26,b-8193,12];break;case 16384>=\nb:g=[27,b-12289,12];break;case 24576>=b:g=[28,b-16385,13];break;case 32768>=b:g=[29,b-24577,13];break;default:q(\"invalid distance\")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,k;h=0;for(k=d.length;h<k;++h)m[p++]=d[h];v[d[0]]++;x[d[3]]++;r=a.length+c-1;n=null}var d,f,e,g,k,h={},l,s,n,m=B?new Uint16Array(2*a.length):[],p=0,r=0,v=new (B?Uint32Array:Array)(286),x=new (B?Uint32Array:Array)(30),Q=b.I,y;if(!B){for(e=0;285>=e;)v[e++]=0;for(e=0;29>=e;)x[e++]=0}v[256]=1;d=0;for(f=a.length;d<f;++d){e=k=0;\nfor(g=3;e<g&&d+e!==f;++e)k=k<<8|a[d+e];h[k]===t&&(h[k]=[]);l=h[k];if(!(0<r--)){for(;0<l.length&&32768<d-l[0];)l.shift();if(d+3>=f){n&&c(n,-1);e=0;for(g=f-d;e<g;++e)y=a[d+e],m[p++]=y,++v[y];break}0<l.length?(s=Ba(a,d,l),n?n.length<s.length?(y=a[d-1],m[p++]=y,++v[y],c(s,0)):c(n,-1):s.length<Q?n=s:c(s,0)):n?c(n,-1):(y=a[d],m[p++]=y,++v[y])}l.push(d)}m[p++]=256;v[256]++;b.V=v;b.U=x;return B?m.subarray(0,p):m}\nfunction Ba(b,a,c){var d,f,e=0,g,k,h,l,s=b.length;k=0;l=c.length;a:for(;k<l;k++){d=c[l-k-1];g=3;if(3<e){for(h=e;3<h;h--)if(b[d+h-1]!==b[a+h-1])continue a;g=e}for(;258>g&&a+g<s&&b[d+g]===b[a+g];)++g;g>e&&(f=d,e=g);if(258===g)break}return new xa(e,a-f)}\nfunction ua(b,a){var c=b.length,d=new la(572),f=new (B?Uint8Array:Array)(c),e,g,k,h,l;if(!B)for(h=0;h<c;h++)f[h]=0;for(h=0;h<c;++h)0<b[h]&&d.push(h,b[h]);e=Array(d.length/2);g=new (B?Uint32Array:Array)(d.length/2);if(1===e.length)return f[d.pop().index]=1,f;h=0;for(l=d.length/2;h<l;++h)e[h]=d.pop(),g[h]=e[h].value;k=Ca(g,g.length,a);h=0;for(l=e.length;h<l;++h)f[e[h].index]=k[h];return f}\nfunction Ca(b,a,c){function d(b){var c=h[b][l[b]];c===a?(d(b+1),d(b+1)):--g[c];++l[b]}var f=new (B?Uint16Array:Array)(c),e=new (B?Uint8Array:Array)(c),g=new (B?Uint8Array:Array)(a),k=Array(c),h=Array(c),l=Array(c),s=(1<<c)-a,n=1<<c-1,m,p,r,v,x;f[c-1]=a;for(p=0;p<c;++p)s<n?e[p]=0:(e[p]=1,s-=n),s<<=1,f[c-2-p]=(f[c-1-p]/2|0)+a;f[0]=e[0];k[0]=Array(f[0]);h[0]=Array(f[0]);for(p=1;p<c;++p)f[p]>2*f[p-1]+e[p]&&(f[p]=2*f[p-1]+e[p]),k[p]=Array(f[p]),h[p]=Array(f[p]);for(m=0;m<a;++m)g[m]=c;for(r=0;r<f[c-1];++r)k[c-\n1][r]=b[r],h[c-1][r]=r;for(m=0;m<c;++m)l[m]=0;1===e[c-1]&&(--g[0],++l[c-1]);for(p=c-2;0<=p;--p){v=m=0;x=l[p+1];for(r=0;r<f[p];r++)v=k[p+1][x]+k[p+1][x+1],v>b[m]?(k[p][r]=v,h[p][r]=a,x+=2):(k[p][r]=b[m],h[p][r]=m,++m);l[p]=0;1===e[p]&&d(p)}return g}\nfunction va(b){var a=new (B?Uint16Array:Array)(b.length),c=[],d=[],f=0,e,g,k,h;e=0;for(g=b.length;e<g;e++)c[b[e]]=(c[b[e]]|0)+1;e=1;for(g=16;e<=g;e++)d[e]=f,f+=c[e]|0,f<<=1;e=0;for(g=b.length;e<g;e++){f=d[b[e]];d[b[e]]+=1;k=a[e]=0;for(h=b[e];k<h;k++)a[e]=a[e]<<1|f&1,f>>>=1}return a};function Da(b,a){this.input=b;this.b=this.c=0;this.i={};a&&(a.flags&&(this.i=a.flags),\"string\"===typeof a.filename&&(this.filename=a.filename),\"string\"===typeof a.comment&&(this.A=a.comment),a.deflateOptions&&(this.l=a.deflateOptions));this.l||(this.l={})}\nDa.prototype.g=function(){var b,a,c,d,f,e,g,k,h=new (B?Uint8Array:Array)(32768),l=0,s=this.input,n=this.c,m=this.filename,p=this.A;h[l++]=31;h[l++]=139;h[l++]=8;b=0;this.i.fname&&(b|=Ea);this.i.fcomment&&(b|=Fa);this.i.fhcrc&&(b|=Ga);h[l++]=b;a=(Date.now?Date.now():+new Date)/1E3|0;h[l++]=a&255;h[l++]=a>>>8&255;h[l++]=a>>>16&255;h[l++]=a>>>24&255;h[l++]=0;h[l++]=Ha;if(this.i.fname!==t){g=0;for(k=m.length;g<k;++g)e=m.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}if(this.i.comment){g=\n0;for(k=p.length;g<k;++g)e=p.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}this.i.fhcrc&&(c=ja(h,0,l)&65535,h[l++]=c&255,h[l++]=c>>>8&255);this.l.outputBuffer=h;this.l.outputIndex=l;f=new na(s,this.l);h=f.g();l=f.b;B&&(l+8>h.buffer.byteLength?(this.a=new Uint8Array(l+8),this.a.set(new Uint8Array(h.buffer)),h=this.a):h=new Uint8Array(h.buffer));d=ja(s,t,t);h[l++]=d&255;h[l++]=d>>>8&255;h[l++]=d>>>16&255;h[l++]=d>>>24&255;k=s.length;h[l++]=k&255;h[l++]=k>>>8&255;h[l++]=k>>>16&255;h[l++]=\nk>>>24&255;this.c=n;B&&l<h.length&&(this.a=h=h.subarray(0,l));return h};var Ha=255,Ga=2,Ea=8,Fa=16;A(\"Zlib.Gzip\",Da);A(\"Zlib.Gzip.prototype.compress\",Da.prototype.g);function T(b,a){this.p=[];this.q=32768;this.e=this.j=this.c=this.u=0;this.input=B?new Uint8Array(b):b;this.w=!1;this.r=Ia;this.L=!1;if(a||!(a={}))a.index&&(this.c=a.index),a.bufferSize&&(this.q=a.bufferSize),a.bufferType&&(this.r=a.bufferType),a.resize&&(this.L=a.resize);switch(this.r){case Xa:this.b=32768;this.a=new (B?Uint8Array:Array)(32768+this.q+258);break;case Ia:this.b=0;this.a=new (B?Uint8Array:Array)(this.q);this.f=this.T;this.B=this.Q;this.s=this.S;break;default:q(Error(\"invalid inflate mode\"))}}\nvar Xa=0,Ia=1,Ya={N:Xa,M:Ia};\nT.prototype.h=function(){for(;!this.w;){var b=U(this,3);b&1&&(this.w=u);b>>>=1;switch(b){case 0:var a=this.input,c=this.c,d=this.a,f=this.b,e=t,g=t,k=t,h=d.length,l=t;this.e=this.j=0;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (first byte)\"));g=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (second byte)\"));g|=e<<8;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (first byte)\"));k=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (second byte)\"));k|=\ne<<8;g===~k&&q(Error(\"invalid uncompressed block header: length verify\"));c+g>a.length&&q(Error(\"input buffer is broken\"));switch(this.r){case Xa:for(;f+g>d.length;){l=h-f;g-=l;if(B)d.set(a.subarray(c,c+l),f),f+=l,c+=l;else for(;l--;)d[f++]=a[c++];this.b=f;d=this.f();f=this.b}break;case Ia:for(;f+g>d.length;)d=this.f({F:2});break;default:q(Error(\"invalid inflate mode\"))}if(B)d.set(a.subarray(c,c+g),f),f+=g,c+=g;else for(;g--;)d[f++]=a[c++];this.c=c;this.b=f;this.a=d;break;case 1:this.s(Za,$a);break;\ncase 2:ab(this);break;default:q(Error(\"unknown BTYPE: \"+b))}}return this.B()};\nvar bb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],cb=B?new Uint16Array(bb):bb,db=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],eb=B?new Uint16Array(db):db,fb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],gb=B?new Uint8Array(fb):fb,hb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ib=B?new Uint16Array(hb):hb,jb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,\n10,11,11,12,12,13,13],kb=B?new Uint8Array(jb):jb,lb=new (B?Uint8Array:Array)(288),V,mb;V=0;for(mb=lb.length;V<mb;++V)lb[V]=143>=V?8:255>=V?9:279>=V?7:8;var Za=ma(lb),nb=new (B?Uint8Array:Array)(30),ob,qb;ob=0;for(qb=nb.length;ob<qb;++ob)nb[ob]=5;var $a=ma(nb);function U(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g;d<a;)g=f[e++],g===t&&q(Error(\"input buffer is broken\")),c|=g<<d,d+=8;g=c&(1<<a)-1;b.j=c>>>a;b.e=d-a;b.c=e;return g}\nfunction rb(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g=a[0],k=a[1],h,l,s;d<k;){h=f[e++];if(h===t)break;c|=h<<d;d+=8}l=g[c&(1<<k)-1];s=l>>>16;b.j=c>>s;b.e=d-s;b.c=e;return l&65535}\nfunction ab(b){function a(a,b,c){var d,e,f,g;for(g=0;g<a;)switch(d=rb(this,b),d){case 16:for(f=3+U(this,2);f--;)c[g++]=e;break;case 17:for(f=3+U(this,3);f--;)c[g++]=0;e=0;break;case 18:for(f=11+U(this,7);f--;)c[g++]=0;e=0;break;default:e=c[g++]=d}return c}var c=U(b,5)+257,d=U(b,5)+1,f=U(b,4)+4,e=new (B?Uint8Array:Array)(cb.length),g,k,h,l;for(l=0;l<f;++l)e[cb[l]]=U(b,3);g=ma(e);k=new (B?Uint8Array:Array)(c);h=new (B?Uint8Array:Array)(d);b.s(ma(a.call(b,c,g,k)),ma(a.call(b,d,g,h)))}\nT.prototype.s=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length-258,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(this.b=d,c=this.f(),d=this.b),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d>=f&&(this.b=d,c=this.f(),d=this.b);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.S=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(c=this.f(),f=c.length),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d+h>f&&(c=this.f(),f=c.length);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.f=function(){var b=new (B?Uint8Array:Array)(this.b-32768),a=this.b-32768,c,d,f=this.a;if(B)b.set(f.subarray(32768,b.length));else{c=0;for(d=b.length;c<d;++c)b[c]=f[c+32768]}this.p.push(b);this.u+=b.length;if(B)f.set(f.subarray(a,a+32768));else for(c=0;32768>c;++c)f[c]=f[a+c];this.b=32768;return f};\nT.prototype.T=function(b){var a,c=this.input.length/this.c+1|0,d,f,e,g=this.input,k=this.a;b&&(\"number\"===typeof b.F&&(c=b.F),\"number\"===typeof b.O&&(c+=b.O));2>c?(d=(g.length-this.c)/this.C[2],e=258*(d/2)|0,f=e<k.length?k.length+e:k.length<<1):f=k.length*c;B?(a=new Uint8Array(f),a.set(k)):a=k;return this.a=a};\nT.prototype.B=function(){var b=0,a=this.a,c=this.p,d,f=new (B?Uint8Array:Array)(this.u+(this.b-32768)),e,g,k,h;if(0===c.length)return B?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);e=0;for(g=c.length;e<g;++e){d=c[e];k=0;for(h=d.length;k<h;++k)f[b++]=d[k]}e=32768;for(g=this.b;e<g;++e)f[b++]=a[e];this.p=[];return this.buffer=f};\nT.prototype.Q=function(){var b,a=this.b;B?this.L?(b=new Uint8Array(a),b.set(this.a.subarray(0,a))):b=this.a.subarray(0,a):(this.a.length>a&&(this.a.length=a),b=this.a);return this.buffer=b};function sb(b){this.input=b;this.c=0;this.t=[];this.D=!1}sb.prototype.W=function(){this.D||this.h();return this.t.slice()};\nsb.prototype.h=function(){for(var b=this.input.length;this.c<b;){var a=new P,c=t,d=t,f=t,e=t,g=t,k=t,h=t,l=t,s=t,n=this.input,m=this.c;a.G=n[m++];a.H=n[m++];(31!==a.G||139!==a.H)&&q(Error(\"invalid file signature:\"+a.G+\",\"+a.H));a.z=n[m++];switch(a.z){case 8:break;default:q(Error(\"unknown compression method: \"+a.z))}a.n=n[m++];l=n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24;a.Y=new Date(1E3*l);a.ea=n[m++];a.da=n[m++];0<(a.n&4)&&(a.$=n[m++]|n[m++]<<8,m+=a.$);if(0<(a.n&Ea)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=\nString.fromCharCode(g);a.name=h.join(\"\")}if(0<(a.n&Fa)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=String.fromCharCode(g);a.A=h.join(\"\")}0<(a.n&Ga)&&(a.R=ja(n,0,m)&65535,a.R!==(n[m++]|n[m++]<<8)&&q(Error(\"invalid header crc16\")));c=n[n.length-4]|n[n.length-3]<<8|n[n.length-2]<<16|n[n.length-1]<<24;n.length-m-4-4<512*c&&(e=c);d=new T(n,{index:m,bufferSize:e});a.data=f=d.h();m=d.c;a.ba=s=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;ja(f,t,t)!==s&&q(Error(\"invalid CRC-32 checksum: 0x\"+ja(f,t,t).toString(16)+\n\" / 0x\"+s.toString(16)));a.ca=c=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;(f.length&4294967295)!==c&&q(Error(\"invalid input size: \"+(f.length&4294967295)+\" / \"+c));this.t.push(a);this.c=m}this.D=u;var p=this.t,r,v,x=0,Q=0,y;r=0;for(v=p.length;r<v;++r)Q+=p[r].data.length;if(B){y=new Uint8Array(Q);for(r=0;r<v;++r)y.set(p[r].data,x),x+=p[r].data.length}else{y=[];for(r=0;r<v;++r)y[r]=p[r].data;y=Array.prototype.concat.apply([],y)}return y};A(\"Zlib.Gunzip\",sb);A(\"Zlib.Gunzip.prototype.decompress\",sb.prototype.h);A(\"Zlib.Gunzip.prototype.getMembers\",sb.prototype.W);function tb(b){if(\"string\"===typeof b){var a=b.split(\"\"),c,d;c=0;for(d=a.length;c<d;c++)a[c]=(a[c].charCodeAt(0)&255)>>>0;b=a}for(var f=1,e=0,g=b.length,k,h=0;0<g;){k=1024<g?1024:g;g-=k;do f+=b[h++],e+=f;while(--k);f%=65521;e%=65521}return(e<<16|f)>>>0};function ub(b,a){var c,d;this.input=b;this.c=0;if(a||!(a={}))a.index&&(this.c=a.index),a.verify&&(this.Z=a.verify);c=b[this.c++];d=b[this.c++];switch(c&15){case vb:this.method=vb;break;default:q(Error(\"unsupported compression method\"))}0!==((c<<8)+d)%31&&q(Error(\"invalid fcheck flag:\"+((c<<8)+d)%31));d&32&&q(Error(\"fdict flag is not supported\"));this.K=new T(b,{index:this.c,bufferSize:a.bufferSize,bufferType:a.bufferType,resize:a.resize})}\nub.prototype.h=function(){var b=this.input,a,c;a=this.K.h();this.c=this.K.c;this.Z&&(c=(b[this.c++]<<24|b[this.c++]<<16|b[this.c++]<<8|b[this.c++])>>>0,c!==tb(a)&&q(Error(\"invalid adler-32 checksum\")));return a};var vb=8;function wb(b,a){this.input=b;this.a=new (B?Uint8Array:Array)(32768);this.k=W.o;var c={},d;if((a||!(a={}))&&\"number\"===typeof a.compressionType)this.k=a.compressionType;for(d in a)c[d]=a[d];c.outputBuffer=this.a;this.J=new na(this.input,c)}var W=ra;\nwb.prototype.g=function(){var b,a,c,d,f,e,g,k=0;g=this.a;b=vb;switch(b){case vb:a=Math.LOG2E*Math.log(32768)-8;break;default:q(Error(\"invalid compression method\"))}c=a<<4|b;g[k++]=c;switch(b){case vb:switch(this.k){case W.NONE:f=0;break;case W.v:f=1;break;case W.o:f=2;break;default:q(Error(\"unsupported compression type\"))}break;default:q(Error(\"invalid compression method\"))}d=f<<6|0;g[k++]=d|31-(256*c+d)%31;e=tb(this.input);this.J.b=k;g=this.J.g();k=g.length;B&&(g=new Uint8Array(g.buffer),g.length<=\nk+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,k+4));g[k++]=e>>24&255;g[k++]=e>>16&255;g[k++]=e>>8&255;g[k++]=e&255;return g};function xb(b,a){var c,d,f,e;if(Object.keys)c=Object.keys(a);else for(d in c=[],f=0,a)c[f++]=d;f=0;for(e=c.length;f<e;++f)d=c[f],A(b+\".\"+d,a[d])};A(\"Zlib.Inflate\",ub);A(\"Zlib.Inflate.prototype.decompress\",ub.prototype.h);xb(\"Zlib.Inflate.BufferType\",{ADAPTIVE:Ya.M,BLOCK:Ya.N});A(\"Zlib.Deflate\",wb);A(\"Zlib.Deflate.compress\",function(b,a){return(new wb(b,a)).g()});A(\"Zlib.Deflate.prototype.compress\",wb.prototype.g);xb(\"Zlib.Deflate.CompressionType\",{NONE:W.NONE,FIXED:W.v,DYNAMIC:W.o});}).call(this); //@ sourceMappingURL=zlib_and_gzip.min.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL3psaWJfYW5kX2d6aXAubWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3ZlbmRvci96bGliX2FuZF9nemlwLm1pbi5qcz81NmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSB6bGliLmpzIDIwMTIgLSBpbWF5YSBbIGh0dHBzOi8vZ2l0aHViLmNvbS9pbWF5YS96bGliLmpzIF0gVGhlIE1JVCBMaWNlbnNlICovKGZ1bmN0aW9uKCkgeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBxKGIpe3Rocm93IGI7fXZhciB0PXZvaWQgMCx1PSEwLGFhPXRoaXM7ZnVuY3Rpb24gQShiLGEpe3ZhciBjPWIuc3BsaXQoXCIuXCIpLGQ9YWE7IShjWzBdaW4gZCkmJmQuZXhlY1NjcmlwdCYmZC5leGVjU2NyaXB0KFwidmFyIFwiK2NbMF0pO2Zvcih2YXIgZjtjLmxlbmd0aCYmKGY9Yy5zaGlmdCgpKTspIWMubGVuZ3RoJiZhIT09dD9kW2ZdPWE6ZD1kW2ZdP2RbZl06ZFtmXT17fX07dmFyIEI9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBVaW50OEFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQxNkFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5O2Z1bmN0aW9uIEYoYixhKXt0aGlzLmluZGV4PVwibnVtYmVyXCI9PT10eXBlb2YgYT9hOjA7dGhpcy5tPTA7dGhpcy5idWZmZXI9YiBpbnN0YW5jZW9mKEI/VWludDhBcnJheTpBcnJheSk/YjpuZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpOzIqdGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZxKEVycm9yKFwiaW52YWxpZCBpbmRleFwiKSk7dGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZ0aGlzLmYoKX1GLnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYSxjPWIubGVuZ3RoLGQ9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGM8PDEpO2lmKEIpZC5zZXQoYik7ZWxzZSBmb3IoYT0wO2E8YzsrK2EpZFthXT1iW2FdO3JldHVybiB0aGlzLmJ1ZmZlcj1kfTtcbkYucHJvdG90eXBlLmQ9ZnVuY3Rpb24oYixhLGMpe3ZhciBkPXRoaXMuYnVmZmVyLGY9dGhpcy5pbmRleCxlPXRoaXMubSxnPWRbZl0saztjJiYxPGEmJihiPTg8YT8oSFtiJjI1NV08PDI0fEhbYj4+PjgmMjU1XTw8MTZ8SFtiPj4+MTYmMjU1XTw8OHxIW2I+Pj4yNCYyNTVdKT4+MzItYTpIW2JdPj44LWEpO2lmKDg+YStlKWc9Zzw8YXxiLGUrPWE7ZWxzZSBmb3Ioaz0wO2s8YTsrK2spZz1nPDwxfGI+PmEtay0xJjEsOD09PSsrZSYmKGU9MCxkW2YrK109SFtnXSxnPTAsZj09PWQubGVuZ3RoJiYoZD10aGlzLmYoKSkpO2RbZl09Zzt0aGlzLmJ1ZmZlcj1kO3RoaXMubT1lO3RoaXMuaW5kZXg9Zn07Ri5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYT10aGlzLmluZGV4LGM7MDx0aGlzLm0mJihiW2FdPDw9OC10aGlzLm0sYlthXT1IW2JbYV1dLGErKyk7Qj9jPWIuc3ViYXJyYXkoMCxhKTooYi5sZW5ndGg9YSxjPWIpO3JldHVybiBjfTtcbnZhciBiYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjU2KSxjYTtmb3IoY2E9MDsyNTY+Y2E7KytjYSl7Zm9yKHZhciBLPWNhLGRhPUssZWE9NyxLPUs+Pj4xO0s7Sz4+Pj0xKWRhPDw9MSxkYXw9SyYxLC0tZWE7YmFbY2FdPShkYTw8ZWEmMjU1KT4+PjB9dmFyIEg9YmE7ZnVuY3Rpb24gamEoYixhLGMpe3ZhciBkLGY9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E6YT0wLGU9XCJudW1iZXJcIj09PXR5cGVvZiBjP2M6Yi5sZW5ndGg7ZD0tMTtmb3IoZj1lJjc7Zi0tOysrYSlkPWQ+Pj44Xk9bKGReYlthXSkmMjU1XTtmb3IoZj1lPj4zO2YtLTthKz04KWQ9ZD4+PjheT1soZF5iW2FdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErMV0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSsyXSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzNdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErNF0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSs1XSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzZdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErN10pJjI1NV07cmV0dXJuKGReNDI5NDk2NzI5NSk+Pj4wfVxudmFyIGthPVswLDE5OTY5NTk4OTQsMzk5MzkxOTc4OCwyNTY3NTI0Nzk0LDEyNDYzNDEzNywxODg2MDU3NjE1LDM5MTU2MjE2ODUsMjY1NzM5MjAzNSwyNDkyNjgyNzQsMjA0NDUwODMyNCwzNzcyMTE1MjMwLDI1NDcxNzc4NjQsMTYyOTQxOTk1LDIxMjU1NjEwMjEsMzg4NzYwNzA0NywyNDI4NDQ0MDQ5LDQ5ODUzNjU0OCwxNzg5OTI3NjY2LDQwODkwMTY2NDgsMjIyNzA2MTIxNCw0NTA1NDg4NjEsMTg0MzI1ODYwMyw0MTA3NTgwNzUzLDIyMTE2Nzc2MzksMzI1ODgzOTkwLDE2ODQ3NzcxNTIsNDI1MTEyMjA0MiwyMzIxOTI2NjM2LDMzNTYzMzQ4NywxNjYxMzY1NDY1LDQxOTUzMDI3NTUsMjM2NjExNTMxNyw5OTcwNzMwOTYsMTI4MTk1Mzg4NiwzNTc5ODU1MzMyLDI3MjQ2ODgyNDIsMTAwNjg4ODE0NSwxMjU4NjA3Njg3LDM1MjQxMDE2MjksMjc2ODk0MjQ0Myw5MDEwOTc3MjIsMTExOTAwMDY4NCwzNjg2NTE3MjA2LDI4OTgwNjU3MjgsODUzMDQ0NDUxLDExNzIyNjYxMDEsMzcwNTAxNTc1OSxcbjI4ODI2MTY2NjUsNjUxNzY3OTgwLDEzNzM1MDM1NDYsMzM2OTU1NDMwNCwzMjE4MTA0NTk4LDU2NTUwNzI1MywxNDU0NjIxNzMxLDM0ODUxMTE3MDUsMzA5OTQzNjMwMyw2NzEyNjY5NzQsMTU5NDE5ODAyNCwzMzIyNzMwOTMwLDI5NzAzNDc4MTIsNzk1ODM1NTI3LDE0ODMyMzAyMjUsMzI0NDM2NzI3NSwzMDYwMTQ5NTY1LDE5OTQxNDYxOTIsMzExNTg1MzQsMjU2MzkwNzc3Miw0MDIzNzE3OTMwLDE5MDc0NTk0NjUsMTEyNjM3MjE1LDI2ODAxNTMyNTMsMzkwNDQyNzA1OSwyMDEzNzc2MjkwLDI1MTcyMjAzNiwyNTE3MjE1Mzc0LDM3NzU4MzAwNDAsMjEzNzY1Njc2MywxNDEzNzY4MTMsMjQzOTI3NzcxOSwzODY1MjcxMjk3LDE4MDIxOTU0NDQsNDc2ODY0ODY2LDIyMzgwMDEzNjgsNDA2NjUwODg3OCwxODEyMzcwOTI1LDQ1MzA5MjczMSwyMTgxNjI1MDI1LDQxMTE0NTEyMjMsMTcwNjA4ODkwMiwzMTQwNDI3MDQsMjM0NDUzMjIwMiw0MjQwMDE3NTMyLDE2NTg2NTgyNzEsMzY2NjE5OTc3LFxuMjM2MjY3MDMyMyw0MjI0OTk0NDA1LDEzMDM1MzU5NjAsOTg0OTYxNDg2LDI3NDcwMDcwOTIsMzU2OTAzNzUzOCwxMjU2MTcwODE3LDEwMzc2MDQzMTEsMjc2NTIxMDczMywzNTU0MDc5OTk1LDExMzEwMTQ1MDYsODc5Njc5OTk2LDI5MDkyNDM0NjIsMzY2Mzc3MTg1NiwxMTQxMTI0NDY3LDg1NTg0MjI3NywyODUyODAxNjMxLDM3MDg2NDg2NDksMTM0MjUzMzk0OCw2NTQ0NTkzMDYsMzE4ODM5NjA0OCwzMzczMDE1MTc0LDE0NjY0Nzk5MDksNTQ0MTc5NjM1LDMxMTA1MjM5MTMsMzQ2MjUyMjAxNSwxNTkxNjcxMDU0LDcwMjEzODc3NiwyOTY2NDYwNDUwLDMzNTI3OTk0MTIsMTUwNDkxODgwNyw3ODM1NTE4NzMsMzA4MjY0MDQ0MywzMjMzNDQyOTg5LDM5ODgyOTIzODQsMjU5NjI1NDY0Niw2MjMxNzA2OCwxOTU3ODEwODQyLDM5Mzk4NDU5NDUsMjY0NzgxNjExMSw4MTQ3MDk5NywxOTQzODAzNTIzLDM4MTQ5MTg5MzAsMjQ4OTU5NjgwNCwyMjUyNzQ0MzAsMjA1Mzc5MDM3NiwzODI2MTc1NzU1LFxuMjQ2NjkwNjAxMywxNjc4MTY3NDMsMjA5NzY1MTM3Nyw0MDI3NTUyNTgwLDIyNjU0OTAzODYsNTAzNDQ0MDcyLDE3NjIwNTA4MTQsNDE1MDQxNzI0NSwyMTU0MTI5MzU1LDQyNjUyMjIyNSwxODUyNTA3ODc5LDQyNzUzMTM1MjYsMjMxMjMxNzkyMCwyODI3NTM2MjYsMTc0MjU1NTg1Miw0MTg5NzA4MTQzLDIzOTQ4Nzc5NDUsMzk3OTE3NzYzLDE2MjIxODM2MzcsMzYwNDM5MDg4OCwyNzE0ODY2NTU4LDk1MzcyOTczMiwxMzQwMDc2NjI2LDM1MTg3MTk5ODUsMjc5NzM2MDk5OSwxMDY4ODI4MzgxLDEyMTk2Mzg4NTksMzYyNDc0MTg1MCwyOTM2Njc1MTQ4LDkwNjE4NTQ2MiwxMDkwODEyNTEyLDM3NDc2NzIwMDMsMjgyNTM3OTY2OSw4MjkzMjkxMzUsMTE4MTMzNTE2MSwzNDEyMTc3ODA0LDMxNjA4MzQ4NDIsNjI4MDg1NDA4LDEzODI2MDUzNjYsMzQyMzM2OTEwOSwzMTM4MDc4NDY3LDU3MDU2MjIzMywxNDI2NDAwODE1LDMzMTczMTY1NDIsMjk5ODczMzYwOCw3MzMyMzk5NTQsMTU1NTI2MTk1NixcbjMyNjg5MzU1OTEsMzA1MDM2MDYyNSw3NTI0NTk0MDMsMTU0MTMyMDIyMSwyNjA3MDcxOTIwLDM5NjU5NzMwMzAsMTk2OTkyMjk3Miw0MDczNTQ5OCwyNjE3ODM3MjI1LDM5NDM1NzcxNTEsMTkxMzA4Nzg3Nyw4MzkwODM3MSwyNTEyMzQxNjM0LDM4MDM3NDA2OTIsMjA3NTIwODYyMiwyMTMyNjExMTIsMjQ2MzI3MjYwMywzODU1OTkwMjg1LDIwOTQ4NTQwNzEsMTk4OTU4ODgxLDIyNjIwMjkwMTIsNDA1NzI2MDYxMCwxNzU5MzU5OTkyLDUzNDQxNDE5MCwyMTc2NzE4NTQxLDQxMzkzMjkxMTUsMTg3MzgzNjAwMSw0MTQ2NjQ1NjcsMjI4MjI0ODkzNCw0Mjc5MjAwMzY4LDE3MTE2ODQ1NTQsMjg1MjgxMTE2LDI0MDU4MDE3MjcsNDE2NzIxNjc0NSwxNjM0NDY3Nzk1LDM3NjIyOTcwMSwyNjg1MDY3ODk2LDM2MDgwMDc0MDYsMTMwODkxODYxMiw5NTY1NDM5MzgsMjgwODU1NTEwNSwzNDk1OTU4MjYzLDEyMzE2MzYzMDEsMTA0NzQyNzAzNSwyOTMyOTU5ODE4LDM2NTQ3MDM4MzYsMTA4ODM1OTI3MCxcbjkzNjkxOEUzLDI4NDc3MTQ4OTksMzczNjgzNzgyOSwxMjAyOTAwODYzLDgxNzIzMzg5NywzMTgzMzQyMTA4LDM0MDEyMzcxMzAsMTQwNDI3NzU1Miw2MTU4MTgxNTAsMzEzNDIwNzQ5MywzNDUzNDIxMjAzLDE0MjM4NTc0NDksNjAxNDUwNDMxLDMwMDk4Mzc2MTQsMzI5NDcxMDQ1NiwxNTY3MTAzNzQ2LDcxMTkyODcyNCwzMDIwNjY4NDcxLDMyNzIzODAwNjUsMTUxMDMzNDIzNSw3NTUxNjcxMTddLE89Qj9uZXcgVWludDMyQXJyYXkoa2EpOmthO2Z1bmN0aW9uIFAoKXt9UC5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O1AucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfTtQLnByb3RvdHlwZS5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWX07QShcIlpsaWIuR3VuemlwTWVtYmVyXCIsUCk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXROYW1lXCIsUC5wcm90b3R5cGUuZ2V0TmFtZSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXREYXRhXCIsUC5wcm90b3R5cGUuZ2V0RGF0YSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXRNdGltZVwiLFAucHJvdG90eXBlLlgpO2Z1bmN0aW9uIGxhKGIpe3RoaXMuYnVmZmVyPW5ldyAoQj9VaW50MTZBcnJheTpBcnJheSkoMipiKTt0aGlzLmxlbmd0aD0wfWxhLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oYil7cmV0dXJuIDIqKChiLTIpLzR8MCl9O2xhLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGIsYSl7dmFyIGMsZCxmPXRoaXMuYnVmZmVyLGU7Yz10aGlzLmxlbmd0aDtmW3RoaXMubGVuZ3RoKytdPWE7Zm9yKGZbdGhpcy5sZW5ndGgrK109YjswPGM7KWlmKGQ9dGhpcy5nZXRQYXJlbnQoYyksZltjXT5mW2RdKWU9ZltjXSxmW2NdPWZbZF0sZltkXT1lLGU9ZltjKzFdLGZbYysxXT1mW2QrMV0sZltkKzFdPWUsYz1kO2Vsc2UgYnJlYWs7cmV0dXJuIHRoaXMubGVuZ3RofTtcbmxhLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgYixhLGM9dGhpcy5idWZmZXIsZCxmLGU7YT1jWzBdO2I9Y1sxXTt0aGlzLmxlbmd0aC09MjtjWzBdPWNbdGhpcy5sZW5ndGhdO2NbMV09Y1t0aGlzLmxlbmd0aCsxXTtmb3IoZT0wOzspe2Y9MiplKzI7aWYoZj49dGhpcy5sZW5ndGgpYnJlYWs7ZisyPHRoaXMubGVuZ3RoJiZjW2YrMl0+Y1tmXSYmKGYrPTIpO2lmKGNbZl0+Y1tlXSlkPWNbZV0sY1tlXT1jW2ZdLGNbZl09ZCxkPWNbZSsxXSxjW2UrMV09Y1tmKzFdLGNbZisxXT1kO2Vsc2UgYnJlYWs7ZT1mfXJldHVybntpbmRleDpiLHZhbHVlOmEsbGVuZ3RoOnRoaXMubGVuZ3RofX07ZnVuY3Rpb24gbWEoYil7dmFyIGE9Yi5sZW5ndGgsYz0wLGQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGYsZSxnLGssaCxsLHMsbixtO2ZvcihuPTA7bjxhOysrbiliW25dPmMmJihjPWJbbl0pLGJbbl08ZCYmKGQ9YltuXSk7Zj0xPDxjO2U9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShmKTtnPTE7az0wO2ZvcihoPTI7Zzw9Yzspe2ZvcihuPTA7bjxhOysrbilpZihiW25dPT09Zyl7bD0wO3M9aztmb3IobT0wO208ZzsrK20pbD1sPDwxfHMmMSxzPj49MTtmb3IobT1sO208ZjttKz1oKWVbbV09Zzw8MTZ8bjsrK2t9KytnO2s8PD0xO2g8PD0xfXJldHVybltlLGMsZF19O2Z1bmN0aW9uIG5hKGIsYSl7dGhpcy5rPXFhO3RoaXMuST0wO3RoaXMuaW5wdXQ9QiYmYiBpbnN0YW5jZW9mIEFycmF5P25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy5iPTA7YSYmKGEubGF6eSYmKHRoaXMuST1hLmxhenkpLFwibnVtYmVyXCI9PT10eXBlb2YgYS5jb21wcmVzc2lvblR5cGUmJih0aGlzLms9YS5jb21wcmVzc2lvblR5cGUpLGEub3V0cHV0QnVmZmVyJiYodGhpcy5hPUImJmEub3V0cHV0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXk/bmV3IFVpbnQ4QXJyYXkoYS5vdXRwdXRCdWZmZXIpOmEub3V0cHV0QnVmZmVyKSxcIm51bWJlclwiPT09dHlwZW9mIGEub3V0cHV0SW5kZXgmJih0aGlzLmI9YS5vdXRwdXRJbmRleCkpO3RoaXMuYXx8KHRoaXMuYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpKX12YXIgcWE9MixyYT17Tk9ORTowLHY6MSxvOnFhLGFhOjN9LHNhPVtdLFM7XG5mb3IoUz0wOzI4OD5TO1MrKylzd2l0Y2godSl7Y2FzZSAxNDM+PVM6c2EucHVzaChbUys0OCw4XSk7YnJlYWs7Y2FzZSAyNTU+PVM6c2EucHVzaChbUy0xNDQrNDAwLDldKTticmVhaztjYXNlIDI3OT49UzpzYS5wdXNoKFtTLTI1NiswLDddKTticmVhaztjYXNlIDI4Nz49UzpzYS5wdXNoKFtTLTI4MCsxOTIsOF0pO2JyZWFrO2RlZmF1bHQ6cShcImludmFsaWQgbGl0ZXJhbDogXCIrUyl9XG5uYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGY9dGhpcy5pbnB1dDtzd2l0Y2godGhpcy5rKXtjYXNlIDA6Yz0wO2ZvcihkPWYubGVuZ3RoO2M8ZDspe2E9Qj9mLnN1YmFycmF5KGMsYys2NTUzNSk6Zi5zbGljZShjLGMrNjU1MzUpO2MrPWEubGVuZ3RoO3ZhciBlPWEsZz1jPT09ZCxrPXQsaD10LGw9dCxzPXQsbj10LG09dGhpcy5hLHA9dGhpcy5iO2lmKEIpe2ZvcihtPW5ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpO20ubGVuZ3RoPD1wK2UubGVuZ3RoKzU7KW09bmV3IFVpbnQ4QXJyYXkobS5sZW5ndGg8PDEpO20uc2V0KHRoaXMuYSl9az1nPzE6MDttW3ArK109a3wwO2g9ZS5sZW5ndGg7bD1+aCs2NTUzNiY2NTUzNTttW3ArK109aCYyNTU7bVtwKytdPWg+Pj44JjI1NTttW3ArK109bCYyNTU7bVtwKytdPWw+Pj44JjI1NTtpZihCKW0uc2V0KGUscCkscCs9ZS5sZW5ndGgsbT1tLnN1YmFycmF5KDAscCk7ZWxzZXtzPTA7Zm9yKG49ZS5sZW5ndGg7czxuOysrcyltW3ArK109XG5lW3NdO20ubGVuZ3RoPXB9dGhpcy5iPXA7dGhpcy5hPW19YnJlYWs7Y2FzZSAxOnZhciByPW5ldyBGKEI/bmV3IFVpbnQ4QXJyYXkodGhpcy5hLmJ1ZmZlcik6dGhpcy5hLHRoaXMuYik7ci5kKDEsMSx1KTtyLmQoMSwyLHUpO3ZhciB2PXRhKHRoaXMsZikseCxRLHk7eD0wO2ZvcihRPXYubGVuZ3RoO3g8UTt4KyspaWYoeT12W3hdLEYucHJvdG90eXBlLmQuYXBwbHkocixzYVt5XSksMjU2PHkpci5kKHZbKyt4XSx2WysreF0sdSksci5kKHZbKyt4XSw1KSxyLmQodlsrK3hdLHZbKyt4XSx1KTtlbHNlIGlmKDI1Nj09PXkpYnJlYWs7dGhpcy5hPXIuZmluaXNoKCk7dGhpcy5iPXRoaXMuYS5sZW5ndGg7YnJlYWs7Y2FzZSBxYTp2YXIgRT1uZXcgRihCP25ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpOnRoaXMuYSx0aGlzLmIpLEphLFIsWCxZLFoscGI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGZhLEthLGdhLExhLG9hLHdhPUFycmF5KDE5KSxcbk1hLCQscGEsQyxOYTtKYT1xYTtFLmQoMSwxLHUpO0UuZChKYSwyLHUpO1I9dGEodGhpcyxmKTtmYT11YSh0aGlzLlYsMTUpO0thPXZhKGZhKTtnYT11YSh0aGlzLlUsNyk7TGE9dmEoZ2EpO2ZvcihYPTI4NjsyNTc8WCYmMD09PWZhW1gtMV07WC0tKTtmb3IoWT0zMDsxPFkmJjA9PT1nYVtZLTFdO1ktLSk7dmFyIE9hPVgsUGE9WSxKPW5ldyAoQj9VaW50MzJBcnJheTpBcnJheSkoT2ErUGEpLHcsTCx6LGhhLEk9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMTYpLEcsRCxNPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgxOSk7Zm9yKHc9TD0wO3c8T2E7dysrKUpbTCsrXT1mYVt3XTtmb3Iodz0wO3c8UGE7dysrKUpbTCsrXT1nYVt3XTtpZighQil7dz0wO2ZvcihoYT1NLmxlbmd0aDt3PGhhOysrdylNW3ddPTB9dz1HPTA7Zm9yKGhhPUoubGVuZ3RoO3c8aGE7dys9TCl7Zm9yKEw9MTt3K0w8aGEmJkpbdytMXT09PUpbd107KytMKTt6PUw7aWYoMD09PUpbd10paWYoMz56KWZvcig7MDxcbnotLTspSVtHKytdPTAsTVswXSsrO2Vsc2UgZm9yKDswPHo7KUQ9MTM4Pno/ejoxMzgsRD56LTMmJkQ8eiYmKEQ9ei0zKSwxMD49RD8oSVtHKytdPTE3LElbRysrXT1ELTMsTVsxN10rKyk6KElbRysrXT0xOCxJW0crK109RC0xMSxNWzE4XSsrKSx6LT1EO2Vsc2UgaWYoSVtHKytdPUpbd10sTVtKW3ddXSsrLHotLSwzPnopZm9yKDswPHotLTspSVtHKytdPUpbd10sTVtKW3ddXSsrO2Vsc2UgZm9yKDswPHo7KUQ9Nj56P3o6NixEPnotMyYmRDx6JiYoRD16LTMpLElbRysrXT0xNixJW0crK109RC0zLE1bMTZdKyssei09RH1iPUI/SS5zdWJhcnJheSgwLEcpOkkuc2xpY2UoMCxHKTtvYT11YShNLDcpO2ZvcihDPTA7MTk+QztDKyspd2FbQ109b2FbcGJbQ11dO2ZvcihaPTE5OzQ8WiYmMD09PXdhW1otMV07Wi0tKTtNYT12YShvYSk7RS5kKFgtMjU3LDUsdSk7RS5kKFktMSw1LHUpO0UuZChaLTQsNCx1KTtmb3IoQz0wO0M8WjtDKyspRS5kKHdhW0NdLDMsdSk7Qz0wO2ZvcihOYT1iLmxlbmd0aDtDPFxuTmE7QysrKWlmKCQ9YltDXSxFLmQoTWFbJF0sb2FbJF0sdSksMTY8PSQpe0MrKztzd2l0Y2goJCl7Y2FzZSAxNjpwYT0yO2JyZWFrO2Nhc2UgMTc6cGE9MzticmVhaztjYXNlIDE4OnBhPTc7YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBjb2RlOiBcIiskKX1FLmQoYltDXSxwYSx1KX12YXIgUWE9W0thLGZhXSxSYT1bTGEsZ2FdLE4sU2EsaWEsemEsVGEsVWEsVmEsV2E7VGE9UWFbMF07VWE9UWFbMV07VmE9UmFbMF07V2E9UmFbMV07Tj0wO2ZvcihTYT1SLmxlbmd0aDtOPFNhOysrTilpZihpYT1SW05dLEUuZChUYVtpYV0sVWFbaWFdLHUpLDI1NjxpYSlFLmQoUlsrK05dLFJbKytOXSx1KSx6YT1SWysrTl0sRS5kKFZhW3phXSxXYVt6YV0sdSksRS5kKFJbKytOXSxSWysrTl0sdSk7ZWxzZSBpZigyNTY9PT1pYSlicmVhazt0aGlzLmE9RS5maW5pc2goKTt0aGlzLmI9dGhpcy5hLmxlbmd0aDticmVhaztkZWZhdWx0OnEoXCJpbnZhbGlkIGNvbXByZXNzaW9uIHR5cGVcIil9cmV0dXJuIHRoaXMuYX07XG5mdW5jdGlvbiB4YShiLGEpe3RoaXMubGVuZ3RoPWI7dGhpcy5QPWF9XG52YXIgeWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3N3aXRjaCh1KXtjYXNlIDM9PT1hOnJldHVyblsyNTcsYS0zLDBdO2Nhc2UgND09PWE6cmV0dXJuWzI1OCxhLTQsMF07Y2FzZSA1PT09YTpyZXR1cm5bMjU5LGEtNSwwXTtjYXNlIDY9PT1hOnJldHVyblsyNjAsYS02LDBdO2Nhc2UgNz09PWE6cmV0dXJuWzI2MSxhLTcsMF07Y2FzZSA4PT09YTpyZXR1cm5bMjYyLGEtOCwwXTtjYXNlIDk9PT1hOnJldHVyblsyNjMsYS05LDBdO2Nhc2UgMTA9PT1hOnJldHVyblsyNjQsYS0xMCwwXTtjYXNlIDEyPj1hOnJldHVyblsyNjUsYS0xMSwxXTtjYXNlIDE0Pj1hOnJldHVyblsyNjYsYS0xMywxXTtjYXNlIDE2Pj1hOnJldHVyblsyNjcsYS0xNSwxXTtjYXNlIDE4Pj1hOnJldHVyblsyNjgsYS0xNywxXTtjYXNlIDIyPj1hOnJldHVyblsyNjksYS0xOSwyXTtjYXNlIDI2Pj1hOnJldHVyblsyNzAsYS0yMywyXTtjYXNlIDMwPj1hOnJldHVyblsyNzEsYS0yNywyXTtjYXNlIDM0Pj1hOnJldHVyblsyNzIsXG5hLTMxLDJdO2Nhc2UgNDI+PWE6cmV0dXJuWzI3MyxhLTM1LDNdO2Nhc2UgNTA+PWE6cmV0dXJuWzI3NCxhLTQzLDNdO2Nhc2UgNTg+PWE6cmV0dXJuWzI3NSxhLTUxLDNdO2Nhc2UgNjY+PWE6cmV0dXJuWzI3NixhLTU5LDNdO2Nhc2UgODI+PWE6cmV0dXJuWzI3NyxhLTY3LDRdO2Nhc2UgOTg+PWE6cmV0dXJuWzI3OCxhLTgzLDRdO2Nhc2UgMTE0Pj1hOnJldHVyblsyNzksYS05OSw0XTtjYXNlIDEzMD49YTpyZXR1cm5bMjgwLGEtMTE1LDRdO2Nhc2UgMTYyPj1hOnJldHVyblsyODEsYS0xMzEsNV07Y2FzZSAxOTQ+PWE6cmV0dXJuWzI4MixhLTE2Myw1XTtjYXNlIDIyNj49YTpyZXR1cm5bMjgzLGEtMTk1LDVdO2Nhc2UgMjU3Pj1hOnJldHVyblsyODQsYS0yMjcsNV07Y2FzZSAyNTg9PT1hOnJldHVyblsyODUsYS0yNTgsMF07ZGVmYXVsdDpxKFwiaW52YWxpZCBsZW5ndGg6IFwiK2EpfX12YXIgYT1bXSxjLGQ7Zm9yKGM9MzsyNTg+PWM7YysrKWQ9YihjKSxhW2NdPWRbMl08PDI0fGRbMV08PFxuMTZ8ZFswXTtyZXR1cm4gYX0oKSxBYT1CP25ldyBVaW50MzJBcnJheSh5YSk6eWE7XG5mdW5jdGlvbiB0YShiLGEpe2Z1bmN0aW9uIGMoYSxjKXt2YXIgYj1hLlAsZD1bXSxlPTAsZjtmPUFhW2EubGVuZ3RoXTtkW2UrK109ZiY2NTUzNTtkW2UrK109Zj4+MTYmMjU1O2RbZSsrXT1mPj4yNDt2YXIgZztzd2l0Y2godSl7Y2FzZSAxPT09YjpnPVswLGItMSwwXTticmVhaztjYXNlIDI9PT1iOmc9WzEsYi0yLDBdO2JyZWFrO2Nhc2UgMz09PWI6Zz1bMixiLTMsMF07YnJlYWs7Y2FzZSA0PT09YjpnPVszLGItNCwwXTticmVhaztjYXNlIDY+PWI6Zz1bNCxiLTUsMV07YnJlYWs7Y2FzZSA4Pj1iOmc9WzUsYi03LDFdO2JyZWFrO2Nhc2UgMTI+PWI6Zz1bNixiLTksMl07YnJlYWs7Y2FzZSAxNj49YjpnPVs3LGItMTMsMl07YnJlYWs7Y2FzZSAyND49YjpnPVs4LGItMTcsM107YnJlYWs7Y2FzZSAzMj49YjpnPVs5LGItMjUsM107YnJlYWs7Y2FzZSA0OD49YjpnPVsxMCxiLTMzLDRdO2JyZWFrO2Nhc2UgNjQ+PWI6Zz1bMTEsYi00OSw0XTticmVhaztjYXNlIDk2Pj1iOmc9WzEyLGItXG42NSw1XTticmVhaztjYXNlIDEyOD49YjpnPVsxMyxiLTk3LDVdO2JyZWFrO2Nhc2UgMTkyPj1iOmc9WzE0LGItMTI5LDZdO2JyZWFrO2Nhc2UgMjU2Pj1iOmc9WzE1LGItMTkzLDZdO2JyZWFrO2Nhc2UgMzg0Pj1iOmc9WzE2LGItMjU3LDddO2JyZWFrO2Nhc2UgNTEyPj1iOmc9WzE3LGItMzg1LDddO2JyZWFrO2Nhc2UgNzY4Pj1iOmc9WzE4LGItNTEzLDhdO2JyZWFrO2Nhc2UgMTAyND49YjpnPVsxOSxiLTc2OSw4XTticmVhaztjYXNlIDE1MzY+PWI6Zz1bMjAsYi0xMDI1LDldO2JyZWFrO2Nhc2UgMjA0OD49YjpnPVsyMSxiLTE1MzcsOV07YnJlYWs7Y2FzZSAzMDcyPj1iOmc9WzIyLGItMjA0OSwxMF07YnJlYWs7Y2FzZSA0MDk2Pj1iOmc9WzIzLGItMzA3MywxMF07YnJlYWs7Y2FzZSA2MTQ0Pj1iOmc9WzI0LGItNDA5NywxMV07YnJlYWs7Y2FzZSA4MTkyPj1iOmc9WzI1LGItNjE0NSwxMV07YnJlYWs7Y2FzZSAxMjI4OD49YjpnPVsyNixiLTgxOTMsMTJdO2JyZWFrO2Nhc2UgMTYzODQ+PVxuYjpnPVsyNyxiLTEyMjg5LDEyXTticmVhaztjYXNlIDI0NTc2Pj1iOmc9WzI4LGItMTYzODUsMTNdO2JyZWFrO2Nhc2UgMzI3Njg+PWI6Zz1bMjksYi0yNDU3NywxM107YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBkaXN0YW5jZVwiKX1mPWc7ZFtlKytdPWZbMF07ZFtlKytdPWZbMV07ZFtlKytdPWZbMl07dmFyIGgsaztoPTA7Zm9yKGs9ZC5sZW5ndGg7aDxrOysraCltW3ArK109ZFtoXTt2W2RbMF1dKys7eFtkWzNdXSsrO3I9YS5sZW5ndGgrYy0xO249bnVsbH12YXIgZCxmLGUsZyxrLGg9e30sbCxzLG4sbT1CP25ldyBVaW50MTZBcnJheSgyKmEubGVuZ3RoKTpbXSxwPTAscj0wLHY9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgyODYpLHg9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMCksUT1iLkkseTtpZighQil7Zm9yKGU9MDsyODU+PWU7KXZbZSsrXT0wO2ZvcihlPTA7Mjk+PWU7KXhbZSsrXT0wfXZbMjU2XT0xO2Q9MDtmb3IoZj1hLmxlbmd0aDtkPGY7KytkKXtlPWs9MDtcbmZvcihnPTM7ZTxnJiZkK2UhPT1mOysrZSlrPWs8PDh8YVtkK2VdO2hba109PT10JiYoaFtrXT1bXSk7bD1oW2tdO2lmKCEoMDxyLS0pKXtmb3IoOzA8bC5sZW5ndGgmJjMyNzY4PGQtbFswXTspbC5zaGlmdCgpO2lmKGQrMz49Zil7biYmYyhuLC0xKTtlPTA7Zm9yKGc9Zi1kO2U8ZzsrK2UpeT1hW2QrZV0sbVtwKytdPXksKyt2W3ldO2JyZWFrfTA8bC5sZW5ndGg/KHM9QmEoYSxkLGwpLG4/bi5sZW5ndGg8cy5sZW5ndGg/KHk9YVtkLTFdLG1bcCsrXT15LCsrdlt5XSxjKHMsMCkpOmMobiwtMSk6cy5sZW5ndGg8UT9uPXM6YyhzLDApKTpuP2MobiwtMSk6KHk9YVtkXSxtW3ArK109eSwrK3ZbeV0pfWwucHVzaChkKX1tW3ArK109MjU2O3ZbMjU2XSsrO2IuVj12O2IuVT14O3JldHVybiBCP20uc3ViYXJyYXkoMCxwKTptfVxuZnVuY3Rpb24gQmEoYixhLGMpe3ZhciBkLGYsZT0wLGcsayxoLGwscz1iLmxlbmd0aDtrPTA7bD1jLmxlbmd0aDthOmZvcig7azxsO2srKyl7ZD1jW2wtay0xXTtnPTM7aWYoMzxlKXtmb3IoaD1lOzM8aDtoLS0paWYoYltkK2gtMV0hPT1iW2EraC0xXSljb250aW51ZSBhO2c9ZX1mb3IoOzI1OD5nJiZhK2c8cyYmYltkK2ddPT09YlthK2ddOykrK2c7Zz5lJiYoZj1kLGU9Zyk7aWYoMjU4PT09ZylicmVha31yZXR1cm4gbmV3IHhhKGUsYS1mKX1cbmZ1bmN0aW9uIHVhKGIsYSl7dmFyIGM9Yi5sZW5ndGgsZD1uZXcgbGEoNTcyKSxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KShjKSxlLGcsayxoLGw7aWYoIUIpZm9yKGg9MDtoPGM7aCsrKWZbaF09MDtmb3IoaD0wO2g8YzsrK2gpMDxiW2hdJiZkLnB1c2goaCxiW2hdKTtlPUFycmF5KGQubGVuZ3RoLzIpO2c9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShkLmxlbmd0aC8yKTtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGZbZC5wb3AoKS5pbmRleF09MSxmO2g9MDtmb3IobD1kLmxlbmd0aC8yO2g8bDsrK2gpZVtoXT1kLnBvcCgpLGdbaF09ZVtoXS52YWx1ZTtrPUNhKGcsZy5sZW5ndGgsYSk7aD0wO2ZvcihsPWUubGVuZ3RoO2g8bDsrK2gpZltlW2hdLmluZGV4XT1rW2hdO3JldHVybiBmfVxuZnVuY3Rpb24gQ2EoYixhLGMpe2Z1bmN0aW9uIGQoYil7dmFyIGM9aFtiXVtsW2JdXTtjPT09YT8oZChiKzEpLGQoYisxKSk6LS1nW2NdOysrbFtiXX12YXIgZj1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGMpLGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGMpLGc9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGEpLGs9QXJyYXkoYyksaD1BcnJheShjKSxsPUFycmF5KGMpLHM9KDE8PGMpLWEsbj0xPDxjLTEsbSxwLHIsdix4O2ZbYy0xXT1hO2ZvcihwPTA7cDxjOysrcClzPG4/ZVtwXT0wOihlW3BdPTEscy09biksczw8PTEsZltjLTItcF09KGZbYy0xLXBdLzJ8MCkrYTtmWzBdPWVbMF07a1swXT1BcnJheShmWzBdKTtoWzBdPUFycmF5KGZbMF0pO2ZvcihwPTE7cDxjOysrcClmW3BdPjIqZltwLTFdK2VbcF0mJihmW3BdPTIqZltwLTFdK2VbcF0pLGtbcF09QXJyYXkoZltwXSksaFtwXT1BcnJheShmW3BdKTtmb3IobT0wO208YTsrK20pZ1ttXT1jO2ZvcihyPTA7cjxmW2MtMV07KytyKWtbYy1cbjFdW3JdPWJbcl0saFtjLTFdW3JdPXI7Zm9yKG09MDttPGM7KyttKWxbbV09MDsxPT09ZVtjLTFdJiYoLS1nWzBdLCsrbFtjLTFdKTtmb3IocD1jLTI7MDw9cDstLXApe3Y9bT0wO3g9bFtwKzFdO2ZvcihyPTA7cjxmW3BdO3IrKyl2PWtbcCsxXVt4XStrW3ArMV1beCsxXSx2PmJbbV0/KGtbcF1bcl09dixoW3BdW3JdPWEseCs9Mik6KGtbcF1bcl09YlttXSxoW3BdW3JdPW0sKyttKTtsW3BdPTA7MT09PWVbcF0mJmQocCl9cmV0dXJuIGd9XG5mdW5jdGlvbiB2YShiKXt2YXIgYT1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGIubGVuZ3RoKSxjPVtdLGQ9W10sZj0wLGUsZyxrLGg7ZT0wO2ZvcihnPWIubGVuZ3RoO2U8ZztlKyspY1tiW2VdXT0oY1tiW2VdXXwwKSsxO2U9MTtmb3IoZz0xNjtlPD1nO2UrKylkW2VdPWYsZis9Y1tlXXwwLGY8PD0xO2U9MDtmb3IoZz1iLmxlbmd0aDtlPGc7ZSsrKXtmPWRbYltlXV07ZFtiW2VdXSs9MTtrPWFbZV09MDtmb3IoaD1iW2VdO2s8aDtrKyspYVtlXT1hW2VdPDwxfGYmMSxmPj4+PTF9cmV0dXJuIGF9O2Z1bmN0aW9uIERhKGIsYSl7dGhpcy5pbnB1dD1iO3RoaXMuYj10aGlzLmM9MDt0aGlzLmk9e307YSYmKGEuZmxhZ3MmJih0aGlzLmk9YS5mbGFncyksXCJzdHJpbmdcIj09PXR5cGVvZiBhLmZpbGVuYW1lJiYodGhpcy5maWxlbmFtZT1hLmZpbGVuYW1lKSxcInN0cmluZ1wiPT09dHlwZW9mIGEuY29tbWVudCYmKHRoaXMuQT1hLmNvbW1lbnQpLGEuZGVmbGF0ZU9wdGlvbnMmJih0aGlzLmw9YS5kZWZsYXRlT3B0aW9ucykpO3RoaXMubHx8KHRoaXMubD17fSl9XG5EYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGYsZSxnLGssaD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpLGw9MCxzPXRoaXMuaW5wdXQsbj10aGlzLmMsbT10aGlzLmZpbGVuYW1lLHA9dGhpcy5BO2hbbCsrXT0zMTtoW2wrK109MTM5O2hbbCsrXT04O2I9MDt0aGlzLmkuZm5hbWUmJihifD1FYSk7dGhpcy5pLmZjb21tZW50JiYoYnw9RmEpO3RoaXMuaS5maGNyYyYmKGJ8PUdhKTtoW2wrK109YjthPShEYXRlLm5vdz9EYXRlLm5vdygpOituZXcgRGF0ZSkvMUUzfDA7aFtsKytdPWEmMjU1O2hbbCsrXT1hPj4+OCYyNTU7aFtsKytdPWE+Pj4xNiYyNTU7aFtsKytdPWE+Pj4yNCYyNTU7aFtsKytdPTA7aFtsKytdPUhhO2lmKHRoaXMuaS5mbmFtZSE9PXQpe2c9MDtmb3Ioaz1tLmxlbmd0aDtnPGs7KytnKWU9bS5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfWlmKHRoaXMuaS5jb21tZW50KXtnPVxuMDtmb3Ioaz1wLmxlbmd0aDtnPGs7KytnKWU9cC5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfXRoaXMuaS5maGNyYyYmKGM9amEoaCwwLGwpJjY1NTM1LGhbbCsrXT1jJjI1NSxoW2wrK109Yz4+PjgmMjU1KTt0aGlzLmwub3V0cHV0QnVmZmVyPWg7dGhpcy5sLm91dHB1dEluZGV4PWw7Zj1uZXcgbmEocyx0aGlzLmwpO2g9Zi5nKCk7bD1mLmI7QiYmKGwrOD5oLmJ1ZmZlci5ieXRlTGVuZ3RoPyh0aGlzLmE9bmV3IFVpbnQ4QXJyYXkobCs4KSx0aGlzLmEuc2V0KG5ldyBVaW50OEFycmF5KGguYnVmZmVyKSksaD10aGlzLmEpOmg9bmV3IFVpbnQ4QXJyYXkoaC5idWZmZXIpKTtkPWphKHMsdCx0KTtoW2wrK109ZCYyNTU7aFtsKytdPWQ+Pj44JjI1NTtoW2wrK109ZD4+PjE2JjI1NTtoW2wrK109ZD4+PjI0JjI1NTtrPXMubGVuZ3RoO2hbbCsrXT1rJjI1NTtoW2wrK109az4+PjgmMjU1O2hbbCsrXT1rPj4+MTYmMjU1O2hbbCsrXT1cbms+Pj4yNCYyNTU7dGhpcy5jPW47QiYmbDxoLmxlbmd0aCYmKHRoaXMuYT1oPWguc3ViYXJyYXkoMCxsKSk7cmV0dXJuIGh9O3ZhciBIYT0yNTUsR2E9MixFYT04LEZhPTE2O0EoXCJabGliLkd6aXBcIixEYSk7QShcIlpsaWIuR3ppcC5wcm90b3R5cGUuY29tcHJlc3NcIixEYS5wcm90b3R5cGUuZyk7ZnVuY3Rpb24gVChiLGEpe3RoaXMucD1bXTt0aGlzLnE9MzI3Njg7dGhpcy5lPXRoaXMuaj10aGlzLmM9dGhpcy51PTA7dGhpcy5pbnB1dD1CP25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy53PSExO3RoaXMucj1JYTt0aGlzLkw9ITE7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEuYnVmZmVyU2l6ZSYmKHRoaXMucT1hLmJ1ZmZlclNpemUpLGEuYnVmZmVyVHlwZSYmKHRoaXMucj1hLmJ1ZmZlclR5cGUpLGEucmVzaXplJiYodGhpcy5MPWEucmVzaXplKTtzd2l0Y2godGhpcy5yKXtjYXNlIFhhOnRoaXMuYj0zMjc2ODt0aGlzLmE9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKDMyNzY4K3RoaXMucSsyNTgpO2JyZWFrO2Nhc2UgSWE6dGhpcy5iPTA7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnEpO3RoaXMuZj10aGlzLlQ7dGhpcy5CPXRoaXMuUTt0aGlzLnM9dGhpcy5TO2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgaW5mbGF0ZSBtb2RlXCIpKX19XG52YXIgWGE9MCxJYT0xLFlhPXtOOlhhLE06SWF9O1xuVC5wcm90b3R5cGUuaD1mdW5jdGlvbigpe2Zvcig7IXRoaXMudzspe3ZhciBiPVUodGhpcywzKTtiJjEmJih0aGlzLnc9dSk7Yj4+Pj0xO3N3aXRjaChiKXtjYXNlIDA6dmFyIGE9dGhpcy5pbnB1dCxjPXRoaXMuYyxkPXRoaXMuYSxmPXRoaXMuYixlPXQsZz10LGs9dCxoPWQubGVuZ3RoLGw9dDt0aGlzLmU9dGhpcy5qPTA7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IExFTiAoZmlyc3QgYnl0ZSlcIikpO2c9ZTtlPWFbYysrXTtlPT09dCYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogTEVOIChzZWNvbmQgYnl0ZSlcIikpO2d8PWU8PDg7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKGZpcnN0IGJ5dGUpXCIpKTtrPWU7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKHNlY29uZCBieXRlKVwiKSk7a3w9XG5lPDw4O2c9PT1+ayYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogbGVuZ3RoIHZlcmlmeVwiKSk7YytnPmEubGVuZ3RoJiZxKEVycm9yKFwiaW5wdXQgYnVmZmVyIGlzIGJyb2tlblwiKSk7c3dpdGNoKHRoaXMucil7Y2FzZSBYYTpmb3IoO2YrZz5kLmxlbmd0aDspe2w9aC1mO2ctPWw7aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytsKSxmKSxmKz1sLGMrPWw7ZWxzZSBmb3IoO2wtLTspZFtmKytdPWFbYysrXTt0aGlzLmI9ZjtkPXRoaXMuZigpO2Y9dGhpcy5ifWJyZWFrO2Nhc2UgSWE6Zm9yKDtmK2c+ZC5sZW5ndGg7KWQ9dGhpcy5mKHtGOjJ9KTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGluZmxhdGUgbW9kZVwiKSl9aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytnKSxmKSxmKz1nLGMrPWc7ZWxzZSBmb3IoO2ctLTspZFtmKytdPWFbYysrXTt0aGlzLmM9Yzt0aGlzLmI9Zjt0aGlzLmE9ZDticmVhaztjYXNlIDE6dGhpcy5zKFphLCRhKTticmVhaztcbmNhc2UgMjphYih0aGlzKTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bmtub3duIEJUWVBFOiBcIitiKSl9fXJldHVybiB0aGlzLkIoKX07XG52YXIgYmI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGNiPUI/bmV3IFVpbnQxNkFycmF5KGJiKTpiYixkYj1bMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwyNTgsMjU4XSxlYj1CP25ldyBVaW50MTZBcnJheShkYik6ZGIsZmI9WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDBdLGdiPUI/bmV3IFVpbnQ4QXJyYXkoZmIpOmZiLGhiPVsxLDIsMyw0LDUsNyw5LDEzLDE3LDI1LDMzLDQ5LDY1LDk3LDEyOSwxOTMsMjU3LDM4NSw1MTMsNzY5LDEwMjUsMTUzNywyMDQ5LDMwNzMsNDA5Nyw2MTQ1LDgxOTMsMTIyODksMTYzODUsMjQ1NzddLGliPUI/bmV3IFVpbnQxNkFycmF5KGhiKTpoYixqYj1bMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCxcbjEwLDExLDExLDEyLDEyLDEzLDEzXSxrYj1CP25ldyBVaW50OEFycmF5KGpiKTpqYixsYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjg4KSxWLG1iO1Y9MDtmb3IobWI9bGIubGVuZ3RoO1Y8bWI7KytWKWxiW1ZdPTE0Mz49Vj84OjI1NT49Vj85OjI3OT49Vj83Ojg7dmFyIFphPW1hKGxiKSxuYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzApLG9iLHFiO29iPTA7Zm9yKHFiPW5iLmxlbmd0aDtvYjxxYjsrK29iKW5iW29iXT01O3ZhciAkYT1tYShuYik7ZnVuY3Rpb24gVShiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc7ZDxhOylnPWZbZSsrXSxnPT09dCYmcShFcnJvcihcImlucHV0IGJ1ZmZlciBpcyBicm9rZW5cIikpLGN8PWc8PGQsZCs9ODtnPWMmKDE8PGEpLTE7Yi5qPWM+Pj5hO2IuZT1kLWE7Yi5jPWU7cmV0dXJuIGd9XG5mdW5jdGlvbiByYihiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc9YVswXSxrPWFbMV0saCxsLHM7ZDxrOyl7aD1mW2UrK107aWYoaD09PXQpYnJlYWs7Y3w9aDw8ZDtkKz04fWw9Z1tjJigxPDxrKS0xXTtzPWw+Pj4xNjtiLmo9Yz4+cztiLmU9ZC1zO2IuYz1lO3JldHVybiBsJjY1NTM1fVxuZnVuY3Rpb24gYWIoYil7ZnVuY3Rpb24gYShhLGIsYyl7dmFyIGQsZSxmLGc7Zm9yKGc9MDtnPGE7KXN3aXRjaChkPXJiKHRoaXMsYiksZCl7Y2FzZSAxNjpmb3IoZj0zK1UodGhpcywyKTtmLS07KWNbZysrXT1lO2JyZWFrO2Nhc2UgMTc6Zm9yKGY9MytVKHRoaXMsMyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7Y2FzZSAxODpmb3IoZj0xMStVKHRoaXMsNyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7ZGVmYXVsdDplPWNbZysrXT1kfXJldHVybiBjfXZhciBjPVUoYiw1KSsyNTcsZD1VKGIsNSkrMSxmPVUoYiw0KSs0LGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGNiLmxlbmd0aCksZyxrLGgsbDtmb3IobD0wO2w8ZjsrK2wpZVtjYltsXV09VShiLDMpO2c9bWEoZSk7az1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoYyk7aD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoZCk7Yi5zKG1hKGEuY2FsbChiLGMsZyxrKSksbWEoYS5jYWxsKGIsZCxnLGgpKSl9XG5ULnByb3RvdHlwZS5zPWZ1bmN0aW9uKGIsYSl7dmFyIGM9dGhpcy5hLGQ9dGhpcy5iO3RoaXMuQz1iO2Zvcih2YXIgZj1jLmxlbmd0aC0yNTgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpLGNbZCsrXT1lO2Vsc2V7Zz1lLTI1NztoPWViW2ddOzA8Z2JbZ10mJihoKz1VKHRoaXMsZ2JbZ10pKTtlPXJiKHRoaXMsYSk7az1pYltlXTswPGtiW2VdJiYoays9VSh0aGlzLGtiW2VdKSk7ZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpO2Zvcig7aC0tOyljW2RdPWNbZCsrLWtdfWZvcig7ODw9dGhpcy5lOyl0aGlzLmUtPTgsdGhpcy5jLS07dGhpcy5iPWR9O1xuVC5wcm90b3R5cGUuUz1mdW5jdGlvbihiLGEpe3ZhciBjPXRoaXMuYSxkPXRoaXMuYjt0aGlzLkM9Yjtmb3IodmFyIGY9Yy5sZW5ndGgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCksY1tkKytdPWU7ZWxzZXtnPWUtMjU3O2g9ZWJbZ107MDxnYltnXSYmKGgrPVUodGhpcyxnYltnXSkpO2U9cmIodGhpcyxhKTtrPWliW2VdOzA8a2JbZV0mJihrKz1VKHRoaXMsa2JbZV0pKTtkK2g+ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCk7Zm9yKDtoLS07KWNbZF09Y1tkKysta119Zm9yKDs4PD10aGlzLmU7KXRoaXMuZS09OCx0aGlzLmMtLTt0aGlzLmI9ZH07XG5ULnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKHRoaXMuYi0zMjc2OCksYT10aGlzLmItMzI3NjgsYyxkLGY9dGhpcy5hO2lmKEIpYi5zZXQoZi5zdWJhcnJheSgzMjc2OCxiLmxlbmd0aCkpO2Vsc2V7Yz0wO2ZvcihkPWIubGVuZ3RoO2M8ZDsrK2MpYltjXT1mW2MrMzI3NjhdfXRoaXMucC5wdXNoKGIpO3RoaXMudSs9Yi5sZW5ndGg7aWYoQilmLnNldChmLnN1YmFycmF5KGEsYSszMjc2OCkpO2Vsc2UgZm9yKGM9MDszMjc2OD5jOysrYylmW2NdPWZbYStjXTt0aGlzLmI9MzI3Njg7cmV0dXJuIGZ9O1xuVC5wcm90b3R5cGUuVD1mdW5jdGlvbihiKXt2YXIgYSxjPXRoaXMuaW5wdXQubGVuZ3RoL3RoaXMuYysxfDAsZCxmLGUsZz10aGlzLmlucHV0LGs9dGhpcy5hO2ImJihcIm51bWJlclwiPT09dHlwZW9mIGIuRiYmKGM9Yi5GKSxcIm51bWJlclwiPT09dHlwZW9mIGIuTyYmKGMrPWIuTykpOzI+Yz8oZD0oZy5sZW5ndGgtdGhpcy5jKS90aGlzLkNbMl0sZT0yNTgqKGQvMil8MCxmPWU8ay5sZW5ndGg/ay5sZW5ndGgrZTprLmxlbmd0aDw8MSk6Zj1rLmxlbmd0aCpjO0I/KGE9bmV3IFVpbnQ4QXJyYXkoZiksYS5zZXQoaykpOmE9aztyZXR1cm4gdGhpcy5hPWF9O1xuVC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3ZhciBiPTAsYT10aGlzLmEsYz10aGlzLnAsZCxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnUrKHRoaXMuYi0zMjc2OCkpLGUsZyxrLGg7aWYoMD09PWMubGVuZ3RoKXJldHVybiBCP3RoaXMuYS5zdWJhcnJheSgzMjc2OCx0aGlzLmIpOnRoaXMuYS5zbGljZSgzMjc2OCx0aGlzLmIpO2U9MDtmb3IoZz1jLmxlbmd0aDtlPGc7KytlKXtkPWNbZV07az0wO2ZvcihoPWQubGVuZ3RoO2s8aDsrK2spZltiKytdPWRba119ZT0zMjc2ODtmb3IoZz10aGlzLmI7ZTxnOysrZSlmW2IrK109YVtlXTt0aGlzLnA9W107cmV0dXJuIHRoaXMuYnVmZmVyPWZ9O1xuVC5wcm90b3R5cGUuUT1mdW5jdGlvbigpe3ZhciBiLGE9dGhpcy5iO0I/dGhpcy5MPyhiPW5ldyBVaW50OEFycmF5KGEpLGIuc2V0KHRoaXMuYS5zdWJhcnJheSgwLGEpKSk6Yj10aGlzLmEuc3ViYXJyYXkoMCxhKToodGhpcy5hLmxlbmd0aD5hJiYodGhpcy5hLmxlbmd0aD1hKSxiPXRoaXMuYSk7cmV0dXJuIHRoaXMuYnVmZmVyPWJ9O2Z1bmN0aW9uIHNiKGIpe3RoaXMuaW5wdXQ9Yjt0aGlzLmM9MDt0aGlzLnQ9W107dGhpcy5EPSExfXNiLnByb3RvdHlwZS5XPWZ1bmN0aW9uKCl7dGhpcy5EfHx0aGlzLmgoKTtyZXR1cm4gdGhpcy50LnNsaWNlKCl9O1xuc2IucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5pbnB1dC5sZW5ndGg7dGhpcy5jPGI7KXt2YXIgYT1uZXcgUCxjPXQsZD10LGY9dCxlPXQsZz10LGs9dCxoPXQsbD10LHM9dCxuPXRoaXMuaW5wdXQsbT10aGlzLmM7YS5HPW5bbSsrXTthLkg9blttKytdOygzMSE9PWEuR3x8MTM5IT09YS5IKSYmcShFcnJvcihcImludmFsaWQgZmlsZSBzaWduYXR1cmU6XCIrYS5HK1wiLFwiK2EuSCkpO2Euej1uW20rK107c3dpdGNoKGEueil7Y2FzZSA4OmJyZWFrO2RlZmF1bHQ6cShFcnJvcihcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kOiBcIithLnopKX1hLm49blttKytdO2w9blttKytdfG5bbSsrXTw8OHxuW20rK108PDE2fG5bbSsrXTw8MjQ7YS5ZPW5ldyBEYXRlKDFFMypsKTthLmVhPW5bbSsrXTthLmRhPW5bbSsrXTswPChhLm4mNCkmJihhLiQ9blttKytdfG5bbSsrXTw8OCxtKz1hLiQpO2lmKDA8KGEubiZFYSkpe2g9W107Zm9yKGs9MDswPChnPW5bbSsrXSk7KWhbaysrXT1cblN0cmluZy5mcm9tQ2hhckNvZGUoZyk7YS5uYW1lPWguam9pbihcIlwiKX1pZigwPChhLm4mRmEpKXtoPVtdO2ZvcihrPTA7MDwoZz1uW20rK10pOyloW2srK109U3RyaW5nLmZyb21DaGFyQ29kZShnKTthLkE9aC5qb2luKFwiXCIpfTA8KGEubiZHYSkmJihhLlI9amEobiwwLG0pJjY1NTM1LGEuUiE9PShuW20rK118blttKytdPDw4KSYmcShFcnJvcihcImludmFsaWQgaGVhZGVyIGNyYzE2XCIpKSk7Yz1uW24ubGVuZ3RoLTRdfG5bbi5sZW5ndGgtM108PDh8bltuLmxlbmd0aC0yXTw8MTZ8bltuLmxlbmd0aC0xXTw8MjQ7bi5sZW5ndGgtbS00LTQ8NTEyKmMmJihlPWMpO2Q9bmV3IFQobix7aW5kZXg6bSxidWZmZXJTaXplOmV9KTthLmRhdGE9Zj1kLmgoKTttPWQuYzthLmJhPXM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7amEoZix0LHQpIT09cyYmcShFcnJvcihcImludmFsaWQgQ1JDLTMyIGNoZWNrc3VtOiAweFwiK2phKGYsdCx0KS50b1N0cmluZygxNikrXG5cIiAvIDB4XCIrcy50b1N0cmluZygxNikpKTthLmNhPWM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7KGYubGVuZ3RoJjQyOTQ5NjcyOTUpIT09YyYmcShFcnJvcihcImludmFsaWQgaW5wdXQgc2l6ZTogXCIrKGYubGVuZ3RoJjQyOTQ5NjcyOTUpK1wiIC8gXCIrYykpO3RoaXMudC5wdXNoKGEpO3RoaXMuYz1tfXRoaXMuRD11O3ZhciBwPXRoaXMudCxyLHYseD0wLFE9MCx5O3I9MDtmb3Iodj1wLmxlbmd0aDtyPHY7KytyKVErPXBbcl0uZGF0YS5sZW5ndGg7aWYoQil7eT1uZXcgVWludDhBcnJheShRKTtmb3Iocj0wO3I8djsrK3IpeS5zZXQocFtyXS5kYXRhLHgpLHgrPXBbcl0uZGF0YS5sZW5ndGh9ZWxzZXt5PVtdO2ZvcihyPTA7cjx2Oysrcil5W3JdPXBbcl0uZGF0YTt5PUFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10seSl9cmV0dXJuIHl9O0EoXCJabGliLkd1bnppcFwiLHNiKTtBKFwiWmxpYi5HdW56aXAucHJvdG90eXBlLmRlY29tcHJlc3NcIixzYi5wcm90b3R5cGUuaCk7QShcIlpsaWIuR3VuemlwLnByb3RvdHlwZS5nZXRNZW1iZXJzXCIsc2IucHJvdG90eXBlLlcpO2Z1bmN0aW9uIHRiKGIpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYil7dmFyIGE9Yi5zcGxpdChcIlwiKSxjLGQ7Yz0wO2ZvcihkPWEubGVuZ3RoO2M8ZDtjKyspYVtjXT0oYVtjXS5jaGFyQ29kZUF0KDApJjI1NSk+Pj4wO2I9YX1mb3IodmFyIGY9MSxlPTAsZz1iLmxlbmd0aCxrLGg9MDswPGc7KXtrPTEwMjQ8Zz8xMDI0Omc7Zy09aztkbyBmKz1iW2grK10sZSs9Zjt3aGlsZSgtLWspO2YlPTY1NTIxO2UlPTY1NTIxfXJldHVybihlPDwxNnxmKT4+PjB9O2Z1bmN0aW9uIHViKGIsYSl7dmFyIGMsZDt0aGlzLmlucHV0PWI7dGhpcy5jPTA7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEudmVyaWZ5JiYodGhpcy5aPWEudmVyaWZ5KTtjPWJbdGhpcy5jKytdO2Q9Ylt0aGlzLmMrK107c3dpdGNoKGMmMTUpe2Nhc2UgdmI6dGhpcy5tZXRob2Q9dmI7YnJlYWs7ZGVmYXVsdDpxKEVycm9yKFwidW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX0wIT09KChjPDw4KStkKSUzMSYmcShFcnJvcihcImludmFsaWQgZmNoZWNrIGZsYWc6XCIrKChjPDw4KStkKSUzMSkpO2QmMzImJnEoRXJyb3IoXCJmZGljdCBmbGFnIGlzIG5vdCBzdXBwb3J0ZWRcIikpO3RoaXMuSz1uZXcgVChiLHtpbmRleDp0aGlzLmMsYnVmZmVyU2l6ZTphLmJ1ZmZlclNpemUsYnVmZmVyVHlwZTphLmJ1ZmZlclR5cGUscmVzaXplOmEucmVzaXplfSl9XG51Yi5wcm90b3R5cGUuaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuaW5wdXQsYSxjO2E9dGhpcy5LLmgoKTt0aGlzLmM9dGhpcy5LLmM7dGhpcy5aJiYoYz0oYlt0aGlzLmMrK108PDI0fGJbdGhpcy5jKytdPDwxNnxiW3RoaXMuYysrXTw8OHxiW3RoaXMuYysrXSk+Pj4wLGMhPT10YihhKSYmcShFcnJvcihcImludmFsaWQgYWRsZXItMzIgY2hlY2tzdW1cIikpKTtyZXR1cm4gYX07dmFyIHZiPTg7ZnVuY3Rpb24gd2IoYixhKXt0aGlzLmlucHV0PWI7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgzMjc2OCk7dGhpcy5rPVcubzt2YXIgYz17fSxkO2lmKChhfHwhKGE9e30pKSYmXCJudW1iZXJcIj09PXR5cGVvZiBhLmNvbXByZXNzaW9uVHlwZSl0aGlzLms9YS5jb21wcmVzc2lvblR5cGU7Zm9yKGQgaW4gYSljW2RdPWFbZF07Yy5vdXRwdXRCdWZmZXI9dGhpcy5hO3RoaXMuSj1uZXcgbmEodGhpcy5pbnB1dCxjKX12YXIgVz1yYTtcbndiLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7dmFyIGIsYSxjLGQsZixlLGcsaz0wO2c9dGhpcy5hO2I9dmI7c3dpdGNoKGIpe2Nhc2UgdmI6YT1NYXRoLkxPRzJFKk1hdGgubG9nKDMyNzY4KS04O2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX1jPWE8PDR8YjtnW2srK109Yztzd2l0Y2goYil7Y2FzZSB2Yjpzd2l0Y2godGhpcy5rKXtjYXNlIFcuTk9ORTpmPTA7YnJlYWs7Y2FzZSBXLnY6Zj0xO2JyZWFrO2Nhc2UgVy5vOmY9MjticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlXCIpKX1icmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZFwiKSl9ZD1mPDw2fDA7Z1trKytdPWR8MzEtKDI1NipjK2QpJTMxO2U9dGIodGhpcy5pbnB1dCk7dGhpcy5KLmI9aztnPXRoaXMuSi5nKCk7az1nLmxlbmd0aDtCJiYoZz1uZXcgVWludDhBcnJheShnLmJ1ZmZlciksZy5sZW5ndGg8PVxuays0JiYodGhpcy5hPW5ldyBVaW50OEFycmF5KGcubGVuZ3RoKzQpLHRoaXMuYS5zZXQoZyksZz10aGlzLmEpLGc9Zy5zdWJhcnJheSgwLGsrNCkpO2dbaysrXT1lPj4yNCYyNTU7Z1trKytdPWU+PjE2JjI1NTtnW2srK109ZT4+OCYyNTU7Z1trKytdPWUmMjU1O3JldHVybiBnfTtmdW5jdGlvbiB4YihiLGEpe3ZhciBjLGQsZixlO2lmKE9iamVjdC5rZXlzKWM9T2JqZWN0LmtleXMoYSk7ZWxzZSBmb3IoZCBpbiBjPVtdLGY9MCxhKWNbZisrXT1kO2Y9MDtmb3IoZT1jLmxlbmd0aDtmPGU7KytmKWQ9Y1tmXSxBKGIrXCIuXCIrZCxhW2RdKX07QShcIlpsaWIuSW5mbGF0ZVwiLHViKTtBKFwiWmxpYi5JbmZsYXRlLnByb3RvdHlwZS5kZWNvbXByZXNzXCIsdWIucHJvdG90eXBlLmgpO3hiKFwiWmxpYi5JbmZsYXRlLkJ1ZmZlclR5cGVcIix7QURBUFRJVkU6WWEuTSxCTE9DSzpZYS5OfSk7QShcIlpsaWIuRGVmbGF0ZVwiLHdiKTtBKFwiWmxpYi5EZWZsYXRlLmNvbXByZXNzXCIsZnVuY3Rpb24oYixhKXtyZXR1cm4obmV3IHdiKGIsYSkpLmcoKX0pO0EoXCJabGliLkRlZmxhdGUucHJvdG90eXBlLmNvbXByZXNzXCIsd2IucHJvdG90eXBlLmcpO3hiKFwiWmxpYi5EZWZsYXRlLkNvbXByZXNzaW9uVHlwZVwiLHtOT05FOlcuTk9ORSxGSVhFRDpXLnYsRFlOQU1JQzpXLm99KTt9KS5jYWxsKHRoaXMpOyAvL0Agc291cmNlTWFwcGluZ1VSTD16bGliX2FuZF9nemlwLm1pbi5qcy5tYXBcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/vendor/zlib_and_gzip.min.js\n");

/***/ }),

/***/ "canvas":
/*!*************************!*\
  !*** external "canvas" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"canvas\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmFzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY2FudmFzXCI/ZDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjYW52YXNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///canvas\n");

/***/ }),

/***/ "extend":
/*!*************************!*\
  !*** external "extend" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"extend\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5kLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXh0ZW5kXCI/MGU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJleHRlbmRcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///extend\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiP2E0MGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///fs\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jquery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jquery\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwianF1ZXJ5XCI/OGY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqcXVlcnlcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///jquery\n");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0aC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIj83NGJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///path\n");

/***/ }),

/***/ "xhr2":
/*!***********************!*\
  !*** external "xhr2" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"xhr2\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGhyMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInhocjJcIj85YTkwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInhocjJcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///xhr2\n");

/***/ })

/******/ });