/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/indexes/image_gen_index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/bam.js":
/*!********************!*\
  !*** ./src/bam.js ***!
  \********************/
/*! exports provided: loadBamIndex, BamReader, BamSource, BamFilter, BamAlignment, PairedAlignment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Zlib) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBamIndex\", function() { return loadBamIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamReader\", function() { return BamReader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamSource\", function() { return BamSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamFilter\", function() { return BamFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BamAlignment\", function() { return BamAlignment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PairedAlignment\", function() { return PairedAlignment; });\n/* harmony import */ var _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n/* harmony import */ var _bigwig_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n/* harmony import */ var _vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vendor/inflate.js */ \"./src/vendor/inflate.js\");\n/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./feature.js */ \"./src/feature.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst BAI_MAGIC = 21578050;\r\nconst TABIX_MAGIC = 21578324;\r\nconst MAX_HEADER_SIZE = 100000000;   // IF the header is larger than this we can't read it !\r\nconst B_MAX_GZIP_BLOCK_SIZE = (1 << 16);\r\n\r\n\r\n    /**\r\n     * @param indexURL\r\n     * @param config\r\n     * @param tabix\r\n     *\r\n     * @returns a Promised for the bam or tabix index.  The fulfill function takes the index as an argument.\r\n     */\r\nlet loadBamIndex = function (indexURL, config, tabix) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var genome = null;\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(indexURL,\r\n                {\r\n                    headers: config.headers,\r\n                    withCredentials: config.withCredentials\r\n                }).then(function (arrayBuffer) {\r\n\r\n                var indices = [],\r\n                    magic, nbin, nintv, nref, parser,\r\n                    blockMin = Number.MAX_VALUE,\r\n                    blockMax = 0,\r\n                    binIndex, linearIndex, binNumber, cs, ce, b, i, ref, sequenceIndexMap;\r\n\r\n                if (!arrayBuffer) {\r\n                    fulfill(null);\r\n                    return;\r\n                }\r\n\r\n                if (tabix) {\r\n                    var inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arrayBuffer));\r\n                    arrayBuffer = inflate.decompress().buffer;\r\n                }\r\n\r\n                parser = new _bigwig_js__WEBPACK_IMPORTED_MODULE_1__[\"BinaryParser\"](new DataView(arrayBuffer));\r\n\r\n                magic = parser.getInt();\r\n\r\n                if (magic === BAI_MAGIC || (tabix && magic === TABIX_MAGIC)) {\r\n\r\n                    nref = parser.getInt();\r\n\r\n\r\n                    if (tabix) {\r\n                        // Tabix header parameters aren't used, but they must be read to advance the pointer\r\n                        var format = parser.getInt();\r\n                        var col_seq = parser.getInt();\r\n                        var col_beg = parser.getInt();\r\n                        var col_end = parser.getInt();\r\n                        var meta = parser.getInt();\r\n                        var skip = parser.getInt();\r\n                        var l_nm = parser.getInt();\r\n\r\n                        sequenceIndexMap = {};\r\n                        for (i = 0; i < nref; i++) {\r\n                            var seq_name = parser.getString();\r\n\r\n                            // Translate to \"official\" chr name.\r\n                            if (genome) seq_name = genome.getChromosomeName(seq_name);\r\n\r\n                            sequenceIndexMap[seq_name] = i;\r\n                        }\r\n                    }\r\n\r\n                    for (ref = 0; ref < nref; ++ref) {\r\n\r\n                        binIndex = {};\r\n                        linearIndex = [];\r\n\r\n                        nbin = parser.getInt();\r\n\r\n                        for (b = 0; b < nbin; ++b) {\r\n\r\n                            binNumber = parser.getInt();\r\n\r\n                            if (binNumber == 37450) {\r\n                                // This is a psuedo bin, not used but we have to consume the bytes\r\n                                nchnk = parser.getInt(); // # of chunks for this bin\r\n                                cs = parser.getVPointer();   // unmapped beg\r\n                                ce = parser.getVPointer();   // unmapped end\r\n                                var n_maped = parser.getLong();\r\n                                var nUnmapped = parser.getLong();\r\n\r\n                            }\r\n                            else {\r\n                                \r\n                                binIndex[binNumber] = [];\r\n                                var nchnk = parser.getInt(); // # of chunks for this bin\r\n\r\n                                for (i = 0; i < nchnk; i++) {\r\n                                    cs = parser.getVPointer();\r\n                                    ce = parser.getVPointer();\r\n                                    if (cs && ce) {\r\n                                        if (cs.block < blockMin) {\r\n                                            blockMin = cs.block;    // Block containing first alignment\r\n                                        }\r\n                                        if (ce.block > blockMax) {\r\n                                            blockMax = ce.block;\r\n                                        }\r\n                                        binIndex[binNumber].push([cs, ce]);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n\r\n                        nintv = parser.getInt();\r\n                        for (i = 0; i < nintv; i++) {\r\n                            cs = parser.getVPointer();\r\n                            linearIndex.push(cs);   // Might be null\r\n                        }\r\n\r\n                        if (nbin > 0) {\r\n                            indices[ref] = {\r\n                                binIndex: binIndex,\r\n                                linearIndex: linearIndex\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    throw new Error(indexURL + \" is not a \" + (tabix ? \"tabix\" : \"bai\") + \" file\");\r\n                }\r\n                fulfill(new BamIndex(indices, blockMin, sequenceIndexMap, tabix));\r\n            }).catch(reject);\r\n        })\r\n    }\r\n\r\n\r\nclass BamIndex{\r\n    constructor (indices, blockMin, sequenceIndexMap, tabix) {\r\n        this.firstAlignmentBlock = blockMin;\r\n        this.indices = indices;\r\n        this.sequenceIndexMap = sequenceIndexMap;\r\n        this.tabix = tabix;\r\n    }\r\n\r\n    /**\r\n     * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.\r\n     *\r\n     * @param refId  the sequence dictionary index of the chromosome\r\n     * @param min  genomic start position\r\n     * @param max  genomic end position\r\n     * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}\r\n     */\r\n    blocksForRange(refId, min, max) {\r\n\r\n        var bam = this,\r\n            ba = bam.indices[refId],\r\n            overlappingBins,\r\n            leafChunks,\r\n            otherChunks,\r\n            nintv,\r\n            lowest,\r\n            minLin,\r\n            maxLin,\r\n            lb,\r\n            prunedOtherChunks,\r\n            i,\r\n            chnk,\r\n            dif,\r\n            intChunks,\r\n            mergedChunks;\r\n\r\n        if (!ba) {\r\n            return [];\r\n        }\r\n        else {\r\n\r\n            overlappingBins = BamIndex.reg2bins(min, max);        // List of bin #s that might overlap min, max\r\n            leafChunks = [];\r\n            otherChunks = [];\r\n\r\n\r\n            overlappingBins.forEach(function (bin) {\r\n\r\n                if (ba.binIndex[bin]) {\r\n                    var chunks = ba.binIndex[bin],\r\n                        nchnk = chunks.length;\r\n\r\n                    for (var c = 0; c < nchnk; ++c) {\r\n                        var cs = chunks[c][0];\r\n                        var ce = chunks[c][1];\r\n                        (bin < 4681 ? otherChunks : leafChunks).push({minv: cs, maxv: ce, bin: bin});\r\n                    }\r\n\r\n                }\r\n            });\r\n\r\n            // Use the linear index to find the lowest chunk that could contain alignments in the region\r\n            nintv = ba.linearIndex.length;\r\n            lowest = null;\r\n            minLin = Math.min(min >> 14, nintv - 1), maxLin = Math.min(max >> 14, nintv - 1);\r\n            for (i = minLin; i <= maxLin; ++i) {\r\n                lb = ba.linearIndex[i];\r\n                if (!lb) {\r\n                    continue;\r\n                }\r\n                if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {\r\n                    lowest = lb;\r\n                }\r\n            }\r\n\r\n            // Prune chunks that end before the lowest chunk\r\n            prunedOtherChunks = [];\r\n            if (lowest != null) {\r\n                for (i = 0; i < otherChunks.length; ++i) {\r\n                    chnk = otherChunks[i];\r\n                    if (chnk.maxv.block > lowest.block || (chnk.maxv.block == lowest.block && chnk.maxv.offset >= lowest.offset)) {\r\n                        prunedOtherChunks.push(chnk);\r\n                    }\r\n                }\r\n            }\r\n\r\n            intChunks = [];\r\n            for (i = 0; i < prunedOtherChunks.length; ++i) {\r\n                intChunks.push(prunedOtherChunks[i]);\r\n            }\r\n            for (i = 0; i < leafChunks.length; ++i) {\r\n                intChunks.push(leafChunks[i]);\r\n            }\r\n\r\n            intChunks.sort(function (c0, c1) {\r\n                dif = c0.minv.block - c1.minv.block;\r\n                if (dif != 0) {\r\n                    return dif;\r\n                } else {\r\n                    return c0.minv.offset - c1.minv.offset;\r\n                }\r\n            });\r\n\r\n            mergedChunks = [];\r\n            if (intChunks.length > 0) {\r\n                var cur = intChunks[0];\r\n                for (var i = 1; i < intChunks.length; ++i) {\r\n                    var nc = intChunks[i];\r\n                    if ((nc.minv.block - cur.maxv.block) < 65000) { // Merge blocks that are withing 65k of each other\r\n                        cur = {minv: cur.minv, maxv: nc.maxv};\r\n                    } else {\r\n                        mergedChunks.push(cur);\r\n                        cur = nc;\r\n                    }\r\n                }\r\n                mergedChunks.push(cur);\r\n            }\r\n            return mergedChunks;\r\n        }\r\n\r\n    };\r\n\r\n\r\n    /**\r\n     * Calculate the list of bins that may overlap with region [beg, end]\r\n     *\r\n     */\r\n    static reg2bins(beg, end) {\r\n        var i = 0, k, list = [];\r\n        if (end >= 1 << 29)   end = 1 << 29;\r\n        --end;\r\n        list.push(0);\r\n        for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) list.push(k);\r\n        for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) list.push(k);\r\n        for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) list.push(k);\r\n        for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) list.push(k);\r\n        for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) list.push(k);\r\n        return list;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nclass BGZFile{\r\n\r\n    constructor (config) {\r\n        this.filePosition = 0;\r\n        this.config = config;\r\n    }\r\n\r\n    nextBlock() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path,\r\n                {\r\n                    headers: self.config.headers,\r\n                    range: {start: self.filePosition, size: BLOCK_HEADER_LENGTH},\r\n                    withCredentials: self.config.withCredentials\r\n\r\n                }).then(function (arrayBuffer) {\r\n\r\n                var ba = new Uint8Array(arrayBuffer);\r\n                var xlen = (ba[11] << 8) | (ba[10]);\r\n                var si1 = ba[12];\r\n                var si2 = ba[13];\r\n                var slen = (ba[15] << 8) | (ba[14]);\r\n                var bsize = (ba[17] << 8) | (ba[16]) + 1;\r\n\r\n                self.filePosition += BLOCK_HEADER_LENGTH;\r\n\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, {\r\n                    headers: self.config.headers,\r\n                    range: {start: self.filePosition, size: bsize},\r\n                    withCredentials: self.config.withCredentials\r\n\r\n                }).then(function (arrayBuffer) {\r\n\r\n                    var unc = Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__[\"jszlib_inflate_buffer\"])(arrayBuffer);\r\n\r\n                    self.filePosition += (bsize + 8);  // \"8\" for CRC-32 and size of uncompressed data\r\n\r\n                    fulfill(unc);\r\n\r\n                }).catch(reject)\r\n            }).catch(reject);\r\n        })\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n    var BAM_MAGIC = 21840194;\r\n    var SECRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\r\n    var CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\r\n    var READ_STRAND_FLAG = 0x10;\r\n    var MATE_STRAND_FLAG = 0x20;\r\n    var FIRST_OF_PAIR_FLAG = 0x40;\r\n    var SECOND_OF_PAIR_FLAG = 0x80;\r\n    var READ_UNMAPPED_FLAG = 0x4;\r\n    var MATE_UNMAPPED_FLAG = 0x8;\r\n    var READ_PAIRED_FLAG = 0x1;\r\n    var PROPER_PAIR_FLAG = 0x2;\r\n    var SECONDARY_ALIGNMNET_FLAG = 0x100;\r\n    var SUPPLEMENTARY_ALIGNMENT_FLAG = 0x800;\r\n\r\n\r\n\r\n\r\n    var NOT_PRIMARY_ALIGNMENT_FLAG = 0x100;\r\n    var READ_FAILS_VENDOR_QUALITY_CHECK_FLAG = 0x200;\r\n    var DUPLICATE_READ_FLAG = 0x400;\r\n    var SUPPLEMENTARY_FLAG = 0x800;\r\n\r\n    const MAX_GZIP_BLOCK_SIZE = 65536;   //  APPARENTLY.  Where is this documented???\r\n    const DEFAULT_SAMPLING_WINDOW_SIZE = 100;\r\n    const DEFAULT_SAMPLING_DEPTH = 50;\r\n    const MAXIMUM_SAMPLING_DEPTH = 2500;\r\n\r\n    /**\r\n     * Class for reading a bam file\r\n     *\r\n     * @param config\r\n     * @constructor\r\n     */\r\n class BamReader{\r\n     constructor(config) {\r\n\r\n        this.config = config;\r\n\r\n        this.filter = config.filter || new BamFilter();\r\n\r\n        this.bamPath = config.url;\r\n        // Todo - deal with Picard convention.  WHY DOES THERE HAVE TO BE 2?\r\n        this.baiPath = config.indexURL || this.bamPath + \".bai\"; // If there is an indexURL provided, use it!\r\n        this.headPath = config.headURL || this.bamPath;\r\n\r\n\r\n        this.samplingWindowSize = config.samplingWindowSize === undefined ? DEFAULT_SAMPLING_WINDOW_SIZE : config.samplingWindowSize;\r\n        this.samplingDepth = config.samplingDepth === undefined ? DEFAULT_SAMPLING_DEPTH : config.samplingDepth;\r\n        if(this.samplingDepth > MAXIMUM_SAMPLING_DEPTH) {\r\n            igv.log(\"Warning: attempt to set sampling depth > maximum value of 2500\");\r\n            this.samplingDepth = MAXIMUM_SAMPLING_DEPTH;\r\n        }\r\n\r\n        if (config.viewAsPairs) {\r\n            this.pairsSupported = true;\r\n        }\r\n        else {\r\n            this.pairsSupported = config.pairsSupported === undefined ? true : config.pairsSupported;\r\n        }\r\n\r\n    }\r\n\r\n    readAlignments(chr, bpStart, bpEnd) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n\r\n            getChrIndex(self).then(function (chrToIndex) {\r\n\r\n                var chrId = chrToIndex[chr],\r\n\r\n                    alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, self.samplingWindowSize, self.samplingDepth, self.pairsSupported);\r\n                    \r\n                if (chrId === undefined) {\r\n                    fulfill(alignmentContainer);\r\n                } else {\r\n\r\n                    getIndex(self).then(function (bamIndex) {\r\n\r\n                        var chunks = bamIndex.blocksForRange(chrId, bpStart, bpEnd),\r\n                            promises = [];\r\n\r\n\r\n                        if (!chunks) {\r\n                            fulfill(null);\r\n                            reject(\"Error reading bam index\");\r\n                            return;\r\n                        }\r\n                        if (chunks.length === 0) {\r\n                            fulfill(alignmentContainer);\r\n                            return;\r\n                        }\r\n\r\n                        chunks.forEach(function (c) {\r\n\r\n                            promises.push(new Promise(function (fulfill, reject) {\r\n\r\n                                var fetchMin = c.minv.block,\r\n                                    fetchMax = c.maxv.block + MAX_GZIP_BLOCK_SIZE,   // Make sure we get the whole block.\r\n                                    range = {start: fetchMin, size: fetchMax - fetchMin + 1};\r\n\r\n                                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.bamPath,\r\n                                    {\r\n                                        headers: self.config.headers,\r\n                                        range: range,\r\n                                        withCredentials: self.config.withCredentials\r\n                                    }).then(function (compressed) {\r\n\r\n                                    var ba = new Uint8Array(new unbgzf(compressed)); //new Uint8Array(igv.unbgzf(compressed)); //, c.maxv.block - c.minv.block + 1));\r\n                                    decodeBamRecords(ba, c.minv.offset, alignmentContainer, bpStart, bpEnd, chrId, self.filter);\r\n\r\n                                    fulfill(alignmentContainer);\r\n\r\n                                }).catch(function (obj) {\r\n                                    reject(obj);\r\n                                });\r\n\r\n                            }))\r\n                        });\r\n\r\n\r\n                        Promise.all(promises).then(function (ignored) {\r\n                            alignmentContainer.finish();\r\n                            fulfill(alignmentContainer);\r\n                        }).catch(function (obj) {\r\n                            reject(obj);\r\n                        });\r\n                    }).catch(reject);\r\n                }\r\n            }).catch(reject);\r\n        });\r\n\r\n\r\n        function decodeBamRecords(ba, offset, alignmentContainer, min, max, chrId, filter) {\r\n\r\n            var blockSize,\r\n                blockEnd,\r\n                alignment,\r\n                blocks,\r\n                refID,\r\n                pos,\r\n                bmn,\r\n                bin,\r\n                mq,\r\n                nl,\r\n                flag_nc,\r\n                flag,\r\n                nc,\r\n                lseq,\r\n                mateRefID,\r\n                matePos,\r\n                readName,\r\n                j,\r\n                p,\r\n                lengthOnRef,\r\n                cigar,\r\n                c,\r\n                cigarArray,\r\n                seq,\r\n                seqBytes;\r\n\r\n            while (true) {\r\n\r\n                blockSize = readInt(ba, offset);\r\n                blockEnd = offset + blockSize + 4;\r\n\r\n                if (blockEnd > ba.length) {\r\n                    return;\r\n                }\r\n\r\n                alignment = new BamAlignment();\r\n\r\n                refID = readInt(ba, offset + 4);\r\n                pos = readInt(ba, offset + 8);\r\n\r\n                if(refID < 0) {\r\n                    return;   // unmapped reads\r\n                }\r\n                else if (refID > chrId || pos > max) {\r\n                    return;    // off right edge, we're done\r\n                }\r\n                else if (refID < chrId) {\r\n                    continue;   // to left of start, not sure this is possible\r\n                }\r\n\r\n                bmn = readInt(ba, offset + 12);\r\n                bin = (bmn & 0xffff0000) >> 16;\r\n                mq = (bmn & 0xff00) >> 8;\r\n                nl = bmn & 0xff;\r\n\r\n                flag_nc = readInt(ba, offset + 16);\r\n                flag = (flag_nc & 0xffff0000) >> 16;\r\n                nc = flag_nc & 0xffff;\r\n\r\n                alignment.flags = flag;\r\n                alignment.strand = !(flag & READ_STRAND_FLAG);\r\n\r\n                lseq = readInt(ba, offset + 20);\r\n\r\n                mateRefID = readInt(ba, offset + 24);\r\n                matePos = readInt(ba, offset + 28);\r\n                alignment.fragmentLength = readInt(ba, offset + 32);\r\n\r\n                readName = '';\r\n                for (j = 0; j < nl - 1; ++j) {\r\n                    readName += String.fromCharCode(ba[offset + 36 + j]);\r\n                }\r\n\r\n                p = offset + 36 + nl;\r\n\r\n                lengthOnRef = 0;\r\n                cigar = '';\r\n\r\n\r\n                cigarArray = [];\r\n                for (c = 0; c < nc; ++c) {\r\n                    var cigop = readInt(ba, p);\r\n                    var opLen = (cigop >> 4);\r\n                    var opLtr = CIGAR_DECODER[cigop & 0xf];\r\n                    if (opLtr == 'M' || opLtr == 'EQ' || opLtr == 'X' || opLtr == 'D' || opLtr == 'N' || opLtr == '=')\r\n                        lengthOnRef += opLen;\r\n                    cigar = cigar + opLen + opLtr;\r\n                    p += 4;\r\n\r\n                    cigarArray.push({len: opLen, ltr: opLtr});\r\n                }\r\n                alignment.cigar = cigar;\r\n                alignment.lengthOnRef = lengthOnRef;\r\n\r\n                if (alignment.start + alignment.lengthOnRef < min) continue;  // Record out-of-range \"to the left\", skip to next one\r\n\r\n\r\n                seq = '';\r\n                seqBytes = (lseq + 1) >> 1;\r\n                for (j = 0; j < seqBytes; ++j) {\r\n                    var sb = ba[p + j];\r\n                    seq += SECRET_DECODER[(sb & 0xf0) >> 4];\r\n                    seq += SECRET_DECODER[(sb & 0x0f)];\r\n                }\r\n                seq = seq.substring(0, lseq);  // seq might have one extra character (if lseq is an odd number)\r\n\r\n                p += seqBytes;\r\n                alignment.seq = seq;\r\n\r\n\r\n                if (lseq === 1 && String.fromCharCode(ba[p + j] + 33) === \"*\") {\r\n                    // TODO == how to represent this?\r\n                }\r\n                else {\r\n                    alignment.qual = [];\r\n                    for (j = 0; j < lseq; ++j) {\r\n                        alignment.qual.push(ba[p + j]);\r\n                    }\r\n                }\r\n                p += lseq;\r\n\r\n\r\n                alignment.start = pos;\r\n                alignment.mq = mq;\r\n                alignment.readName = readName;\r\n                alignment.chr = self.indexToChr[refID];\r\n\r\n                if (mateRefID >= 0) {\r\n                    alignment.mate = {\r\n                        chr: self.indexToChr[mateRefID],\r\n                        position: matePos,\r\n                        strand: !(flag & MATE_STRAND_FLAG)\r\n                    };\r\n                }\r\n\r\n\r\n                alignment.tagBA = new Uint8Array(ba.buffer.slice(p, blockEnd));  // decode thiese on demand\r\n                p += blockEnd;\r\n\r\n                if (!min || alignment.start <= max &&\r\n                    alignment.start + alignment.lengthOnRef >= min &&\r\n                    filter.pass(alignment)) {\r\n                    if (chrId === undefined || refID == chrId) {\r\n                        blocks = makeBlocks(alignment, cigarArray);\r\n                        alignment.blocks = blocks.blocks;\r\n                        alignment.insertions = blocks.insertions;\r\n                        alignmentContainer.push(alignment);\r\n                    }\r\n                }\r\n                offset = blockEnd;\r\n            }\r\n            // Exits via top of loop.\r\n        }\r\n\r\n        /**\r\n         * Split the alignment record into blocks as specified in the cigarArray.  Each aligned block contains\r\n         * its portion of the read sequence and base quality strings.  A read sequence or base quality string\r\n         * of \"*\" indicates the value is not recorded.  In all other cases the length of the block sequence (block.seq)\r\n         * and quality string (block.qual) must == the block length.\r\n         *\r\n         * NOTE: Insertions are not yet treated // TODO\r\n         *\r\n         * @param record\r\n         * @param cigarArray\r\n         * @returns array of blocks\r\n         */\r\n        function makeBlocks(record, cigarArray) {\r\n\r\n            var blocks = [],\r\n                insertions,\r\n                seqOffset = 0,\r\n                pos = record.start,\r\n                len = cigarArray.length,\r\n                blockSeq,\r\n                blockQuals,\r\n                gapType,\r\n                minQ = 5,  //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MIN)\r\n                maxQ = 20; //prefs.getAsInt(PreferenceManager.SAM_BASE_QUALITY_MAX)\r\n\r\n            for (var i = 0; i < len; i++) {\r\n\r\n                var c = cigarArray[i];\r\n\r\n                switch (c.ltr) {\r\n                    case 'H' :\r\n                        break; // ignore hard clips\r\n                    case 'P' :\r\n                        break; // ignore pads\r\n                    case 'S' :\r\n                        seqOffset += c.len;\r\n                        gapType = 'S';\r\n                        break; // soft clip read bases\r\n                    case 'N' :\r\n                        pos += c.len;\r\n                        gapType = 'N';\r\n                        break;  // reference skip\r\n                    case 'D' :\r\n                        pos += c.len;\r\n                        gapType = 'D';\r\n                        break;\r\n                    case 'I' :\r\n                        blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\r\n                        blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\r\n                        if (insertions === undefined) insertions = [];\r\n                        insertions.push({start: pos, len: c.len, seq: blockSeq, qual: blockQuals});\r\n                        seqOffset += c.len;\r\n                        break;\r\n                    case 'M' :\r\n                    case 'EQ' :\r\n                    case '=' :\r\n                    case 'X' :\r\n\r\n                        blockSeq = record.seq === \"*\" ? \"*\" : record.seq.substr(seqOffset, c.len);\r\n                        blockQuals = record.qual ? record.qual.slice(seqOffset, c.len) : undefined;\r\n                        blocks.push({start: pos, len: c.len, seq: blockSeq, qual: blockQuals, gapType: gapType});\r\n                        seqOffset += c.len;\r\n                        pos += c.len;\r\n\r\n                        break;\r\n\r\n                    default :\r\n                        console.log(\"Error processing cigar element: \" + c.len + c.ltr);\r\n                }\r\n            }\r\n\r\n            return {blocks: blocks, insertions: insertions};\r\n\r\n        }\r\n    }\r\n\r\n    readHeader() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            getIndex(self).then(function (index) {\r\n\r\n                var len = index.firstAlignmentBlock + MAX_GZIP_BLOCK_SIZE;   // Insure we get the complete compressed block containing the header\r\n\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.bamPath,\r\n                    {\r\n                        headers: self.config.headers,\r\n\r\n                        range: {start: 0, size: len},\r\n\r\n                        withCredentials: self.config.withCredentials\r\n                    }).then(function (compressedBuffer) {\r\n\r\n                    var unc = new unbgzf(compressedBuffer, len),\r\n                        uncba = new Uint8Array(unc),\r\n                        magic = readInt(uncba, 0),\r\n                        samHeaderLen = readInt(uncba, 4),\r\n                        samHeader = '',\r\n                        genome = null;\r\n\r\n                    for (var i = 0; i < samHeaderLen; ++i) {\r\n                        samHeader += String.fromCharCode(uncba[i + 8]);\r\n                    }\r\n\r\n                    var nRef = readInt(uncba, samHeaderLen + 8);\r\n                    var p = samHeaderLen + 12;\r\n\r\n                    self.chrToIndex = {};\r\n                    self.indexToChr = [];\r\n                    for (var i = 0; i < nRef; ++i) {\r\n                        var lName = readInt(uncba, p);\r\n                        var name = '';\r\n                        for (var j = 0; j < lName - 1; ++j) {\r\n                            name += String.fromCharCode(uncba[p + 4 + j]);\r\n                        }\r\n                        var lRef = readInt(uncba, p + lName + 4);\r\n                        //dlog(name + ': ' + lRef);\r\n\r\n                        if (genome && genome.getChromosomeName) {\r\n                            name = genome.getChromosomeName(name);\r\n                        }\r\n\r\n                        self.chrToIndex[name] = i;\r\n                        self.indexToChr.push(name);\r\n\r\n                        p = p + 8 + lName;\r\n                    }\r\n\r\n                    fulfill();\r\n\r\n                }).catch(reject);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n}\r\n    function getIndex(bam) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (bam.index) {\r\n                fulfill(bam.index);\r\n            }\r\n            else {\r\n                loadBamIndex(bam.baiPath, bam.config).then(function (index) {\r\n                    bam.index = index;\r\n\r\n                    fulfill(bam.index);\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    function getChrIndex(bam) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (bam.chrToIndex) {\r\n                fulfill(bam.chrToIndex);\r\n            }\r\n            else {\r\n                bam.readHeader().then(function () {\r\n                    fulfill(bam.chrToIndex);\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n    function readInt(ba, offset) {\r\n        return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);\r\n    }\r\n\r\n    function readShort(ba, offset) {\r\n        return (ba[offset + 1] << 8) | (ba[offset]);\r\n    }\r\n\r\n\r\n\r\n\r\nclass BamSource{\r\n    constructor(config) {\r\n\r\n        this.config = config;\r\n        this.alignmentContainer = undefined;\r\n        this.maxRows = config.maxRows || 1000;\r\n        this.sequence_source=new _feature_js__WEBPACK_IMPORTED_MODULE_3__[\"FastaSequence\"](config.seq_url);\r\n\r\n        if (config.sourceType === \"ga4gh\") {\r\n            this.bamReader = new igv.Ga4ghAlignmentReader(config);\r\n        }\r\n        else {\r\n            this.bamReader = new BamReader(config);\r\n        }\r\n\r\n       this.viewAsPairs = config.viewAsPairs;\r\n    };\r\n\r\n    setViewAsPairs(bool) {\r\n        var self = this;\r\n\r\n        if (this.viewAsPairs !== bool) {\r\n            this.viewAsPairs = bool;\r\n            // TODO -- repair alignments\r\n            if (this.alignmentContainer) {\r\n                var alignmentContainer = this.alignmentContainer,\r\n                    alignments;\r\n\r\n                if (bool) {\r\n                    alignments = pairAlignments(alignmentContainer.packedAlignmentRows);\r\n                }\r\n                else {\r\n                    alignments = unpairAlignments(alignmentContainer.packedAlignmentRows);\r\n                }\r\n                alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, self.maxRows);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    getAlignments(chr, bpStart, bpEnd) {\r\n\r\n        var self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.alignmentContainer && self.alignmentContainer.contains(chr, bpStart, bpEnd)) {\r\n                fulfill(self.alignmentContainer);\r\n            } else {\r\n\r\n                self.bamReader.readAlignments(chr, bpStart, bpEnd).then(function (alignmentContainer) {\r\n\r\n                    var maxRows = self.config.maxRows || 500,\r\n                        alignments = alignmentContainer.alignments;\r\n\r\n                    if (!self.viewAsPairs) {\r\n                        alignments = unpairAlignments([{alignments: alignments}]);\r\n                    }\r\n\r\n                    alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, maxRows);\r\n\r\n\r\n                    alignmentContainer.alignments = undefined;  // Don't need to hold onto these anymore\r\n                    self.alignmentContainer = alignmentContainer;\r\n\r\n                   self.sequence_source.getSequence(alignmentContainer.chr, alignmentContainer.start, alignmentContainer.end).then(\r\n                        function (sequence) {\r\n\r\n\r\n                            if (sequence) {\r\n\r\n                                alignmentContainer.coverageMap.refSeq = sequence;    // TODO -- fix this\r\n                                alignmentContainer.sequence = sequence;           // TODO -- fix this\r\n\r\n\r\n                                fulfill(alignmentContainer);\r\n                            }\r\n                        }).catch(reject);\r\n\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n    function pairAlignments(rows) {\r\n\r\n        var pairCache = {},\r\n            result = [];\r\n\r\n        rows.forEach(function (row) {\r\n\r\n            row.alignments.forEach(function (alignment) {\r\n\r\n                var pairedAlignment;\r\n\r\n                if (canBePaired(alignment)) {\r\n\r\n                    pairedAlignment = pairCache[alignment.readName];\r\n                    if (pairedAlignment) {\r\n                        pairedAlignment.setSecondAlignment(alignment);\r\n                        pairCache[alignment.readName] = undefined;   // Don't need to track this anymore.\r\n                    }\r\n                    else {\r\n                        pairedAlignment = new igv.PairedAlignment(alignment);\r\n                        pairCache[alignment.readName] = pairedAlignment;\r\n                        result.push(pairedAlignment);\r\n                    }\r\n                }\r\n\r\n                else {\r\n                    result.push(alignment);\r\n                }\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function unpairAlignments(rows) {\r\n        var result = [];\r\n        rows.forEach(function (row) {\r\n            row.alignments.forEach(function (alignment) {\r\n                if (alignment instanceof PairedAlignment) {\r\n                    if (alignment.firstAlignment) result.push(alignment.firstAlignment);  // shouldn't need the null test\r\n                    if (alignment.secondAlignment) result.push(alignment.secondAlignment);\r\n\r\n                }\r\n                else {\r\n                    result.push(alignment);\r\n                }\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n\r\n    function canBePaired(alignment) {\r\n        return alignment.isPaired() &&\r\n            alignment.isMateMapped() &&\r\n            alignment.chr === alignment.mate.chr &&\r\n            (alignment.isFirstOfPair() || alignment.isSecondOfPair()) && !(alignment.isSecondary() || alignment.isSupplementary());\r\n    }\r\n\r\n\r\n    function packAlignmentRows(alignments, start, end, maxRows) {\r\n\r\n        if (!alignments) return;\r\n\r\n        alignments.sort(function (a, b) {\r\n            return a.start - b.start;\r\n        });\r\n\r\n        if (alignments.length === 0) {\r\n\r\n            return [];\r\n\r\n        } else {\r\n\r\n            var bucketList = [],\r\n                allocatedCount = 0,\r\n                lastAllocatedCount = 0,\r\n                nextStart = start,\r\n                alignmentRow,\r\n                index,\r\n                bucket,\r\n                alignment,\r\n                alignmentSpace = 4 * 2,\r\n                packedAlignmentRows = [],\r\n                bucketStart = Math.max(start, alignments[0].start);\r\n\r\n            alignments.forEach(function (alignment) {\r\n\r\n                var buckListIndex = Math.max(0, alignment.start - bucketStart);\r\n                if (bucketList[buckListIndex] === undefined) {\r\n                    bucketList[buckListIndex] = [];\r\n                }\r\n                bucketList[buckListIndex].push(alignment);\r\n            });\r\n\r\n\r\n            while (allocatedCount < alignments.length && packedAlignmentRows.length < maxRows) {\r\n\r\n                alignmentRow = new BamAlignmentRow();\r\n\r\n                while (nextStart <= end) {\r\n\r\n                    bucket = undefined;\r\n\r\n                    while (!bucket && nextStart <= end) {\r\n\r\n                        index = nextStart - bucketStart;\r\n                        if (bucketList[index] === undefined) {\r\n                            ++nextStart;                     // No alignments at this index\r\n                        } else {\r\n                            bucket = bucketList[index];\r\n                        }\r\n\r\n                    } // while (bucket)\r\n\r\n                    if (!bucket) {\r\n                        break;\r\n                    }\r\n                    alignment = bucket.pop();\r\n                    if (0 === bucket.length) {\r\n                        bucketList[index] = undefined;\r\n                    }\r\n\r\n                    alignmentRow.alignments.push(alignment);\r\n                    nextStart = alignment.start + alignment.lengthOnRef + alignmentSpace;\r\n                    ++allocatedCount;\r\n\r\n                } // while (nextStart)\r\n\r\n                if (alignmentRow.alignments.length > 0) {\r\n                    packedAlignmentRows.push(alignmentRow);\r\n                }\r\n\r\n                nextStart = bucketStart;\r\n\r\n                if (allocatedCount === lastAllocatedCount) break;   // Protect from infinite loops\r\n\r\n                lastAllocatedCount = allocatedCount;\r\n\r\n            } // while (allocatedCount)\r\n\r\n            return packedAlignmentRows;\r\n        }\r\n    }\r\n\r\n\r\n\r\nclass BamAlignment{\r\n    constructor(){\r\n        this.hidden = false;\r\n    }\r\n\r\n    isMapped() {\r\n        return (this.flags & READ_UNMAPPED_FLAG) == 0;\r\n    }\r\n\r\n    isPaired () {\r\n        return (this.flags & READ_PAIRED_FLAG) != 0;\r\n    }\r\n\r\n    isProperPair () {\r\n        return (this.flags & PROPER_PAIR_FLAG) != 0;\r\n    }\r\n\r\n    isFirstOfPair() {\r\n        return (this.flags & FIRST_OF_PAIR_FLAG) != 0;\r\n    }\r\n\r\n    isSecondOfPair() {\r\n        return (this.flags & SECOND_OF_PAIR_FLAG) != 0;\r\n    }\r\n\r\n    isSecondary() {\r\n        return (this.flags & SECONDARY_ALIGNMNET_FLAG) != 0;\r\n    }\r\n\r\n    isSupplementary() {\r\n        return (this.flags & SUPPLEMENTARY_ALIGNMENT_FLAG) != 0;\r\n    }\r\n\r\n    isFailsVendorQualityCheck() {\r\n        return (this.flags & READ_FAILS_VENDOR_QUALITY_CHECK_FLAG) != 0;\r\n    }\r\n\r\n    isDuplicate() {\r\n        return (this.flags & DUPLICATE_READ_FLAG) != 0;\r\n    }\r\n\r\n    isMateMapped() {\r\n        return (this.flags & MATE_UNMAPPED_FLAG) == 0;\r\n    }\r\n\r\n    isNegativeStrand() {\r\n        return (this.flags & READ_STRAND_FLAG) != 0;\r\n    }\r\n\r\n    isMateNegativeStrand() {\r\n        return (this.flags & MATE_STRAND_FLAG) != 0;\r\n    }\r\n\r\n    tags() {\r\n\r\n        function decodeTags(ba) {\r\n\r\n            var p = 0,\r\n                len = ba.length,\r\n                tags = {};\r\n\r\n            while (p < len) {\r\n                var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);\r\n                var type = String.fromCharCode(ba[p + 2]);\r\n                var value;\r\n\r\n                if (type == 'A') {\r\n                    value = String.fromCharCode(ba[p + 3]);\r\n                    p += 4;\r\n                } else if (type === 'i' || type === 'I') {\r\n                    value = readInt(ba, p + 3);\r\n                    p += 7;\r\n                } else if (type === 'c' || type === 'C') {\r\n                    value = ba[p + 3];\r\n                    p += 4;\r\n                } else if (type === 's' || type === 'S') {\r\n                    value = readShort(ba, p + 3);\r\n                    p += 5;\r\n                } else if (type === 'f') {\r\n                    // TODO 'FIXME need floats';\r\n                    value = readFloat(ba, p + 3);\r\n                    p += 7;\r\n                } else if (type === 'Z') {\r\n                    p += 3;\r\n                    value = '';\r\n                    for (; ;) {\r\n                        var cc = ba[p++];\r\n                        if (cc === 0) {\r\n                            break;\r\n                        } else {\r\n                            value += String.fromCharCode(cc);\r\n                        }\r\n                    }\r\n                } else {\r\n                    //'Unknown type ' + type;\r\n                    value = 'Error unknown type: ' + type;\r\n                    tags[tag] = value;\r\n                    break;\r\n                }\r\n                tags[tag] = value;\r\n            }\r\n            return tags;\r\n        }\r\n\r\n        if (!this.tagDict) {\r\n            if (this.tagBA) {\r\n                this.tagDict = decodeTags(this.tagBA);\r\n                this.tagBA = undefined;\r\n            } else {\r\n                this.tagDict = {};  // Mark so we don't try again.  The record has not tags\r\n            }\r\n        }\r\n        return this.tagDict;\r\n\r\n    }\r\n\r\n    popupData(genomicLocation) {\r\n\r\n        // if the user clicks on a base next to an insertion, show just the\r\n        // inserted bases in a popup (like in desktop IGV).\r\n        var nameValues = [], isFirst, tagDict;\r\n\r\n        if(this.insertions) {\r\n            for(var i = 0; i < this.insertions.length; i += 1) {\r\n                var ins_start = this.insertions[i].start;\r\n                if(genomicLocation == ins_start || genomicLocation == ins_start - 1) {\r\n                    nameValues.push({name: 'Insertion', value: this.insertions[i].seq });\r\n                    nameValues.push({name: 'Location', value: ins_start });\r\n                    return nameValues;\r\n                }\r\n            }\r\n        }\r\n\r\n        nameValues.push({ name: 'Read Name', value: this.readName });\r\n\r\n        // Sample\r\n        // Read group\r\n        nameValues.push(\"<hr>\");\r\n\r\n        // Add 1 to genomic location to map from 0-based computer units to user-based units\r\n        nameValues.push({ name: 'Alignment Start', value: igv.numberFormatter(1 + this.start), borderTop: true });\r\n\r\n        nameValues.push({ name: 'Read Strand', value: (true === this.strand ? '(+)' : '(-)'), borderTop: true });\r\n        nameValues.push({ name: 'Cigar', value: this.cigar });\r\n        nameValues.push({ name: 'Mapped', value: yesNo(this.isMapped()) });\r\n        nameValues.push({ name: 'Mapping Quality', value: this.mq });\r\n        nameValues.push({ name: 'Secondary', value: yesNo(this.isSecondary()) });\r\n        nameValues.push({ name: 'Supplementary', value: yesNo(this.isSupplementary()) });\r\n        nameValues.push({ name: 'Duplicate', value: yesNo(this.isDuplicate()) });\r\n        nameValues.push({ name: 'Failed QC', value: yesNo(this.isFailsVendorQualityCheck()) });\r\n\r\n        if (this.isPaired()) {\r\n            nameValues.push(\"<hr>\");\r\n            nameValues.push({ name: 'First in Pair', value: !this.isSecondOfPair(), borderTop: true });\r\n            nameValues.push({ name: 'Mate is Mapped', value: yesNo(this.isMateMapped()) });\r\n            if (this.isMateMapped()) {\r\n                nameValues.push({ name: 'Mate Chromosome', value: this.mate.chr });\r\n                nameValues.push({ name: 'Mate Start', value: (this.mate.position + 1)});\r\n                nameValues.push({ name: 'Mate Strand', value: (true === this.mate.strand ? '(+)' : '(-)')});\r\n                nameValues.push({ name: 'Insert Size', value: this.fragmentLength });\r\n                // Mate Start\r\n                // Mate Strand\r\n                // Insert Size\r\n            }\r\n            // First in Pair\r\n            // Pair Orientation\r\n\r\n        }\r\n\r\n        nameValues.push(\"<hr>\");\r\n        tagDict = this.tags();\r\n        isFirst = true;\r\n        for (var key in tagDict) {\r\n\r\n            if (tagDict.hasOwnProperty(key)) {\r\n\r\n                if (isFirst) {\r\n                    nameValues.push({ name: key, value: tagDict[key], borderTop: true });\r\n                    isFirst = false;\r\n                } else {\r\n                    nameValues.push({ name: key, value: tagDict[key] });\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return nameValues;\r\n\r\n\r\n        function yesNo(bool) {\r\n            return bool ? 'Yes' : 'No';\r\n        }\r\n    }\r\n}\r\n\r\n\r\n   \r\n\r\n   \r\n\r\n    function readFloat(ba, offset) {\r\n\r\n        var dataView = new DataView(ba.buffer),\r\n            littleEndian = true;\r\n\r\n        return dataView.getFloat32(offset, littleEndian);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\nclass BamFilter{\r\n\r\n  constructor (options) {\r\n        if (!options) options = {};\r\n        this.vendorFailed = options.vendorFailed === undefined ? true : options.vendorFailed;\r\n        this.duplicates = options.duplicates === undefined ? true : options.duplicates;\r\n        this.secondary = options.secondary || false;\r\n        this.supplementary = options.supplementary || false;\r\n        this.mqThreshold = options.mqThreshold === undefined ? 0 : options.mqThreshold;\r\n    }\r\n\r\n    pass(alignment) {\r\n\r\n        if (this.vendorFailed && alignment.isFailsVendorQualityCheck()) return false;\r\n        if (this.duplicates && alignment.isDuplicate()) return false;\r\n        if (this.secondary && alignment.isSecondary()) return false;\r\n        if (this.supplementary && alignment.isSupplementary()) return false;\r\n        if (alignment.mq < this.mqThreshold) return false;\r\n\r\n        return true;\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n    var BLOCK_HEADER_LENGTH = 18;\r\n    var BLOCK_LENGTH_OFFSET = 16;  // Location in the gzip block of the total block size (actually total block size - 1)\r\n    var BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\r\n    var MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\r\n    var GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\r\n    var GZIP_ID1 = 31;   // Magic number\r\n    var GZIP_ID2 = 139;  // Magic number\r\n    var GZIP_FLG = 4; // FEXTRA flag means there are optional fields\r\n\r\n\r\n    // Uncompress data,  assumed to be series of bgzipped blocks\r\n    // Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\r\nclass unbgzf{\r\n    constructor(data, lim) {\r\n        for (let a in data){\r\n           console.log(a);\r\n         }\r\n        var oBlockList = [],\r\n            ptr = [0],\r\n            totalSize = 0;\r\n\r\n        lim = lim || data.byteLength - 18;\r\n\r\n        while (ptr[0] < lim) {\r\n\r\n            var ba = new Uint8Array(data, ptr[0], 18);\r\n\r\n            var xlen = (ba[11] << 8) | (ba[10]);\r\n            var si1 = ba[12];\r\n            var si2 = ba[13];\r\n            var slen = (ba[15] << 8) | (ba[14]);\r\n            var bsize = (ba[17] << 8) | (ba[16]) + 1;\r\n\r\n            var start = 12 + xlen + ptr[0];    // Start of CDATA\r\n            var length = data.byteLength - start;\r\n\r\n            if (length < (bsize + 8)) break;\r\n\r\n            var unc = Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__[\"jszlib_inflate_buffer\"])(data, start, length, ptr);\r\n\r\n            ptr[0] += 8;    // Skipping CRC-32 and size of uncompressed data\r\n\r\n            totalSize += unc.byteLength;\r\n            oBlockList.push(unc);\r\n        }\r\n\r\n        // Concatenate decompressed blocks\r\n        if (oBlockList.length == 1) {\r\n            return oBlockList[0];\r\n        } else {\r\n            var out = new Uint8Array(totalSize);\r\n            var cursor = 0;\r\n            for (var i = 0; i < oBlockList.length; ++i) {\r\n                var b = new Uint8Array(oBlockList[i]);\r\n                Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_2__[\"arrayCopy\"])(b, 0, out, cursor, b.length);\r\n                cursor += b.length;\r\n            }\r\n            return out.buffer;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nclass AlignmentContainer{\r\n    constructor(chr, start, end, samplingWindowSize, samplingDepth, pairsSupported) {\r\n\r\n        this.chr = chr;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.length = (end - start);\r\n\r\n        this.coverageMap = new CoverageMap(chr, start, end);\r\n        this.alignments = [];\r\n        this.downsampledIntervals = [];\r\n\r\n        this.samplingWindowSize = samplingWindowSize === undefined ? 100 : samplingWindowSize;\r\n        this.samplingDepth = samplingDepth === undefined ? 50 : samplingDepth;\r\n\r\n        this.pairsSupported = pairsSupported;\r\n        this.paired = false;  // false until proven otherwise\r\n        this.pairsCache = {};  // working cache of paired alignments by read name\r\n\r\n        this.downsampledReads = new Set();\r\n\r\n        this.currentBucket = new DownsampleBucket(this.start, this.start + this.samplingWindowSize, this);\r\n\r\n        this.filter = function filter(alignment) {         // TODO -- pass this in\r\n            return alignment.isMapped() && !alignment.isFailsVendorQualityCheck();\r\n        }\r\n\r\n    }\r\n\r\n    push(alignment) {\r\n\r\n        if (this.filter(alignment) === false) return;\r\n\r\n        this.coverageMap.incCounts(alignment);   // Count coverage before any downsampling\r\n\r\n        if (this.pairsSupported && this.downsampledReads.has(alignment.readName)) {\r\n            return;   // Mate already downsampled -- pairs are treated as a single alignment for downsampling\r\n        }\r\n\r\n        if (alignment.start >= this.currentBucket.end) {\r\n            finishBucket.call(this);\r\n            this.currentBucket = new DownsampleBucket(alignment.start, alignment.start + this.samplingWindowSize, this);\r\n        }\r\n\r\n        this.currentBucket.addAlignment(alignment);\r\n\r\n    }\r\n\r\n    forEach(callback) {\r\n        this.alignments.forEach(callback);\r\n    }\r\n\r\n    finish() {\r\n\r\n        if (this.currentBucket !== undefined) {\r\n            finishBucket.call(this);\r\n        }\r\n\r\n        // Need to remove partial pairs whose mate was downsampled\r\n        if(this.pairsSupported) {\r\n            var tmp = [], ds = this.downsampledReads;\r\n\r\n            this.alignments.forEach(function (a) {\r\n                if (!ds.has(a.readName)) {\r\n                    tmp.push(a);\r\n                }\r\n            })\r\n            this.alignments = tmp;\r\n        }\r\n\r\n        this.alignments.sort(function (a, b) {\r\n            return a.start - b.start\r\n        });\r\n\r\n        this.pairsCache = undefined;\r\n        this.downsampledReads = undefined;\r\n    }\r\n\r\n    contains(chr, start, end) {\r\n        return this.chr == chr &&\r\n            this.start <= start &&\r\n            this.end >= end;\r\n    }\r\n\r\n    hasDownsampledIntervals() {\r\n        return this.downsampledIntervals && this.downsampledIntervals.length > 0;\r\n    }\r\n}\r\n    function finishBucket() {\r\n        this.alignments = this.alignments.concat(this.currentBucket.alignments);\r\n        if (this.currentBucket.downsampledCount > 0) {\r\n            this.downsampledIntervals.push(new DownsampledInterval(\r\n                this.currentBucket.start,\r\n                this.currentBucket.end,\r\n                this.currentBucket.downsampledCount));\r\n        }\r\n        this.paired = this.paired || this.currentBucket.paired;\r\n    }\r\n\r\nclass DownsampleBucket{\r\n    constructor(start, end, alignmentContainer) {\r\n\r\n        this.start = start;\r\n        this.end = end;\r\n        this.alignments = [];\r\n        this.downsampledCount = 0;\r\n        this.samplingDepth = alignmentContainer.samplingDepth;\r\n        this.pairsSupported = alignmentContainer.pairsSupported;\r\n        this.downsampledReads = alignmentContainer.downsampledReads;\r\n        this.pairsCache = alignmentContainer.pairsCache;\r\n    }\r\n\r\n    addAlignment(alignment) {\r\n\r\n        var samplingProb, idx, replacedAlignment, pairedAlignment;\r\n\r\n        if (this.alignments.length < this.samplingDepth) {\r\n\r\n            if (this.pairsSupported && canBePaired(alignment)) {\r\n                pairedAlignment = this.pairsCache[alignment.readName];\r\n                if (pairedAlignment) {\r\n                    //Not subject to downsampling, just update the existing alignment\r\n                    pairedAlignment.setSecondAlignment(alignment);\r\n                    this.pairsCache[alignment.readName] = undefined;   // Don't need to track this anymore. NOTE: Don't \"delete\", causes runtime performance issues\r\n                }\r\n                else {\r\n                    // First alignment in a pair\r\n                    pairedAlignment = new PairedAlignment(alignment);\r\n                    this.paired = true;\r\n                    this.pairsCache[alignment.readName] = pairedAlignment;\r\n                    this.alignments.push(pairedAlignment);\r\n                }\r\n            }\r\n            else {\r\n                this.alignments.push(alignment);\r\n            }\r\n\r\n        } else {\r\n\r\n            samplingProb = this.samplingDepth / (this.samplingDepth + this.downsampledCount + 1);\r\n\r\n            if (Math.random() < samplingProb) {\r\n\r\n                idx = Math.floor(Math.random() * (this.alignments.length - 1));\r\n                replacedAlignment = this.alignments[idx];   // To be replaced\r\n\r\n                if (this.pairsSupported && canBePaired(alignment)) {\r\n\r\n                    if(this.pairsCache[replacedAlignment.readName] !== undefined) {\r\n                        this.pairsCache[replacedAlignment.readName] = undefined;\r\n                    }\r\n\r\n                    pairedAlignment = new PairedAlignment(alignment);\r\n                    this.paired = true;\r\n                    this.pairsCache[alignment.readName] = pairedAlignment;\r\n                    this.alignments[idx] = pairedAlignment;\r\n\r\n                }\r\n                else {\r\n                    this.alignments[idx] = alignment;\r\n                }\r\n                this.downsampledReads.add(replacedAlignment.readName);\r\n\r\n            }\r\n            else {\r\n                this.downsampledReads.add(alignment.readName);\r\n            }\r\n\r\n            this.downsampledCount++;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\n    // TODO -- refactor this to use an object, rather than an array,  if end-start is > some threshold\r\nclass CoverageMap{\r\n    constructor(chr, start, end) {\r\n\r\n        this.chr = chr;\r\n        this.bpStart = start;\r\n        this.length = (end - start);\r\n\r\n        this.coverage = new Array(this.length);\r\n\r\n        this.maximum = 0;\r\n\r\n       \r\n    }\r\n\r\n    incCounts(alignment) {\r\n\r\n        var self = this;\r\n\r\n        if (alignment.blocks === undefined) {\r\n\r\n            incBlockCount(alignment);\r\n        }\r\n        else {\r\n            alignment.blocks.forEach(function (block) {\r\n                incBlockCount(block);\r\n            });\r\n        }\r\n\r\n        function incBlockCount(block) {\r\n\r\n            var key,\r\n                base,\r\n                i,\r\n                j,\r\n                q;\r\n\r\n            for (i = block.start - self.bpStart, j = 0; j < block.len; i++, j++) {\r\n\r\n                if (!self.coverage[i]) {\r\n                    self.coverage[i] = new Coverage();\r\n                }\r\n\r\n                base = block.seq.charAt(j);\r\n                key = (alignment.strand) ? \"pos\" + base : \"neg\" + base;\r\n                q = block.qual[j];\r\n\r\n                self.coverage[i][key] += 1;\r\n                self.coverage[i][\"qual\" + base] += q;\r\n\r\n                self.coverage[i].total += 1;\r\n                self.coverage[i].qual += q;\r\n\r\n                self.maximum = Math.max(self.coverage[i].total, self.maximum);\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nCoverageMap.threshold = 0.2;\r\nCoverageMap.qualityWeight = true;\r\n\r\nclass Coverage{\r\n    constructor() {\r\n        this.posA = 0;\r\n        this.negA = 0;\r\n\r\n        this.posT = 0;\r\n        this.negT = 0;\r\n\r\n        this.posC = 0;\r\n        this.negC = 0;\r\n        this.posG = 0;\r\n\r\n        this.negG = 0;\r\n\r\n        this.posN = 0;\r\n        this.negN = 0;\r\n\r\n        this.pos = 0;\r\n        this.neg = 0;\r\n\r\n        this.qualA = 0;\r\n        this.qualT = 0;\r\n        this.qualC = 0;\r\n        this.qualG = 0;\r\n        this.qualN = 0;\r\n\r\n        this.qual = 0;\r\n\r\n        this.total = 0;\r\n    }\r\n\r\n    isMismatch(refBase) {\r\n\r\n        var myself = this,\r\n            mismatchQualitySum,\r\n            threshold = CoverageMap.threshold * ((CoverageMap.qualityWeight && this.qual) ? this.qual : this.total);\r\n\r\n        mismatchQualitySum = 0;\r\n        [\"A\", \"T\", \"C\", \"G\"].forEach(function (base) {\r\n\r\n            if (base !== refBase) {\r\n                mismatchQualitySum += ((CoverageMap.qualityWeight && myself.qual) ? myself[\"qual\" + base] : (myself[\"pos\" + base] + myself[\"neg\" + base]));\r\n            }\r\n        });\r\n\r\n        return mismatchQualitySum >= threshold;\r\n\r\n    }\r\n}\r\n\r\nclass DownsampledInterval{\r\n    constructor(start, end, counts) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.counts = counts;\r\n    }\r\n\r\n    popupData(genomicLocation) {\r\n        return [\r\n            {name: \"start\", value: this.start + 1},\r\n            {name: \"end\", value: this.end},\r\n            {name: \"# downsampled:\", value: this.counts}]\r\n    }\r\n}\r\n\r\n\r\nclass PairedAlignment{\r\n    constructor(firstAlignment) {\r\n\r\n        this.firstAlignment = firstAlignment;\r\n        this.chr = firstAlignment.chr;\r\n        this.readName = firstAlignment.readName;\r\n\r\n        if (firstAlignment.start < firstAlignment.mate.position) {\r\n            this.start = firstAlignment.start;\r\n            this.end = Math.max(firstAlignment.mate.position, firstAlignment.start + firstAlignment.lengthOnRef);  // Approximate\r\n            this.connectingStart = firstAlignment.start + firstAlignment.lengthOnRef;\r\n            this.connectingEnd = firstAlignment.mate.position;\r\n        }\r\n        else {\r\n            this.start = firstAlignment.mate.position;\r\n            this.end = firstAlignment.start + firstAlignment.lengthOnRef;\r\n            this.connectingStart = firstAlignment.mate.position;\r\n            this.connectingEnd = firstAlignment.start;\r\n        }\r\n        this.lengthOnRef = this.end - this.start;\r\n\r\n    }\r\n\r\n    setSecondAlignment(alignment) {\r\n\r\n        // TODO -- check the chrs are equal,  error otherwise\r\n        this.secondAlignment = alignment;\r\n\r\n        if (alignment.start > this.firstAlignment.start) {\r\n            this.end = alignment.start + alignment.lengthOnRef;\r\n            this.connectingEnd = alignment.start;\r\n        }\r\n        else {\r\n            this.start = alignment.start;\r\n            this.connectingStart = alignment.start + alignment.lengthOnRef;\r\n        }\r\n        this.lengthOnRef = this.end - this.start;\r\n\r\n\r\n    }\r\n\r\n    popupData(genomicLocation) {\r\n\r\n        var nameValues = [];\r\n\r\n        nameValues = nameValues.concat(this.firstAlignment.popupData(genomicLocation));\r\n\r\n        if (this.secondAlignment) {\r\n            nameValues.push(\"-------------------------------\");\r\n            nameValues = nameValues.concat(this.secondAlignment.popupData(genomicLocation));\r\n        }\r\n        return nameValues;\r\n    }\r\n\r\n    isPaired () {\r\n        return true; // By definition\r\n    }\r\n\r\n    firstOfPairStrand () {\r\n        if (this.firstAlignment.isFirstOfPair()) {\r\n            return this.firstAlignment.strand;\r\n        }\r\n        else if (this.secondAlignment) {\r\n            return this.secondAlignment.strand;\r\n        }\r\n        else {\r\n            return this.firstAlignment.strand;          // This assumes inward pointing pairs\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass BamAlignmentRow {\r\n    constructor(){\r\n        this.alignments = [];\r\n        this.score = undefined;\r\n    }\r\n\r\n    findCenterAlignment(bpStart, bpEnd) {\r\n\r\n        var centerAlignment = undefined;\r\n\r\n        // find single alignment that overlaps sort location\r\n        this.alignments.forEach(function(a){\r\n\r\n            if (undefined === centerAlignment) {\r\n\r\n                if ((a.start + a.lengthOnRef) < bpStart || a.start > bpEnd) {\r\n                    // do nothing\r\n                } else {\r\n                    centerAlignment = a;\r\n                }\r\n\r\n            }\r\n\r\n        });\r\n\r\n        return centerAlignment;\r\n    }\r\n\r\n    updateScore(genomicLocation, genomicInterval, sortOption) {\r\n\r\n        this.score = this.caculateScore(genomicLocation, (1 + genomicLocation), genomicInterval, sortOption);\r\n\r\n    };\r\n\r\n    caculateScore(bpStart, bpEnd, genomicInterval, sortOption) {\r\n\r\n        var baseScore,\r\n            alignment;\r\n\r\n        alignment = this.findCenterAlignment(bpStart, bpEnd);\r\n        if (undefined === alignment) {\r\n            return Number.MAX_VALUE;\r\n        }\r\n\r\n        if (\"NUCLEOTIDE\" === sortOption.sort) {\r\n\r\n            baseScore = undefined;\r\n\r\n            alignment.blocks.forEach(function (block) {\r\n\r\n                var sequence = genomicInterval.sequence,\r\n                    coverageMap = genomicInterval.coverageMap,\r\n                    reference,\r\n                    base,\r\n                    coverage,\r\n                    count,\r\n                    phred;\r\n\r\n                if (\"*\" !== block.seq) {\r\n\r\n                    for (var i = 0, indexReferenceSequence = block.start - genomicInterval.start, bpBlockSequence = block.start, lengthBlockSequence = block.seq.length;\r\n                         i < lengthBlockSequence;\r\n                         i++, indexReferenceSequence++, bpBlockSequence++) {\r\n\r\n                        if (bpStart === bpBlockSequence) {\r\n\r\n                            reference = sequence.charAt(indexReferenceSequence);\r\n                            base = block.seq.charAt(i);\r\n\r\n                            if (base === \"=\") {\r\n                                base = reference;\r\n                            }\r\n\r\n                            if (base === 'N') {\r\n                                baseScore = 2;\r\n                            }\r\n                            else if (base === reference) {\r\n                                baseScore = 3;\r\n                            }\r\n                            else if (base === \"X\" || base !== reference){\r\n\r\n                                coverage = coverageMap.coverage[ (bpBlockSequence - coverageMap.bpStart) ];\r\n                                count = coverage[ \"pos\" + base ] + coverage[ \"neg\" + base ];\r\n                                phred = (coverage.qual) ? coverage.qual : 0;\r\n                                baseScore = -(count + (phred / 1000.0));\r\n                            } else {\r\n                                console.log(\"BamAlignmentRow.caculateScore - huh?\");\r\n                            }\r\n\r\n                        } // bpStart === bpBlockSequence\r\n\r\n                    } // block.seq.length\r\n\r\n                }\r\n                else {\r\n                    baseScore = 3;\r\n                }\r\n\r\n            });\r\n\r\n            return (undefined === baseScore) ? Number.MAX_VALUE : baseScore;\r\n        }\r\n        else if (\"STRAND\" === sortOption.sort) {\r\n\r\n            return alignment.strand ? 1 : -1;\r\n        }\r\n        else if (\"START\" === sortOption.sort) {\r\n\r\n            return alignment.start;\r\n        }\r\n\r\n        return Number.MAX_VALUE;\r\n\r\n    }\r\n}\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmFtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2JhbS5qcz9jNzU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuaW1wb3J0IHtpZ3Z4aHJ9IGZyb20gXCIuL2lndnhoci5qc1wiO1xyXG5pbXBvcnQge0JpbmFyeVBhcnNlcn0gZnJvbSBcIi4vYmlnd2lnLmpzXCI7XHJcbmltcG9ydCB7anN6bGliX2luZmxhdGVfYnVmZmVyLGFycmF5Q29weX0gZnJvbSBcIi4vdmVuZG9yL2luZmxhdGUuanNcIjtcclxuaW1wb3J0IHtGYXN0YVNlcXVlbmNlfSBmcm9tIFwiLi9mZWF0dXJlLmpzXCJcclxuXHJcblxyXG5jb25zdCBCQUlfTUFHSUMgPSAyMTU3ODA1MDtcclxuY29uc3QgVEFCSVhfTUFHSUMgPSAyMTU3ODMyNDtcclxuY29uc3QgTUFYX0hFQURFUl9TSVpFID0gMTAwMDAwMDAwOyAgIC8vIElGIHRoZSBoZWFkZXIgaXMgbGFyZ2VyIHRoYW4gdGhpcyB3ZSBjYW4ndCByZWFkIGl0ICFcclxuY29uc3QgQl9NQVhfR1pJUF9CTE9DS19TSVpFID0gKDEgPDwgMTYpO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpbmRleFVSTFxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICogQHBhcmFtIHRhYml4XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYSBQcm9taXNlZCBmb3IgdGhlIGJhbSBvciB0YWJpeCBpbmRleC4gIFRoZSBmdWxmaWxsIGZ1bmN0aW9uIHRha2VzIHRoZSBpbmRleCBhcyBhbiBhcmd1bWVudC5cclxuICAgICAqL1xyXG5sZXQgbG9hZEJhbUluZGV4ID0gZnVuY3Rpb24gKGluZGV4VVJMLCBjb25maWcsIHRhYml4KSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2Vub21lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoaW5kZXhVUkwsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBjb25maWcud2l0aENyZWRlbnRpYWxzXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFnaWMsIG5iaW4sIG5pbnR2LCBucmVmLCBwYXJzZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tNaW4gPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTWF4ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBiaW5JbmRleCwgbGluZWFySW5kZXgsIGJpbk51bWJlciwgY3MsIGNlLCBiLCBpLCByZWYsIHNlcXVlbmNlSW5kZXhNYXA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0YWJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlID0gbmV3IFpsaWIuWmxpYi5HdW56aXAobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheUJ1ZmZlciA9IGluZmxhdGUuZGVjb21wcmVzcygpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcikpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hZ2ljID0gcGFyc2VyLmdldEludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYWdpYyA9PT0gQkFJX01BR0lDIHx8ICh0YWJpeCAmJiBtYWdpYyA9PT0gVEFCSVhfTUFHSUMpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5yZWYgPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFiaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFiaXggaGVhZGVyIHBhcmFtZXRlcnMgYXJlbid0IHVzZWQsIGJ1dCB0aGV5IG11c3QgYmUgcmVhZCB0byBhZHZhbmNlIHRoZSBwb2ludGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xfc2VxID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sX2JlZyA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbF9lbmQgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhID0gcGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcCA9IHBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxfbm0gPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUluZGV4TWFwID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBucmVmOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXFfbmFtZSA9IHBhcnNlci5nZXRTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgdG8gXCJvZmZpY2lhbFwiIGNociBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSkgc2VxX25hbWUgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUoc2VxX25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSW5kZXhNYXBbc2VxX25hbWVdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyZWYgPSAwOyByZWYgPCBucmVmOyArK3JlZikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluSW5kZXggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXggPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5iaW4gPSBwYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGIgPSAwOyBiIDwgbmJpbjsgKytiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluTnVtYmVyID0gcGFyc2VyLmdldEludCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5OdW1iZXIgPT0gMzc0NTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHN1ZWRvIGJpbiwgbm90IHVzZWQgYnV0IHdlIGhhdmUgdG8gY29uc3VtZSB0aGUgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuY2huayA9IHBhcnNlci5nZXRJbnQoKTsgLy8gIyBvZiBjaHVua3MgZm9yIHRoaXMgYmluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBwYXJzZXIuZ2V0VlBvaW50ZXIoKTsgICAvLyB1bm1hcHBlZCBiZWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZSA9IHBhcnNlci5nZXRWUG9pbnRlcigpOyAgIC8vIHVubWFwcGVkIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuX21hcGVkID0gcGFyc2VyLmdldExvbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgblVubWFwcGVkID0gcGFyc2VyLmdldExvbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleFtiaW5OdW1iZXJdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5jaG5rID0gcGFyc2VyLmdldEludCgpOyAvLyAjIG9mIGNodW5rcyBmb3IgdGhpcyBiaW5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5jaG5rOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3MgPSBwYXJzZXIuZ2V0VlBvaW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2UgPSBwYXJzZXIuZ2V0VlBvaW50ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzICYmIGNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3MuYmxvY2sgPCBibG9ja01pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTWluID0gY3MuYmxvY2s7ICAgIC8vIEJsb2NrIGNvbnRhaW5pbmcgZmlyc3QgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2UuYmxvY2sgPiBibG9ja01heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTWF4ID0gY2UuYmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleFtiaW5OdW1iZXJdLnB1c2goW2NzLCBjZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmludHYgPSBwYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuaW50djsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IHBhcnNlci5nZXRWUG9pbnRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXgucHVzaChjcyk7ICAgLy8gTWlnaHQgYmUgbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmJpbiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNbcmVmXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5JbmRleDogYmluSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFySW5kZXg6IGxpbmVhckluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoaW5kZXhVUkwgKyBcIiBpcyBub3QgYSBcIiArICh0YWJpeCA/IFwidGFiaXhcIiA6IFwiYmFpXCIpICsgXCIgZmlsZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwobmV3IEJhbUluZGV4KGluZGljZXMsIGJsb2NrTWluLCBzZXF1ZW5jZUluZGV4TWFwLCB0YWJpeCkpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxuY2xhc3MgQmFtSW5kZXh7XHJcbiAgICBjb25zdHJ1Y3RvciAoaW5kaWNlcywgYmxvY2tNaW4sIHNlcXVlbmNlSW5kZXhNYXAsIHRhYml4KSB7XHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudEJsb2NrID0gYmxvY2tNaW47XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcclxuICAgICAgICB0aGlzLnNlcXVlbmNlSW5kZXhNYXAgPSBzZXF1ZW5jZUluZGV4TWFwO1xyXG4gICAgICAgIHRoaXMudGFiaXggPSB0YWJpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGJsb2NrcyBmb3IgYSBwYXJ0aWN1bGFyIGdlbm9taWMgcmFuZ2UuICBUaGlzIG1ldGhvZCBpcyBwdWJsaWMgc28gaXQgY2FuIGJlIHVuaXQtdGVzdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWZJZCAgdGhlIHNlcXVlbmNlIGRpY3Rpb25hcnkgaW5kZXggb2YgdGhlIGNocm9tb3NvbWVcclxuICAgICAqIEBwYXJhbSBtaW4gIGdlbm9taWMgc3RhcnQgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSBtYXggIGdlbm9taWMgZW5kIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gcmV0dXJuIGFuIGFycmF5IG9mIHttaW52OiB7ZmlsZVBvaW50ZXIsIG9mZnNldH0sIHttYXh2OiB7ZmlsZVBvaW50ZXIsIG9mZnNldH19XHJcbiAgICAgKi9cclxuICAgIGJsb2Nrc0ZvclJhbmdlKHJlZklkLCBtaW4sIG1heCkge1xyXG5cclxuICAgICAgICB2YXIgYmFtID0gdGhpcyxcclxuICAgICAgICAgICAgYmEgPSBiYW0uaW5kaWNlc1tyZWZJZF0sXHJcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyxcclxuICAgICAgICAgICAgbGVhZkNodW5rcyxcclxuICAgICAgICAgICAgb3RoZXJDaHVua3MsXHJcbiAgICAgICAgICAgIG5pbnR2LFxyXG4gICAgICAgICAgICBsb3dlc3QsXHJcbiAgICAgICAgICAgIG1pbkxpbixcclxuICAgICAgICAgICAgbWF4TGluLFxyXG4gICAgICAgICAgICBsYixcclxuICAgICAgICAgICAgcHJ1bmVkT3RoZXJDaHVua3MsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGNobmssXHJcbiAgICAgICAgICAgIGRpZixcclxuICAgICAgICAgICAgaW50Q2h1bmtzLFxyXG4gICAgICAgICAgICBtZXJnZWRDaHVua3M7XHJcblxyXG4gICAgICAgIGlmICghYmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nQmlucyA9IEJhbUluZGV4LnJlZzJiaW5zKG1pbiwgbWF4KTsgICAgICAgIC8vIExpc3Qgb2YgYmluICNzIHRoYXQgbWlnaHQgb3ZlcmxhcCBtaW4sIG1heFxyXG4gICAgICAgICAgICBsZWFmQ2h1bmtzID0gW107XHJcbiAgICAgICAgICAgIG90aGVyQ2h1bmtzID0gW107XHJcblxyXG5cclxuICAgICAgICAgICAgb3ZlcmxhcHBpbmdCaW5zLmZvckVhY2goZnVuY3Rpb24gKGJpbikge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiYS5iaW5JbmRleFtiaW5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5jaG5rID0gY2h1bmtzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuY2huazsgKytjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcyA9IGNodW5rc1tjXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlID0gY2h1bmtzW2NdWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYmluIDwgNDY4MSA/IG90aGVyQ2h1bmtzIDogbGVhZkNodW5rcykucHVzaCh7bWludjogY3MsIG1heHY6IGNlLCBiaW46IGJpbn0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBsaW5lYXIgaW5kZXggdG8gZmluZCB0aGUgbG93ZXN0IGNodW5rIHRoYXQgY291bGQgY29udGFpbiBhbGlnbm1lbnRzIGluIHRoZSByZWdpb25cclxuICAgICAgICAgICAgbmludHYgPSBiYS5saW5lYXJJbmRleC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxvd2VzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIG1pbkxpbiA9IE1hdGgubWluKG1pbiA+PiAxNCwgbmludHYgLSAxKSwgbWF4TGluID0gTWF0aC5taW4obWF4ID4+IDE0LCBuaW50diAtIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBtaW5MaW47IGkgPD0gbWF4TGluOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGxiID0gYmEubGluZWFySW5kZXhbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWxvd2VzdCB8fCBsYi5ibG9jayA8IGxvd2VzdC5ibG9jayB8fCBsYi5vZmZzZXQgPCBsb3dlc3Qub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXN0ID0gbGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBydW5lIGNodW5rcyB0aGF0IGVuZCBiZWZvcmUgdGhlIGxvd2VzdCBjaHVua1xyXG4gICAgICAgICAgICBwcnVuZWRPdGhlckNodW5rcyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAobG93ZXN0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdGhlckNodW5rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNobmsgPSBvdGhlckNodW5rc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2huay5tYXh2LmJsb2NrID4gbG93ZXN0LmJsb2NrIHx8IChjaG5rLm1heHYuYmxvY2sgPT0gbG93ZXN0LmJsb2NrICYmIGNobmsubWF4di5vZmZzZXQgPj0gbG93ZXN0Lm9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJ1bmVkT3RoZXJDaHVua3MucHVzaChjaG5rKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludENodW5rcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJ1bmVkT3RoZXJDaHVua3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGludENodW5rcy5wdXNoKHBydW5lZE90aGVyQ2h1bmtzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVhZkNodW5rcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaW50Q2h1bmtzLnB1c2gobGVhZkNodW5rc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludENodW5rcy5zb3J0KGZ1bmN0aW9uIChjMCwgYzEpIHtcclxuICAgICAgICAgICAgICAgIGRpZiA9IGMwLm1pbnYuYmxvY2sgLSBjMS5taW52LmJsb2NrO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZiAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMwLm1pbnYub2Zmc2V0IC0gYzEubWludi5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzID0gW107XHJcbiAgICAgICAgICAgIGlmIChpbnRDaHVua3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1ciA9IGludENodW5rc1swXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaW50Q2h1bmtzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5jID0gaW50Q2h1bmtzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobmMubWludi5ibG9jayAtIGN1ci5tYXh2LmJsb2NrKSA8IDY1MDAwKSB7IC8vIE1lcmdlIGJsb2NrcyB0aGF0IGFyZSB3aXRoaW5nIDY1ayBvZiBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IHttaW52OiBjdXIubWludiwgbWF4djogbmMubWF4dn07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gbmM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgbGlzdCBvZiBiaW5zIHRoYXQgbWF5IG92ZXJsYXAgd2l0aCByZWdpb24gW2JlZywgZW5kXVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlZzJiaW5zKGJlZywgZW5kKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBrLCBsaXN0ID0gW107XHJcbiAgICAgICAgaWYgKGVuZCA+PSAxIDw8IDI5KSAgIGVuZCA9IDEgPDwgMjk7XHJcbiAgICAgICAgLS1lbmQ7XHJcbiAgICAgICAgbGlzdC5wdXNoKDApO1xyXG4gICAgICAgIGZvciAoayA9IDEgKyAoYmVnID4+IDI2KTsgayA8PSAxICsgKGVuZCA+PiAyNik7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDkgKyAoYmVnID4+IDIzKTsgayA8PSA5ICsgKGVuZCA+PiAyMyk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDczICsgKGJlZyA+PiAyMCk7IGsgPD0gNzMgKyAoZW5kID4+IDIwKTsgKytrKSBsaXN0LnB1c2goayk7XHJcbiAgICAgICAgZm9yIChrID0gNTg1ICsgKGJlZyA+PiAxNyk7IGsgPD0gNTg1ICsgKGVuZCA+PiAxNyk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIGZvciAoayA9IDQ2ODEgKyAoYmVnID4+IDE0KTsgayA8PSA0NjgxICsgKGVuZCA+PiAxNCk7ICsraykgbGlzdC5wdXNoKGspO1xyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEJHWkZpbGV7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuZmlsZVBvc2l0aW9uID0gMDtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICBuZXh0QmxvY2soKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5wYXRoLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHtzdGFydDogc2VsZi5maWxlUG9zaXRpb24sIHNpemU6IEJMT0NLX0hFQURFUl9MRU5HVEh9LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogc2VsZi5jb25maWcud2l0aENyZWRlbnRpYWxzXHJcblxyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgICAgIHZhciBzaTEgPSBiYVsxMl07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2kyID0gYmFbMTNdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYnNpemUgPSAoYmFbMTddIDw8IDgpIHwgKGJhWzE2XSkgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZmlsZVBvc2l0aW9uICs9IEJMT0NLX0hFQURFUl9MRU5HVEg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7c3RhcnQ6IHNlbGYuZmlsZVBvc2l0aW9uLCBzaXplOiBic2l6ZX0sXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuXHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGFycmF5QnVmZmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5maWxlUG9zaXRpb24gKz0gKGJzaXplICsgOCk7ICAvLyBcIjhcIiBmb3IgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwodW5jKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpXHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuICAgIHZhciBCQU1fTUFHSUMgPSAyMTg0MDE5NDtcclxuICAgIHZhciBTRUNSRVRfREVDT0RFUiA9IFsnPScsICdBJywgJ0MnLCAneCcsICdHJywgJ3gnLCAneCcsICd4JywgJ1QnLCAneCcsICd4JywgJ3gnLCAneCcsICd4JywgJ3gnLCAnTiddO1xyXG4gICAgdmFyIENJR0FSX0RFQ09ERVIgPSBbJ00nLCAnSScsICdEJywgJ04nLCAnUycsICdIJywgJ1AnLCAnPScsICdYJywgJz8nLCAnPycsICc/JywgJz8nLCAnPycsICc/JywgJz8nXTtcclxuICAgIHZhciBSRUFEX1NUUkFORF9GTEFHID0gMHgxMDtcclxuICAgIHZhciBNQVRFX1NUUkFORF9GTEFHID0gMHgyMDtcclxuICAgIHZhciBGSVJTVF9PRl9QQUlSX0ZMQUcgPSAweDQwO1xyXG4gICAgdmFyIFNFQ09ORF9PRl9QQUlSX0ZMQUcgPSAweDgwO1xyXG4gICAgdmFyIFJFQURfVU5NQVBQRURfRkxBRyA9IDB4NDtcclxuICAgIHZhciBNQVRFX1VOTUFQUEVEX0ZMQUcgPSAweDg7XHJcbiAgICB2YXIgUkVBRF9QQUlSRURfRkxBRyA9IDB4MTtcclxuICAgIHZhciBQUk9QRVJfUEFJUl9GTEFHID0gMHgyO1xyXG4gICAgdmFyIFNFQ09OREFSWV9BTElHTk1ORVRfRkxBRyA9IDB4MTAwO1xyXG4gICAgdmFyIFNVUFBMRU1FTlRBUllfQUxJR05NRU5UX0ZMQUcgPSAweDgwMDtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgTk9UX1BSSU1BUllfQUxJR05NRU5UX0ZMQUcgPSAweDEwMDtcclxuICAgIHZhciBSRUFEX0ZBSUxTX1ZFTkRPUl9RVUFMSVRZX0NIRUNLX0ZMQUcgPSAweDIwMDtcclxuICAgIHZhciBEVVBMSUNBVEVfUkVBRF9GTEFHID0gMHg0MDA7XHJcbiAgICB2YXIgU1VQUExFTUVOVEFSWV9GTEFHID0gMHg4MDA7XHJcblxyXG4gICAgY29uc3QgTUFYX0daSVBfQkxPQ0tfU0laRSA9IDY1NTM2OyAgIC8vICBBUFBBUkVOVExZLiAgV2hlcmUgaXMgdGhpcyBkb2N1bWVudGVkPz8/XHJcbiAgICBjb25zdCBERUZBVUxUX1NBTVBMSU5HX1dJTkRPV19TSVpFID0gMTAwO1xyXG4gICAgY29uc3QgREVGQVVMVF9TQU1QTElOR19ERVBUSCA9IDUwO1xyXG4gICAgY29uc3QgTUFYSU1VTV9TQU1QTElOR19ERVBUSCA9IDI1MDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBmb3IgcmVhZGluZyBhIGJhbSBmaWxlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuIGNsYXNzIEJhbVJlYWRlcntcclxuICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuXHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gY29uZmlnLmZpbHRlciB8fCBuZXcgQmFtRmlsdGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmFtUGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgLy8gVG9kbyAtIGRlYWwgd2l0aCBQaWNhcmQgY29udmVudGlvbi4gIFdIWSBET0VTIFRIRVJFIEhBVkUgVE8gQkUgMj9cclxuICAgICAgICB0aGlzLmJhaVBhdGggPSBjb25maWcuaW5kZXhVUkwgfHwgdGhpcy5iYW1QYXRoICsgXCIuYmFpXCI7IC8vIElmIHRoZXJlIGlzIGFuIGluZGV4VVJMIHByb3ZpZGVkLCB1c2UgaXQhXHJcbiAgICAgICAgdGhpcy5oZWFkUGF0aCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMuYmFtUGF0aDtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdXaW5kb3dTaXplID0gY29uZmlnLnNhbXBsaW5nV2luZG93U2l6ZSA9PT0gdW5kZWZpbmVkID8gREVGQVVMVF9TQU1QTElOR19XSU5ET1dfU0laRSA6IGNvbmZpZy5zYW1wbGluZ1dpbmRvd1NpemU7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gY29uZmlnLnNhbXBsaW5nRGVwdGggPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfU0FNUExJTkdfREVQVEggOiBjb25maWcuc2FtcGxpbmdEZXB0aDtcclxuICAgICAgICBpZih0aGlzLnNhbXBsaW5nRGVwdGggPiBNQVhJTVVNX1NBTVBMSU5HX0RFUFRIKSB7XHJcbiAgICAgICAgICAgIGlndi5sb2coXCJXYXJuaW5nOiBhdHRlbXB0IHRvIHNldCBzYW1wbGluZyBkZXB0aCA+IG1heGltdW0gdmFsdWUgb2YgMjUwMFwiKTtcclxuICAgICAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gTUFYSU1VTV9TQU1QTElOR19ERVBUSDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjb25maWcudmlld0FzUGFpcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhaXJzU3VwcG9ydGVkID0gY29uZmlnLnBhaXJzU3VwcG9ydGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29uZmlnLnBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEFsaWdubWVudHMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG5cclxuICAgICAgICAgICAgZ2V0Q2hySW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoY2hyVG9JbmRleCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjaHJJZCA9IGNoclRvSW5kZXhbY2hyXSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyID0gbmV3IEFsaWdubWVudENvbnRhaW5lcihjaHIsIGJwU3RhcnQsIGJwRW5kLCBzZWxmLnNhbXBsaW5nV2luZG93U2l6ZSwgc2VsZi5zYW1wbGluZ0RlcHRoLCBzZWxmLnBhaXJzU3VwcG9ydGVkKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChjaHJJZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0SW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoYmFtSW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua3MgPSBiYW1JbmRleC5ibG9ja3NGb3JSYW5nZShjaHJJZCwgYnBTdGFydCwgYnBFbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNodW5rcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcIkVycm9yIHJlYWRpbmcgYmFtIGluZGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaE1pbiA9IGMubWludi5ibG9jayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hNYXggPSBjLm1heHYuYmxvY2sgKyBNQVhfR1pJUF9CTE9DS19TSVpFLCAgIC8vIE1ha2Ugc3VyZSB3ZSBnZXQgdGhlIHdob2xlIGJsb2NrLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtzdGFydDogZmV0Y2hNaW4sIHNpemU6IGZldGNoTWF4IC0gZmV0Y2hNaW4gKyAxfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLmJhbVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wcmVzc2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShuZXcgdW5iZ3pmKGNvbXByZXNzZWQpKTsgLy9uZXcgVWludDhBcnJheShpZ3YudW5iZ3pmKGNvbXByZXNzZWQpKTsgLy8sIGMubWF4di5ibG9jayAtIGMubWludi5ibG9jayArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlQmFtUmVjb3JkcyhiYSwgYy5taW52Lm9mZnNldCwgYWxpZ25tZW50Q29udGFpbmVyLCBicFN0YXJ0LCBicEVuZCwgY2hySWQsIHNlbGYuZmlsdGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5maW5pc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYWxpZ25tZW50Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVCYW1SZWNvcmRzKGJhLCBvZmZzZXQsIGFsaWdubWVudENvbnRhaW5lciwgbWluLCBtYXgsIGNocklkLCBmaWx0ZXIpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBibG9ja0VuZCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIGJsb2NrcyxcclxuICAgICAgICAgICAgICAgIHJlZklELFxyXG4gICAgICAgICAgICAgICAgcG9zLFxyXG4gICAgICAgICAgICAgICAgYm1uLFxyXG4gICAgICAgICAgICAgICAgYmluLFxyXG4gICAgICAgICAgICAgICAgbXEsXHJcbiAgICAgICAgICAgICAgICBubCxcclxuICAgICAgICAgICAgICAgIGZsYWdfbmMsXHJcbiAgICAgICAgICAgICAgICBmbGFnLFxyXG4gICAgICAgICAgICAgICAgbmMsXHJcbiAgICAgICAgICAgICAgICBsc2VxLFxyXG4gICAgICAgICAgICAgICAgbWF0ZVJlZklELFxyXG4gICAgICAgICAgICAgICAgbWF0ZVBvcyxcclxuICAgICAgICAgICAgICAgIHJlYWROYW1lLFxyXG4gICAgICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgICAgIHAsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGhPblJlZixcclxuICAgICAgICAgICAgICAgIGNpZ2FyLFxyXG4gICAgICAgICAgICAgICAgYyxcclxuICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXksXHJcbiAgICAgICAgICAgICAgICBzZXEsXHJcbiAgICAgICAgICAgICAgICBzZXFCeXRlcztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYmxvY2tTaXplID0gcmVhZEludChiYSwgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIGJsb2NrRW5kID0gb2Zmc2V0ICsgYmxvY2tTaXplICsgNDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tFbmQgPiBiYS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gbmV3IEJhbUFsaWdubWVudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlZklEID0gcmVhZEludChiYSwgb2Zmc2V0ICsgNCk7XHJcbiAgICAgICAgICAgICAgICBwb3MgPSByZWFkSW50KGJhLCBvZmZzZXQgKyA4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZWZJRCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAgLy8gdW5tYXBwZWQgcmVhZHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZklEID4gY2hySWQgfHwgcG9zID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgICAvLyBvZmYgcmlnaHQgZWRnZSwgd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmSUQgPCBjaHJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAgIC8vIHRvIGxlZnQgb2Ygc3RhcnQsIG5vdCBzdXJlIHRoaXMgaXMgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBibW4gPSByZWFkSW50KGJhLCBvZmZzZXQgKyAxMik7XHJcbiAgICAgICAgICAgICAgICBiaW4gPSAoYm1uICYgMHhmZmZmMDAwMCkgPj4gMTY7XHJcbiAgICAgICAgICAgICAgICBtcSA9IChibW4gJiAweGZmMDApID4+IDg7XHJcbiAgICAgICAgICAgICAgICBubCA9IGJtbiAmIDB4ZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxhZ19uYyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDE2KTtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSAoZmxhZ19uYyAmIDB4ZmZmZjAwMDApID4+IDE2O1xyXG4gICAgICAgICAgICAgICAgbmMgPSBmbGFnX25jICYgMHhmZmZmO1xyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5mbGFncyA9IGZsYWc7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuc3RyYW5kID0gIShmbGFnICYgUkVBRF9TVFJBTkRfRkxBRyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbHNlcSA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDIwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRlUmVmSUQgPSByZWFkSW50KGJhLCBvZmZzZXQgKyAyNCk7XHJcbiAgICAgICAgICAgICAgICBtYXRlUG9zID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjgpO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LmZyYWdtZW50TGVuZ3RoID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMzIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlYWROYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmwgLSAxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFkTmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW29mZnNldCArIDM2ICsgal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHAgPSBvZmZzZXQgKyAzNiArIG5sO1xyXG5cclxuICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmID0gMDtcclxuICAgICAgICAgICAgICAgIGNpZ2FyID0gJyc7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGNpZ2FyQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBuYzsgKytjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNpZ29wID0gcmVhZEludChiYSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wTGVuID0gKGNpZ29wID4+IDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcEx0ciA9IENJR0FSX0RFQ09ERVJbY2lnb3AgJiAweGZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcEx0ciA9PSAnTScgfHwgb3BMdHIgPT0gJ0VRJyB8fCBvcEx0ciA9PSAnWCcgfHwgb3BMdHIgPT0gJ0QnIHx8IG9wTHRyID09ICdOJyB8fCBvcEx0ciA9PSAnPScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aE9uUmVmICs9IG9wTGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNpZ2FyID0gY2lnYXIgKyBvcExlbiArIG9wTHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2lnYXJBcnJheS5wdXNoKHtsZW46IG9wTGVuLCBsdHI6IG9wTHRyfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQuY2lnYXIgPSBjaWdhcjtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5sZW5ndGhPblJlZiA9IGxlbmd0aE9uUmVmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgPCBtaW4pIGNvbnRpbnVlOyAgLy8gUmVjb3JkIG91dC1vZi1yYW5nZSBcInRvIHRoZSBsZWZ0XCIsIHNraXAgdG8gbmV4dCBvbmVcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgc2VxID0gJyc7XHJcbiAgICAgICAgICAgICAgICBzZXFCeXRlcyA9IChsc2VxICsgMSkgPj4gMTtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzZXFCeXRlczsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNiID0gYmFbcCArIGpdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcSArPSBTRUNSRVRfREVDT0RFUlsoc2IgJiAweGYwKSA+PiA0XTtcclxuICAgICAgICAgICAgICAgICAgICBzZXEgKz0gU0VDUkVUX0RFQ09ERVJbKHNiICYgMHgwZildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VxID0gc2VxLnN1YnN0cmluZygwLCBsc2VxKTsgIC8vIHNlcSBtaWdodCBoYXZlIG9uZSBleHRyYSBjaGFyYWN0ZXIgKGlmIGxzZXEgaXMgYW4gb2RkIG51bWJlcilcclxuXHJcbiAgICAgICAgICAgICAgICBwICs9IHNlcUJ5dGVzO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnNlcSA9IHNlcTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxzZXEgPT09IDEgJiYgU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgal0gKyAzMykgPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyA9PSBob3cgdG8gcmVwcmVzZW50IHRoaXM/XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQucXVhbCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsc2VxOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50LnF1YWwucHVzaChiYVtwICsgal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAgKz0gbHNlcTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50LnN0YXJ0ID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50Lm1xID0gbXE7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQucmVhZE5hbWUgPSByZWFkTmFtZTtcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC5jaHIgPSBzZWxmLmluZGV4VG9DaHJbcmVmSURdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYXRlUmVmSUQgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5tYXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHI6IHNlbGYuaW5kZXhUb0NoclttYXRlUmVmSURdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogbWF0ZVBvcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyYW5kOiAhKGZsYWcgJiBNQVRFX1NUUkFORF9GTEFHKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudC50YWdCQSA9IG5ldyBVaW50OEFycmF5KGJhLmJ1ZmZlci5zbGljZShwLCBibG9ja0VuZCkpOyAgLy8gZGVjb2RlIHRoaWVzZSBvbiBkZW1hbmRcclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tFbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFtaW4gfHwgYWxpZ25tZW50LnN0YXJ0IDw9IG1heCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZiA+PSBtaW4gJiZcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIucGFzcyhhbGlnbm1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocklkID09PSB1bmRlZmluZWQgfHwgcmVmSUQgPT0gY2hySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzID0gbWFrZUJsb2NrcyhhbGlnbm1lbnQsIGNpZ2FyQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQuYmxvY2tzID0gYmxvY2tzLmJsb2NrcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Lmluc2VydGlvbnMgPSBibG9ja3MuaW5zZXJ0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBibG9ja0VuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFeGl0cyB2aWEgdG9wIG9mIGxvb3AuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpdCB0aGUgYWxpZ25tZW50IHJlY29yZCBpbnRvIGJsb2NrcyBhcyBzcGVjaWZpZWQgaW4gdGhlIGNpZ2FyQXJyYXkuICBFYWNoIGFsaWduZWQgYmxvY2sgY29udGFpbnNcclxuICAgICAgICAgKiBpdHMgcG9ydGlvbiBvZiB0aGUgcmVhZCBzZXF1ZW5jZSBhbmQgYmFzZSBxdWFsaXR5IHN0cmluZ3MuICBBIHJlYWQgc2VxdWVuY2Ugb3IgYmFzZSBxdWFsaXR5IHN0cmluZ1xyXG4gICAgICAgICAqIG9mIFwiKlwiIGluZGljYXRlcyB0aGUgdmFsdWUgaXMgbm90IHJlY29yZGVkLiAgSW4gYWxsIG90aGVyIGNhc2VzIHRoZSBsZW5ndGggb2YgdGhlIGJsb2NrIHNlcXVlbmNlIChibG9jay5zZXEpXHJcbiAgICAgICAgICogYW5kIHF1YWxpdHkgc3RyaW5nIChibG9jay5xdWFsKSBtdXN0ID09IHRoZSBibG9jayBsZW5ndGguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBJbnNlcnRpb25zIGFyZSBub3QgeWV0IHRyZWF0ZWQgLy8gVE9ET1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHJlY29yZFxyXG4gICAgICAgICAqIEBwYXJhbSBjaWdhckFycmF5XHJcbiAgICAgICAgICogQHJldHVybnMgYXJyYXkgb2YgYmxvY2tzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUJsb2NrcyhyZWNvcmQsIGNpZ2FyQXJyYXkpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBibG9ja3MgPSBbXSxcclxuICAgICAgICAgICAgICAgIGluc2VydGlvbnMsXHJcbiAgICAgICAgICAgICAgICBzZXFPZmZzZXQgPSAwLFxyXG4gICAgICAgICAgICAgICAgcG9zID0gcmVjb3JkLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgbGVuID0gY2lnYXJBcnJheS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBibG9ja1NlcSxcclxuICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMsXHJcbiAgICAgICAgICAgICAgICBnYXBUeXBlLFxyXG4gICAgICAgICAgICAgICAgbWluUSA9IDUsICAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUlOKVxyXG4gICAgICAgICAgICAgICAgbWF4USA9IDIwOyAvL3ByZWZzLmdldEFzSW50KFByZWZlcmVuY2VNYW5hZ2VyLlNBTV9CQVNFX1FVQUxJVFlfTUFYKVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjID0gY2lnYXJBcnJheVtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMubHRyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gaWdub3JlIGhhcmQgY2xpcHNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdQJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBpZ25vcmUgcGFkc1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ1MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gc29mdCBjbGlwIHJlYWQgYmFzZXNcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwVHlwZSA9ICdOJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAvLyByZWZlcmVuY2Ugc2tpcFxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0QnIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXBUeXBlID0gJ0QnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdJJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrU2VxID0gcmVjb3JkLnNlcSA9PT0gXCIqXCIgPyBcIipcIiA6IHJlY29yZC5zZXEuc3Vic3RyKHNlcU9mZnNldCwgYy5sZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja1F1YWxzID0gcmVjb3JkLnF1YWwgPyByZWNvcmQucXVhbC5zbGljZShzZXFPZmZzZXQsIGMubGVuKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbnMgPT09IHVuZGVmaW5lZCkgaW5zZXJ0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRpb25zLnB1c2goe3N0YXJ0OiBwb3MsIGxlbjogYy5sZW4sIHNlcTogYmxvY2tTZXEsIHF1YWw6IGJsb2NrUXVhbHN9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxT2Zmc2V0ICs9IGMubGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRVEnIDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWCcgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tTZXEgPSByZWNvcmQuc2VxID09PSBcIipcIiA/IFwiKlwiIDogcmVjb3JkLnNlcS5zdWJzdHIoc2VxT2Zmc2V0LCBjLmxlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrUXVhbHMgPSByZWNvcmQucXVhbCA/IHJlY29yZC5xdWFsLnNsaWNlKHNlcU9mZnNldCwgYy5sZW4pIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MucHVzaCh7c3RhcnQ6IHBvcywgbGVuOiBjLmxlbiwgc2VxOiBibG9ja1NlcSwgcXVhbDogYmxvY2tRdWFscywgZ2FwVHlwZTogZ2FwVHlwZX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXFPZmZzZXQgKz0gYy5sZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBjLmxlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBwcm9jZXNzaW5nIGNpZ2FyIGVsZW1lbnQ6IFwiICsgYy5sZW4gKyBjLmx0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7YmxvY2tzOiBibG9ja3MsIGluc2VydGlvbnM6IGluc2VydGlvbnN9O1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgZ2V0SW5kZXgoc2VsZikudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gaW5kZXguZmlyc3RBbGlnbm1lbnRCbG9jayArIE1BWF9HWklQX0JMT0NLX1NJWkU7ICAgLy8gSW5zdXJlIHdlIGdldCB0aGUgY29tcGxldGUgY29tcHJlc3NlZCBibG9jayBjb250YWluaW5nIHRoZSBoZWFkZXJcclxuXHJcbiAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYuYmFtUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHNlbGYuY29uZmlnLmhlYWRlcnMsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiAwLCBzaXplOiBsZW59LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21wcmVzc2VkQnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmMgPSBuZXcgdW5iZ3pmKGNvbXByZXNzZWRCdWZmZXIsIGxlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY2JhID0gbmV3IFVpbnQ4QXJyYXkodW5jKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFnaWMgPSByZWFkSW50KHVuY2JhLCAwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtSGVhZGVyTGVuID0gcmVhZEludCh1bmNiYSwgNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciA9ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5vbWUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbUhlYWRlckxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbUhlYWRlciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVuY2JhW2kgKyA4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgblJlZiA9IHJlYWRJbnQodW5jYmEsIHNhbUhlYWRlckxlbiArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gc2FtSGVhZGVyTGVuICsgMTI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyVG9JbmRleCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhUb0NociA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJlZjsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsTmFtZSA9IHJlYWRJbnQodW5jYmEsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxOYW1lIC0gMTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5jYmFbcCArIDQgKyBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxSZWYgPSByZWFkSW50KHVuY2JhLCBwICsgbE5hbWUgKyA0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kbG9nKG5hbWUgKyAnOiAnICsgbFJlZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2Vub21lICYmIGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGdlbm9tZS5nZXRDaHJvbW9zb21lTmFtZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJUb0luZGV4W25hbWVdID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleFRvQ2hyLnB1c2gobmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcCArIDggKyBsTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYmFtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFtLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5pbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkQmFtSW5kZXgoYmFtLmJhaVBhdGgsIGJhbS5jb25maWcpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFtLmluZGV4ID0gaW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q2hySW5kZXgoYmFtKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmFtLmNoclRvSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoYmFtLmNoclRvSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFtLnJlYWRIZWFkZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGJhbS5jaHJUb0luZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWFkSW50KGJhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gKGJhW29mZnNldCArIDNdIDw8IDI0KSB8IChiYVtvZmZzZXQgKyAyXSA8PCAxNikgfCAoYmFbb2Zmc2V0ICsgMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZFNob3J0KGJhLCBvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gKGJhW29mZnNldCArIDFdIDw8IDgpIHwgKGJhW29mZnNldF0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQmFtU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50Q29udGFpbmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubWF4Um93cyA9IGNvbmZpZy5tYXhSb3dzIHx8IDEwMDA7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZV9zb3VyY2U9bmV3IEZhc3RhU2VxdWVuY2UoY29uZmlnLnNlcV91cmwpO1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLnNvdXJjZVR5cGUgPT09IFwiZ2E0Z2hcIikge1xyXG4gICAgICAgICAgICB0aGlzLmJhbVJlYWRlciA9IG5ldyBpZ3YuR2E0Z2hBbGlnbm1lbnRSZWFkZXIoY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFtUmVhZGVyID0gbmV3IEJhbVJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICB0aGlzLnZpZXdBc1BhaXJzID0gY29uZmlnLnZpZXdBc1BhaXJzO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZXRWaWV3QXNQYWlycyhib29sKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAodGhpcy52aWV3QXNQYWlycyAhPT0gYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdBc1BhaXJzID0gYm9vbDtcclxuICAgICAgICAgICAgLy8gVE9ETyAtLSByZXBhaXIgYWxpZ25tZW50c1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hbGlnbm1lbnRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGlnbm1lbnRDb250YWluZXIgPSB0aGlzLmFsaWdubWVudENvbnRhaW5lcixcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50cyA9IHBhaXJBbGlnbm1lbnRzKGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudHMgPSB1bnBhaXJBbGlnbm1lbnRzKGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudENvbnRhaW5lci5wYWNrZWRBbGlnbm1lbnRSb3dzID0gcGFja0FsaWdubWVudFJvd3MoYWxpZ25tZW50cywgYWxpZ25tZW50Q29udGFpbmVyLnN0YXJ0LCBhbGlnbm1lbnRDb250YWluZXIuZW5kLCBzZWxmLm1heFJvd3MpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBnZXRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5hbGlnbm1lbnRDb250YWluZXIgJiYgc2VsZi5hbGlnbm1lbnRDb250YWluZXIuY29udGFpbnMoY2hyLCBicFN0YXJ0LCBicEVuZCkpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5hbGlnbm1lbnRDb250YWluZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuYmFtUmVhZGVyLnJlYWRBbGlnbm1lbnRzKGNociwgYnBTdGFydCwgYnBFbmQpLnRoZW4oZnVuY3Rpb24gKGFsaWdubWVudENvbnRhaW5lcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4Um93cyA9IHNlbGYuY29uZmlnLm1heFJvd3MgfHwgNTAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gYWxpZ25tZW50Q29udGFpbmVyLmFsaWdubWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi52aWV3QXNQYWlycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzID0gdW5wYWlyQWxpZ25tZW50cyhbe2FsaWdubWVudHM6IGFsaWdubWVudHN9XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIucGFja2VkQWxpZ25tZW50Um93cyA9IHBhY2tBbGlnbm1lbnRSb3dzKGFsaWdubWVudHMsIGFsaWdubWVudENvbnRhaW5lci5zdGFydCwgYWxpZ25tZW50Q29udGFpbmVyLmVuZCwgbWF4Um93cyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRDb250YWluZXIuYWxpZ25tZW50cyA9IHVuZGVmaW5lZDsgIC8vIERvbid0IG5lZWQgdG8gaG9sZCBvbnRvIHRoZXNlIGFueW1vcmVcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsaWdubWVudENvbnRhaW5lciA9IGFsaWdubWVudENvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICBzZWxmLnNlcXVlbmNlX3NvdXJjZS5nZXRTZXF1ZW5jZShhbGlnbm1lbnRDb250YWluZXIuY2hyLCBhbGlnbm1lbnRDb250YWluZXIuc3RhcnQsIGFsaWdubWVudENvbnRhaW5lci5lbmQpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLmNvdmVyYWdlTWFwLnJlZlNlcSA9IHNlcXVlbmNlOyAgICAvLyBUT0RPIC0tIGZpeCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50Q29udGFpbmVyLnNlcXVlbmNlID0gc2VxdWVuY2U7ICAgICAgICAgICAvLyBUT0RPIC0tIGZpeCB0aGlzXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsaWdubWVudENvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG4gICAgZnVuY3Rpb24gcGFpckFsaWdubWVudHMocm93cykge1xyXG5cclxuICAgICAgICB2YXIgcGFpckNhY2hlID0ge30sXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG5cclxuICAgICAgICAgICAgcm93LmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuQmVQYWlyZWQoYWxpZ25tZW50KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudC5zZXRTZWNvbmRBbGlnbm1lbnQoYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckNhY2hlW2FsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7ICAgLy8gRG9uJ3QgbmVlZCB0byB0cmFjayB0aGlzIGFueW1vcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgaWd2LlBhaXJlZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlyQ2FjaGVbYWxpZ25tZW50LnJlYWROYW1lXSA9IHBhaXJlZEFsaWdubWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFpcmVkQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bnBhaXJBbGlnbm1lbnRzKHJvd3MpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgcm93LmFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50IGluc3RhbmNlb2YgUGFpcmVkQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWdubWVudC5maXJzdEFsaWdubWVudCkgcmVzdWx0LnB1c2goYWxpZ25tZW50LmZpcnN0QWxpZ25tZW50KTsgIC8vIHNob3VsZG4ndCBuZWVkIHRoZSBudWxsIHRlc3RcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCkgcmVzdWx0LnB1c2goYWxpZ25tZW50LnNlY29uZEFsaWdubWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjYW5CZVBhaXJlZChhbGlnbm1lbnQpIHtcclxuICAgICAgICByZXR1cm4gYWxpZ25tZW50LmlzUGFpcmVkKCkgJiZcclxuICAgICAgICAgICAgYWxpZ25tZW50LmlzTWF0ZU1hcHBlZCgpICYmXHJcbiAgICAgICAgICAgIGFsaWdubWVudC5jaHIgPT09IGFsaWdubWVudC5tYXRlLmNociAmJlxyXG4gICAgICAgICAgICAoYWxpZ25tZW50LmlzRmlyc3RPZlBhaXIoKSB8fCBhbGlnbm1lbnQuaXNTZWNvbmRPZlBhaXIoKSkgJiYgIShhbGlnbm1lbnQuaXNTZWNvbmRhcnkoKSB8fCBhbGlnbm1lbnQuaXNTdXBwbGVtZW50YXJ5KCkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBwYWNrQWxpZ25tZW50Um93cyhhbGlnbm1lbnRzLCBzdGFydCwgZW5kLCBtYXhSb3dzKSB7XHJcblxyXG4gICAgICAgIGlmICghYWxpZ25tZW50cykgcmV0dXJuO1xyXG5cclxuICAgICAgICBhbGlnbm1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50cy5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBidWNrZXRMaXN0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICBsYXN0QWxsb2NhdGVkQ291bnQgPSAwLFxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXJ0ID0gc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRSb3csXHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIGJ1Y2tldCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFNwYWNlID0gNCAqIDIsXHJcbiAgICAgICAgICAgICAgICBwYWNrZWRBbGlnbm1lbnRSb3dzID0gW10sXHJcbiAgICAgICAgICAgICAgICBidWNrZXRTdGFydCA9IE1hdGgubWF4KHN0YXJ0LCBhbGlnbm1lbnRzWzBdLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1Y2tMaXN0SW5kZXggPSBNYXRoLm1heCgwLCBhbGlnbm1lbnQuc3RhcnQgLSBidWNrZXRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnVja2V0TGlzdFtidWNrTGlzdEluZGV4XS5wdXNoKGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChhbGxvY2F0ZWRDb3VudCA8IGFsaWdubWVudHMubGVuZ3RoICYmIHBhY2tlZEFsaWdubWVudFJvd3MubGVuZ3RoIDwgbWF4Um93cykge1xyXG5cclxuICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdyA9IG5ldyBCYW1BbGlnbm1lbnRSb3coKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dFN0YXJ0IDw9IGVuZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghYnVja2V0ICYmIG5leHRTdGFydCA8PSBlbmQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dFN0YXJ0IC0gYnVja2V0U3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidWNrZXRMaXN0W2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25leHRTdGFydDsgICAgICAgICAgICAgICAgICAgICAvLyBObyBhbGlnbm1lbnRzIGF0IHRoaXMgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IGJ1Y2tldExpc3RbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gd2hpbGUgKGJ1Y2tldClcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWNrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IGJ1Y2tldC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gYnVja2V0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXRMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudFJvdy5hbGlnbm1lbnRzLnB1c2goYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhcnQgPSBhbGlnbm1lbnQuc3RhcnQgKyBhbGlnbm1lbnQubGVuZ3RoT25SZWYgKyBhbGlnbm1lbnRTcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICArK2FsbG9jYXRlZENvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gLy8gd2hpbGUgKG5leHRTdGFydClcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWxpZ25tZW50Um93LmFsaWdubWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhY2tlZEFsaWdubWVudFJvd3MucHVzaChhbGlnbm1lbnRSb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5leHRTdGFydCA9IGJ1Y2tldFN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChhbGxvY2F0ZWRDb3VudCA9PT0gbGFzdEFsbG9jYXRlZENvdW50KSBicmVhazsgICAvLyBQcm90ZWN0IGZyb20gaW5maW5pdGUgbG9vcHNcclxuXHJcbiAgICAgICAgICAgICAgICBsYXN0QWxsb2NhdGVkQ291bnQgPSBhbGxvY2F0ZWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgIH0gLy8gd2hpbGUgKGFsbG9jYXRlZENvdW50KVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhY2tlZEFsaWdubWVudFJvd3M7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1BbGlnbm1lbnR7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaXNNYXBwZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUkVBRF9VTk1BUFBFRF9GTEFHKSA9PSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUGFpcmVkICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1BBSVJFRF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzUHJvcGVyUGFpciAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgUFJPUEVSX1BBSVJfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0ZpcnN0T2ZQYWlyKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIEZJUlNUX09GX1BBSVJfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1NlY29uZE9mUGFpcigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBTRUNPTkRfT0ZfUEFJUl9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzU2Vjb25kYXJ5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFNFQ09OREFSWV9BTElHTk1ORVRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc1N1cHBsZW1lbnRhcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgU1VQUExFTUVOVEFSWV9BTElHTk1FTlRfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIFJFQURfRkFJTFNfVkVORE9SX1FVQUxJVFlfQ0hFQ0tfRkxBRykgIT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpc0R1cGxpY2F0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBEVVBMSUNBVEVfUkVBRF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWF0ZU1hcHBlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBNQVRFX1VOTUFQUEVEX0ZMQUcpID09IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaXNOZWdhdGl2ZVN0cmFuZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiBSRUFEX1NUUkFORF9GTEFHKSAhPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWF0ZU5lZ2F0aXZlU3RyYW5kKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIE1BVEVfU1RSQU5EX0ZMQUcpICE9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgdGFncygpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlVGFncyhiYSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHAgPSAwLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gYmEubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgdGFncyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHAgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3BdKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIDFdKTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgMl0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdBJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgM10pO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2knIHx8IHR5cGUgPT09ICdJJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZEludChiYSwgcCArIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2MnIHx8IHR5cGUgPT09ICdDJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFbcCArIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3MnIHx8IHR5cGUgPT09ICdTJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZFNob3J0KGJhLCBwICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcCArPSA1O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPICdGSVhNRSBuZWVkIGZsb2F0cyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkRmxvYXQoYmEsIHAgKyAzKTtcclxuICAgICAgICAgICAgICAgICAgICBwICs9IDc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gMztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYyA9IGJhW3ArK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8nVW5rbm93biB0eXBlICcgKyB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ0Vycm9yIHVua25vd24gdHlwZTogJyArIHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnc1t0YWddID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFncztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy50YWdEaWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhZ0JBKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0RpY3QgPSBkZWNvZGVUYWdzKHRoaXMudGFnQkEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdCQSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnRGljdCA9IHt9OyAgLy8gTWFyayBzbyB3ZSBkb24ndCB0cnkgYWdhaW4uICBUaGUgcmVjb3JkIGhhcyBub3QgdGFnc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0RpY3Q7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgY2xpY2tzIG9uIGEgYmFzZSBuZXh0IHRvIGFuIGluc2VydGlvbiwgc2hvdyBqdXN0IHRoZVxyXG4gICAgICAgIC8vIGluc2VydGVkIGJhc2VzIGluIGEgcG9wdXAgKGxpa2UgaW4gZGVza3RvcCBJR1YpLlxyXG4gICAgICAgIHZhciBuYW1lVmFsdWVzID0gW10sIGlzRmlyc3QsIHRhZ0RpY3Q7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuaW5zZXJ0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnNlcnRpb25zLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zX3N0YXJ0ID0gdGhpcy5pbnNlcnRpb25zW2ldLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYoZ2Vub21pY0xvY2F0aW9uID09IGluc19zdGFydCB8fCBnZW5vbWljTG9jYXRpb24gPT0gaW5zX3N0YXJ0IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0luc2VydGlvbicsIHZhbHVlOiB0aGlzLmluc2VydGlvbnNbaV0uc2VxIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7bmFtZTogJ0xvY2F0aW9uJywgdmFsdWU6IGluc19zdGFydCB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVZhbHVlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1JlYWQgTmFtZScsIHZhbHVlOiB0aGlzLnJlYWROYW1lIH0pO1xyXG5cclxuICAgICAgICAvLyBTYW1wbGVcclxuICAgICAgICAvLyBSZWFkIGdyb3VwXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiPGhyPlwiKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIDEgdG8gZ2Vub21pYyBsb2NhdGlvbiB0byBtYXAgZnJvbSAwLWJhc2VkIGNvbXB1dGVyIHVuaXRzIHRvIHVzZXItYmFzZWQgdW5pdHNcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnQWxpZ25tZW50IFN0YXJ0JywgdmFsdWU6IGlndi5udW1iZXJGb3JtYXR0ZXIoMSArIHRoaXMuc3RhcnQpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdSZWFkIFN0cmFuZCcsIHZhbHVlOiAodHJ1ZSA9PT0gdGhpcy5zdHJhbmQgPyAnKCspJyA6ICcoLSknKSwgYm9yZGVyVG9wOiB0cnVlIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdDaWdhcicsIHZhbHVlOiB0aGlzLmNpZ2FyIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXBwZWQnLCB2YWx1ZTogeWVzTm8odGhpcy5pc01hcHBlZCgpKSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnTWFwcGluZyBRdWFsaXR5JywgdmFsdWU6IHRoaXMubXEgfSk7XHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ1NlY29uZGFyeScsIHZhbHVlOiB5ZXNObyh0aGlzLmlzU2Vjb25kYXJ5KCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdTdXBwbGVtZW50YXJ5JywgdmFsdWU6IHllc05vKHRoaXMuaXNTdXBwbGVtZW50YXJ5KCkpIH0pO1xyXG4gICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdEdXBsaWNhdGUnLCB2YWx1ZTogeWVzTm8odGhpcy5pc0R1cGxpY2F0ZSgpKSB9KTtcclxuICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnRmFpbGVkIFFDJywgdmFsdWU6IHllc05vKHRoaXMuaXNGYWlsc1ZlbmRvclF1YWxpdHlDaGVjaygpKSB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNQYWlyZWQoKSkge1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goXCI8aHI+XCIpO1xyXG4gICAgICAgICAgICBuYW1lVmFsdWVzLnB1c2goeyBuYW1lOiAnRmlyc3QgaW4gUGFpcicsIHZhbHVlOiAhdGhpcy5pc1NlY29uZE9mUGFpcigpLCBib3JkZXJUb3A6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIGlzIE1hcHBlZCcsIHZhbHVlOiB5ZXNObyh0aGlzLmlzTWF0ZU1hcHBlZCgpKSB9KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXRlTWFwcGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIENocm9tb3NvbWUnLCB2YWx1ZTogdGhpcy5tYXRlLmNociB9KTtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdNYXRlIFN0YXJ0JywgdmFsdWU6ICh0aGlzLm1hdGUucG9zaXRpb24gKyAxKX0pO1xyXG4gICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZTogJ01hdGUgU3RyYW5kJywgdmFsdWU6ICh0cnVlID09PSB0aGlzLm1hdGUuc3RyYW5kID8gJygrKScgOiAnKC0pJyl9KTtcclxuICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6ICdJbnNlcnQgU2l6ZScsIHZhbHVlOiB0aGlzLmZyYWdtZW50TGVuZ3RoIH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0ZSBTdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gTWF0ZSBTdHJhbmRcclxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBTaXplXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRmlyc3QgaW4gUGFpclxyXG4gICAgICAgICAgICAvLyBQYWlyIE9yaWVudGF0aW9uXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiPGhyPlwiKTtcclxuICAgICAgICB0YWdEaWN0ID0gdGhpcy50YWdzKCk7XHJcbiAgICAgICAgaXNGaXJzdCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRhZ0RpY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YWdEaWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVWYWx1ZXMucHVzaCh7IG5hbWU6IGtleSwgdmFsdWU6IHRhZ0RpY3Rba2V5XSwgYm9yZGVyVG9wOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKHsgbmFtZToga2V5LCB2YWx1ZTogdGFnRGljdFtrZXldIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB5ZXNObyhib29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBib29sID8gJ1llcycgOiAnTm8nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbiAgIFxyXG5cclxuICAgXHJcblxyXG4gICAgZnVuY3Rpb24gcmVhZEZsb2F0KGJhLCBvZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJhLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCYW1GaWx0ZXJ7XHJcblxyXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy52ZW5kb3JGYWlsZWQgPSBvcHRpb25zLnZlbmRvckZhaWxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMudmVuZG9yRmFpbGVkO1xyXG4gICAgICAgIHRoaXMuZHVwbGljYXRlcyA9IG9wdGlvbnMuZHVwbGljYXRlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuZHVwbGljYXRlcztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeSA9IG9wdGlvbnMuc2Vjb25kYXJ5IHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3VwcGxlbWVudGFyeSA9IG9wdGlvbnMuc3VwcGxlbWVudGFyeSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLm1xVGhyZXNob2xkID0gb3B0aW9ucy5tcVRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMubXFUaHJlc2hvbGQ7XHJcbiAgICB9XHJcblxyXG4gICAgcGFzcyhhbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudmVuZG9yRmFpbGVkICYmIGFsaWdubWVudC5pc0ZhaWxzVmVuZG9yUXVhbGl0eUNoZWNrKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5kdXBsaWNhdGVzICYmIGFsaWdubWVudC5pc0R1cGxpY2F0ZSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5ICYmIGFsaWdubWVudC5pc1NlY29uZGFyeSgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudGFyeSAmJiBhbGlnbm1lbnQuaXNTdXBwbGVtZW50YXJ5KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoYWxpZ25tZW50Lm1xIDwgdGhpcy5tcVRocmVzaG9sZCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG4gICAgdmFyIEJMT0NLX0hFQURFUl9MRU5HVEggPSAxODtcclxuICAgIHZhciBCTE9DS19MRU5HVEhfT0ZGU0VUID0gMTY7ICAvLyBMb2NhdGlvbiBpbiB0aGUgZ3ppcCBibG9jayBvZiB0aGUgdG90YWwgYmxvY2sgc2l6ZSAoYWN0dWFsbHkgdG90YWwgYmxvY2sgc2l6ZSAtIDEpXHJcbiAgICB2YXIgQkxPQ0tfRk9PVEVSX0xFTkdUSCA9IDg7IC8vIE51bWJlciBvZiBieXRlcyB0aGF0IGZvbGxvdyB0aGUgZGVmbGF0ZWQgZGF0YVxyXG4gICAgdmFyIE1BWF9DT01QUkVTU0VEX0JMT0NLX1NJWkUgPSA2NCAqIDEwMjQ7IC8vIFdlIHJlcXVpcmUgdGhhdCBhIGNvbXByZXNzZWQgYmxvY2sgKGluY2x1ZGluZyBoZWFkZXIgYW5kIGZvb3RlciwgYmUgPD0gdGhpcylcclxuICAgIHZhciBHWklQX09WRVJIRUFEID0gQkxPQ0tfSEVBREVSX0xFTkdUSCArIEJMT0NLX0ZPT1RFUl9MRU5HVEggKyAyOyAvLyBHemlwIG92ZXJoZWFkIGlzIHRoZSBoZWFkZXIsIHRoZSBmb290ZXIsIGFuZCB0aGUgYmxvY2sgc2l6ZSAoZW5jb2RlZCBhcyBhIHNob3J0KS5cclxuICAgIHZhciBHWklQX0lEMSA9IDMxOyAgIC8vIE1hZ2ljIG51bWJlclxyXG4gICAgdmFyIEdaSVBfSUQyID0gMTM5OyAgLy8gTWFnaWMgbnVtYmVyXHJcbiAgICB2YXIgR1pJUF9GTEcgPSA0OyAvLyBGRVhUUkEgZmxhZyBtZWFucyB0aGVyZSBhcmUgb3B0aW9uYWwgZmllbGRzXHJcblxyXG5cclxuICAgIC8vIFVuY29tcHJlc3MgZGF0YSwgIGFzc3VtZWQgdG8gYmUgc2VyaWVzIG9mIGJnemlwcGVkIGJsb2Nrc1xyXG4gICAgLy8gQ29kZSBpcyBiYXNlZCBoZWF2aWx5IG9uIGJhbS5qcywgcGFydCBvZiB0aGUgRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlciwgIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMDEuXHJcbmNsYXNzIHVuYmd6ZntcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGxpbSkge1xyXG4gICAgICAgIGZvciAobGV0IGEgaW4gZGF0YSl7XHJcbiAgICAgICAgICAgY29uc29sZS5sb2coYSk7XHJcbiAgICAgICAgIH1cclxuICAgICAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdLFxyXG4gICAgICAgICAgICBwdHIgPSBbMF0sXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIGxpbSA9IGxpbSB8fCBkYXRhLmJ5dGVMZW5ndGggLSAxODtcclxuXHJcbiAgICAgICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxOCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAxMiArIHhsZW4gKyBwdHJbMF07ICAgIC8vIFN0YXJ0IG9mIENEQVRBXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAoYnNpemUgKyA4KSkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIHN0YXJ0LCBsZW5ndGgsIHB0cik7XHJcblxyXG4gICAgICAgICAgICBwdHJbMF0gKz0gODsgICAgLy8gU2tpcHBpbmcgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGVjb21wcmVzc2VkIGJsb2Nrc1xyXG4gICAgICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmNsYXNzIEFsaWdubWVudENvbnRhaW5lcntcclxuICAgIGNvbnN0cnVjdG9yKGNociwgc3RhcnQsIGVuZCwgc2FtcGxpbmdXaW5kb3dTaXplLCBzYW1wbGluZ0RlcHRoLCBwYWlyc1N1cHBvcnRlZCkge1xyXG5cclxuICAgICAgICB0aGlzLmNociA9IGNocjtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAoZW5kIC0gc3RhcnQpO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlTWFwID0gbmV3IENvdmVyYWdlTWFwKGNociwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscyA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSA9IHNhbXBsaW5nV2luZG93U2l6ZSA9PT0gdW5kZWZpbmVkID8gMTAwIDogc2FtcGxpbmdXaW5kb3dTaXplO1xyXG4gICAgICAgIHRoaXMuc2FtcGxpbmdEZXB0aCA9IHNhbXBsaW5nRGVwdGggPT09IHVuZGVmaW5lZCA/IDUwIDogc2FtcGxpbmdEZXB0aDtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IHBhaXJzU3VwcG9ydGVkO1xyXG4gICAgICAgIHRoaXMucGFpcmVkID0gZmFsc2U7ICAvLyBmYWxzZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0ge307ICAvLyB3b3JraW5nIGNhY2hlIG9mIHBhaXJlZCBhbGlnbm1lbnRzIGJ5IHJlYWQgbmFtZVxyXG5cclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBuZXcgU2V0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KHRoaXMuc3RhcnQsIHRoaXMuc3RhcnQgKyB0aGlzLnNhbXBsaW5nV2luZG93U2l6ZSwgdGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGFsaWdubWVudCkgeyAgICAgICAgIC8vIFRPRE8gLS0gcGFzcyB0aGlzIGluXHJcbiAgICAgICAgICAgIHJldHVybiBhbGlnbm1lbnQuaXNNYXBwZWQoKSAmJiAhYWxpZ25tZW50LmlzRmFpbHNWZW5kb3JRdWFsaXR5Q2hlY2soKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1c2goYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcihhbGlnbm1lbnQpID09PSBmYWxzZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmNvdmVyYWdlTWFwLmluY0NvdW50cyhhbGlnbm1lbnQpOyAgIC8vIENvdW50IGNvdmVyYWdlIGJlZm9yZSBhbnkgZG93bnNhbXBsaW5nXHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIHRoaXMuZG93bnNhbXBsZWRSZWFkcy5oYXMoYWxpZ25tZW50LnJlYWROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm47ICAgLy8gTWF0ZSBhbHJlYWR5IGRvd25zYW1wbGVkIC0tIHBhaXJzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIGFsaWdubWVudCBmb3IgZG93bnNhbXBsaW5nXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYWxpZ25tZW50LnN0YXJ0ID49IHRoaXMuY3VycmVudEJ1Y2tldC5lbmQpIHtcclxuICAgICAgICAgICAgZmluaXNoQnVja2V0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldCA9IG5ldyBEb3duc2FtcGxlQnVja2V0KGFsaWdubWVudC5zdGFydCwgYWxpZ25tZW50LnN0YXJ0ICsgdGhpcy5zYW1wbGluZ1dpbmRvd1NpemUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmFkZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzLmZvckVhY2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmlzaCgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJ1Y2tldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEJ1Y2tldC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmVlZCB0byByZW1vdmUgcGFydGlhbCBwYWlycyB3aG9zZSBtYXRlIHdhcyBkb3duc2FtcGxlZFxyXG4gICAgICAgIGlmKHRoaXMucGFpcnNTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCA9IFtdLCBkcyA9IHRoaXMuZG93bnNhbXBsZWRSZWFkcztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRzLmhhcyhhLnJlYWROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcC5wdXNoKGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB0aGlzLmFsaWdubWVudHMgPSB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFsaWdubWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5wYWlyc0NhY2hlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRSZWFkcyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWlucyhjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaHIgPT0gY2hyICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPD0gc3RhcnQgJiZcclxuICAgICAgICAgICAgdGhpcy5lbmQgPj0gZW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc0Rvd25zYW1wbGVkSW50ZXJ2YWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvd25zYW1wbGVkSW50ZXJ2YWxzICYmIHRoaXMuZG93bnNhbXBsZWRJbnRlcnZhbHMubGVuZ3RoID4gMDtcclxuICAgIH1cclxufVxyXG4gICAgZnVuY3Rpb24gZmluaXNoQnVja2V0KCkge1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IHRoaXMuYWxpZ25tZW50cy5jb25jYXQodGhpcy5jdXJyZW50QnVja2V0LmFsaWdubWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCdWNrZXQuZG93bnNhbXBsZWRDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZEludGVydmFscy5wdXNoKG5ldyBEb3duc2FtcGxlZEludGVydmFsKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QnVja2V0LmVuZCxcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEJ1Y2tldC5kb3duc2FtcGxlZENvdW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFpcmVkID0gdGhpcy5wYWlyZWQgfHwgdGhpcy5jdXJyZW50QnVja2V0LnBhaXJlZDtcclxuICAgIH1cclxuXHJcbmNsYXNzIERvd25zYW1wbGVCdWNrZXR7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBhbGlnbm1lbnRDb250YWluZXIpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZG93bnNhbXBsZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zYW1wbGluZ0RlcHRoID0gYWxpZ25tZW50Q29udGFpbmVyLnNhbXBsaW5nRGVwdGg7XHJcbiAgICAgICAgdGhpcy5wYWlyc1N1cHBvcnRlZCA9IGFsaWdubWVudENvbnRhaW5lci5wYWlyc1N1cHBvcnRlZDtcclxuICAgICAgICB0aGlzLmRvd25zYW1wbGVkUmVhZHMgPSBhbGlnbm1lbnRDb250YWluZXIuZG93bnNhbXBsZWRSZWFkcztcclxuICAgICAgICB0aGlzLnBhaXJzQ2FjaGUgPSBhbGlnbm1lbnRDb250YWluZXIucGFpcnNDYWNoZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBzYW1wbGluZ1Byb2IsIGlkeCwgcmVwbGFjZWRBbGlnbm1lbnQsIHBhaXJlZEFsaWdubWVudDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpZ25tZW50cy5sZW5ndGggPCB0aGlzLnNhbXBsaW5nRGVwdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBhaXJlZEFsaWdubWVudCA9IHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhaXJlZEFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTm90IHN1YmplY3QgdG8gZG93bnNhbXBsaW5nLCBqdXN0IHVwZGF0ZSB0aGUgZXhpc3RpbmcgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgcGFpcmVkQWxpZ25tZW50LnNldFNlY29uZEFsaWdubWVudChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gdW5kZWZpbmVkOyAgIC8vIERvbid0IG5lZWQgdG8gdHJhY2sgdGhpcyBhbnltb3JlLiBOT1RFOiBEb24ndCBcImRlbGV0ZVwiLCBjYXVzZXMgcnVudGltZSBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGFsaWdubWVudCBpbiBhIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50cy5wdXNoKHBhaXJlZEFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFsaWdubWVudHMucHVzaChhbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICBzYW1wbGluZ1Byb2IgPSB0aGlzLnNhbXBsaW5nRGVwdGggLyAodGhpcy5zYW1wbGluZ0RlcHRoICsgdGhpcy5kb3duc2FtcGxlZENvdW50ICsgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHNhbXBsaW5nUHJvYikge1xyXG5cclxuICAgICAgICAgICAgICAgIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0aGlzLmFsaWdubWVudHMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZWRBbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudHNbaWR4XTsgICAvLyBUbyBiZSByZXBsYWNlZFxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhaXJzU3VwcG9ydGVkICYmIGNhbkJlUGFpcmVkKGFsaWdubWVudCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wYWlyc0NhY2hlW3JlcGxhY2VkQWxpZ25tZW50LnJlYWROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVtyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBwYWlyZWRBbGlnbm1lbnQgPSBuZXcgUGFpcmVkQWxpZ25tZW50KGFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFpcnNDYWNoZVthbGlnbm1lbnQucmVhZE5hbWVdID0gcGFpcmVkQWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gcGFpcmVkQWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25tZW50c1tpZHhdID0gYWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChyZXBsYWNlZEFsaWdubWVudC5yZWFkTmFtZSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb3duc2FtcGxlZFJlYWRzLmFkZChhbGlnbm1lbnQucmVhZE5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRvd25zYW1wbGVkQ291bnQrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuICAgIC8vIFRPRE8gLS0gcmVmYWN0b3IgdGhpcyB0byB1c2UgYW4gb2JqZWN0LCByYXRoZXIgdGhhbiBhbiBhcnJheSwgIGlmIGVuZC1zdGFydCBpcyA+IHNvbWUgdGhyZXNob2xkXHJcbmNsYXNzIENvdmVyYWdlTWFwe1xyXG4gICAgY29uc3RydWN0b3IoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY2hyID0gY2hyO1xyXG4gICAgICAgIHRoaXMuYnBTdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gKGVuZCAtIHN0YXJ0KTtcclxuXHJcbiAgICAgICAgdGhpcy5jb3ZlcmFnZSA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIHRoaXMubWF4aW11bSA9IDA7XHJcblxyXG4gICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgaW5jQ291bnRzKGFsaWdubWVudCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuYmxvY2tzID09PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIGluY0Jsb2NrQ291bnQoYWxpZ25tZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuICAgICAgICAgICAgICAgIGluY0Jsb2NrQ291bnQoYmxvY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluY0Jsb2NrQ291bnQoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBrZXksXHJcbiAgICAgICAgICAgICAgICBiYXNlLFxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgIGosXHJcbiAgICAgICAgICAgICAgICBxO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gYmxvY2suc3RhcnQgLSBzZWxmLmJwU3RhcnQsIGogPSAwOyBqIDwgYmxvY2subGVuOyBpKyssIGorKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5jb3ZlcmFnZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0gPSBuZXcgQ292ZXJhZ2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiYXNlID0gYmxvY2suc2VxLmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgIGtleSA9IChhbGlnbm1lbnQuc3RyYW5kKSA/IFwicG9zXCIgKyBiYXNlIDogXCJuZWdcIiArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICBxID0gYmxvY2sucXVhbFtqXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmNvdmVyYWdlW2ldW2tleV0gKz0gMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV1bXCJxdWFsXCIgKyBiYXNlXSArPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0udG90YWwgKz0gMTtcclxuICAgICAgICAgICAgICAgIHNlbGYuY292ZXJhZ2VbaV0ucXVhbCArPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYubWF4aW11bSA9IE1hdGgubWF4KHNlbGYuY292ZXJhZ2VbaV0udG90YWwsIHNlbGYubWF4aW11bSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5Db3ZlcmFnZU1hcC50aHJlc2hvbGQgPSAwLjI7XHJcbkNvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgPSB0cnVlO1xyXG5cclxuY2xhc3MgQ292ZXJhZ2V7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvc0EgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnQSA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zVCA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdUID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NDID0gMDtcclxuICAgICAgICB0aGlzLm5lZ0MgPSAwO1xyXG4gICAgICAgIHRoaXMucG9zRyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMubmVnRyA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucG9zTiA9IDA7XHJcbiAgICAgICAgdGhpcy5uZWdOID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xyXG4gICAgICAgIHRoaXMubmVnID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5xdWFsQSA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsVCA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsQyA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsRyA9IDA7XHJcbiAgICAgICAgdGhpcy5xdWFsTiA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMucXVhbCA9IDA7XHJcblxyXG4gICAgICAgIHRoaXMudG90YWwgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlzTWlzbWF0Y2gocmVmQmFzZSkge1xyXG5cclxuICAgICAgICB2YXIgbXlzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgbWlzbWF0Y2hRdWFsaXR5U3VtLFxyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBDb3ZlcmFnZU1hcC50aHJlc2hvbGQgKiAoKENvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgJiYgdGhpcy5xdWFsKSA/IHRoaXMucXVhbCA6IHRoaXMudG90YWwpO1xyXG5cclxuICAgICAgICBtaXNtYXRjaFF1YWxpdHlTdW0gPSAwO1xyXG4gICAgICAgIFtcIkFcIiwgXCJUXCIsIFwiQ1wiLCBcIkdcIl0uZm9yRWFjaChmdW5jdGlvbiAoYmFzZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGJhc2UgIT09IHJlZkJhc2UpIHtcclxuICAgICAgICAgICAgICAgIG1pc21hdGNoUXVhbGl0eVN1bSArPSAoKENvdmVyYWdlTWFwLnF1YWxpdHlXZWlnaHQgJiYgbXlzZWxmLnF1YWwpID8gbXlzZWxmW1wicXVhbFwiICsgYmFzZV0gOiAobXlzZWxmW1wicG9zXCIgKyBiYXNlXSArIG15c2VsZltcIm5lZ1wiICsgYmFzZV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbWlzbWF0Y2hRdWFsaXR5U3VtID49IHRocmVzaG9sZDtcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIERvd25zYW1wbGVkSW50ZXJ2YWx7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBjb3VudHMpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5jb3VudHMgPSBjb3VudHM7XHJcbiAgICB9XHJcblxyXG4gICAgcG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHtuYW1lOiBcInN0YXJ0XCIsIHZhbHVlOiB0aGlzLnN0YXJ0ICsgMX0sXHJcbiAgICAgICAgICAgIHtuYW1lOiBcImVuZFwiLCB2YWx1ZTogdGhpcy5lbmR9LFxyXG4gICAgICAgICAgICB7bmFtZTogXCIjIGRvd25zYW1wbGVkOlwiLCB2YWx1ZTogdGhpcy5jb3VudHN9XVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgUGFpcmVkQWxpZ25tZW50e1xyXG4gICAgY29uc3RydWN0b3IoZmlyc3RBbGlnbm1lbnQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5maXJzdEFsaWdubWVudCA9IGZpcnN0QWxpZ25tZW50O1xyXG4gICAgICAgIHRoaXMuY2hyID0gZmlyc3RBbGlnbm1lbnQuY2hyO1xyXG4gICAgICAgIHRoaXMucmVhZE5hbWUgPSBmaXJzdEFsaWdubWVudC5yZWFkTmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGZpcnN0QWxpZ25tZW50LnN0YXJ0IDwgZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmlyc3RBbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gTWF0aC5tYXgoZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbiwgZmlyc3RBbGlnbm1lbnQuc3RhcnQgKyBmaXJzdEFsaWdubWVudC5sZW5ndGhPblJlZik7ICAvLyBBcHByb3hpbWF0ZVxyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0ICsgZmlyc3RBbGlnbm1lbnQubGVuZ3RoT25SZWY7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gZmlyc3RBbGlnbm1lbnQubWF0ZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5lbmQgPSBmaXJzdEFsaWdubWVudC5zdGFydCArIGZpcnN0QWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGZpcnN0QWxpZ25tZW50Lm1hdGUucG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGluZ0VuZCA9IGZpcnN0QWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aE9uUmVmID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRTZWNvbmRBbGlnbm1lbnQoYWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gLS0gY2hlY2sgdGhlIGNocnMgYXJlIGVxdWFsLCAgZXJyb3Igb3RoZXJ3aXNlXHJcbiAgICAgICAgdGhpcy5zZWNvbmRBbGlnbm1lbnQgPSBhbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQuc3RhcnQgPiB0aGlzLmZpcnN0QWxpZ25tZW50LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYWxpZ25tZW50LnN0YXJ0ICsgYWxpZ25tZW50Lmxlbmd0aE9uUmVmO1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdFbmQgPSBhbGlnbm1lbnQuc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RpbmdTdGFydCA9IGFsaWdubWVudC5zdGFydCArIGFsaWdubWVudC5sZW5ndGhPblJlZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZW5ndGhPblJlZiA9IHRoaXMuZW5kIC0gdGhpcy5zdGFydDtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pIHtcclxuXHJcbiAgICAgICAgdmFyIG5hbWVWYWx1ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgbmFtZVZhbHVlcyA9IG5hbWVWYWx1ZXMuY29uY2F0KHRoaXMuZmlyc3RBbGlnbm1lbnQucG9wdXBEYXRhKGdlbm9taWNMb2NhdGlvbikpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zZWNvbmRBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcy5wdXNoKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcclxuICAgICAgICAgICAgbmFtZVZhbHVlcyA9IG5hbWVWYWx1ZXMuY29uY2F0KHRoaXMuc2Vjb25kQWxpZ25tZW50LnBvcHVwRGF0YShnZW5vbWljTG9jYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hbWVWYWx1ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgaXNQYWlyZWQgKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBCeSBkZWZpbml0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgZmlyc3RPZlBhaXJTdHJhbmQgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0QWxpZ25tZW50LmlzRmlyc3RPZlBhaXIoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdEFsaWdubWVudC5zdHJhbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Vjb25kQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY29uZEFsaWdubWVudC5zdHJhbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maXJzdEFsaWdubWVudC5zdHJhbmQ7ICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyBpbndhcmQgcG9pbnRpbmcgcGFpcnNcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jbGFzcyBCYW1BbGlnbm1lbnRSb3cge1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnNjb3JlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRDZW50ZXJBbGlnbm1lbnQoYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgdmFyIGNlbnRlckFsaWdubWVudCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgLy8gZmluZCBzaW5nbGUgYWxpZ25tZW50IHRoYXQgb3ZlcmxhcHMgc29ydCBsb2NhdGlvblxyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG5cclxuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2VudGVyQWxpZ25tZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChhLnN0YXJ0ICsgYS5sZW5ndGhPblJlZikgPCBicFN0YXJ0IHx8IGEuc3RhcnQgPiBicEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VudGVyQWxpZ25tZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjZW50ZXJBbGlnbm1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlU2NvcmUoZ2Vub21pY0xvY2F0aW9uLCBnZW5vbWljSW50ZXJ2YWwsIHNvcnRPcHRpb24pIHtcclxuXHJcbiAgICAgICAgdGhpcy5zY29yZSA9IHRoaXMuY2FjdWxhdGVTY29yZShnZW5vbWljTG9jYXRpb24sICgxICsgZ2Vub21pY0xvY2F0aW9uKSwgZ2Vub21pY0ludGVydmFsLCBzb3J0T3B0aW9uKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGNhY3VsYXRlU2NvcmUoYnBTdGFydCwgYnBFbmQsIGdlbm9taWNJbnRlcnZhbCwgc29ydE9wdGlvbikge1xyXG5cclxuICAgICAgICB2YXIgYmFzZVNjb3JlLFxyXG4gICAgICAgICAgICBhbGlnbm1lbnQ7XHJcblxyXG4gICAgICAgIGFsaWdubWVudCA9IHRoaXMuZmluZENlbnRlckFsaWdubWVudChicFN0YXJ0LCBicEVuZCk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gYWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKFwiTlVDTEVPVElERVwiID09PSBzb3J0T3B0aW9uLnNvcnQpIHtcclxuXHJcbiAgICAgICAgICAgIGJhc2VTY29yZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGFsaWdubWVudC5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBnZW5vbWljSW50ZXJ2YWwuc2VxdWVuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2VNYXAgPSBnZW5vbWljSW50ZXJ2YWwuY292ZXJhZ2VNYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY292ZXJhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGhyZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFwiKlwiICE9PSBibG9jay5zZXEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGluZGV4UmVmZXJlbmNlU2VxdWVuY2UgPSBibG9jay5zdGFydCAtIGdlbm9taWNJbnRlcnZhbC5zdGFydCwgYnBCbG9ja1NlcXVlbmNlID0gYmxvY2suc3RhcnQsIGxlbmd0aEJsb2NrU2VxdWVuY2UgPSBibG9jay5zZXEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGxlbmd0aEJsb2NrU2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpKyssIGluZGV4UmVmZXJlbmNlU2VxdWVuY2UrKywgYnBCbG9ja1NlcXVlbmNlKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicFN0YXJ0ID09PSBicEJsb2NrU2VxdWVuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2UgPSBzZXF1ZW5jZS5jaGFyQXQoaW5kZXhSZWZlcmVuY2VTZXF1ZW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmxvY2suc2VxLmNoYXJBdChpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZSA9PT0gXCI9XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gcmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlID09PSAnTicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmFzZSA9PT0gcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNjb3JlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJhc2UgPT09IFwiWFwiIHx8IGJhc2UgIT09IHJlZmVyZW5jZSl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyYWdlID0gY292ZXJhZ2VNYXAuY292ZXJhZ2VbIChicEJsb2NrU2VxdWVuY2UgLSBjb3ZlcmFnZU1hcC5icFN0YXJ0KSBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gY292ZXJhZ2VbIFwicG9zXCIgKyBiYXNlIF0gKyBjb3ZlcmFnZVsgXCJuZWdcIiArIGJhc2UgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaHJlZCA9IChjb3ZlcmFnZS5xdWFsKSA/IGNvdmVyYWdlLnF1YWwgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VTY29yZSA9IC0oY291bnQgKyAocGhyZWQgLyAxMDAwLjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJCYW1BbGlnbm1lbnRSb3cuY2FjdWxhdGVTY29yZSAtIGh1aD9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGJwU3RhcnQgPT09IGJwQmxvY2tTZXF1ZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IC8vIGJsb2NrLnNlcS5sZW5ndGhcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlU2NvcmUgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKHVuZGVmaW5lZCA9PT0gYmFzZVNjb3JlKSA/IE51bWJlci5NQVhfVkFMVUUgOiBiYXNlU2NvcmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiU1RSQU5EXCIgPT09IHNvcnRPcHRpb24uc29ydCkge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFsaWdubWVudC5zdHJhbmQgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFwiU1RBUlRcIiA9PT0gc29ydE9wdGlvbi5zb3J0KSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYWxpZ25tZW50LnN0YXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQge2xvYWRCYW1JbmRleCxCYW1SZWFkZXIsQmFtU291cmNlLEJhbUZpbHRlcixCYW1BbGlnbm1lbnQsUGFpcmVkQWxpZ25tZW50fTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/bam.js\n");

/***/ }),

/***/ "./src/bigwig.js":
/*!***********************!*\
  !*** ./src/bigwig.js ***!
  \***********************/
/*! exports provided: BWSource, BinaryParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Zlib, __webpack_provided_$_dot_extend) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BWSource\", function() { return BWSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryParser\", function() { return BinaryParser; });\n/* harmony import */ var _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n//***********js/bigwig/bufferedReader.js*****************\r\nclass BufferedReader{\r\n    constructor(config, contentLength, bufferSize) {\r\n        this.path = config.url;\r\n        this.contentLength = contentLength;\r\n        this.bufferSize = bufferSize ? bufferSize : 512000;\r\n        this.range = {start: -1, size: -1};\r\n        this.config = config;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param requestedRange - byte rangeas {start, size}\r\n     * @param fulfill - function to receive result\r\n     * @param asUint8 - optional flag to return result as an UInt8Array\r\n     */\r\n    dataViewForRange(requestedRange, asUint8) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var hasData = (self.data && (self.range.start <= requestedRange.start) &&\r\n                ((self.range.start + self.range.size) >= (requestedRange.start + requestedRange.size))),\r\n                bufferSize,\r\n                loadRange;\r\n\r\n            if (hasData) {\r\n                subbuffer(self, requestedRange, asUint8);\r\n            }\r\n            else {\r\n                // Expand buffer size if needed, but not beyond content length\r\n                bufferSize = Math.max(self.bufferSize, requestedRange.size);\r\n\r\n                if (self.contentLength > 0 && requestedRange.start + bufferSize > self.contentLength) {\r\n                    loadRange = {start: requestedRange.start};\r\n                }\r\n                else {\r\n                    loadRange = {start: requestedRange.start, size: bufferSize};\r\n                }\r\n\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, Object.assign(self.config, {range: loadRange}))\r\n                    .then(function (arrayBuffer) {\r\n                    self.data = arrayBuffer;\r\n                    self.range = loadRange;\r\n                    subbuffer(self, requestedRange, asUint8);\r\n                }).catch(reject);\r\n\r\n            }\r\n\r\n\r\n            function subbuffer(bufferedReader, requestedRange, asUint8) {\r\n\r\n                var len = bufferedReader.data.byteLength,\r\n                    bufferStart = requestedRange.start - bufferedReader.range.start,\r\n                    result = asUint8 ?\r\n                        new Uint8Array(bufferedReader.data, bufferStart, len - bufferStart) :\r\n                        new DataView(bufferedReader.data, bufferStart, len - bufferStart);\r\n                fulfill(result);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n//**********js/bigwig/bwSource.js***************\r\nclass BWSource{\r\n\r\n    constructor(config,create_feature_function) {\r\n        this.reader = new BWReader(config);\r\n        this.bufferedReader = new BufferedReader(config);\r\n        if (!create_feature_function){\r\n            this.create_feature=BWSource.createFeature;\r\n        }\r\n        else{\r\n            this.create_feature=create_feature_function;\r\n        }\r\n    }\r\n    \r\n    /**\r\n\t* Creates a panel\r\n\t* @param {string} chr - The chromosome\r\n\t* @param {int} bpStart The starting postition \r\n\t* @param {int} bpEnd - The end of the region to show\r\n\t* @param {boolean} use_existing - If true then the cached feature will be used- only used\r\n\t* if the co-oridinates have not changed. Although, the BWreader has a cache, it is sometimes\r\n\t* ignored and features are re-fetched for the same region\r\n\t* @param {object} data - Should contain pixelWidth- the width of the entire canvas and \r\n\t* bpPerPixel.\r\n\t*/\r\n    getFeatures(chr, bpStart, bpEnd,use_existing,data) {\r\n        this.st = new Date().getTime();\r\n        var self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n            if (self.features && use_existing){\r\n                fulfill(self.features);\r\n                return;\r\n            }\r\n            self.reader.getZoomHeaders().then(function (zoomLevelHeaders) {\r\n\r\n                // Select a biwig \"zoom level\" appropriate for the current resolution\r\n                var bwReader = self.reader,\r\n                    bufferedReader = self.bufferedReader,\r\n                    bpp =data.bpPerPixel,\r\n                    zoomLevelHeader=BWSource.zoomLevelForScale(bpp, zoomLevelHeaders),\r\n                    treeOffset\r\n                \r\n               \r\n                if (zoomLevelHeader && bwReader.type===\"BigWig\") {\r\n                    treeOffset = zoomLevelHeader.indexOffset;\r\n                    self.decodeFunction = BWSource.decodeZoomData;\r\n                } else {\r\n                    treeOffset = bwReader.header.fullIndexOffset;\r\n                    if (bwReader.type === \"BigWig\") {\r\n                        self.decodeFunction =BWSource.decodeWigData;\r\n                    }\r\n                    else {\r\n                        self.decodeFunction =self.decodeBedData;\r\n                    }\r\n                }\r\n\r\n                bwReader.loadRPTree(treeOffset).then(function (rpTree) {\r\n\r\n                    var chrIdx = self.reader.chromTree.dictionary[chr];\r\n                    if (chrIdx === undefined) {\r\n                        fulfill(null);\r\n                    }\r\n                    else {\r\n\r\n                        rpTree.findLeafItemsOverlapping(chrIdx, bpStart, bpEnd).then(function (leafItems) {\r\n\r\n                            var promises = [];\r\n\r\n                            if (!leafItems || leafItems.length == 0) fulfill([]);\r\n\r\n                            leafItems.forEach(function (item) {\r\n\r\n                                promises.push(new Promise(function (fulfill, reject) {\r\n                                    var features = [];\r\n\r\n                                    bufferedReader.dataViewForRange({\r\n                                        start: item.dataOffset,\r\n                                        size: item.dataSize\r\n                                    }, true).then(function (uint8Array) {\r\n                                  \r\n                                       var inflate = new Zlib.Zlib.Inflate(uint8Array);\r\n                                       var plain= inflate.decompress();\r\n                                       //var inflate = new pako.Inflate();\r\n                                       //inflate.push(uint8Array, true);\r\n                                        //var plain = inflate.result;\r\n                                        self.decodeFunction(new DataView(plain.buffer), chr, chrIdx, bpStart, bpEnd, features);\r\n\r\n                                        fulfill(features);\r\n\r\n                                    }).catch(reject);\r\n                                }));\r\n                            });\r\n\r\n\r\n                            Promise.all(promises).then(function (featureArrays) {\r\n                                var en = new Date().getTime();\r\n                                var e = en-self.st;\r\n                                var a = bpp;\r\n                                //console.log(e);\r\n                                var i, allFeatures = featureArrays[0];\r\n                                if(featureArrays.length > 1) {\r\n                                   for(i=1; i<featureArrays.length; i++) {\r\n                                       allFeatures = allFeatures.concat(featureArrays[i]);\r\n                                   }\r\n                                }  \r\n                                allFeatures.sort(function (a, b) {\r\n                                    return a.start - b.start;\r\n                                })\r\n                                self.features=allFeatures;\r\n                                fulfill(allFeatures)\r\n                            }).catch(reject);\r\n\r\n                        }).catch(function(error){\r\n                            reject(error);\r\n                        });\r\n                    }\r\n                }).catch(function(error){\r\n                    reject(error)\r\n                });\r\n            }).catch(function(error){\r\n                reject(error);\r\n            }\r\n            );\r\n\r\n\r\n        });\r\n    }\r\n    \r\n    \r\n    getDefaultRange() {\r\n        \r\n        if(this.reader.totalSummary != undefined) {\r\n            return this.reader.totalSummary.defaultRange;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    static zoomLevelForScale(bpPerPixel, zoomLevelHeaders) {\r\n\r\n        var level = null, i, zl;\r\n\r\n        for (i = 0; i < zoomLevelHeaders.length; i++) {\r\n\r\n            zl = zoomLevelHeaders[i];\r\n\r\n            if (zl.reductionLevel > bpPerPixel) {\r\n                level = zl;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (null == level) {\r\n            level = zoomLevelHeaders[zoomLevelHeaders.length - 1];\r\n        }\r\n\r\n        return (level && level.reductionLevel < 4 * bpPerPixel) ? level : null;\r\n    }\r\n\r\n\r\n    static decodeWigData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\r\n\r\n        var binaryParser = new BinaryParser(data),\r\n            chromId = binaryParser.getInt(),\r\n            chromStart = binaryParser.getInt(),\r\n            chromEnd = binaryParser.getInt(),\r\n            itemStep = binaryParser.getInt(),\r\n            itemSpan = binaryParser.getInt(),\r\n            type = binaryParser.getByte(),\r\n            reserved = binaryParser.getByte(),\r\n            itemCount = binaryParser.getUShort(),\r\n            value;\r\n\r\n        if (chromId === chrIdx) {\r\n\r\n            while (itemCount-- > 0) {\r\n\r\n                switch (type) {\r\n                    case 1:\r\n                        chromStart = binaryParser.getInt();\r\n                        chromEnd = binaryParser.getInt();\r\n                        value = binaryParser.getFloat();\r\n                        break;\r\n                    case 2:\r\n                        chromStart = binaryParser.getInt();\r\n                        value = binaryParser.getFloat();\r\n                        chromEnd = chromStart + itemSpan;\r\n                        break;\r\n                    case 3:  // Fixed step\r\n                        value = binaryParser.getFloat();\r\n                        chromEnd = chromStart + itemSpan;\r\n                        chromStart += itemStep;\r\n                        break;\r\n\r\n                }\r\n\r\n                if (chromStart >= bpEnd) {\r\n                    break; // Out of interval\r\n                } else if (chromEnd > bpStart && Number.isFinite(value)) {\r\n                    featureArray.push({chr: chr, start: chromStart, end: chromEnd, value: value});\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static decodeZoomData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\r\n\r\n        var binaryParser = new BinaryParser(data),\r\n            minSize = 8 * 4,   // Minimum # of bytes required for a zoom record\r\n            chromId,\r\n            chromStart,\r\n            chromEnd,\r\n            validCount,\r\n            minVal,\r\n            maxVal,\r\n            sumData,\r\n            sumSquares,\r\n            value;\r\n\r\n        while (binaryParser.remLength() >= minSize) {\r\n            chromId = binaryParser.getInt();\r\n            if (chromId === chrIdx) {\r\n\r\n                chromStart = binaryParser.getInt();\r\n                chromEnd = binaryParser.getInt();\r\n                validCount = binaryParser.getInt();\r\n                minVal = binaryParser.getFloat();\r\n                maxVal = binaryParser.getFloat();\r\n                sumData = binaryParser.getFloat();\r\n                sumSquares = binaryParser.getFloat();\r\n                value = validCount == 0 ? 0 : sumData / validCount;\r\n\r\n                if (chromStart >= bpEnd && chromStart<1000000000) {\r\n                     console.log(\"should have broken\")\r\n\r\n                    break; // Out of interval\r\n                   \r\n                } else if (chromEnd > bpStart && Number.isFinite(value)) {\r\n                    featureArray.push({chr: chr, start: chromStart, end: chromEnd, value: value});\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    decodeBedData(data, chr, chrIdx, bpStart, bpEnd, featureArray) {\r\n\r\n        var binaryParser = new BinaryParser(data),\r\n            minSize = 3 * 4 + 1,   // Minimum # of bytes required for a bed record\r\n            chromId,\r\n            chromStart,\r\n            chromEnd,\r\n            rest,\r\n            tokens,\r\n            feature,\r\n            exonCount, exonSizes, exonStarts, exons, eStart, eEnd;\r\n\r\n\r\n        while (binaryParser.remLength() >= minSize) {\r\n\r\n            chromId = binaryParser.getInt();\r\n            if (chromId != chrIdx) continue;\r\n\r\n            chromStart = binaryParser.getInt();\r\n            chromEnd = binaryParser.getInt();\r\n            rest = binaryParser.getString();\r\n\r\n            feature = {chr: chr, start: chromStart, end: chromEnd};\r\n\r\n            if (chromStart < bpEnd && chromEnd >= bpStart) {\r\n                featureArray.push(feature);\r\n\r\n                tokens = rest.split(\"\\t\");\r\n                this.create_feature(tokens,feature);\r\n\r\n                \r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n    static createFeature(tokens,feature){\r\n        if (tokens.length > 0) {\r\n                    feature.name = tokens[0];\r\n                }\r\n\r\n                if (tokens.length > 1) {\r\n                    feature.score = parseFloat(tokens[1]);\r\n                }\r\n                if (tokens.length > 2) {\r\n                    feature.strand = tokens[2];\r\n                }\r\n                if (tokens.length > 3) {\r\n                    feature.cdStart = parseInt(tokens[3]);\r\n                }\r\n                if (tokens.length > 4) {\r\n                    feature.cdEnd = parseInt(tokens[4]);\r\n                }\r\n                if (tokens.length > 5) {\r\n                    //if (tokens[5] !== \".\" && tokens[5] !== \"0\")\r\n                        //feature.color = igv.createColorString(tokens[5]);\r\n                }\r\n                if (tokens.length > 8) {\r\n                    exonCount = parseInt(tokens[6]);\r\n                    exonSizes = tokens[7].split(',');\r\n                    exonStarts = tokens[8].split(',');\r\n                    exons = [];\r\n\r\n                    for (var i = 0; i < exonCount; i++) {\r\n                        eStart = start + parseInt(exonStarts[i]);\r\n                        eEnd = eStart + parseInt(exonSizes[i]);\r\n                        exons.push({start: eStart, end: eEnd});\r\n                    }\r\n\r\n                    feature.exons = exons;\r\n                }\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n//************js/bigwig/bwReader.js*****************\r\n\r\n\r\nconst BIGWIG_MAGIC_LTH = 0x888FFC26; // BigWig Magic Low to High\r\nconst BIGWIG_MAGIC_HTL = 0x26FC8F66; // BigWig Magic High to Low\r\nconst BIGBED_MAGIC_LTH = 0x8789F2EB; // BigBed Magic Low to High\r\nconst BIGBED_MAGIC_HTL = 0xEBF28987; // BigBed Magic High to Low\r\nconst BBFILE_HEADER_SIZE = 64;\r\n\r\n\r\nclass BWReader{\r\n    constructor(config) {\r\n        this.path = config.url;\r\n        this.headPath = config.headURL || this.path;\r\n        this.rpTreeCache = {};\r\n        this.config = __webpack_provided_$_dot_extend({},config,true);\r\n    };\r\n\r\n    getZoomHeaders() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            if (self.zoomLevelHeaders) {\r\n                fulfill(self.zoomLevelHeaders);\r\n            }\r\n            else {\r\n                self.loadHeader().then(function () {\r\n                    fulfill(self.zoomLevelHeaders);\r\n                }).catch(function (error) {\r\n                    reject(error);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    loadHeader() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, Object.assign(self.config, {range: {start: 0, size: BBFILE_HEADER_SIZE}}))\r\n                .then(function (data) {\r\n\r\n                if (!data) return;\r\n\r\n                // Assume low-to-high unless proven otherwise\r\n                self.littleEndian = true;\r\n\r\n                var binaryParser = new BinaryParser(new DataView(data));\r\n\r\n                var magic = binaryParser.getUInt();\r\n\r\n                if (magic === BIGWIG_MAGIC_LTH) {\r\n                    self.type = \"BigWig\";\r\n                }\r\n                else if (magic == BIGBED_MAGIC_LTH) {\r\n                    self.type = \"BigBed\";\r\n                }\r\n                else {\r\n                    //Try big endian order\r\n                    self.littleEndian = false;\r\n\r\n                    binaryParser.littleEndian = false;\r\n                    binaryParser.position = 0;\r\n                    var magic = binaryParser.getUInt();\r\n\r\n                    if (magic === BIGWIG_MAGIC_HTL) {\r\n                        self.type = \"BigWig\";\r\n                    }\r\n                    else if (magic == BIGBED_MAGIC_HTL) {\r\n                        self.type = \"BigBed\";\r\n                    }\r\n                    else {\r\n                        // TODO -- error, unknown file type  or BE\r\n                    }\r\n\r\n                }\r\n                // Table 5  \"Common header for BigWig and BigBed files\"\r\n                self.header = {};\r\n                self.header.bwVersion = binaryParser.getUShort();\r\n                self.header.nZoomLevels = binaryParser.getUShort();\r\n                self.header.chromTreeOffset = binaryParser.getLong();\r\n                self.header.fullDataOffset = binaryParser.getLong();\r\n                self.header.fullIndexOffset = binaryParser.getLong();\r\n                self.header.fieldCount = binaryParser.getUShort();\r\n                self.header.definedFieldCount = binaryParser.getUShort();\r\n                self.header.autoSqlOffset = binaryParser.getLong();\r\n                self.header.totalSummaryOffset = binaryParser.getLong();\r\n                self.header.uncompressBuffSize = binaryParser.getInt();\r\n                self.header.reserved = binaryParser.getLong();\r\n\r\n                self.loadZoomHeadersAndChrTree().then(fulfill).catch(reject);\r\n            }).catch(function (error) {\r\n                    reject(error);\r\n                });\r\n\r\n        });\r\n    }\r\n\r\n\r\n   loadZoomHeadersAndChrTree() {\r\n\r\n\r\n        var startOffset = BBFILE_HEADER_SIZE,\r\n            self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            \r\n            var range = {start: startOffset, size: (self.header.fullDataOffset - startOffset + 5)};\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_0__[\"igvxhr\"].loadArrayBuffer(self.path, Object.assign(self.config, {range: range}))\r\n                .then(function (data) {\r\n\r\n                var nZooms = self.header.nZoomLevels,\r\n                    binaryParser = new BinaryParser(new DataView(data)),\r\n                    i,\r\n                    len,\r\n                    zoomNumber,\r\n                    zlh;\r\n\r\n                self.zoomLevelHeaders = [];\r\n\r\n                self.firstZoomDataOffset = Number.MAX_VALUE;\r\n                for (i = 0; i < nZooms; i++) {\r\n                    zoomNumber = nZooms - i;\r\n                    zlh = new ZoomLevelHeader(zoomNumber, binaryParser);\r\n                    self.firstZoomDataOffset = Math.min(zlh.dataOffset, self.firstZoomDataOffset);\r\n                    self.zoomLevelHeaders.push(zlh);\r\n                }\r\n\r\n                // Autosql\r\n                if (self.header.autoSqlOffset > 0) {\r\n                    binaryParser.position = self.header.autoSqlOffset - startOffset;\r\n                    self.autoSql = binaryParser.getString();\r\n                }\r\n\r\n                // Total summary\r\n                if (self.header.totalSummaryOffset > 0) {\r\n                    binaryParser.position = self.header.totalSummaryOffset - startOffset;\r\n                    self.totalSummary = new BWTotalSummary(binaryParser);\r\n                }\r\n\r\n                // Chrom data index\r\n                if (self.header.chromTreeOffset > 0) {\r\n                    binaryParser.position = self.header.chromTreeOffset - startOffset;\r\n                    self.chromTree = new BPTree(binaryParser, startOffset);\r\n                }\r\n                else {\r\n                    // TODO -- this is an error, not expected\r\n                }\r\n\r\n                //Finally total data count\r\n                binaryParser.position = self.header.fullDataOffset - startOffset;\r\n                self.dataCount = binaryParser.getInt();\r\n\r\n                fulfill();\r\n\r\n            }).catch(function(error){\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    loadRPTree(offset) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var rpTree = self.rpTreeCache[offset];\r\n            if (rpTree) {\r\n                fulfill(rpTree);\r\n            }\r\n            else {\r\n                rpTree = new RPTree(offset, self.contentLength, self.config, self.littleEndian);\r\n                self.rpTreeCache[offset] = rpTree;\r\n                rpTree.load().then(function () {\r\n                    fulfill(rpTree);\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n class ZoomLevelHeader{\r\n     constructor(index, byteBuffer) {\r\n        this.index = index;\r\n        this.reductionLevel = byteBuffer.getInt();\r\n        this.reserved = byteBuffer.getInt();\r\n        this.dataOffset = byteBuffer.getLong();\r\n        this.indexOffset = byteBuffer.getLong();\r\n    }\r\n }\r\n\r\n\r\nconst RPTREE_MAGIC_LTH = 0x2468ACE0;\r\nconst RPTREE_MAGIC_HTL = 0xE0AC6824;\r\nconst RPTREE_HEADER_SIZE = 48;\r\nconst RPTREE_NODE_LEAF_ITEM_SIZE = 32;   // leaf item size\r\nconst RPTREE_NODE_CHILD_ITEM_SIZE = 24;  // child item size\r\nconst BUFFER_SIZE = 512000; \r\n\r\n//***********js/bigwig/RPTree*******************\r\n\r\n\r\n     //  buffer\r\n\r\nclass RPTree{\r\n\r\n    constructor (fileOffset, contentLength, config, littleEndian) {\r\n\r\n        this.config = config;\r\n        this.filesize = contentLength;\r\n        this.fileOffset = fileOffset; // File offset to beginning of tree\r\n        this.path = config.url;\r\n        this.littleEndian = littleEndian;\r\n    }\r\n\r\n\r\n    load() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var rootNodeOffset = self.fileOffset + RPTREE_HEADER_SIZE,\r\n                bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\r\n\r\n            self.readNode(rootNodeOffset, bufferedReader).then(function (node) {\r\n                self.rootNode = node;\r\n                fulfill(self);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n\r\n    readNode(filePosition, bufferedReader) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            bufferedReader.dataViewForRange({start: filePosition, size: 4}, false).then(function (dataView) {\r\n                var binaryParser = new BinaryParser(dataView, self.littleEndian);\r\n\r\n                var type = binaryParser.getByte();\r\n                var isLeaf = (type === 1) ? true : false;\r\n                var reserved = binaryParser.getByte();\r\n                var count = binaryParser.getUShort();\r\n\r\n                filePosition += 4;\r\n\r\n                var bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);\r\n                var range2 = {start: filePosition, size: bytesRequired};\r\n\r\n                bufferedReader.dataViewForRange(range2, false).then(function (dataView) {\r\n\r\n                    var i,\r\n                        items = new Array(count),\r\n                        binaryParser = new BinaryParser(dataView);\r\n\r\n                    if (isLeaf) {\r\n                        for (i = 0; i < count; i++) {\r\n                            var item = {\r\n                                isLeaf: true,\r\n                                startChrom: binaryParser.getInt(),\r\n                                startBase: binaryParser.getInt(),\r\n                                endChrom: binaryParser.getInt(),\r\n                                endBase: binaryParser.getInt(),\r\n                                dataOffset: binaryParser.getLong(),\r\n                                dataSize: binaryParser.getLong()\r\n                            };\r\n                            items[i] = item;\r\n\r\n                        }\r\n                        fulfill(new RPTreeNode(items));\r\n                    }\r\n                    else { // non-leaf\r\n                        for (i = 0; i < count; i++) {\r\n\r\n                            var item = {\r\n                                isLeaf: false,\r\n                                startChrom: binaryParser.getInt(),\r\n                                startBase: binaryParser.getInt(),\r\n                                endChrom: binaryParser.getInt(),\r\n                                endBase: binaryParser.getInt(),\r\n                                childOffset: binaryParser.getLong()\r\n                            };\r\n                            items[i] = item;\r\n\r\n                        }\r\n\r\n                        fulfill(new RPTreeNode(items));\r\n                    }\r\n                }).catch(reject);\r\n            }).catch(reject);\r\n        });\r\n    }\r\n\r\n\r\n    findLeafItemsOverlapping(chrIdx, startBase, endBase) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var leafItems = [],\r\n                processing = new Set(),\r\n                bufferedReader = new BufferedReader(self.config, self.filesize, BUFFER_SIZE);\r\n\r\n            processing.add(0);  // Zero represents the root node\r\n            findLeafItems(self.rootNode, 0);\r\n\r\n            function findLeafItems(node, nodeId) {\r\n\r\n                if (RPTree.overlaps(node, chrIdx, startBase, endBase)) {\r\n\r\n                    var items = node.items;\r\n\r\n                    items.forEach(function (item) {\r\n\r\n                        if (RPTree.overlaps(item, chrIdx, startBase, endBase)) {\r\n\r\n                            if (item.isLeaf) {\r\n                                leafItems.push(item);\r\n                            }\r\n\r\n                            else {\r\n                                if (item.childNode) {\r\n                                    findLeafItems(item.childNode);\r\n                                }\r\n                                else {\r\n                                    processing.add(item.childOffset);  // Represent node to-be-loaded by its file position\r\n                                    self.readNode(item.childOffset, bufferedReader).then(function (node) {\r\n                                        item.childNode = node;\r\n                                        findLeafItems(node, item.childOffset);\r\n                                    }).catch(reject);\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                }\r\n\r\n                if (nodeId != undefined) processing.delete(nodeId);\r\n\r\n                // Wait until all nodes are processed\r\n                if (processing.size===0) {\r\n                    fulfill(leafItems);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Return true if {chrIdx:startBase-endBase} overlaps item's interval\r\n     * @returns {boolean}\r\n     */\r\n    static overlaps(item, chrIdx, startBase, endBase) {\r\n\r\n        //  if (chrIdx > item.endChrom || chrIdx < item.startChrom) return false;\r\n\r\n        if (!item) {\r\n            console.log(\"null item\");\r\n            return false;\r\n        }\r\n\r\n        return ((chrIdx > item.startChrom) || (chrIdx == item.startChrom && endBase >= item.startBase)) &&\r\n            ((chrIdx < item.endChrom) || (chrIdx == item.endChrom && startBase < item.endBase));\r\n    }\r\n}\r\n\r\n\r\nclass RPTreeNode{\r\n    constructor(items) {\r\n        this.items = items;\r\n\r\n        var minChromId = Number.MAX_VALUE,\r\n            maxChromId = 0,\r\n            minStartBase = Number.MAX_VALUE,\r\n            maxEndBase = 0,\r\n            i,\r\n            item;\r\n\r\n        for (i = 0; i < items.length; i++) {\r\n            item = items[i];\r\n            minChromId = Math.min(minChromId, item.startChrom);\r\n            maxChromId = Math.max(maxChromId, item.endChrom);\r\n            minStartBase = Math.min(minStartBase, item.startBase);\r\n            maxEndBase = Math.max(maxEndBase, item.endBase);\r\n        }\r\n\r\n        this.startChrom = minChromId;\r\n        this.endChrom = maxChromId;\r\n        this.startBase = minStartBase;\r\n        this.endBase = maxEndBase;\r\n\r\n    }\r\n}\r\n\r\n//*******************js/binary.js******************\r\nclass BinaryParser{\r\n    constructor(dataView, littleEndian) {\r\n\r\n        this.littleEndian = (littleEndian ? littleEndian : true);\r\n        this.position = 0;\r\n        this.view = dataView;\r\n        this.length = dataView.byteLength;\r\n    }\r\n\r\n    available() {\r\n        return this.length - this.position;\r\n    }\r\n\r\n    remLength() {\r\n        return this.length - this.position;\r\n    }\r\n\r\n    hasNext() {\r\n        return this.position < this.length - 1;\r\n    }\r\n\r\n    getByte() {\r\n        var retValue = this.view.getUint8(this.position, this.littleEndian);\r\n        this.position++;\r\n        return retValue;\r\n    }\r\n\r\n    getShort() {\r\n\r\n        var retValue = this.view.getInt16(this.position, this.littleEndian);\r\n        this.position += 2\r\n        return retValue;\r\n    }\r\n\r\n    getUShort(){\r\n\r\n        // var byte1 = this.getByte(),\r\n        //     byte2 = this.getByte(),\r\n        //     retValue = ((byte2 << 24 >>> 16) + (byte1 << 24 >>> 24));\r\n        //     return retValue;\r\n\r\n       //\r\n        var retValue = this.view.getUint16 (this.position, this.littleEndian);\r\n        this.position += 2\r\n        return retValue;\r\n    }\r\n\r\n\r\n    getInt() {\r\n\r\n        var retValue = this.view.getInt32(this.position, this.littleEndian);\r\n        this.position += 4;\r\n        return retValue;\r\n    }\r\n\r\n\r\n    getUInt() {\r\n        var retValue = this.view.getUint32(this.position, this.littleEndian);\r\n        this.position += 4;\r\n        return retValue;\r\n    }\r\n\r\n    getLong() {\r\n\r\n        // DataView doesn't support long. So we'll try manually\r\n\r\n        var b = [];\r\n        b[0] = this.view.getUint8(this.position);\r\n        b[1] = this.view.getUint8(this.position + 1);\r\n        b[2] = this.view.getUint8(this.position + 2);\r\n        b[3] = this.view.getUint8(this.position + 3);\r\n        b[4] = this.view.getUint8(this.position + 4);\r\n        b[5] = this.view.getUint8(this.position + 5);\r\n        b[6] = this.view.getUint8(this.position + 6);\r\n        b[7] = this.view.getUint8(this.position + 7);\r\n\r\n        var value = 0;\r\n        if (this.littleEndian) {\r\n            for (var i = b.length - 1; i >= 0; i--) {\r\n                value = (value * 256) + b[i];\r\n            }\r\n        } else {\r\n            for (var i = 0; i < b.length; i++) {\r\n                value = (value * 256) + b[i];\r\n            }\r\n        }\r\n\r\n\r\n        this.position += 8;\r\n        return value;\r\n    }\r\n\r\n    getString(len) {\r\n\r\n        var s = \"\";\r\n        var c;\r\n        while ((c = this.view.getUint8(this.position++)) != 0) {\r\n            s += String.fromCharCode(c);\r\n            if (len && s.length == len) break;\r\n        }\r\n        return s;\r\n    }\r\n\r\n    getFixedLengthString(len) {\r\n\r\n        var s = \"\";\r\n        var i;\r\n        var c;\r\n        for (i = 0; i < len; i++) {\r\n            c = this.view.getUint8(this.position++);\r\n            if (c > 0) {\r\n                s += String.fromCharCode(c);\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n\r\n    getFixedLengthTrimmedString(len) {\r\n\r\n        var s = \"\";\r\n        var i;\r\n        var c;\r\n        for (i = 0; i < len; i++) {\r\n            c = this.view.getUint8(this.position++);\r\n            if (c > 32) {\r\n                s += String.fromCharCode(c);\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n\r\n    getFloat() {\r\n\r\n        var retValue = this.view.getFloat32(this.position, this.littleEndian);\r\n        this.position += 4;\r\n        return retValue;\r\n\r\n\r\n    }\r\n\r\n    getDouble() {\r\n\r\n        var retValue = this.view.getFloat64(this.position, this.littleEndian);\r\n        this.position += 8;\r\n        return retValue;\r\n    }\r\n\r\n    skip(n) {\r\n\r\n        this.position += n;\r\n        return this.position;\r\n    }\r\n\r\n\r\n    /**\r\n     * Return a bgzip (bam and tabix) virtual pointer\r\n     * TODO -- why isn't 8th byte used ?\r\n     * @returns {*}\r\n     */\r\n    getVPointer() {\r\n\r\n        var position = this.position,\r\n            offset = (this.view.getUint8(position + 1) << 8) | (this.view.getUint8(position)),\r\n            byte6 = ((this.view.getUint8(position + 6) & 0xff) * 0x100000000),\r\n            byte5 = ((this.view.getUint8(position + 5) & 0xff) * 0x1000000),\r\n            byte4 = ((this.view.getUint8(position + 4) & 0xff) * 0x10000),\r\n            byte3 = ((this.view.getUint8(position + 3) & 0xff) * 0x100),\r\n            byte2 = ((this.view.getUint8(position + 2) & 0xff)),\r\n            block = byte6 + byte5 + byte4 + byte3 + byte2;\r\n        this.position += 8;\r\n\r\n        //       if (block == 0 && offset == 0) {\r\n        //           return null;\r\n        //       } else {\r\n        return new VPointer(block, offset);\r\n        //       }\r\n    }\r\n}\r\n\r\nclass VPointer{\r\n    constructor(block, offset) {\r\n        this.block = block;\r\n        this.offset = offset;\r\n    }\r\n\r\n    isLessThan(vp) {\r\n        return this.block < vp.block ||\r\n            (this.block === vp.block && this.offset < vp.offset);\r\n    }\r\n\r\n    isGreaterThan(vp) {\r\n        return this.block > vp.block ||\r\n            (this.block === vp.block && this.offset > vp.offset);\r\n    }\r\n\r\n    print() {\r\n        return \"\" + this.block + \":\" + this.offset;\r\n    }\r\n}\r\n\r\n\r\n//*******js/bigwig/bwTotalSummary.js*************\r\n\r\n\r\n\r\nclass BWTotalSummary{\r\n    constructor(byteBuffer) {\r\n\r\n        if (byteBuffer) {\r\n\r\n            this.basesCovered = byteBuffer.getLong();\r\n            this.minVal = byteBuffer.getDouble();\r\n            this.maxVal = byteBuffer.getDouble();\r\n            this.sumData = byteBuffer.getDouble();\r\n            this.sumSquares = byteBuffer.getDouble();\r\n\r\n            this.computeStats();\r\n        }\r\n        else {\r\n            this.basesCovered = 0;\r\n            this.minVal = 0;\r\n            this.maxVal = 0;\r\n            this.sumData = 0;\r\n            this.sumSquares = 0;\r\n            this.mean = 0;\r\n            this.stddev = 0;\r\n        }\r\n    }\r\n\r\n\r\n     computeStats() {\r\n        var n = this.basesCovered;\r\n        if (n > 0) {\r\n            this.mean = this.sumData / n;\r\n            this.stddev = Math.sqrt(this.sumSquares / (n - 1));\r\n\r\n            var min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0,\r\n                max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;\r\n\r\n            this.defaultRange = {\r\n                min: 0,\r\n                max: this.mean + 3 * this.stddev\r\n            }\r\n        }\r\n    }\r\n\r\n    updateStats(stats) {\r\n\r\n        this.basesCovered += stats.count;\r\n        this.sumData += status.sumData;\r\n        this.sumSquares += sumSquares;\r\n        this.minVal = MIN(_minVal, min);\r\n        this.maxVal = MAX(_maxVal, max);\r\n\r\n        computeStats.call(this);\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//***************js/bigwig/bwBPTree.js**************\r\n\r\n\r\nconst BPTREE_MAGIC_LTH = 0x78CA8C91;\r\nconst BPTREE_MAGIC_HTL = 0x918CCA78;\r\nconst BPTREE_HEADER_SIZE = 32;\r\n\r\n\r\n class BPTree{\r\n     constructor(binaryParser, startOffset) {\r\n\r\n        var self = this,\r\n            genome =  null;\r\n\r\n        this.header = {};\r\n        this.header.magic = binaryParser.getInt();\r\n        this.header.blockSize = binaryParser.getInt();\r\n        this.header.keySize = binaryParser.getInt();\r\n        this.header.valSize = binaryParser.getInt();\r\n        this.header.itemCount = binaryParser.getLong();\r\n        this.header.reserved = binaryParser.getLong();\r\n\r\n        this.dictionary = {};\r\n\r\n        // Recursively walk tree to populate dictionary\r\n        readTreeNode(binaryParser, -1, this.header.keySize, this.dictionary);\r\n\r\n        var itemSize = 8 + this.header.keySize;\r\n        var minSize = 4 + itemSize;   // Bytes for a node with 1 item\r\n\r\n        function readTreeNode(byteBuffer, offset, keySize, dictionary) {\r\n\r\n            if (offset >= 0) byteBuffer.position = offset;\r\n\r\n            var type = byteBuffer.getByte(),\r\n                reserved = byteBuffer.getByte(),\r\n                count = byteBuffer.getUShort(),\r\n                i,\r\n                key,\r\n                chromId,\r\n                chromSize,\r\n                childOffset,\r\n                bufferOffset,\r\n                currOffset;\r\n\r\n\r\n            if (type == 1) {\r\n\r\n                for (i = 0; i < count; i++) {\r\n\r\n                    key = byteBuffer.getFixedLengthTrimmedString(keySize);\r\n                    chromId = byteBuffer.getInt();\r\n                    chromSize = byteBuffer.getInt();\r\n\r\n                    if(genome) key = genome.getChromosomeName(key);  // Translate to canonical chr name\r\n                    dictionary[key] = chromId;\r\n\r\n                }\r\n            }\r\n            else { // non-leaf\r\n\r\n                for (i = 0; i < count; i++) {\r\n\r\n                    key = byteBuffer.getFixedLengthTrimmedString(keySize);\r\n                    childOffset = byteBuffer.getLong();\r\n                    bufferOffset = childOffset - startOffset;\r\n                    currOffset = byteBuffer.position;\r\n                    readTreeNode(byteBuffer, bufferOffset, keySize, dictionary);\r\n                    byteBuffer.position = currOffset;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\"), __webpack_require__(/*! extend */ \"extend\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYmlnd2lnLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2JpZ3dpZy5qcz9lODgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5pbXBvcnQge2lndnhocn0gZnJvbSBcIi4vaWd2eGhyLmpzXCI7XHJcblxyXG5cclxuLy8qKioqKioqKioqKmpzL2JpZ3dpZy9idWZmZXJlZFJlYWRlci5qcyoqKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJ1ZmZlcmVkUmVhZGVye1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBjb250ZW50TGVuZ3RoLCBidWZmZXJTaXplKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemUgPyBidWZmZXJTaXplIDogNTEyMDAwO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSB7c3RhcnQ6IC0xLCBzaXplOiAtMX07XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZFJhbmdlIC0gYnl0ZSByYW5nZWFzIHtzdGFydCwgc2l6ZX1cclxuICAgICAqIEBwYXJhbSBmdWxmaWxsIC0gZnVuY3Rpb24gdG8gcmVjZWl2ZSByZXN1bHRcclxuICAgICAqIEBwYXJhbSBhc1VpbnQ4IC0gb3B0aW9uYWwgZmxhZyB0byByZXR1cm4gcmVzdWx0IGFzIGFuIFVJbnQ4QXJyYXlcclxuICAgICAqL1xyXG4gICAgZGF0YVZpZXdGb3JSYW5nZShyZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBoYXNEYXRhID0gKHNlbGYuZGF0YSAmJiAoc2VsZi5yYW5nZS5zdGFydCA8PSByZXF1ZXN0ZWRSYW5nZS5zdGFydCkgJiZcclxuICAgICAgICAgICAgICAgICgoc2VsZi5yYW5nZS5zdGFydCArIHNlbGYucmFuZ2Uuc2l6ZSkgPj0gKHJlcXVlc3RlZFJhbmdlLnN0YXJ0ICsgcmVxdWVzdGVkUmFuZ2Uuc2l6ZSkpKSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlclNpemUsXHJcbiAgICAgICAgICAgICAgICBsb2FkUmFuZ2U7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGFzRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgc3ViYnVmZmVyKHNlbGYsIHJlcXVlc3RlZFJhbmdlLCBhc1VpbnQ4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBidWZmZXIgc2l6ZSBpZiBuZWVkZWQsIGJ1dCBub3QgYmV5b25kIGNvbnRlbnQgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBidWZmZXJTaXplID0gTWF0aC5tYXgoc2VsZi5idWZmZXJTaXplLCByZXF1ZXN0ZWRSYW5nZS5zaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb250ZW50TGVuZ3RoID4gMCAmJiByZXF1ZXN0ZWRSYW5nZS5zdGFydCArIGJ1ZmZlclNpemUgPiBzZWxmLmNvbnRlbnRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkUmFuZ2UgPSB7c3RhcnQ6IHJlcXVlc3RlZFJhbmdlLnN0YXJ0fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRSYW5nZSA9IHtzdGFydDogcmVxdWVzdGVkUmFuZ2Uuc3RhcnQsIHNpemU6IGJ1ZmZlclNpemV9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkQXJyYXlCdWZmZXIoc2VsZi5wYXRoLCBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCB7cmFuZ2U6IGxvYWRSYW5nZX0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF0YSA9IGFycmF5QnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmFuZ2UgPSBsb2FkUmFuZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViYnVmZmVyKHNlbGYsIHJlcXVlc3RlZFJhbmdlLCBhc1VpbnQ4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3ViYnVmZmVyKGJ1ZmZlcmVkUmVhZGVyLCByZXF1ZXN0ZWRSYW5nZSwgYXNVaW50OCkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXJlZFJlYWRlci5kYXRhLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyU3RhcnQgPSByZXF1ZXN0ZWRSYW5nZS5zdGFydCAtIGJ1ZmZlcmVkUmVhZGVyLnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFzVWludDggP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShidWZmZXJlZFJlYWRlci5kYXRhLCBidWZmZXJTdGFydCwgbGVuIC0gYnVmZmVyU3RhcnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGJ1ZmZlcmVkUmVhZGVyLmRhdGEsIGJ1ZmZlclN0YXJ0LCBsZW4gLSBidWZmZXJTdGFydCk7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqKioqanMvYmlnd2lnL2J3U291cmNlLmpzKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJXU291cmNle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxjcmVhdGVfZmVhdHVyZV9mdW5jdGlvbikge1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gbmV3IEJXUmVhZGVyKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihjb25maWcpO1xyXG4gICAgICAgIGlmICghY3JlYXRlX2ZlYXR1cmVfZnVuY3Rpb24pe1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlPUJXU291cmNlLmNyZWF0ZUZlYXR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlX2ZlYXR1cmU9Y3JlYXRlX2ZlYXR1cmVfZnVuY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuXHQqIENyZWF0ZXMgYSBwYW5lbFxyXG5cdCogQHBhcmFtIHtzdHJpbmd9IGNociAtIFRoZSBjaHJvbW9zb21lXHJcblx0KiBAcGFyYW0ge2ludH0gYnBTdGFydCBUaGUgc3RhcnRpbmcgcG9zdGl0aW9uIFxyXG5cdCogQHBhcmFtIHtpbnR9IGJwRW5kIC0gVGhlIGVuZCBvZiB0aGUgcmVnaW9uIHRvIHNob3dcclxuXHQqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlX2V4aXN0aW5nIC0gSWYgdHJ1ZSB0aGVuIHRoZSBjYWNoZWQgZmVhdHVyZSB3aWxsIGJlIHVzZWQtIG9ubHkgdXNlZFxyXG5cdCogaWYgdGhlIGNvLW9yaWRpbmF0ZXMgaGF2ZSBub3QgY2hhbmdlZC4gQWx0aG91Z2gsIHRoZSBCV3JlYWRlciBoYXMgYSBjYWNoZSwgaXQgaXMgc29tZXRpbWVzXHJcblx0KiBpZ25vcmVkIGFuZCBmZWF0dXJlcyBhcmUgcmUtZmV0Y2hlZCBmb3IgdGhlIHNhbWUgcmVnaW9uXHJcblx0KiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIFNob3VsZCBjb250YWluIHBpeGVsV2lkdGgtIHRoZSB3aWR0aCBvZiB0aGUgZW50aXJlIGNhbnZhcyBhbmQgXHJcblx0KiBicFBlclBpeGVsLlxyXG5cdCovXHJcbiAgICBnZXRGZWF0dXJlcyhjaHIsIGJwU3RhcnQsIGJwRW5kLHVzZV9leGlzdGluZyxkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5zdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoc2VsZi5mZWF0dXJlcyAmJiB1c2VfZXhpc3Rpbmcpe1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmZlYXR1cmVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxmLnJlYWRlci5nZXRab29tSGVhZGVycygpLnRoZW4oZnVuY3Rpb24gKHpvb21MZXZlbEhlYWRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgYSBiaXdpZyBcInpvb20gbGV2ZWxcIiBhcHByb3ByaWF0ZSBmb3IgdGhlIGN1cnJlbnQgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIGJ3UmVhZGVyID0gc2VsZi5yZWFkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRSZWFkZXIgPSBzZWxmLmJ1ZmZlcmVkUmVhZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGJwcCA9ZGF0YS5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbEhlYWRlcj1CV1NvdXJjZS56b29tTGV2ZWxGb3JTY2FsZShicHAsIHpvb21MZXZlbEhlYWRlcnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyZWVPZmZzZXRcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICh6b29tTGV2ZWxIZWFkZXIgJiYgYndSZWFkZXIudHlwZT09PVwiQmlnV2lnXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlT2Zmc2V0ID0gem9vbUxldmVsSGVhZGVyLmluZGV4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24gPSBCV1NvdXJjZS5kZWNvZGVab29tRGF0YTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJlZU9mZnNldCA9IGJ3UmVhZGVyLmhlYWRlci5mdWxsSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ3UmVhZGVyLnR5cGUgPT09IFwiQmlnV2lnXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvZGVGdW5jdGlvbiA9QldTb3VyY2UuZGVjb2RlV2lnRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb2RlRnVuY3Rpb24gPXNlbGYuZGVjb2RlQmVkRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYndSZWFkZXIubG9hZFJQVHJlZSh0cmVlT2Zmc2V0KS50aGVuKGZ1bmN0aW9uIChycFRyZWUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNocklkeCA9IHNlbGYucmVhZGVyLmNocm9tVHJlZS5kaWN0aW9uYXJ5W2Nocl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNocklkeCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcnBUcmVlLmZpbmRMZWFmSXRlbXNPdmVybGFwcGluZyhjaHJJZHgsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bmN0aW9uIChsZWFmSXRlbXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxlYWZJdGVtcyB8fCBsZWFmSXRlbXMubGVuZ3RoID09IDApIGZ1bGZpbGwoW10pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkUmVhZGVyLmRhdGFWaWV3Rm9yUmFuZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGl0ZW0uZGF0YU9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGl0ZW0uZGF0YVNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSkudGhlbihmdW5jdGlvbiAodWludDhBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZsYXRlID0gbmV3IFpsaWIuWmxpYi5JbmZsYXRlKHVpbnQ4QXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhaW49IGluZmxhdGUuZGVjb21wcmVzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2luZmxhdGUucHVzaCh1aW50OEFycmF5LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIHBsYWluID0gaW5mbGF0ZS5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29kZUZ1bmN0aW9uKG5ldyBEYXRhVmlldyhwbGFpbi5idWZmZXIpLCBjaHIsIGNocklkeCwgYnBTdGFydCwgYnBFbmQsIGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGZlYXR1cmVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChmZWF0dXJlQXJyYXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBlbi1zZWxmLnN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gYnBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGFsbEZlYXR1cmVzID0gZmVhdHVyZUFycmF5c1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmZWF0dXJlQXJyYXlzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaT0xOyBpPGZlYXR1cmVBcnJheXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBhbGxGZWF0dXJlcy5jb25jYXQoZmVhdHVyZUFycmF5c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlcz1hbGxGZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGFsbEZlYXR1cmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG5cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgZ2V0RGVmYXVsdFJhbmdlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnRvdGFsU3VtbWFyeS5kZWZhdWx0UmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIHpvb21MZXZlbEZvclNjYWxlKGJwUGVyUGl4ZWwsIHpvb21MZXZlbEhlYWRlcnMpIHtcclxuXHJcbiAgICAgICAgdmFyIGxldmVsID0gbnVsbCwgaSwgemw7XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICB6bCA9IHpvb21MZXZlbEhlYWRlcnNbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAoemwucmVkdWN0aW9uTGV2ZWwgPiBicFBlclBpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IHpsO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChudWxsID09IGxldmVsKSB7XHJcbiAgICAgICAgICAgIGxldmVsID0gem9vbUxldmVsSGVhZGVyc1t6b29tTGV2ZWxIZWFkZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsZXZlbCAmJiBsZXZlbC5yZWR1Y3Rpb25MZXZlbCA8IDQgKiBicFBlclBpeGVsKSA/IGxldmVsIDogbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIGRlY29kZVdpZ0RhdGEoZGF0YSwgY2hyLCBjaHJJZHgsIGJwU3RhcnQsIGJwRW5kLCBmZWF0dXJlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YSksXHJcbiAgICAgICAgICAgIGNocm9tSWQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICBpdGVtU3RlcCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgaXRlbVNwYW4gPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgIHR5cGUgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpLFxyXG4gICAgICAgICAgICByZXNlcnZlZCA9IGJpbmFyeVBhcnNlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgIGl0ZW1Db3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKSxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChjaHJvbUlkID09PSBjaHJJZHgpIHtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVtQ291bnQtLSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tU3RhcnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6ICAvLyBGaXhlZCBzdGVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNocm9tRW5kID0gY2hyb21TdGFydCArIGl0ZW1TcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHJvbVN0YXJ0ICs9IGl0ZW1TdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNocm9tU3RhcnQgPj0gYnBFbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gT3V0IG9mIGludGVydmFsXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZVpvb21EYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gOCAqIDQsICAgLy8gTWluaW11bSAjIG9mIGJ5dGVzIHJlcXVpcmVkIGZvciBhIHpvb20gcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICB2YWxpZENvdW50LFxyXG4gICAgICAgICAgICBtaW5WYWwsXHJcbiAgICAgICAgICAgIG1heFZhbCxcclxuICAgICAgICAgICAgc3VtRGF0YSxcclxuICAgICAgICAgICAgc3VtU3F1YXJlcyxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIHdoaWxlIChiaW5hcnlQYXJzZXIucmVtTGVuZ3RoKCkgPj0gbWluU2l6ZSkge1xyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCA9PT0gY2hySWR4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIGNocm9tRW5kID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgICAgIG1pblZhbCA9IGJpbmFyeVBhcnNlci5nZXRGbG9hdCgpO1xyXG4gICAgICAgICAgICAgICAgbWF4VmFsID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1EYXRhID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICBzdW1TcXVhcmVzID0gYmluYXJ5UGFyc2VyLmdldEZsb2F0KCk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbGlkQ291bnQgPT0gMCA/IDAgOiBzdW1EYXRhIC8gdmFsaWRDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyb21TdGFydCA+PSBicEVuZCAmJiBjaHJvbVN0YXJ0PDEwMDAwMDAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaG91bGQgaGF2ZSBicm9rZW5cIilcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIE91dCBvZiBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNocm9tRW5kID4gYnBTdGFydCAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUFycmF5LnB1c2goe2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZCwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICBkZWNvZGVCZWREYXRhKGRhdGEsIGNociwgY2hySWR4LCBicFN0YXJ0LCBicEVuZCwgZmVhdHVyZUFycmF5KSB7XHJcblxyXG4gICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKGRhdGEpLFxyXG4gICAgICAgICAgICBtaW5TaXplID0gMyAqIDQgKyAxLCAgIC8vIE1pbmltdW0gIyBvZiBieXRlcyByZXF1aXJlZCBmb3IgYSBiZWQgcmVjb3JkXHJcbiAgICAgICAgICAgIGNocm9tSWQsXHJcbiAgICAgICAgICAgIGNocm9tU3RhcnQsXHJcbiAgICAgICAgICAgIGNocm9tRW5kLFxyXG4gICAgICAgICAgICByZXN0LFxyXG4gICAgICAgICAgICB0b2tlbnMsXHJcbiAgICAgICAgICAgIGZlYXR1cmUsXHJcbiAgICAgICAgICAgIGV4b25Db3VudCwgZXhvblNpemVzLCBleG9uU3RhcnRzLCBleG9ucywgZVN0YXJ0LCBlRW5kO1xyXG5cclxuXHJcbiAgICAgICAgd2hpbGUgKGJpbmFyeVBhcnNlci5yZW1MZW5ndGgoKSA+PSBtaW5TaXplKSB7XHJcblxyXG4gICAgICAgICAgICBjaHJvbUlkID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyb21JZCAhPSBjaHJJZHgpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgY2hyb21TdGFydCA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICAgICAgY2hyb21FbmQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgIHJlc3QgPSBiaW5hcnlQYXJzZXIuZ2V0U3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogY2hyb21TdGFydCwgZW5kOiBjaHJvbUVuZH07XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hyb21TdGFydCA8IGJwRW5kICYmIGNocm9tRW5kID49IGJwU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVBcnJheS5wdXNoKGZlYXR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRva2VucyA9IHJlc3Quc3BsaXQoXCJcXHRcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZV9mZWF0dXJlKHRva2VucyxmZWF0dXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRpYyBjcmVhdGVGZWF0dXJlKHRva2VucyxmZWF0dXJlKXtcclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm5hbWUgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc3RyYW5kID0gdG9rZW5zWzJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5jZFN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuY2RFbmQgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAodG9rZW5zWzVdICE9PSBcIi5cIiAmJiB0b2tlbnNbNV0gIT09IFwiMFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZlYXR1cmUuY29sb3IgPSBpZ3YuY3JlYXRlQ29sb3JTdHJpbmcodG9rZW5zWzVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4b25Db3VudCA9IHBhcnNlSW50KHRva2Vuc1s2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvblNpemVzID0gdG9rZW5zWzddLnNwbGl0KCcsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhvblN0YXJ0cyA9IHRva2Vuc1s4XS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4b25zID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVN0YXJ0ID0gc3RhcnQgKyBwYXJzZUludChleG9uU3RhcnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZUVuZCA9IGVTdGFydCArIHBhcnNlSW50KGV4b25TaXplc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4b25zLnB1c2goe3N0YXJ0OiBlU3RhcnQsIGVuZDogZUVuZH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5leG9ucyA9IGV4b25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vLyoqKioqKioqKioqKmpzL2JpZ3dpZy9id1JlYWRlci5qcyoqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY29uc3QgQklHV0lHX01BR0lDX0xUSCA9IDB4ODg4RkZDMjY7IC8vIEJpZ1dpZyBNYWdpYyBMb3cgdG8gSGlnaFxyXG5jb25zdCBCSUdXSUdfTUFHSUNfSFRMID0gMHgyNkZDOEY2NjsgLy8gQmlnV2lnIE1hZ2ljIEhpZ2ggdG8gTG93XHJcbmNvbnN0IEJJR0JFRF9NQUdJQ19MVEggPSAweDg3ODlGMkVCOyAvLyBCaWdCZWQgTWFnaWMgTG93IHRvIEhpZ2hcclxuY29uc3QgQklHQkVEX01BR0lDX0hUTCA9IDB4RUJGMjg5ODc7IC8vIEJpZ0JlZCBNYWdpYyBIaWdoIHRvIExvd1xyXG5jb25zdCBCQkZJTEVfSEVBREVSX1NJWkUgPSA2NDtcclxuXHJcblxyXG5jbGFzcyBCV1JlYWRlcntcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgdGhpcy5oZWFkUGF0aCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMucGF0aDtcclxuICAgICAgICB0aGlzLnJwVHJlZUNhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSAkLmV4dGVuZCh7fSxjb25maWcsdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGdldFpvb21IZWFkZXJzKCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLnpvb21MZXZlbEhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi56b29tTGV2ZWxIZWFkZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZEhlYWRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi56b29tTGV2ZWxIZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRIZWFkZXIoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZToge3N0YXJ0OiAwLCBzaXplOiBCQkZJTEVfSEVBREVSX1NJWkV9fSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBsb3ctdG8taGlnaCB1bmxlc3MgcHJvdmVuIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgc2VsZi5saXR0bGVFbmRpYW4gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiaW5hcnlQYXJzZXIgPSBuZXcgQmluYXJ5UGFyc2VyKG5ldyBEYXRhVmlldyhkYXRhKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldFVJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWFnaWMgPT09IEJJR1dJR19NQUdJQ19MVEgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGUgPSBcIkJpZ1dpZ1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnaWMgPT0gQklHQkVEX01BR0lDX0xUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnQmVkXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1RyeSBiaWcgZW5kaWFuIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5saXR0bGVFbmRpYW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLmxpdHRsZUVuZGlhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hZ2ljID0gYmluYXJ5UGFyc2VyLmdldFVJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hZ2ljID09PSBCSUdXSUdfTUFHSUNfSFRMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZSA9IFwiQmlnV2lnXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2ljID09IEJJR0JFRF9NQUdJQ19IVEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlID0gXCJCaWdCZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gZXJyb3IsIHVua25vd24gZmlsZSB0eXBlICBvciBCRVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSA1ICBcIkNvbW1vbiBoZWFkZXIgZm9yIEJpZ1dpZyBhbmQgQmlnQmVkIGZpbGVzXCJcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyID0ge307XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5id1ZlcnNpb24gPSBiaW5hcnlQYXJzZXIuZ2V0VVNob3J0KCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5uWm9vbUxldmVscyA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci5mdWxsSW5kZXhPZmZzZXQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuZmllbGRDb3VudCA9IGJpbmFyeVBhcnNlci5nZXRVU2hvcnQoKTtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyLmRlZmluZWRGaWVsZENvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCA9IGJpbmFyeVBhcnNlci5nZXRMb25nKCk7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmhlYWRlci50b3RhbFN1bW1hcnlPZmZzZXQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIudW5jb21wcmVzc0J1ZmZTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oZWFkZXIucmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZFpvb21IZWFkZXJzQW5kQ2hyVHJlZSgpLnRoZW4oZnVsZmlsbCkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICBsb2FkWm9vbUhlYWRlcnNBbmRDaHJUcmVlKCkge1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gQkJGSUxFX0hFQURFUl9TSVpFLFxyXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHtzdGFydDogc3RhcnRPZmZzZXQsIHNpemU6IChzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCAtIHN0YXJ0T2Zmc2V0ICsgNSl9O1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWRBcnJheUJ1ZmZlcihzZWxmLnBhdGgsIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIHtyYW5nZTogcmFuZ2V9KSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5ab29tcyA9IHNlbGYuaGVhZGVyLm5ab29tTGV2ZWxzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIobmV3IERhdGFWaWV3KGRhdGEpKSxcclxuICAgICAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbixcclxuICAgICAgICAgICAgICAgICAgICB6b29tTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHpsaDtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnpvb21MZXZlbEhlYWRlcnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLmZpcnN0Wm9vbURhdGFPZmZzZXQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5ab29tczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgem9vbU51bWJlciA9IG5ab29tcyAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgemxoID0gbmV3IFpvb21MZXZlbEhlYWRlcih6b29tTnVtYmVyLCBiaW5hcnlQYXJzZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyc3Rab29tRGF0YU9mZnNldCA9IE1hdGgubWluKHpsaC5kYXRhT2Zmc2V0LCBzZWxmLmZpcnN0Wm9vbURhdGFPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuem9vbUxldmVsSGVhZGVycy5wdXNoKHpsaCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXV0b3NxbFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyLmF1dG9TcWxPZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluYXJ5UGFyc2VyLnBvc2l0aW9uID0gc2VsZi5oZWFkZXIuYXV0b1NxbE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXV0b1NxbCA9IGJpbmFyeVBhcnNlci5nZXRTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUb3RhbCBzdW1tYXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5oZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlci5wb3NpdGlvbiA9IHNlbGYuaGVhZGVyLnRvdGFsU3VtbWFyeU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYudG90YWxTdW1tYXJ5ID0gbmV3IEJXVG90YWxTdW1tYXJ5KGJpbmFyeVBhcnNlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hyb20gZGF0YSBpbmRleFxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyLmNocm9tVHJlZU9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5jaHJvbVRyZWVPZmZzZXQgLSBzdGFydE9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tVHJlZSA9IG5ldyBCUFRyZWUoYmluYXJ5UGFyc2VyLCBzdGFydE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0tIHRoaXMgaXMgYW4gZXJyb3IsIG5vdCBleHBlY3RlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vRmluYWxseSB0b3RhbCBkYXRhIGNvdW50XHJcbiAgICAgICAgICAgICAgICBiaW5hcnlQYXJzZXIucG9zaXRpb24gPSBzZWxmLmhlYWRlci5mdWxsRGF0YU9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2VsZi5kYXRhQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG5cclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZFJQVHJlZShvZmZzZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcnBUcmVlID0gc2VsZi5ycFRyZWVDYWNoZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICBpZiAocnBUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHJwVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBycFRyZWUgPSBuZXcgUlBUcmVlKG9mZnNldCwgc2VsZi5jb250ZW50TGVuZ3RoLCBzZWxmLmNvbmZpZywgc2VsZi5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5ycFRyZWVDYWNoZVtvZmZzZXRdID0gcnBUcmVlO1xyXG4gICAgICAgICAgICAgICAgcnBUcmVlLmxvYWQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJwVHJlZSk7XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbiBjbGFzcyBab29tTGV2ZWxIZWFkZXJ7XHJcbiAgICAgY29uc3RydWN0b3IoaW5kZXgsIGJ5dGVCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5yZWR1Y3Rpb25MZXZlbCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5yZXNlcnZlZCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5kYXRhT2Zmc2V0ID0gYnl0ZUJ1ZmZlci5nZXRMb25nKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleE9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgfVxyXG4gfVxyXG5cclxuXHJcbmNvbnN0IFJQVFJFRV9NQUdJQ19MVEggPSAweDI0NjhBQ0UwO1xyXG5jb25zdCBSUFRSRUVfTUFHSUNfSFRMID0gMHhFMEFDNjgyNDtcclxuY29uc3QgUlBUUkVFX0hFQURFUl9TSVpFID0gNDg7XHJcbmNvbnN0IFJQVFJFRV9OT0RFX0xFQUZfSVRFTV9TSVpFID0gMzI7ICAgLy8gbGVhZiBpdGVtIHNpemVcclxuY29uc3QgUlBUUkVFX05PREVfQ0hJTERfSVRFTV9TSVpFID0gMjQ7ICAvLyBjaGlsZCBpdGVtIHNpemVcclxuY29uc3QgQlVGRkVSX1NJWkUgPSA1MTIwMDA7IFxyXG5cclxuLy8qKioqKioqKioqKmpzL2JpZ3dpZy9SUFRyZWUqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuICAgICAvLyAgYnVmZmVyXHJcblxyXG5jbGFzcyBSUFRyZWV7XHJcblxyXG4gICAgY29uc3RydWN0b3IgKGZpbGVPZmZzZXQsIGNvbnRlbnRMZW5ndGgsIGNvbmZpZywgbGl0dGxlRW5kaWFuKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuZmlsZXNpemUgPSBjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuZmlsZU9mZnNldCA9IGZpbGVPZmZzZXQ7IC8vIEZpbGUgb2Zmc2V0IHRvIGJlZ2lubmluZyBvZiB0cmVlXHJcbiAgICAgICAgdGhpcy5wYXRoID0gY29uZmlnLnVybDtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgbG9hZCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdE5vZGVPZmZzZXQgPSBzZWxmLmZpbGVPZmZzZXQgKyBSUFRSRUVfSEVBREVSX1NJWkUsXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihzZWxmLmNvbmZpZywgc2VsZi5maWxlc2l6ZSwgQlVGRkVSX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgc2VsZi5yZWFkTm9kZShyb290Tm9kZU9mZnNldCwgYnVmZmVyZWRSZWFkZXIpLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYucm9vdE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmVhZE5vZGUoZmlsZVBvc2l0aW9uLCBidWZmZXJlZFJlYWRlcikge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHtzdGFydDogZmlsZVBvc2l0aW9uLCBzaXplOiA0fSwgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGRhdGFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UGFyc2VyID0gbmV3IEJpbmFyeVBhcnNlcihkYXRhVmlldywgc2VsZi5saXR0bGVFbmRpYW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYmluYXJ5UGFyc2VyLmdldEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0xlYWYgPSAodHlwZSA9PT0gMSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzZXJ2ZWQgPSBiaW5hcnlQYXJzZXIuZ2V0Qnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gYmluYXJ5UGFyc2VyLmdldFVTaG9ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVQb3NpdGlvbiArPSA0O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBieXRlc1JlcXVpcmVkID0gY291bnQgKiAoaXNMZWFmID8gUlBUUkVFX05PREVfTEVBRl9JVEVNX1NJWkUgOiBSUFRSRUVfTk9ERV9DSElMRF9JVEVNX1NJWkUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlMiA9IHtzdGFydDogZmlsZVBvc2l0aW9uLCBzaXplOiBieXRlc1JlcXVpcmVkfTtcclxuXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlci5kYXRhVmlld0ZvclJhbmdlKHJhbmdlMiwgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKGRhdGFWaWV3KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IG5ldyBBcnJheShjb3VudCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVBhcnNlciA9IG5ldyBCaW5hcnlQYXJzZXIoZGF0YVZpZXcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMZWFmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xlYWY6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDaHJvbTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0QmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQmFzZTogYmluYXJ5UGFyc2VyLmdldEludCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQ6IGJpbmFyeVBhcnNlci5nZXRMb25nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVNpemU6IGJpbmFyeVBhcnNlci5nZXRMb25nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwobmV3IFJQVHJlZU5vZGUoaXRlbXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIG5vbi1sZWFmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFmOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydENocm9tOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ2hyb206IGJpbmFyeVBhcnNlci5nZXRJbnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRCYXNlOiBiaW5hcnlQYXJzZXIuZ2V0SW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRPZmZzZXQ6IGJpbmFyeVBhcnNlci5nZXRMb25nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG5ldyBSUFRyZWVOb2RlKGl0ZW1zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZmluZExlYWZJdGVtc092ZXJsYXBwaW5nKGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsZWFmSXRlbXMgPSBbXSxcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcgPSBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICBidWZmZXJlZFJlYWRlciA9IG5ldyBCdWZmZXJlZFJlYWRlcihzZWxmLmNvbmZpZywgc2VsZi5maWxlc2l6ZSwgQlVGRkVSX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgcHJvY2Vzc2luZy5hZGQoMCk7ICAvLyBaZXJvIHJlcHJlc2VudHMgdGhlIHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKHNlbGYucm9vdE5vZGUsIDApO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZExlYWZJdGVtcyhub2RlLCBub2RlSWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoUlBUcmVlLm92ZXJsYXBzKG5vZGUsIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBub2RlLml0ZW1zO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUlBUcmVlLm92ZXJsYXBzKGl0ZW0sIGNocklkeCwgc3RhcnRCYXNlLCBlbmRCYXNlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmlzTGVhZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWZJdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kTGVhZkl0ZW1zKGl0ZW0uY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcuYWRkKGl0ZW0uY2hpbGRPZmZzZXQpOyAgLy8gUmVwcmVzZW50IG5vZGUgdG8tYmUtbG9hZGVkIGJ5IGl0cyBmaWxlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVhZE5vZGUoaXRlbS5jaGlsZE9mZnNldCwgYnVmZmVyZWRSZWFkZXIpLnRoZW4oZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGROb2RlID0gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmRMZWFmSXRlbXMobm9kZSwgaXRlbS5jaGlsZE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgIT0gdW5kZWZpbmVkKSBwcm9jZXNzaW5nLmRlbGV0ZShub2RlSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdhaXQgdW50aWwgYWxsIG5vZGVzIGFyZSBwcm9jZXNzZWRcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nLnNpemU9PT0wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChsZWFmSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB7Y2hySWR4OnN0YXJ0QmFzZS1lbmRCYXNlfSBvdmVybGFwcyBpdGVtJ3MgaW50ZXJ2YWxcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb3ZlcmxhcHMoaXRlbSwgY2hySWR4LCBzdGFydEJhc2UsIGVuZEJhc2UpIHtcclxuXHJcbiAgICAgICAgLy8gIGlmIChjaHJJZHggPiBpdGVtLmVuZENocm9tIHx8IGNocklkeCA8IGl0ZW0uc3RhcnRDaHJvbSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoIWl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJudWxsIGl0ZW1cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKGNocklkeCA+IGl0ZW0uc3RhcnRDaHJvbSkgfHwgKGNocklkeCA9PSBpdGVtLnN0YXJ0Q2hyb20gJiYgZW5kQmFzZSA+PSBpdGVtLnN0YXJ0QmFzZSkpICYmXHJcbiAgICAgICAgICAgICgoY2hySWR4IDwgaXRlbS5lbmRDaHJvbSkgfHwgKGNocklkeCA9PSBpdGVtLmVuZENocm9tICYmIHN0YXJ0QmFzZSA8IGl0ZW0uZW5kQmFzZSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgUlBUcmVlTm9kZXtcclxuICAgIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xyXG5cclxuICAgICAgICB2YXIgbWluQ2hyb21JZCA9IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgICAgIG1heENocm9tSWQgPSAwLFxyXG4gICAgICAgICAgICBtaW5TdGFydEJhc2UgPSBOdW1iZXIuTUFYX1ZBTFVFLFxyXG4gICAgICAgICAgICBtYXhFbmRCYXNlID0gMCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgaXRlbTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgICAgbWluQ2hyb21JZCA9IE1hdGgubWluKG1pbkNocm9tSWQsIGl0ZW0uc3RhcnRDaHJvbSk7XHJcbiAgICAgICAgICAgIG1heENocm9tSWQgPSBNYXRoLm1heChtYXhDaHJvbUlkLCBpdGVtLmVuZENocm9tKTtcclxuICAgICAgICAgICAgbWluU3RhcnRCYXNlID0gTWF0aC5taW4obWluU3RhcnRCYXNlLCBpdGVtLnN0YXJ0QmFzZSk7XHJcbiAgICAgICAgICAgIG1heEVuZEJhc2UgPSBNYXRoLm1heChtYXhFbmRCYXNlLCBpdGVtLmVuZEJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zdGFydENocm9tID0gbWluQ2hyb21JZDtcclxuICAgICAgICB0aGlzLmVuZENocm9tID0gbWF4Q2hyb21JZDtcclxuICAgICAgICB0aGlzLnN0YXJ0QmFzZSA9IG1pblN0YXJ0QmFzZTtcclxuICAgICAgICB0aGlzLmVuZEJhc2UgPSBtYXhFbmRCYXNlO1xyXG5cclxuICAgIH1cclxufVxyXG5cclxuLy8qKioqKioqKioqKioqKioqKioqanMvYmluYXJ5LmpzKioqKioqKioqKioqKioqKioqXHJcbmNsYXNzIEJpbmFyeVBhcnNlcntcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFWaWV3LCBsaXR0bGVFbmRpYW4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSAobGl0dGxlRW5kaWFuID8gbGl0dGxlRW5kaWFuIDogdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gZGF0YVZpZXc7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGF2YWlsYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbUxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPCB0aGlzLmxlbmd0aCAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Qnl0ZSgpIHtcclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2hvcnQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyXHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFVTaG9ydCgpe1xyXG5cclxuICAgICAgICAvLyB2YXIgYnl0ZTEgPSB0aGlzLmdldEJ5dGUoKSxcclxuICAgICAgICAvLyAgICAgYnl0ZTIgPSB0aGlzLmdldEJ5dGUoKSxcclxuICAgICAgICAvLyAgICAgcmV0VmFsdWUgPSAoKGJ5dGUyIDw8IDI0ID4+PiAxNikgKyAoYnl0ZTEgPDwgMjQgPj4+IDI0KSk7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiByZXRWYWx1ZTtcclxuXHJcbiAgICAgICAvL1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYgKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDJcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEludCgpIHtcclxuXHJcbiAgICAgICAgdmFyIHJldFZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBnZXRVSW50KCkge1xyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdGhpcy5saXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcclxuICAgICAgICByZXR1cm4gcmV0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TG9uZygpIHtcclxuXHJcbiAgICAgICAgLy8gRGF0YVZpZXcgZG9lc24ndCBzdXBwb3J0IGxvbmcuIFNvIHdlJ2xsIHRyeSBtYW51YWxseVxyXG5cclxuICAgICAgICB2YXIgYiA9IFtdO1xyXG4gICAgICAgIGJbMF0gPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgYlsxXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMSk7XHJcbiAgICAgICAgYlsyXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMik7XHJcbiAgICAgICAgYlszXSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMyk7XHJcbiAgICAgICAgYls0XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNCk7XHJcbiAgICAgICAgYls1XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNSk7XHJcbiAgICAgICAgYls2XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNik7XHJcbiAgICAgICAgYls3XSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgNyk7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBiLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NikgKyBiW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICB3aGlsZSAoKGMgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5wb3NpdGlvbisrKSkgIT0gMCkge1xyXG4gICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIGlmIChsZW4gJiYgcy5sZW5ndGggPT0gbGVuKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Rml4ZWRMZW5ndGhTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspO1xyXG4gICAgICAgICAgICBpZiAoYyA+IDApIHtcclxuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcobGVuKSB7XHJcblxyXG4gICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgYztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLnBvc2l0aW9uKyspO1xyXG4gICAgICAgICAgICBpZiAoYyA+IDMyKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmxvYXQoKSB7XHJcblxyXG4gICAgICAgIHZhciByZXRWYWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMucG9zaXRpb24sIHRoaXMubGl0dGxlRW5kaWFuKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbHVlO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RG91YmxlKCkge1xyXG5cclxuICAgICAgICB2YXIgcmV0VmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLnBvc2l0aW9uLCB0aGlzLmxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA4O1xyXG4gICAgICAgIHJldHVybiByZXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBza2lwKG4pIHtcclxuXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGJnemlwIChiYW0gYW5kIHRhYml4KSB2aXJ0dWFsIHBvaW50ZXJcclxuICAgICAqIFRPRE8gLS0gd2h5IGlzbid0IDh0aCBieXRlIHVzZWQgP1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGdldFZQb2ludGVyKCkge1xyXG5cclxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMSkgPDwgOCkgfCAodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uKSksXHJcbiAgICAgICAgICAgIGJ5dGU2ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA2KSAmIDB4ZmYpICogMHgxMDAwMDAwMDApLFxyXG4gICAgICAgICAgICBieXRlNSA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgNSkgJiAweGZmKSAqIDB4MTAwMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGU0ID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyA0KSAmIDB4ZmYpICogMHgxMDAwMCksXHJcbiAgICAgICAgICAgIGJ5dGUzID0gKCh0aGlzLnZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAzKSAmIDB4ZmYpICogMHgxMDApLFxyXG4gICAgICAgICAgICBieXRlMiA9ICgodGhpcy52aWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMikgJiAweGZmKSksXHJcbiAgICAgICAgICAgIGJsb2NrID0gYnl0ZTYgKyBieXRlNSArIGJ5dGU0ICsgYnl0ZTMgKyBieXRlMjtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDg7XHJcblxyXG4gICAgICAgIC8vICAgICAgIGlmIChibG9jayA9PSAwICYmIG9mZnNldCA9PSAwKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIC8vICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWUG9pbnRlcihibG9jaywgb2Zmc2V0KTtcclxuICAgICAgICAvLyAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIFZQb2ludGVye1xyXG4gICAgY29uc3RydWN0b3IoYmxvY2ssIG9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpc0xlc3NUaGFuKHZwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPCB2cC5ibG9jayB8fFxyXG4gICAgICAgICAgICAodGhpcy5ibG9jayA9PT0gdnAuYmxvY2sgJiYgdGhpcy5vZmZzZXQgPCB2cC5vZmZzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzR3JlYXRlclRoYW4odnApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA+IHZwLmJsb2NrIHx8XHJcbiAgICAgICAgICAgICh0aGlzLmJsb2NrID09PSB2cC5ibG9jayAmJiB0aGlzLm9mZnNldCA+IHZwLm9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLmJsb2NrICsgXCI6XCIgKyB0aGlzLm9mZnNldDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vKioqKioqKmpzL2JpZ3dpZy9id1RvdGFsU3VtbWFyeS5qcyoqKioqKioqKioqKipcclxuXHJcblxyXG5cclxuY2xhc3MgQldUb3RhbFN1bW1hcnl7XHJcbiAgICBjb25zdHJ1Y3RvcihieXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgIGlmIChieXRlQnVmZmVyKSB7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pblZhbCA9IGJ5dGVCdWZmZXIuZ2V0RG91YmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4VmFsID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdW1EYXRhID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5zdW1TcXVhcmVzID0gYnl0ZUJ1ZmZlci5nZXREb3VibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZVN0YXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VzQ292ZXJlZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMubWluVmFsID0gMDtcclxuICAgICAgICAgICAgdGhpcy5tYXhWYWwgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN1bURhdGEgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN1bVNxdWFyZXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm1lYW4gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZGRldiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAgY29tcHV0ZVN0YXRzKCkge1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5iYXNlc0NvdmVyZWQ7XHJcbiAgICAgICAgaWYgKG4gPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVhbiA9IHRoaXMuc3VtRGF0YSAvIG47XHJcbiAgICAgICAgICAgIHRoaXMuc3RkZGV2ID0gTWF0aC5zcXJ0KHRoaXMuc3VtU3F1YXJlcyAvIChuIC0gMSkpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMubWluVmFsIDwgMCA/IHRoaXMubWVhbiAtIDIgKiB0aGlzLnN0ZGRldiA6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLm1heFZhbCA+IDAgPyB0aGlzLm1lYW4gKyAyICogdGhpcy5zdGRkZXYgOiAwO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0UmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWVhbiArIDMgKiB0aGlzLnN0ZGRldlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZVN0YXRzKHN0YXRzKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmFzZXNDb3ZlcmVkICs9IHN0YXRzLmNvdW50O1xyXG4gICAgICAgIHRoaXMuc3VtRGF0YSArPSBzdGF0dXMuc3VtRGF0YTtcclxuICAgICAgICB0aGlzLnN1bVNxdWFyZXMgKz0gc3VtU3F1YXJlcztcclxuICAgICAgICB0aGlzLm1pblZhbCA9IE1JTihfbWluVmFsLCBtaW4pO1xyXG4gICAgICAgIHRoaXMubWF4VmFsID0gTUFYKF9tYXhWYWwsIG1heCk7XHJcblxyXG4gICAgICAgIGNvbXB1dGVTdGF0cy5jYWxsKHRoaXMpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqKioqKioqKipqcy9iaWd3aWcvYndCUFRyZWUuanMqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJQVFJFRV9NQUdJQ19MVEggPSAweDc4Q0E4QzkxO1xyXG5jb25zdCBCUFRSRUVfTUFHSUNfSFRMID0gMHg5MThDQ0E3ODtcclxuY29uc3QgQlBUUkVFX0hFQURFUl9TSVpFID0gMzI7XHJcblxyXG5cclxuIGNsYXNzIEJQVHJlZXtcclxuICAgICBjb25zdHJ1Y3RvcihiaW5hcnlQYXJzZXIsIHN0YXJ0T2Zmc2V0KSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgZ2Vub21lID0gIG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMuaGVhZGVyID0ge307XHJcbiAgICAgICAgdGhpcy5oZWFkZXIubWFnaWMgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIuYmxvY2tTaXplID0gYmluYXJ5UGFyc2VyLmdldEludCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLmtleVNpemUgPSBiaW5hcnlQYXJzZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXIudmFsU2l6ZSA9IGJpbmFyeVBhcnNlci5nZXRJbnQoKTtcclxuICAgICAgICB0aGlzLmhlYWRlci5pdGVtQ291bnQgPSBiaW5hcnlQYXJzZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyLnJlc2VydmVkID0gYmluYXJ5UGFyc2VyLmdldExvbmcoKTtcclxuXHJcbiAgICAgICAgdGhpcy5kaWN0aW9uYXJ5ID0ge307XHJcblxyXG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHdhbGsgdHJlZSB0byBwb3B1bGF0ZSBkaWN0aW9uYXJ5XHJcbiAgICAgICAgcmVhZFRyZWVOb2RlKGJpbmFyeVBhcnNlciwgLTEsIHRoaXMuaGVhZGVyLmtleVNpemUsIHRoaXMuZGljdGlvbmFyeSk7XHJcblxyXG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IDggKyB0aGlzLmhlYWRlci5rZXlTaXplO1xyXG4gICAgICAgIHZhciBtaW5TaXplID0gNCArIGl0ZW1TaXplOyAgIC8vIEJ5dGVzIGZvciBhIG5vZGUgd2l0aCAxIGl0ZW1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZFRyZWVOb2RlKGJ5dGVCdWZmZXIsIG9mZnNldCwga2V5U2l6ZSwgZGljdGlvbmFyeSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKG9mZnNldCA+PSAwKSBieXRlQnVmZmVyLnBvc2l0aW9uID0gb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBieXRlQnVmZmVyLmdldEJ5dGUoKSxcclxuICAgICAgICAgICAgICAgIHJlc2VydmVkID0gYnl0ZUJ1ZmZlci5nZXRCeXRlKCksXHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IGJ5dGVCdWZmZXIuZ2V0VVNob3J0KCksXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICAgICAgY2hyb21JZCxcclxuICAgICAgICAgICAgICAgIGNocm9tU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgY3Vyck9mZnNldDtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gYnl0ZUJ1ZmZlci5nZXRGaXhlZExlbmd0aFRyaW1tZWRTdHJpbmcoa2V5U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21JZCA9IGJ5dGVCdWZmZXIuZ2V0SW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hyb21TaXplID0gYnl0ZUJ1ZmZlci5nZXRJbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZ2Vub21lKSBrZXkgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUoa2V5KTsgIC8vIFRyYW5zbGF0ZSB0byBjYW5vbmljYWwgY2hyIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0gPSBjaHJvbUlkO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gbm9uLWxlYWZcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBieXRlQnVmZmVyLmdldEZpeGVkTGVuZ3RoVHJpbW1lZFN0cmluZyhrZXlTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE9mZnNldCA9IGJ5dGVCdWZmZXIuZ2V0TG9uZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlck9mZnNldCA9IGNoaWxkT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyck9mZnNldCA9IGJ5dGVCdWZmZXIucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZFRyZWVOb2RlKGJ5dGVCdWZmZXIsIGJ1ZmZlck9mZnNldCwga2V5U2l6ZSwgZGljdGlvbmFyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUJ1ZmZlci5wb3NpdGlvbiA9IGN1cnJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5leHBvcnQge0JXU291cmNlLEJpbmFyeVBhcnNlcn07XHJcblxyXG5cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/bigwig.js\n");

/***/ }),

/***/ "./src/feature.js":
/*!************************!*\
  !*** ./src/feature.js ***!
  \************************/
/*! exports provided: FeatureSource, FastaSequence, BigBedFeatureSource, TabixBedFeatureSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FeatureSource\", function() { return FeatureSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FastaSequence\", function() { return FastaSequence; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BigBedFeatureSource\", function() { return BigBedFeatureSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TabixBedFeatureSource\", function() { return TabixBedFeatureSource; });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n/* harmony import */ var _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./igvxhr.js */ \"./src/igvxhr.js\");\n/* harmony import */ var _bam_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bam.js */ \"./src/bam.js\");\n/* harmony import */ var _bigwig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MAX_GZIP_BLOCK_SIZE = (1 << 16);\r\n\r\n    /**\r\n     * feature source for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n     *\r\n     * @param config\r\n     * @constructor\r\n     */\r\nclass FeatureSource{\r\n    constructor(config) {\r\n        this.config = config || {};\r\n    }\r\n\r\n\r\n    getFileHeader() {\r\n        this.is_indexed=true;  \r\n        return new Promise(function (fulfill, reject) {\r\n            fulfill();        \r\n        });\r\n    }   \r\n\r\n\r\n    getFeatures(chr,start,end,force,data){\r\n      \r\n        //no need to get header\r\n        if (this.is_indexed){\r\n            return this._getFeatures(chr,start,end,force,data);\r\n        }\r\n        //get headers/index then get features\r\n        var self = this;\r\n        return new Promise(function(fulfill,reject){\r\n            self.getFileHeader().then(function(){\r\n                self._getFeatures(chr,start,end,force,data).then(function(features){\r\n                    fulfill(features);\r\n                }).catch(reject)\r\n            }).catch(reject);\r\n        });\r\n        \r\n    }\r\n\r\n    /**\r\n     * Required function fo all data source objects.  Fetches features for the\r\n     * range requested and passes them on to the success function.  Usually this is\r\n     * a function that renders the features on the canvas\r\n     *\r\n     * @param chr\r\n     * @param bpStart\r\n     * @param bpEnd\r\n     */\r\n    _getFeatures(chr, bpStart, bpEnd,force,data) {\r\n        if (bpStart===0){\r\n            bpStart=1;\r\n        }\r\n        var self = this;\r\n        self.time=Date.now();\r\n        return new Promise(function (fulfill, reject) {\r\n            if (self.featureCache && chr !== self.featureCache.range.chr){\r\n                self.featureCache=null;\r\n            }\r\n            var genomicInterval = new GenomicInterval(chr, bpStart, bpEnd),\r\n                featureCache = self.featureCache,\r\n                maxRows = self.config.maxRows || 500;\r\n            let ranges_to_get=false;\r\n            if (!featureCache){\r\n                ranges_to_get={all:[bpStart,bpEnd]};\r\n            }\r\n            else{\r\n                if (featureCache.range !== undefined){\r\n                    ranges_to_get=featureCache.range.rangesToGet(genomicInterval)\r\n                }\r\n            }\r\n            if (!ranges_to_get) {\r\n                fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\r\n            }\r\n            else{\r\n                let promises=[];\r\n                let p_types=[];\r\n                for (let type in ranges_to_get){\r\n                    let range= ranges_to_get[type];\r\n                    promises.push(self.retrieveFeatures(chr, range[0], range[1],force,data));\r\n                    p_types.push([type,ranges_to_get[type]]);\r\n                }\r\n                Promise.all(promises).then(\r\n                    function (all_features) {\r\n                        let existing_features=[];\r\n                        if (self.featureCache){\r\n                            existing_features=self.featureCache.allFeatures();//featureCache.allFeatures(chr,self.featureCache.range.start,self.featureCache.range.end);\r\n                        }\r\n                        let index=0;\r\n                        for (let featureList of all_features){\r\n                            if (featureList === null){\r\n                                featureList=[];\r\n                            }                            \r\n                            if (p_types[index][0]===\"left\"){\r\n                                let end = p_types[index][1][1]; \r\n                                //remove any already retieved  \r\n                                let splice=0;\r\n                                for (let n=featureList.length-1;n>=0;n--){\r\n                                    if (featureList[n].end< end){\r\n                                        break;\r\n                                    }\r\n                                    splice++;\r\n                                }\r\n                                if (splice!==0){\r\n                                    featureList.splice(-splice)\r\n                                }\r\n\r\n                            }\r\n                            if (p_types[index][0]===\"right\"){\r\n                                let start=p_types[index][1][0];\r\n                                //remove any already retieved\r\n                                let i=0\r\n                                for (i=0;i<featureList.length;i++){\r\n                                    if (featureList[i].start> start){\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (i!==0){\r\n                                    featureList.splice(0,i)\r\n                                }\r\n                            }\r\n                            index++;\r\n                            existing_features=existing_features.concat(featureList);\r\n                        }\r\n                        let gi = self.featureCache?self.featureCache.range:genomicInterval;\r\n                        self.featureCache = new FeatureCache(existing_features, gi);\r\n                        FeatureSource.packFeatures(existing_features, maxRows); \r\n                        fulfill(self.featureCache.queryFeatures(chr, bpStart, bpEnd));\r\n                }).catch(function(error){\r\n                    reject(error);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    static packFeatures(features, maxRows) {\r\n\r\n        if (features == null || features.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Segregate by chromosome\r\n\r\n        var chrFeatureMap = {},\r\n            chrs = [];\r\n        features.forEach(function (feature) {\r\n\r\n            var chr = feature.chr,\r\n                flist = chrFeatureMap[chr];\r\n\r\n            if (!flist) {\r\n                flist = [];\r\n                chrFeatureMap[chr] = flist;\r\n                chrs.push(chr);\r\n            }\r\n\r\n            flist.push(feature);\r\n        });\r\n\r\n        // Loop through chrosomosomes and pack features;\r\n\r\n        chrs.forEach(function (chr) {\r\n\r\n            pack(chrFeatureMap[chr], maxRows);\r\n        });\r\n\r\n\r\n        // Assigns a row # to each feature.  If the feature does not fit in any row and #rows == maxRows no\r\n        // row number is assigned.\r\n        function pack(featureList, maxRows) {\r\n\r\n            var rows = [];\r\n\r\n            featureList.sort(function (a, b) {\r\n                return a.start - b.start;\r\n            })\r\n\r\n\r\n            rows.push(-1000);\r\n            featureList.forEach(function (feature) {\r\n\r\n                var i,\r\n                    r,\r\n                    len = Math.min(rows.length, maxRows),\r\n                    start = feature.start;\r\n\r\n                for (r = 0; r < len; r++) {\r\n                    if (start >= rows[r]) {\r\n                        feature.row = r;\r\n                        rows[r] = feature.end;\r\n                        return;\r\n                    }\r\n                }\r\n                feature.row = r;\r\n                rows[r] = feature.end;\r\n\r\n\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass TabixBedFeatureSource extends FeatureSource{\r\n    constructor(config,decode_function){\r\n        super(config);\r\n        this.reader = new FeatureFileReader(config,decode_function);\r\n    }\r\n\r\n    retrieveFeatures(chr,start,end){\r\n        return this.reader.readFeatures(chr,start,end);\r\n    }\r\n\r\n    getFileHeader() {\r\n        var self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n            self.reader.readHeader().then(function () {\r\n                self.is_indexed=true;  \r\n                fulfill();\r\n             }).catch(reject);\r\n                \r\n        });\r\n    }   \r\n}\r\n\r\nclass BigBedFeatureSource extends FeatureSource{\r\n    constructor(config,decode_function){\r\n\t\tconfig.sourceType=\"gtex\";\r\n\t\tsuper(config);\r\n\t\tthis.header=true;\r\n\t\tthis.feature_source=new _bigwig_js__WEBPACK_IMPORTED_MODULE_3__[\"BWSource\"](config,decode_function);\r\n\t}\r\n\r\n\tretrieveFeatures(chr,bpStart,bpEnd,force,data){\r\n\t\treturn this.feature_source.getFeatures(chr,bpStart,bpEnd,false,data);     \t\r\n\t}\r\n}\r\n\r\n//********js/FeatureFileReader.js*****\r\n\r\n\r\n\r\nconst F_MAX_GZIP_BLOCK_SIZE = (1 << 16);\r\n\r\n    /**\r\n     * Reader for \"bed like\" files (tab delimited files with 1 feature per line: bed, gff, vcf, etc)\r\n     *\r\n     * @param config\r\n     * @constructor\r\n     */\r\nclass FeatureFileReader{\r\n    constructor(config,dec_function) {\r\n\r\n        this.config = config || {};\r\n\r\n        if (config.localFile) {\r\n            this.localFile = config.localFile;\r\n            this.filename = config.localFile.name;\r\n        }\r\n        else {\r\n            this.url = config.url;\r\n            this.indexURL = config.indexURL;\r\n            this.headURL = config.headURL || this.filename;\r\n\r\n            var uriParts = _utils_js__WEBPACK_IMPORTED_MODULE_0__[\"Utils\"].parseUri(config.url);\r\n            this.filename = uriParts.file;\r\n            this.path = uriParts.path;\r\n        }\r\n\r\n        this.format = config.format;\r\n\r\n        this.parser = this.getParser(this.format, dec_function);\r\n    };\r\n\r\n\r\n    getParser(format, decode) {\r\n        switch (format) {\r\n            case \"vcf\":\r\n                return new VcfParser();\r\n            case \"seg\" :\r\n                return new SegParser();\r\n            default:\r\n                return new FeatureParser(format, decode, this.config);\r\n        }\r\n\r\n    }\r\n\r\n    // seg files don't have an index\r\n    isIndexable() {\r\n        var configIndexURL = this.config.indexURL,\r\n            type = this.type,\r\n            configIndexed = this.config.indexed;\r\n\r\n        return configIndexURL || (type != \"wig\" && configIndexed != false);\r\n    }\r\n\r\n\r\n    /**\r\n     * Return a Promise for the async loaded index\r\n     */\r\n    loadIndex() {\r\n        var idxFile = this.indexURL;\r\n        if (this.filename.endsWith(\".gz\")) {\r\n            if (!idxFile) idxFile = this.url + \".tbi\";\r\n            return Object(_bam_js__WEBPACK_IMPORTED_MODULE_2__[\"loadBamIndex\"])(idxFile, this.config, true);\r\n        }\r\n        else {\r\n            if (!idxFile) idxFile = this.url + \".idx\";\r\n            return loadTribbleIndex(idxFile, this.config);\r\n        }\r\n    }\r\n\r\n    loadFeaturesNoIndex() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var parser = self.parser,\r\n                options = {\r\n                    headers: self.config.headers,           // http headers, not file header\r\n                    withCredentials: self.config.withCredentials\r\n                };\r\n\r\n            if (self.localFile) {\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadStringFromFile(self.localFile, options).then(parseData).catch(reject);\r\n            }\r\n            else {\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadString(self.url, options).then(parseData).catch(reject);\r\n            }\r\n\r\n\r\n            function parseData(data) {\r\n                self.header = parser.parseHeader(data);\r\n                if (self.header instanceof String && self.header.startsWith(\"##gff-version 3\")) {\r\n                    self.format = 'gff3';\r\n                }\r\n                fulfill(parser.parseFeatures(data));   // <= PARSING DONE HERE\r\n            };\r\n        });\r\n    }\r\n\r\n\r\n    loadFeaturesWithIndex(chr, start, end) {\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var blocks,\r\n                index = self.index,\r\n                tabix = index && index.tabix,\r\n                refId = tabix ? index.sequenceIndexMap[chr] : chr,\r\n                promises = [];\r\n\r\n            blocks = index.blocksForRange(refId, start, end);\r\n\r\n            if (!blocks || blocks.length === 0) {\r\n                fulfill(null);       // TODO -- is this correct?  Should it return an empty array?\r\n            }\r\n            else {\r\n\r\n                blocks.forEach(function (block) {\r\n\r\n                    promises.push(new Promise(function (fulfill, reject) {\r\n\r\n                        var startPos = block.minv.block,\r\n                            startOffset = block.minv.offset,\r\n                            endPos = block.maxv.block + (index.tabix ? F_MAX_GZIP_BLOCK_SIZE : 0),\r\n                            options = {\r\n                                headers: self.config.headers,           // http headers, not file header\r\n                                range: {start: startPos, size: endPos - startPos + 1},\r\n                                withCredentials: self.config.withCredentials\r\n                            },\r\n                            success;\r\n\r\n                        success = function (data) {\r\n\r\n                            var inflated, slicedData;\r\n\r\n                            if (index.tabix) {\r\n\r\n                                inflated = _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].arrayBufferToString(Object(_igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"unbgzf\"])(data));\r\n                                // need to decompress data\r\n                            }\r\n                            else {\r\n                                inflated = data;\r\n                            }\r\n\r\n                            slicedData = startOffset ? inflated.slice(startOffset) : inflated;\r\n                            var f = self.parser.parseFeatures(slicedData,chr,start,end);\r\n                            fulfill(f);\r\n                        };\r\n\r\n\r\n                        // Async load\r\n                        if (self.localFile) {\r\n                            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadStringFromFile(self.localFile, options).then(success).catch(reject);\r\n                        }\r\n                        else {\r\n                            if (index.tabix) {\r\n                                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadArrayBuffer(self.url, options).then(success).catch(reject);\r\n                            }\r\n                            else {\r\n                                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadString(self.url, options).then(success).catch(reject);\r\n                            }\r\n                        }\r\n                    }))\r\n                });\r\n\r\n                Promise.all(promises).then(function (featureArrays) {\r\n\r\n                    var i, allFeatures;\r\n\r\n                    if (featureArrays.length === 1) {\r\n                        allFeatures = featureArrays[0];\r\n                    } else {\r\n                        allFeatures = featureArrays[0];\r\n\r\n                        for (i = 1; i < featureArrays.length; i++) {\r\n                            allFeatures = allFeatures.concat(featureArrays[i]);\r\n                        }\r\n\r\n                        allFeatures.sort(function (a, b) {\r\n                            return a.start - b.start;\r\n                        });\r\n                    }\r\n\r\n                    fulfill(allFeatures)\r\n                }).catch(reject);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n\r\n    getIndex() {\r\n\r\n        var self = this,\r\n        isIndeedIndexible = this.isIndexable();\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.indexed === undefined && isIndeedIndexible) {\r\n                self.loadIndex().then(function (index) {\r\n                    if (index) {\r\n                        self.index = index;\r\n                        self.indexed = true;\r\n                    }\r\n                    else {\r\n                        self.indexed = false;\r\n                    }\r\n                    fulfill(self.index);\r\n                }).catch(reject);\r\n            }\r\n            else {\r\n                fulfill(self.index);   // Is either already loaded, or there isn't one\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    readHeader() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n\r\n            if (self.header) {\r\n                fulfill(self.header);\r\n            }\r\n\r\n            else {\r\n\r\n                // We force a load of the index first\r\n\r\n               self. getIndex().then(function (index) {\r\n\r\n                    if (index) {\r\n                        // Load the file header (not HTTP header) for an indexed file.\r\n                        // TODO -- note this will fail if the file header is > 65kb in size\r\n                        var options = {\r\n                                headers: self.config.headers,           // http headers, not file header\r\n                                bgz: index.tabix,\r\n                                range: {start: 0, size: 65000},\r\n                                withCredentials: self.config.withCredentials\r\n                            },\r\n                            success = function (data) {\r\n                                self.header = self.parser.parseHeader(data);\r\n                                fulfill(self.header);\r\n                            };\r\n\r\n                        if (self.localFile) {\r\n                            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadStringFromFile(self.localFile, options).then(success);\r\n                        }\r\n                        else {\r\n                            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].loadString(self.url, options).then(success).catch(reject);\r\n                        }\r\n                    }\r\n                    else {\r\n                        self.loadFeaturesNoIndex(undefined).then(function (features) {\r\n                            var header = self.header || {};\r\n                            header.features = features;\r\n                            fulfill(header);\r\n                        }).catch(error);\r\n                    }\r\n                }).catch(reject);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param fulfill\r\n     * @param range -- genomic range to load.  For use with indexed source (optional)\r\n     */\r\n    readFeatures(chr, start, end) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.index) {\r\n                self.loadFeaturesWithIndex(chr, start, end).then(packFeatures);\r\n            }\r\n            else {\r\n                self.loadFeaturesNoIndex().then(packFeatures);\r\n            }\r\n\r\n            function packFeatures(features) {\r\n                // TODO pack\r\n                fulfill(features);\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//***js/feature/FeatureParsers.js**************\r\n\r\n\r\nconst maxFeatureCount = Number.MAX_VALUE;    // For future use,  controls downsampling\r\n\r\nconst gffNameFields = [\"Name\", \"gene_name\", \"gene\", \"gene_id\", \"alias\", \"locus\"];\r\n\r\n    /**\r\n     * A factory function.  Return a parser for the given file format.\r\n     */\r\nclass FeatureParser{\r\n    constructor(format, decode_func, config) {\r\n\r\n        var customFormat;\r\n\r\n        this.format = format;\r\n        this.nameField = config ? config.nameField : undefined;\r\n        this.skipRows = 0;   // The number of fixed header rows to skip.  Override for specific types as neede\r\n\r\n        if (decode_func) {\r\n            this.delimiter = /\\s+/;\r\n\r\n            this.decode =function(tokens,ignore){\r\n                let feature={chr:tokens[0],start:parseInt(tokens[1]),end:parseInt(tokens[2])}\r\n                decode_func(tokens.slice(3),feature);\r\n                return feature;\r\n            } ;\r\n        }\r\n        else if (config.decode_function===\"generic\"){\r\n             this.decode =function(tokens,ignore){\r\n                let feature={chr:tokens[0],start:parseInt(tokens[1]),end:parseInt(tokens[2])}\r\n                feature.data=tokens.slice(3);\r\n                return feature;\r\n            } ;\r\n        }\r\n        else{\r\n            this.decode = FeatureParser.decodeBed;\r\n            this.delimiter = /\\s+/;\r\n\r\n        }\r\n\r\n                                       \r\n\r\n\r\n       /* switch (format) {\r\n            case \"narrowpeak\":\r\n            case \"broadpeak\":\r\n            case \"peaks\":\r\n                this.decode = this.decodePeak;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"bedgraph\":\r\n                this.decode = this.decodeBedGraph;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"wig\":\r\n                this.decode = this.decodeWig;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"gff3\" :\r\n            case \"gff\" :\r\n            case \"gtf\" :\r\n                this.decode = this.decodeGFF;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            case \"aneu\":\r\n                this.decode = this.decodeAneu;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            case \"fusionjuncspan\":\r\n                // bhaas, needed for FusionInspector view\r\n                this.decode = this.decodeFusionJuncSpan;\r\n                this.delimiter = /\\s+/;\r\n                break;\r\n            case \"gtexgwas\":\r\n                this.skipRows = 1;\r\n                this.decode = this.decodeGtexGWAS;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            case \"refflat\":\r\n                this.decode = this.decodeRefflat;\r\n                this.delimiter = \"\\t\";\r\n                break;\r\n            default:\r\n\r\n               customFormat = igv.browser.getFormat(format);\r\n                if (customFormat !== undefined) {\r\n                    this.decode = decodeCustom;\r\n                    this.format = customFormat;\r\n                    this.delimiter = customFormat.delimiter || \"\\t\";\r\n                }\r\n\r\n                else {\r\n                \r\n               // }\r\n\r\n        }*/\r\n\r\n    };\r\n\r\n    parseHeader(data) {\r\n\r\n        var lines = data.split(\"\\n\"),\r\n            len = lines.length,\r\n            line,\r\n            i,\r\n            header;\r\n\r\n        for (i = 0; i < len; i++) {\r\n            line = lines[i];\r\n            if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\r\n                if (line.startsWith(\"track\")) {\r\n                    header = this.parseTrackLine(line);\r\n                }\r\n                else if (line.startsWith(\"##gff-version 3\")) {\r\n                    this.format = \"gff3\";\r\n                    if (!header) header = {};\r\n                    header[\"format\"] = \"gff3\";\r\n                }\r\n            }\r\n            else {\r\n                header={};\r\n                break;\r\n            }\r\n        }\r\n        return header;\r\n    };\r\n\r\n    parseFeatures(data,chr,start,end) {\r\n\r\n        if (!data) return null;\r\n\r\n        var wig,\r\n            feature,\r\n            lines = data.split(\"\\n\"),\r\n            len = lines.length,\r\n            tokens,\r\n            allFeatures = [],\r\n            line,\r\n            i,\r\n            cnt = 0,\r\n            j,\r\n            decode = this.decode,\r\n            format = this.format,\r\n            delimiter = this.delimiter || \"\\t\";\r\n\r\n\r\n        for (i = this.skipRows; i < len; i++) {\r\n            line = lines[i];\r\n            if (line.startsWith(\"track\") || line.startsWith(\"#\") || line.startsWith(\"browser\")) {\r\n                continue;\r\n            }\r\n            else if (format === \"wig\" && line.startsWith(\"fixedStep\")) {\r\n                wig = this.parseFixedStep(line);\r\n                continue;\r\n            }\r\n            else if (format === \"wig\" && line.startsWith(\"variableStep\")) {\r\n                wig = this.parseVariableStep(line);\r\n                continue;\r\n            }\r\n\r\n            tokens = lines[i].split(delimiter);\r\n            if (tokens.length < 1) continue;\r\n\r\n            feature = this.decode(tokens, wig);\r\n\r\n\r\n            if (feature) {\r\n                if (feature.chr !==chr || feature.end<start || feature.start>end){\r\n                    continue;\r\n                }\r\n                if (allFeatures.length < maxFeatureCount) {\r\n                    allFeatures.push(feature);\r\n                }\r\n                else {\r\n                    // Reservoir sampling,  conditionally replace existing feature with new one.\r\n                    j = Math.floor(Math.random() * cnt);\r\n                    if (j < maxFeatureCount) {\r\n                        allFeatures[j] = feature;\r\n                    }\r\n                }\r\n                cnt++;\r\n            }\r\n        }\r\n\r\n        return allFeatures;\r\n    };\r\n\r\n\r\n    static parseFixedStep(line) {\r\n\r\n        var tokens = line.split(/\\s+/),\r\n            cc = tokens[1].split(\"=\")[1],\r\n            ss = parseInt(tokens[2].split(\"=\")[1], 10),\r\n            step = parseInt(tokens[3].split(\"=\")[1], 10),\r\n            span = (tokens.length > 4) ? parseInt(tokens[4].split(\"=\")[1], 10) : 1;\r\n\r\n        return {format: \"fixedStep\", chrom: cc, start: ss, step: step, span: span, index: 0};\r\n\r\n    }\r\n\r\n    static parseVariableStep(line) {\r\n\r\n        var tokens = line.split(/\\s+/),\r\n            cc = tokens[1].split(\"=\")[1],\r\n            span = tokens.length > 2 ? parseInt(tokens[2].split(\"=\")[1], 10) : 1;\r\n        return {format: \"variableStep\", chrom: cc, span: span}\r\n\r\n    }\r\n\r\n    static parseTrackLine(line) {\r\n        var properties = {},\r\n            tokens = line.split(/(?:\")([^\"]+)(?:\")|([^\\s\"]+)(?=\\s+|$)/g),\r\n            tmp = [],\r\n            i, tk, curr;\r\n\r\n        // Clean up tokens array\r\n        for (i = 1; i < tokens.length; i++) {\r\n            if (!tokens[i] || tokens[i].trim().length === 0) continue;\r\n\r\n            tk = tokens[i].trim();\r\n\r\n            if (tk.endsWith(\"=\") > 0) {\r\n                curr = tk;\r\n            }\r\n            else if (curr) {\r\n                tmp.push(curr + tk);\r\n                curr = undefined;\r\n            }\r\n            else {\r\n                tmp.push(tk);\r\n            }\r\n\r\n        }\r\n\r\n\r\n        tmp.forEach(function (str) {\r\n            if (!str) return;\r\n            var kv = str.split('=', 2);\r\n            if (kv.length == 2) {\r\n                properties[kv[0]] = kv[1];\r\n            }\r\n\r\n        });\r\n\r\n        return properties;\r\n    }\r\n\r\n    /**\r\n     * Decode the \"standard\" UCSC bed format\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns decoded feature, or null if this is not a valid record\r\n     */\r\n    static decodeBed(tokens, ignore) {\r\n\r\n        var chr, start, end, id, name, tmp, idName, exonCount, exonSizes, exonStarts, exons, exon, feature,\r\n            eStart, eEnd;\r\n\r\n        if (tokens.length < 3) return null;\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]);\r\n        end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;\r\n\r\n        feature = {chr: chr, start: start, end: end, score: 1000};\r\n\r\n        if (tokens.length > 3) {\r\n            // Note: these are very special rules for the gencode gene files.\r\n            tmp = tokens[3].replace(/\"/g, '');\r\n            idName = tmp.split(';');\r\n            for (var i = 0; i < idName.length; i++) {\r\n                var kv = idName[i].split('=');\r\n                if (kv[0] == \"gene_id\") {\r\n                    id = kv[1];\r\n                }\r\n                if (kv[0] == \"gene_name\") {\r\n                    name = kv[1];\r\n                }\r\n            }\r\n            feature.id = id ? id : tmp;\r\n            feature.name = name ? name : tmp;\r\n        }\r\n\r\n        if (tokens.length > 4) {\r\n            feature.score = parseFloat(tokens[4]);\r\n        }\r\n        if (tokens.length > 5) {\r\n            feature.strand = tokens[5];\r\n        }\r\n        if (tokens.length > 6) {\r\n            feature.cdStart = parseInt(tokens[6]);\r\n        }\r\n        if (tokens.length > 7) {\r\n            feature.cdEnd = parseInt(tokens[7]);\r\n        }\r\n        if (tokens.length > 8) {\r\n            if (tokens[8] !== \".\" && tokens[8] !== \"0\")\r\n                feature.color = igv.createColorString(tokens[8]);\r\n        }\r\n        if (tokens.length > 11) {\r\n            exonCount = parseInt(tokens[9]);\r\n            exonSizes = tokens[10].split(',');\r\n            exonStarts = tokens[11].split(',');\r\n            exons = [];\r\n\r\n            for (var i = 0; i < exonCount; i++) {\r\n                eStart = start + parseInt(exonStarts[i]);\r\n                eEnd = eStart + parseInt(exonSizes[i]);\r\n                var exon = {start: eStart, end: eEnd};\r\n\r\n                if (feature.cdStart > eEnd || feature.cdEnd < feature.cdStart) exon.utr = true;   // Entire exon is UTR\r\n                if (feature.cdStart >= eStart && feature.cdStart <= eEnd) exon.cdStart = feature.cdStart;\r\n                if (feature.cdEnd >= eStart && feature.cdEnd <= eEnd) exon.cdEnd = feature.cdEnd;\r\n\r\n                exons.push(exon);\r\n            }\r\n\r\n            feature.exons = exons;\r\n        }\r\n\r\n        feature.popupData = function () {\r\n            var data = [];\r\n            if (feature.name) data.push({name: \"Name\", value: feature.name});\r\n            if (\"+\" === feature.strand || \"-\" === feature.strand) data.push({name: \"Strand\", value: feature.strand});\r\n            return data;\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    /**\r\n     * Decode a UCSC \"refflat\" record\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns {*}\r\n     */\r\n    static decodeRefflat(tokens, ignore) {\r\n\r\n        if (tokens.length < 10) return null;\r\n\r\n        var feature = {\r\n                chr: tokens[2],\r\n                start: parseInt(tokens[4]),\r\n                end: parseInt(tokens[5]),\r\n                id: tokens[1],\r\n                name: tokens[0],\r\n                strand: tokens[3],\r\n                cdStart: parseInt(tokens[6]),\r\n                cdEnd: parseInt(tokens[7])\r\n            },\r\n            exonCount = parseInt(tokens[8]),\r\n            exonStarts = tokens[9].split(','),\r\n            exonEnds = tokens[10].split(','),\r\n            exons = [];\r\n\r\n        for (var i = 0; i < exonCount; i++) {\r\n            exons.push({start: parseInt(exonStarts[i]), end: parseInt(exonEnds[i])});\r\n        }\r\n\r\n        feature.exons = exons;\r\n\r\n        feature.popupData = function () {\r\n            return [{name: \"Name\", value: feature.name}];\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    static decodePeak(tokens, ignore) {\r\n\r\n        var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\r\n\r\n        tokenCount = tokens.length;\r\n        if (tokenCount < 9) {\r\n            return null;\r\n        }\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]);\r\n        end = parseInt(tokens[2]);\r\n        name = tokens[3];\r\n        score = parseFloat(tokens[4]);\r\n        strand = tokens[5].trim();\r\n        signal = parseFloat(tokens[6]);\r\n        pValue = parseFloat(tokens[7]);\r\n        qValue = parseFloat(tokens[8]);\r\n\r\n        if (score === 0) score = signal;\r\n\r\n        return {\r\n            chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\r\n            pValue: pValue, qValue: qValue\r\n        };\r\n    }\r\n\r\n    static decodeBedGraph(tokens, ignore) {\r\n\r\n        var chr, start, end, value;\r\n\r\n        if (tokens.length < 3) return null;\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]);\r\n        end = parseInt(tokens[2]);\r\n\r\n        value = parseFloat(tokens[3]);\r\n\r\n        return {chr: chr, start: start, end: end, value: value};\r\n    }\r\n\r\n    static decodeWig(tokens, wig) {\r\n\r\n        var ss,\r\n            ee,\r\n            value;\r\n\r\n        if (wig.format === \"fixedStep\") {\r\n\r\n            ss = (wig.index * wig.step) + wig.start;\r\n            ee = ss + wig.span;\r\n            value = parseFloat(tokens[0]);\r\n            ++(wig.index);\r\n            return isNaN(value) ? null : {chr: wig.chrom, start: ss, end: ee, value: value};\r\n        }\r\n        else if (wig.format === \"variableStep\") {\r\n\r\n            if (tokens.length < 2) return null;\r\n\r\n            ss = parseInt(tokens[0], 10);\r\n            ee = ss + wig.span;\r\n            value = parseFloat(tokens[1]);\r\n            return isNaN(value) ? null : {chr: wig.chrom, start: ss, end: ee, value: value};\r\n\r\n        }\r\n        else {\r\n            return decodeBedGraph(tokens);\r\n        }\r\n    }\r\n\r\n    static decodeAneu(tokens, ignore) {\r\n\r\n        var chr, start, end, feature;\r\n\r\n\r\n        if (tokens.length < 4) return null;\r\n\r\n        chr = tokens[1];\r\n        start = parseInt(tokens[2]);\r\n        end = tokens.length > 3 ? parseInt(tokens[3]) : start + 1;\r\n\r\n        feature = {chr: chr, start: start, end: end};\r\n\r\n        if (tokens.length > 4) {\r\n            feature.score = parseFloat(tokens[4]);\r\n            feature.value = feature.score;\r\n        }\r\n\r\n\r\n        feature.popupData = function () {\r\n            return [{name: \"Name\", value: feature.name}];\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    static decodeFusionJuncSpan(tokens, ignore) {\r\n\r\n        /*\r\n         Format:\r\n\r\n         0       #scaffold\r\n         1       fusion_break_name\r\n         2       break_left\r\n         3       break_right\r\n         4       num_junction_reads\r\n         5       num_spanning_frags\r\n         6       spanning_frag_coords\r\n\r\n         0       B3GNT1--NPSR1\r\n         1       B3GNT1--NPSR1|2203-10182\r\n         2       2203\r\n         3       10182\r\n         4       189\r\n         5       1138\r\n         6       1860-13757,1798-13819,1391-18127,1443-17174,...\r\n\r\n         */\r\n\r\n\r\n       \r\n\r\n        var chr = tokens[0];\r\n        var fusion_name = tokens[1];\r\n        var junction_left = parseInt(tokens[2]);\r\n        var junction_right = parseInt(tokens[3]);\r\n        var num_junction_reads = parseInt(tokens[4]);\r\n        var num_spanning_frags = parseInt(tokens[5]);\r\n\r\n        var spanning_frag_coords_text = tokens[6];\r\n\r\n        var feature = {\r\n            chr: chr,\r\n            name: fusion_name,\r\n            junction_left: junction_left,\r\n            junction_right: junction_right,\r\n            num_junction_reads: num_junction_reads,\r\n            num_spanning_frags: num_spanning_frags,\r\n            spanning_frag_coords: [],\r\n\r\n            start: -1,\r\n            end: -1\r\n        }; // set start and end later based on min/max of span coords\r\n\r\n        var min_coord = junction_left;\r\n        var max_coord = junction_right;\r\n\r\n        if (num_spanning_frags > 0) {\r\n\r\n            var coord_pairs = spanning_frag_coords_text.split(',');\r\n\r\n            for (var i = 0; i < coord_pairs.length; i++) {\r\n                var split_coords = coord_pairs[i].split('-');\r\n\r\n                var span_left = split_coords[0];\r\n                var span_right = split_coords[1];\r\n\r\n                if (span_left < min_coord) {\r\n                    min_coord = span_left;\r\n                }\r\n                if (span_right > max_coord) {\r\n                    max_coord = span_right;\r\n                }\r\n                feature.spanning_frag_coords.push({left: span_left, right: span_right});\r\n\r\n            }\r\n        }\r\n\r\n        feature.start = min_coord;\r\n        feature.end = max_coord;\r\n\r\n\r\n        feature.popupData = function () {\r\n            return [{name: \"Name\", value: feature.name}];\r\n        };\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n    static decodeGtexGWAS(tokens, ignore) {\r\n\r\n\r\n        var tokenCount, chr, start, end, strand, name, score, qValue, signal, pValue;\r\n\r\n        tokenCount = tokens.length;\r\n        if (tokenCount < 8) {\r\n            return null;\r\n        }\r\n\r\n        chr = tokens[0];\r\n        start = parseInt(tokens[1]) - 1;\r\n        end = parseInt(tokens[3].split(':')[1]);\r\n        //name = tokens[3];\r\n        //score = parseFloat(tokens[4]);\r\n        //strand = tokens[5].trim();\r\n        //signal = parseFloat(tokens[6]);\r\n        pValue = parseFloat(tokens[5]);\r\n        //qValue = parseFloat(tokens[8]);\r\n\r\n        //return {chr: chr, start: start, end: end, name: name, score: score, strand: strand, signal: signal,\r\n        //    pValue: pValue, qValue: qValue};\r\n        return {chr: chr, start: start, end: end, pvalue: pValue};\r\n    }\r\n\r\n    /**\r\n     * Decode a single gff record (1 line in file).  Aggregations such as gene models are constructed at a higher level.\r\n     *      ctg123 . mRNA            1050  9000  .  +  .  ID=mRNA00001;Parent=gene00001\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns {*}\r\n     */\r\n    static decodeGFF(tokens, ignore) {\r\n\r\n        var tokenCount, chr, start, end, strand, type, score, phase, attributeString, id, parent, color, name,\r\n            transcript_id, i,\r\n            format = this.format;\r\n\r\n        tokenCount = tokens.length;\r\n        if (tokenCount < 9) {\r\n            return null;      // Not a valid gff record\r\n        }\r\n\r\n        chr = tokens[0];\r\n        type = tokens[2];\r\n        start = parseInt(tokens[3]) - 1;\r\n        end = parseInt(tokens[4]);\r\n        score = \".\" === tokens[5] ? 0 : parseFloat(tokens[5]);\r\n        strand = tokens[6];\r\n        phase = \".\" === tokens[7] ? 0 : parseInt(tokens[7]);\r\n        attributeString = tokens[8];\r\n\r\n        // Find ID and Parent, or transcript_id\r\n        var delim = ('gff3' === format) ? '=' : /\\s+/;\r\n        var attributes = {};\r\n        attributeString.split(';').forEach(function (kv) {\r\n            var t = kv.trim().split(delim, 2), key, value;\r\n            if (t.length == 2) {\r\n                key = t[0].trim();\r\n                value = t[1].trim();\r\n                //Strip off quotes, if any\r\n                if (value.startsWith('\"') && value.endsWith('\"')) {\r\n                    value = value.substr(1, value.length - 2);\r\n                }\r\n                if (\"ID\" === t[0]) id = t[1];\r\n                else if (\"Parent\" === t[0]) parent = t[1];\r\n                else if (\"color\" === t[0].toLowerCase()) color = igv.createColorString(t[1]);\r\n                else if (\"transcript_id\" === t[0]) id = t[1];     // gtf format\r\n                attributes[key] = value;\r\n            }\r\n        });\r\n\r\n        // Find name (label) property\r\n        if (this.nameField) {\r\n            name = attributes[this.nameField];\r\n        }\r\n        else {\r\n            for (i = 0; i < gffNameFields.length; i++) {\r\n                if (attributes.hasOwnProperty(gffNameFields[i])) {\r\n                    this.nameField = gffNameFields[i];\r\n                    name = attributes[this.nameField];\r\n\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return {\r\n            id: id,\r\n            parent: parent,\r\n            name: name,\r\n            type: type,\r\n            chr: chr,\r\n            start: start,\r\n            end: end,\r\n            score: score,\r\n            strand: strand,\r\n            color: color,\r\n            attributeString: attributeString,\r\n            popupData: function () {\r\n                var kvs = this.attributeString.split(';'),\r\n                    pd = [],\r\n                    key, value;\r\n                kvs.forEach(function (kv) {\r\n                    var t = kv.trim().split(delim, 2);\r\n                    if (t.length === 2 && t[1] !== undefined) {\r\n                        key = t[0].trim();\r\n                        value = t[1].trim();\r\n                        //Strip off quotes, if any\r\n                        if (value.startsWith('\"') && value.endsWith('\"')) {\r\n                            value = value.substr(1, value.length - 2);\r\n                        }\r\n                        pd.push({name: key, value: value});\r\n                    }\r\n                });\r\n                return pd;\r\n            }\r\n\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Decode the \"standard\" UCSC bed format\r\n     * @param tokens\r\n     * @param ignore\r\n     * @returns decoded feature, or null if this is not a valid record\r\n     */\r\n    decodeCustom(tokens, ignore) {\r\n\r\n        var feature,\r\n            chr, start, end,\r\n            format = this.format,         // \"this\" refers to FeatureParser instance\r\n            coords = format.coords || 0;\r\n\r\n        if (tokens.length < 3) return null;\r\n\r\n        chr = tokens[format.chr];\r\n        start = parseInt(tokens[format.start]) - coords;\r\n        end = format.end !== undefined ? parseInt(tokens[format.end]) : start + 1;\r\n\r\n        feature = {chr: chr, start: start, end: end};\r\n\r\n        if (format.fields) {\r\n            format.fields.forEach(function (field, index) {\r\n                if (index != format.chr && index != format.start && index != format.end) {\r\n                    feature[field] = tokens[index];\r\n                }\r\n            });\r\n        }\r\n\r\n        return feature;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n//*******js/feature/featureCache.js**********************\r\n\r\n\r\n    /**\r\n     * Object for caching lists of features.  Supports effecient queries for sub-range  (chr, start, end)\r\n     *\r\n     * @param featureList\r\n     * @param The genomic range spanned by featureList (optional)\r\n     * @constructor\r\n     */\r\n\r\nclass FeatureCache{\r\n    constructor(featureList, range) {\r\n        this.treeMap = FeatureCache.buildTreeMap(featureList);\r\n        this.range = range;\r\n    }\r\n\r\n    queryFeatures(chr, start, end) {\r\n         \r\n\r\n        var featureList, intervalFeatures, feature, len, i, tree, intervals;\r\n\r\n        tree = this.treeMap[chr];\r\n\r\n        if (!tree) return [];\r\n\r\n        intervals = tree.findOverlapping(start, end);\r\n\r\n        if (intervals.length == 0) {\r\n            return [];\r\n        }\r\n        else {\r\n            // Trim the list of features in the intervals to those\r\n            // overlapping the requested range.\r\n            // Assumption: features are sorted by start position\r\n\r\n            featureList = [];\r\n\r\n            intervals.forEach(function (interval) {\r\n                intervalFeatures = interval.value;\r\n                len = intervalFeatures.length;\r\n                for (i = 0; i < len; i++) {\r\n                    feature = intervalFeatures[i];\r\n                    if (feature.start > end) break;\r\n                    else if (feature.end >= start) {\r\n                        featureList.push(feature)\r\n                    }\r\n                }\r\n            });\r\n            return featureList;\r\n        }\r\n\r\n    };\r\n\r\n    allFeatures() {\r\n\r\n        var allFeatures = [];\r\n        var treeMap = this.treeMap;\r\n        if (treeMap) {\r\n            for (var key in treeMap) {\r\n                if (treeMap.hasOwnProperty(key)) {\r\n\r\n                    var tree = treeMap[key];\r\n                    tree.mapIntervals(function (interval) {\r\n                        allFeatures = allFeatures.concat(interval.value);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return allFeatures;\r\n\r\n    }\r\n\r\n    static buildTreeMap(featureList) {\r\n\r\n        var featureCache = {},\r\n            chromosomes = [],\r\n            treeMap = {},\r\n            genome = null;\r\n\r\n        if (featureList) {\r\n\r\n            featureList.forEach(function (feature) {\r\n\r\n                var chr = feature.chr,\r\n                    geneList;\r\n\r\n                // Translate to \"official\" name\r\n                if(genome) chr = genome.getChromosomeName(chr);\r\n\r\n                geneList = featureCache[chr];\r\n\r\n                if (!geneList) {\r\n                    chromosomes.push(chr);\r\n                    geneList = [];\r\n                    featureCache[chr] = geneList;\r\n                }\r\n\r\n                geneList.push(feature);\r\n\r\n            });\r\n\r\n\r\n            // Now build interval tree for each chromosome\r\n\r\n            for (let i = 0; i < chromosomes.length; i++) {\r\n                let chr = chromosomes[i];\r\n                treeMap[chr] =FeatureCache.buildIntervalTree(featureCache[chr]);\r\n            }\r\n        }\r\n\r\n        return treeMap;\r\n    };\r\n\r\n    /**\r\n     * Build an interval tree from the feature list for fast interval based queries.   We lump features in groups\r\n     * of 10, or total size / 100,   to reduce size of the tree.\r\n     *\r\n     * @param featureList\r\n     */\r\n    static buildIntervalTree(featureList) {\r\n\r\n        var i, e, iStart, iEnd, tree, chunkSize, len, subArray;\r\n\r\n        tree = new IntervalTree();\r\n        len = featureList.length;\r\n\r\n        chunkSize = Math.max(10, Math.round(len / 100));\r\n\r\n        featureList.sort(function (f1, f2) {\r\n            return (f1.start === f2.start ? 0 : (f1.start > f2.start ? 1 : -1));\r\n        });\r\n\r\n        for (i = 0; i < len; i += chunkSize) {\r\n            e = Math.min(len, i + chunkSize);\r\n            subArray = featureList.slice(i, e);\r\n            iStart = subArray[0].start;\r\n            //\r\n            iEnd = iStart;\r\n            subArray.forEach(function (feature) {\r\n                iEnd = Math.max(iEnd, feature.end);\r\n            });\r\n            tree.insert(iStart, iEnd, subArray);\r\n        }\r\n\r\n        return tree;\r\n    }\r\n\r\n\r\n}\r\n\r\n//*****js/intervalTree.js************\r\n\r\n\r\nconst BLACK = 1;\r\nconst RED = 2;\r\n\r\nlet NIL = {}\r\nNIL.color = BLACK;\r\nNIL.parent = NIL;\r\nNIL.left = NIL;\r\nNIL.right = NIL;\r\n\r\n  \r\nclass IntervalTree{\r\n    constructor() {    \r\n        this.root = NIL;\r\n    }\r\n\r\n\r\n    insert(start, end, value) {\r\n\r\n        var interval = new Interval(start, end, value);\r\n        var x = new Node(interval);\r\n        this.treeInsert(x);\r\n        x.color = RED;\r\n        while (x != this.root && x.parent.color == RED) {\r\n            if (x.parent == x.parent.parent.left) {\r\n                var y = x.parent.parent.right;\r\n                if (y.color == RED) {\r\n                    x.parent.color = BLACK;\r\n                    y.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    x = x.parent.parent;\r\n                } else {\r\n                    if (x == x.parent.right) {\r\n                        x = x.parent;\r\n                        this.leftRotate(x);\r\n                    }\r\n                    x.parent.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    this.rightRotate(x.parent.parent);\r\n                }\r\n            } else {\r\n                var y = x.parent.parent.left;\r\n                if (y.color == RED) {\r\n                    x.parent.color = BLACK;\r\n                    y.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    x = x.parent.parent;\r\n                } else {\r\n                    if (x == x.parent.left) {\r\n                        x = x.parent;\r\n                        this.rightRotate(x);\r\n                    }\r\n                    x.parent.color = BLACK;\r\n                    x.parent.parent.color = RED;\r\n                    this.leftRotate(x.parent.parent);\r\n                }\r\n            }\r\n        }\r\n        this.root.color = BLACK;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param start - query interval\r\n     * @param end - query interval\r\n     * @returns Array of all intervals overlapping the query region\r\n     */\r\n    findOverlapping(start, end) {\r\n\r\n\r\n        var searchInterval = new Interval(start, end, 0);\r\n\r\n        if (this.root === NIL) return [];\r\n\r\n        var intervals = this.searchAll(searchInterval, this.root, []);\r\n\r\n        if(intervals.length > 1) {\r\n            intervals.sort(function(i1, i2) {\r\n                 return i1.low - i2.low;\r\n            });\r\n        }\r\n\r\n        return intervals;\r\n    }\r\n\r\n    /**\r\n     * Dump info on intervals to console.  For debugging.\r\n     */\r\n    logIntervals() {\r\n\r\n        logNode(this.root, 0);\r\n\r\n        function logNode(node, indent) {\r\n\r\n            var space = \"\";\r\n            for(var i=0; i<indent; i++) space += \" \";\r\n            console.log(space + node.interval.low + \" \" + node.interval.high); // + \" \" + (node.interval.value ? node.interval.value : \" null\"));\r\n\r\n            indent += 5;\r\n\r\n            if(node.left != NIL) logNode(node.left, indent);\r\n            if(node.right != NIL) logNode(node.right, indent);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    mapIntervals(func) {\r\n\r\n        applyInterval(this.root);\r\n\r\n        function applyInterval(node) {\r\n\r\n            func(node.interval);\r\n\r\n            if(node.left != NIL) applyInterval(node.left);\r\n            if(node.right != NIL) applyInterval(node.right);\r\n        }\r\n    }\r\n\r\n    searchAll(interval, node, results) {\r\n\r\n        if (node.interval.overlaps(interval)) {\r\n            results.push(node.interval);\r\n        }\r\n\r\n        if (node.left != NIL && node.left.max >= interval.low) {\r\n            this.searchAll(interval, node.left, results);\r\n        }\r\n\r\n        if (node.right != NIL && node.right.min <= interval.high) {\r\n            this.searchAll(interval, node.right, results);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    leftRotate(x) {\r\n        var y = x.right;\r\n        x.right = y.left;\r\n        if (y.left != NIL) {\r\n            y.left.parent = x;\r\n        }\r\n        y.parent = x.parent;\r\n        if (x.parent == NIL) {\r\n            this.root = y;\r\n        } else {\r\n            if (x.parent.left == x) {\r\n                x.parent.left = y;\r\n            } else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;\r\n        x.parent = y;\r\n\r\n        this.applyUpdate(x);\r\n        // no need to apply update on y, since it'll y is an ancestor\r\n        // of x, and will be touched by applyUpdate().\r\n    }\r\n\r\n\r\n    rightRotate(x) {\r\n        var y = x.left;\r\n        x.left = y.right;\r\n        if (y.right != NIL) {\r\n            y.right.parent = x;\r\n        }\r\n        y.parent = x.parent;\r\n        if (x.parent == NIL) {\r\n            this.root = y;\r\n        } else {\r\n            if (x.parent.right == x) {\r\n                x.parent.right = y;\r\n            } else {\r\n                x.parent.left = y;\r\n            }\r\n        }\r\n        y.right = x;\r\n        x.parent = y;\r\n\r\n\r\n        this.applyUpdate(x);\r\n        // no need to apply update on y, since it'll y is an ancestor\r\n        // of x, and will be touched by applyUpdate().\r\n    }\r\n\r\n\r\n    /**\r\n     * Note:  Does not maintain RB constraints,  this is done post insert\r\n     *\r\n     * @param x  a Node\r\n     */\r\n   treeInsert(x) {\r\n        var node = this.root;\r\n        var y = NIL;\r\n        while (node != NIL) {\r\n            y = node;\r\n            if (x.interval.low <= node.interval.low) {\r\n                node = node.left;\r\n            } else {\r\n                node = node.right;\r\n            }\r\n        }\r\n        x.parent = y;\r\n\r\n        if (y == NIL) {\r\n            this.root = x;\r\n            x.left = x.right = NIL;\r\n        } else {\r\n            if (x.interval.low <= y.interval.low) {\r\n                y.left = x;\r\n            } else {\r\n                y.right = x;\r\n            }\r\n        }\r\n\r\n        this.applyUpdate(x);\r\n    }\r\n\r\n\r\n    // Applies the statistic update on the node and its ancestors.\r\n    applyUpdate (node) {\r\n        while (node != NIL) {\r\n            var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;\r\n            var intervalHigh = node.interval.high;\r\n            node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;\r\n\r\n            var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;\r\n            var intervalLow = node.interval.low;\r\n            node.min = nodeMin < intervalLow ? nodeMin : intervalLow;\r\n\r\n            node = node.parent;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Interval {\r\n    constructor(low, high, value) {\r\n        this.low = low;\r\n        this.high = high;\r\n        this.value = value;\r\n    }\r\n\r\n\r\n    equals(other) {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        if (this == other) {\r\n            return true;\r\n        }\r\n        return (this.low == otherInterval.low &&\r\n            this.high == otherInterval.high);\r\n\r\n    }\r\n\r\n\r\n    compareTo(other) {\r\n        if (this.low < other.low)\r\n            return -1;\r\n        if (this.low > other.low)\r\n            return 1;\r\n\r\n        if (this.high < other.high)\r\n            return -1;\r\n        if (this.high > other.high)\r\n            return 1;\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this interval overlaps the other.\r\n     */\r\n    overlaps(other) {\r\n        try {\r\n            return (this.low <= other.high && other.low <= this.high);\r\n        } catch (e) {\r\n            //alert(e);\r\n            igv.presentAlert(e);\r\n        }\r\n    }\r\n}\r\n\r\nclass Node{\r\n    constructor(interval) {\r\n        this.parent = NIL;\r\n        this.left = NIL;\r\n        this.right = NIL;\r\n        this.interval = interval;\r\n        this.color = RED;\r\n    }\r\n}\r\n\r\nclass GenomicInterval{\r\n\r\n\tconstructor(chr, start, end, features) {\r\n        this.chr = chr;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.features = features;\r\n    }\r\n\r\n    contains (chr, start, end) {\r\n        return this.chr == chr &&\r\n            this.start <= start &&\r\n            this.end >= end;\r\n    }\r\n\r\n    containsRange(range) {\r\n        return this.chr === range.chr &&\r\n            this.start <= range.start &&\r\n            this.end >= range.end;\r\n    }\r\n    rangesToGet(range){\r\n        let needs_range=false;\r\n        let ranges={};\r\n        if (this.chr !== range.chr){\r\n            ranges.all=[range.start,range.end];\r\n            needs_range=true;\r\n            this.start=range.start;\r\n            this.end=range.end;\r\n\r\n        }\r\n        else{   \r\n            if (range.start<this.start){\r\n                ranges.left=[range.start,this.start];\r\n                needs_range=true;\r\n                this.start=range.start;\r\n              \r\n            }\r\n            if (range.end>this.end){\r\n                ranges.right=[this.end,range.end];\r\n                needs_range=true;\r\n                this.end=range.end;\r\n            }\r\n        }\r\n        if (!needs_range){\r\n            return false;\r\n        }\r\n        return ranges;\r\n    }\r\n}\r\n\r\n\r\n\r\nclass FastaSequence{\r\n\r\n    constructor(url) {\r\n\r\n        this.file = url;\r\n        this.indexed = true;\r\n        if (this.indexed) {\r\n            this.indexFile = this.file + \".fai\";\r\n        }\r\n    \r\n\r\n    }\r\n\r\n   init(){\r\n\r\n        var self = this;\r\n\r\n        if (self.indexed) {\r\n\r\n            return new Promise(function (fulfill, reject) {\r\n\r\n                self.getIndex().then(function (index) {\r\n                    var order = 0;\r\n                    self.chromosomes = {};\r\n                    self.chromosomeNames.forEach(function (chrName) {\r\n                        var bpLength = self.index[chrName].size;\r\n                        self.chromosomes[chrName] = new igv.Chromosome(chrName, order++, bpLength);\r\n                    });\r\n\r\n\r\n                    // Ignore index, getting chr names as a side effect.  Really bad practice\r\n                    fulfill();\r\n                }).catch(reject);\r\n            });\r\n        }\r\n        else {\r\n            return self.loadAll();\r\n        }\r\n\r\n    }\r\n\r\n    getSequence(chr, start, end) {\r\n\r\n        if (this.indexed) {\r\n            return this.getSequenceIndexed(chr, start, end);\r\n        }\r\n        else {\r\n            return getSequenceNonIndexed.this(chr, start, end);\r\n\r\n        }\r\n\r\n    }\r\n\r\n    getSequenceIndexed(chr, start, end) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var interval = self.interval;\r\n\r\n            if (interval && interval.contains(chr, start, end)) {\r\n\r\n                fulfill(getSequenceFromInterval(interval, start, end));\r\n            }\r\n            else {\r\n\r\n                //console.log(\"Cache miss: \" + (interval === undefined ? \"nil\" : interval.chr + \":\" + interval.start + \"-\" + interval.end));\r\n\r\n                // Expand query, to minimum of 100kb\r\n                var qstart = start;\r\n                var qend = end;\r\n                if ((end - start) < 100000) {\r\n                    var w = (end - start);\r\n                    var center = Math.round(start + w / 2);\r\n                    qstart = Math.max(0, center - 50000);\r\n                    qend = center + 50000;\r\n                }\r\n\r\n\r\n                self.readSequence(chr, qstart, qend).then(function (seqBytes) {\r\n                    self.interval = new GenomicInterval(chr, qstart, qend, seqBytes);\r\n                    fulfill(getSequenceFromInterval(self.interval, start, end));\r\n                }).catch(reject);\r\n            }\r\n\r\n            function getSequenceFromInterval(interval, start, end) {\r\n                var offset = start - interval.start;\r\n                var n = end - start;\r\n                var seq = interval.features ? interval.features.substr(offset, n) : null;\r\n                return seq;\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    getSequenceNonIndexed(chr, start, end) {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var seq = self.sequences[chr];\r\n            if (seq && seq.length > end) {\r\n                fulfill(seq.substring(start, end));\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    getIndex() {\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            if (self.index) {\r\n                fulfill(self.index);\r\n            } else {\r\n                _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].load(self.indexFile,{}).then(function (data) {\r\n                    var lines = data.split(\"\\n\");\r\n                    var len = lines.length;\r\n                    var lineNo = 0;\r\n\r\n                    self.chromosomeNames = [];     // TODO -- eliminate this side effect !!!!\r\n                    self.index = {};               // TODO -- ditto\r\n                    while (lineNo < len) {\r\n\r\n                        var tokens = lines[lineNo++].split(\"\\t\");\r\n                        var nTokens = tokens.length;\r\n                        if (nTokens == 5) {\r\n                            // Parse the index line.\r\n                            var chr = tokens[0];\r\n                            var size = parseInt(tokens[1]);\r\n                            var position = parseInt(tokens[2]);\r\n                            var basesPerLine = parseInt(tokens[3]);\r\n                            var bytesPerLine = parseInt(tokens[4]);\r\n\r\n                            var indexEntry = {\r\n                                size: size, position: position, basesPerLine: basesPerLine, bytesPerLine: bytesPerLine\r\n                            };\r\n\r\n                            self.chromosomeNames.push(chr);\r\n                            self.index[chr] = indexEntry;\r\n                        }\r\n                    }\r\n\r\n                    if (fulfill) {\r\n                        fulfill(self.index);\r\n                    }\r\n                }).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n    loadAll(){\r\n\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            self.chromosomeNames = [];\r\n            self.chromosomes = {};\r\n            self.sequences = {};\r\n\r\n            _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].load(self.file, {\r\n                withCredentials: self.withCredentials\r\n\r\n            }).then(function (data) {\r\n\r\n                var lines = data.splitLines(),\r\n                    len = lines.length,\r\n                    lineNo = 0,\r\n                    nextLine,\r\n                    currentSeq = \"\",\r\n                    currentChr,\r\n                    order = 0;\r\n\r\n\r\n                while (lineNo < len) {\r\n                    nextLine = lines[lineNo++].trim();\r\n                    if (nextLine.startsWith(\"#\") || nextLine.length === 0) {\r\n                        continue;\r\n                    }\r\n                    else if (nextLine.startsWith(\">\")) {\r\n                        if (currentSeq) {\r\n                            self.chromosomeNames.push(currentChr);\r\n                            self.sequences[currentChr] = currentSeq;\r\n                            self.chromosomes[currentChr] = new igv.Chromosome(currentChr, order++, currentSeq.length);\r\n                        }\r\n                        currentChr = nextLine.substr(1).split(\"\\\\s+\")[0];\r\n                        currentSeq = \"\";\r\n                    }\r\n                    else {\r\n                        currentSeq += nextLine;\r\n                    }\r\n                }\r\n\r\n                fulfill();\r\n\r\n            });\r\n        });\r\n    }\r\n\r\n    readSequence(chr, qstart, qend) {\r\n\r\n        //console.log(\"Read sequence \" + chr + \":\" + qstart + \"-\" + qend);\r\n        var self = this;\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            self.getIndex().then(function () {\r\n\r\n                var idxEntry = self.index[chr];\r\n                if (!idxEntry) {\r\n                    console.log(\"No index entry for chr: \" + chr);\r\n\r\n                    // Tag interval with null so we don't try again\r\n                    self.interval = new GenomicInterval(chr, qstart, qend, null);\r\n                    fulfill(null);\r\n\r\n                } else {\r\n\r\n                    var start = Math.max(0, qstart);    // qstart should never be < 0\r\n                    var end = Math.min(idxEntry.size, qend);\r\n                    var bytesPerLine = idxEntry.bytesPerLine;\r\n                    var basesPerLine = idxEntry.basesPerLine;\r\n                    var position = idxEntry.position;\r\n                    var nEndBytes = bytesPerLine - basesPerLine;\r\n\r\n                    var startLine = Math.floor(start / basesPerLine);\r\n                    var endLine = Math.floor(end / basesPerLine);\r\n\r\n                    var base0 = startLine * basesPerLine;   // Base at beginning of start line\r\n\r\n                    var offset = start - base0;\r\n\r\n                    var startByte = position + startLine * bytesPerLine + offset;\r\n\r\n                    var base1 = endLine * basesPerLine;\r\n                    var offset1 = end - base1;\r\n                    var endByte = position + endLine * bytesPerLine + offset1 - 1;\r\n                    var byteCount = endByte - startByte + 1;\r\n                    if (byteCount <= 0) {\r\n                        fulfill(null);\r\n                    }\r\n\r\n                    _igvxhr_js__WEBPACK_IMPORTED_MODULE_1__[\"igvxhr\"].load(self.file, {\r\n                        range: {start: startByte, size: byteCount}\r\n                    }).then(function (allBytes) {\r\n\r\n                        var nBases,\r\n                            seqBytes = \"\",\r\n                            srcPos = 0,\r\n                            desPos = 0,\r\n                            allBytesLength = allBytes.length;\r\n\r\n                        if (offset > 0) {\r\n                            nBases = Math.min(end - start, basesPerLine - offset);\r\n                            seqBytes += allBytes.substr(srcPos, nBases);\r\n                            srcPos += (nBases + nEndBytes);\r\n                            desPos += nBases;\r\n                        }\r\n\r\n                        while (srcPos < allBytesLength) {\r\n                            nBases = Math.min(basesPerLine, allBytesLength - srcPos);\r\n                            seqBytes += allBytes.substr(srcPos, nBases);\r\n                            srcPos += (nBases + nEndBytes);\r\n                            desPos += nBases;\r\n                        }\r\n\r\n                        fulfill(seqBytes);\r\n                    }).catch(reject)\r\n                }\r\n            }).catch(reject)\r\n        });\r\n    }\r\n}\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZmVhdHVyZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9mZWF0dXJlLmpzPzhkOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBCcm9hZCBJbnN0aXR1dGVcclxuICpcclxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuICpcclxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiAqXHJcbiAqXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuICogVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcblxyXG5pbXBvcnQge1V0aWxzfSBmcm9tIFwiLi91dGlscy5qc1wiO1xyXG5pbXBvcnQge2lndnhocix1bmJnemZ9IGZyb20gXCIuL2lndnhoci5qc1wiO1xyXG5pbXBvcnQge2xvYWRCYW1JbmRleH0gZnJvbSBcIi4vYmFtLmpzXCI7XHJcbmltcG9ydCB7QldTb3VyY2V9IGZyb20gXCIuL2JpZ3dpZy5qc1wiO1xyXG5cclxuY29uc3QgTUFYX0daSVBfQkxPQ0tfU0laRSA9ICgxIDw8IDE2KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGZlYXR1cmUgc291cmNlIGZvciBcImJlZCBsaWtlXCIgZmlsZXMgKHRhYiBkZWxpbWl0ZWQgZmlsZXMgd2l0aCAxIGZlYXR1cmUgcGVyIGxpbmU6IGJlZCwgZ2ZmLCB2Y2YsIGV0YylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG5jbGFzcyBGZWF0dXJlU291cmNle1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEZpbGVIZWFkZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pc19pbmRleGVkPXRydWU7ICBcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdWxmaWxsKCk7ICAgICAgICBcclxuICAgICAgICB9KTtcclxuICAgIH0gICBcclxuXHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKXtcclxuICAgICAgXHJcbiAgICAgICAgLy9ubyBuZWVkIHRvIGdldCBoZWFkZXJcclxuICAgICAgICBpZiAodGhpcy5pc19pbmRleGVkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEZlYXR1cmVzKGNocixzdGFydCxlbmQsZm9yY2UsZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vZ2V0IGhlYWRlcnMvaW5kZXggdGhlbiBnZXQgZmVhdHVyZXNcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGZ1bGZpbGwscmVqZWN0KXtcclxuICAgICAgICAgICAgc2VsZi5nZXRGaWxlSGVhZGVyKCkudGhlbihmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fZ2V0RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCxmb3JjZSxkYXRhKS50aGVuKGZ1bmN0aW9uKGZlYXR1cmVzKXtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGZlYXR1cmVzKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdClcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIGZ1bmN0aW9uIGZvIGFsbCBkYXRhIHNvdXJjZSBvYmplY3RzLiAgRmV0Y2hlcyBmZWF0dXJlcyBmb3IgdGhlXHJcbiAgICAgKiByYW5nZSByZXF1ZXN0ZWQgYW5kIHBhc3NlcyB0aGVtIG9uIHRvIHRoZSBzdWNjZXNzIGZ1bmN0aW9uLiAgVXN1YWxseSB0aGlzIGlzXHJcbiAgICAgKiBhIGZ1bmN0aW9uIHRoYXQgcmVuZGVycyB0aGUgZmVhdHVyZXMgb24gdGhlIGNhbnZhc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaHJcclxuICAgICAqIEBwYXJhbSBicFN0YXJ0XHJcbiAgICAgKiBAcGFyYW0gYnBFbmRcclxuICAgICAqL1xyXG4gICAgX2dldEZlYXR1cmVzKGNociwgYnBTdGFydCwgYnBFbmQsZm9yY2UsZGF0YSkge1xyXG4gICAgICAgIGlmIChicFN0YXJ0PT09MCl7XHJcbiAgICAgICAgICAgIGJwU3RhcnQ9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHNlbGYudGltZT1EYXRlLm5vdygpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLmZlYXR1cmVDYWNoZSAmJiBjaHIgIT09IHNlbGYuZmVhdHVyZUNhY2hlLnJhbmdlLmNocil7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmZlYXR1cmVDYWNoZT1udWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBnZW5vbWljSW50ZXJ2YWwgPSBuZXcgR2Vub21pY0ludGVydmFsKGNociwgYnBTdGFydCwgYnBFbmQpLFxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZUNhY2hlID0gc2VsZi5mZWF0dXJlQ2FjaGUsXHJcbiAgICAgICAgICAgICAgICBtYXhSb3dzID0gc2VsZi5jb25maWcubWF4Um93cyB8fCA1MDA7XHJcbiAgICAgICAgICAgIGxldCByYW5nZXNfdG9fZ2V0PWZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIWZlYXR1cmVDYWNoZSl7XHJcbiAgICAgICAgICAgICAgICByYW5nZXNfdG9fZ2V0PXthbGw6W2JwU3RhcnQsYnBFbmRdfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVDYWNoZS5yYW5nZSAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICByYW5nZXNfdG9fZ2V0PWZlYXR1cmVDYWNoZS5yYW5nZS5yYW5nZXNUb0dldChnZW5vbWljSW50ZXJ2YWwpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFyYW5nZXNfdG9fZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuZmVhdHVyZUNhY2hlLnF1ZXJ5RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBsZXQgcHJvbWlzZXM9W107XHJcbiAgICAgICAgICAgICAgICBsZXQgcF90eXBlcz1bXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gcmFuZ2VzX3RvX2dldCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlPSByYW5nZXNfdG9fZ2V0W3R5cGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goc2VsZi5yZXRyaWV2ZUZlYXR1cmVzKGNociwgcmFuZ2VbMF0sIHJhbmdlWzFdLGZvcmNlLGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBwX3R5cGVzLnB1c2goW3R5cGUscmFuZ2VzX3RvX2dldFt0eXBlXV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFsbF9mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdfZmVhdHVyZXM9W107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmZlYXR1cmVDYWNoZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ19mZWF0dXJlcz1zZWxmLmZlYXR1cmVDYWNoZS5hbGxGZWF0dXJlcygpOy8vZmVhdHVyZUNhY2hlLmFsbEZlYXR1cmVzKGNocixzZWxmLmZlYXR1cmVDYWNoZS5yYW5nZS5zdGFydCxzZWxmLmZlYXR1cmVDYWNoZS5yYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleD0wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBmZWF0dXJlTGlzdCBvZiBhbGxfZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVMaXN0ID09PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTGlzdD1bXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocF90eXBlc1tpbmRleF1bMF09PT1cImxlZnRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHBfdHlwZXNbaW5kZXhdWzFdWzFdOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbnkgYWxyZWFkeSByZXRpZXZlZCAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGljZT0wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG49ZmVhdHVyZUxpc3QubGVuZ3RoLTE7bj49MDtuLS0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZUxpc3Rbbl0uZW5kPCBlbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGxpY2UhPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxpc3Quc3BsaWNlKC1zcGxpY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwX3R5cGVzW2luZGV4XVswXT09PVwicmlnaHRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0PXBfdHlwZXNbaW5kZXhdWzFdWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFueSBhbHJlYWR5IHJldGlldmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGk9MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wO2k8ZmVhdHVyZUxpc3QubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTGlzdFtpXS5zdGFydD4gc3RhcnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkhPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZUxpc3Quc3BsaWNlKDAsaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdfZmVhdHVyZXM9ZXhpc3RpbmdfZmVhdHVyZXMuY29uY2F0KGZlYXR1cmVMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ2kgPSBzZWxmLmZlYXR1cmVDYWNoZT9zZWxmLmZlYXR1cmVDYWNoZS5yYW5nZTpnZW5vbWljSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNhY2hlID0gbmV3IEZlYXR1cmVDYWNoZShleGlzdGluZ19mZWF0dXJlcywgZ2kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGZWF0dXJlU291cmNlLnBhY2tGZWF0dXJlcyhleGlzdGluZ19mZWF0dXJlcywgbWF4Um93cyk7IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuZmVhdHVyZUNhY2hlLnF1ZXJ5RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHN0YXRpYyBwYWNrRmVhdHVyZXMoZmVhdHVyZXMsIG1heFJvd3MpIHtcclxuXHJcbiAgICAgICAgaWYgKGZlYXR1cmVzID09IG51bGwgfHwgZmVhdHVyZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNlZ3JlZ2F0ZSBieSBjaHJvbW9zb21lXHJcblxyXG4gICAgICAgIHZhciBjaHJGZWF0dXJlTWFwID0ge30sXHJcbiAgICAgICAgICAgIGNocnMgPSBbXTtcclxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgY2hyID0gZmVhdHVyZS5jaHIsXHJcbiAgICAgICAgICAgICAgICBmbGlzdCA9IGNockZlYXR1cmVNYXBbY2hyXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghZmxpc3QpIHtcclxuICAgICAgICAgICAgICAgIGZsaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICBjaHJGZWF0dXJlTWFwW2Nocl0gPSBmbGlzdDtcclxuICAgICAgICAgICAgICAgIGNocnMucHVzaChjaHIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbGlzdC5wdXNoKGZlYXR1cmUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBMb29wIHRocm91Z2ggY2hyb3NvbW9zb21lcyBhbmQgcGFjayBmZWF0dXJlcztcclxuXHJcbiAgICAgICAgY2hycy5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHtcclxuXHJcbiAgICAgICAgICAgIHBhY2soY2hyRmVhdHVyZU1hcFtjaHJdLCBtYXhSb3dzKTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIEFzc2lnbnMgYSByb3cgIyB0byBlYWNoIGZlYXR1cmUuICBJZiB0aGUgZmVhdHVyZSBkb2VzIG5vdCBmaXQgaW4gYW55IHJvdyBhbmQgI3Jvd3MgPT0gbWF4Um93cyBub1xyXG4gICAgICAgIC8vIHJvdyBudW1iZXIgaXMgYXNzaWduZWQuXHJcbiAgICAgICAgZnVuY3Rpb24gcGFjayhmZWF0dXJlTGlzdCwgbWF4Um93cykge1xyXG5cclxuICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmVMaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0IC0gYi5zdGFydDtcclxuICAgICAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgICAgICByb3dzLnB1c2goLTEwMDApO1xyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgcixcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSBNYXRoLm1pbihyb3dzLmxlbmd0aCwgbWF4Um93cyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBmZWF0dXJlLnN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCBsZW47IHIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA+PSByb3dzW3JdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUucm93ID0gcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93c1tyXSA9IGZlYXR1cmUuZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5yb3cgPSByO1xyXG4gICAgICAgICAgICAgICAgcm93c1tyXSA9IGZlYXR1cmUuZW5kO1xyXG5cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNsYXNzIFRhYml4QmVkRmVhdHVyZVNvdXJjZSBleHRlbmRzIEZlYXR1cmVTb3VyY2V7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsZGVjb2RlX2Z1bmN0aW9uKXtcclxuICAgICAgICBzdXBlcihjb25maWcpO1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gbmV3IEZlYXR1cmVGaWxlUmVhZGVyKGNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHJpZXZlRmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnJlYWRGZWF0dXJlcyhjaHIsc3RhcnQsZW5kKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRGaWxlSGVhZGVyKCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLnJlYWRlci5yZWFkSGVhZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmlzX2luZGV4ZWQ9dHJ1ZTsgIFxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbCgpO1xyXG4gICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSAgIFxyXG59XHJcblxyXG5jbGFzcyBCaWdCZWRGZWF0dXJlU291cmNlIGV4dGVuZHMgRmVhdHVyZVNvdXJjZXtcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pe1xyXG5cdFx0Y29uZmlnLnNvdXJjZVR5cGU9XCJndGV4XCI7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5oZWFkZXI9dHJ1ZTtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9bmV3IEJXU291cmNlKGNvbmZpZyxkZWNvZGVfZnVuY3Rpb24pO1xyXG5cdH1cclxuXHJcblx0cmV0cmlldmVGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmb3JjZSxkYXRhKXtcclxuXHRcdHJldHVybiB0aGlzLmZlYXR1cmVfc291cmNlLmdldEZlYXR1cmVzKGNocixicFN0YXJ0LGJwRW5kLGZhbHNlLGRhdGEpOyAgICAgXHRcclxuXHR9XHJcbn1cclxuXHJcbi8vKioqKioqKipqcy9GZWF0dXJlRmlsZVJlYWRlci5qcyoqKioqXHJcblxyXG5cclxuXHJcbmNvbnN0IEZfTUFYX0daSVBfQkxPQ0tfU0laRSA9ICgxIDw8IDE2KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRlciBmb3IgXCJiZWQgbGlrZVwiIGZpbGVzICh0YWIgZGVsaW1pdGVkIGZpbGVzIHdpdGggMSBmZWF0dXJlIHBlciBsaW5lOiBiZWQsIGdmZiwgdmNmLCBldGMpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuY2xhc3MgRmVhdHVyZUZpbGVSZWFkZXJ7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsZGVjX2Z1bmN0aW9uKSB7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuICAgICAgICBpZiAoY29uZmlnLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsRmlsZSA9IGNvbmZpZy5sb2NhbEZpbGU7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSBjb25maWcubG9jYWxGaWxlLm5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhVUkwgPSBjb25maWcuaW5kZXhVUkw7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZFVSTCA9IGNvbmZpZy5oZWFkVVJMIHx8IHRoaXMuZmlsZW5hbWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXJpUGFydHMgPSBVdGlscy5wYXJzZVVyaShjb25maWcudXJsKTtcclxuICAgICAgICAgICAgdGhpcy5maWxlbmFtZSA9IHVyaVBhcnRzLmZpbGU7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHVyaVBhcnRzLnBhdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IGNvbmZpZy5mb3JtYXQ7XHJcblxyXG4gICAgICAgIHRoaXMucGFyc2VyID0gdGhpcy5nZXRQYXJzZXIodGhpcy5mb3JtYXQsIGRlY19mdW5jdGlvbik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBnZXRQYXJzZXIoZm9ybWF0LCBkZWNvZGUpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBjYXNlIFwidmNmXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZjZlBhcnNlcigpO1xyXG4gICAgICAgICAgICBjYXNlIFwic2VnXCIgOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWdQYXJzZXIoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmVhdHVyZVBhcnNlcihmb3JtYXQsIGRlY29kZSwgdGhpcy5jb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2VnIGZpbGVzIGRvbid0IGhhdmUgYW4gaW5kZXhcclxuICAgIGlzSW5kZXhhYmxlKCkge1xyXG4gICAgICAgIHZhciBjb25maWdJbmRleFVSTCA9IHRoaXMuY29uZmlnLmluZGV4VVJMLFxyXG4gICAgICAgICAgICB0eXBlID0gdGhpcy50eXBlLFxyXG4gICAgICAgICAgICBjb25maWdJbmRleGVkID0gdGhpcy5jb25maWcuaW5kZXhlZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZ0luZGV4VVJMIHx8ICh0eXBlICE9IFwid2lnXCIgJiYgY29uZmlnSW5kZXhlZCAhPSBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIGFzeW5jIGxvYWRlZCBpbmRleFxyXG4gICAgICovXHJcbiAgICBsb2FkSW5kZXgoKSB7XHJcbiAgICAgICAgdmFyIGlkeEZpbGUgPSB0aGlzLmluZGV4VVJMO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGVuYW1lLmVuZHNXaXRoKFwiLmd6XCIpKSB7XHJcbiAgICAgICAgICAgIGlmICghaWR4RmlsZSkgaWR4RmlsZSA9IHRoaXMudXJsICsgXCIudGJpXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2FkQmFtSW5kZXgoaWR4RmlsZSwgdGhpcy5jb25maWcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCFpZHhGaWxlKSBpZHhGaWxlID0gdGhpcy51cmwgKyBcIi5pZHhcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGxvYWRUcmliYmxlSW5kZXgoaWR4RmlsZSwgdGhpcy5jb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb2FkRmVhdHVyZXNOb0luZGV4KCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSBzZWxmLnBhcnNlcixcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5sb2NhbEZpbGUpIHtcclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nRnJvbUZpbGUoc2VsZi5sb2NhbEZpbGUsIG9wdGlvbnMpLnRoZW4ocGFyc2VEYXRhKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmcoc2VsZi51cmwsIG9wdGlvbnMpLnRoZW4ocGFyc2VEYXRhKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcGFyc2VEYXRhKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuaGVhZGVyID0gcGFyc2VyLnBhcnNlSGVhZGVyKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaGVhZGVyIGluc3RhbmNlb2YgU3RyaW5nICYmIHNlbGYuaGVhZGVyLnN0YXJ0c1dpdGgoXCIjI2dmZi12ZXJzaW9uIDNcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmZvcm1hdCA9ICdnZmYzJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocGFyc2VyLnBhcnNlRmVhdHVyZXMoZGF0YSkpOyAgIC8vIDw9IFBBUlNJTkcgRE9ORSBIRVJFXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGxvYWRGZWF0dXJlc1dpdGhJbmRleChjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYmxvY2tzLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgdGFiaXggPSBpbmRleCAmJiBpbmRleC50YWJpeCxcclxuICAgICAgICAgICAgICAgIHJlZklkID0gdGFiaXggPyBpbmRleC5zZXF1ZW5jZUluZGV4TWFwW2Nocl0gOiBjaHIsXHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgYmxvY2tzID0gaW5kZXguYmxvY2tzRm9yUmFuZ2UocmVmSWQsIHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFibG9ja3MgfHwgYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTsgICAgICAgLy8gVE9ETyAtLSBpcyB0aGlzIGNvcnJlY3Q/ICBTaG91bGQgaXQgcmV0dXJuIGFuIGVtcHR5IGFycmF5P1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFBvcyA9IGJsb2NrLm1pbnYuYmxvY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IGJsb2NrLm1pbnYub2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zID0gYmxvY2subWF4di5ibG9jayArIChpbmRleC50YWJpeCA/IEZfTUFYX0daSVBfQkxPQ0tfU0laRSA6IDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBzZWxmLmNvbmZpZy5oZWFkZXJzLCAgICAgICAgICAgLy8gaHR0cCBoZWFkZXJzLCBub3QgZmlsZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiBzdGFydFBvcywgc2l6ZTogZW5kUG9zIC0gc3RhcnRQb3MgKyAxfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHNlbGYuY29uZmlnLndpdGhDcmVkZW50aWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbGF0ZWQsIHNsaWNlZERhdGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4LnRhYml4KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxhdGVkID0gaWd2eGhyLmFycmF5QnVmZmVyVG9TdHJpbmcodW5iZ3pmKGRhdGEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGRlY29tcHJlc3MgZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGF0ZWQgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlZERhdGEgPSBzdGFydE9mZnNldCA/IGluZmxhdGVkLnNsaWNlKHN0YXJ0T2Zmc2V0KSA6IGluZmxhdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBzZWxmLnBhcnNlci5wYXJzZUZlYXR1cmVzKHNsaWNlZERhdGEsY2hyLHN0YXJ0LGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jIGxvYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubG9jYWxGaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZ0Zyb21GaWxlKHNlbGYubG9jYWxGaWxlLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXgudGFiaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZEFycmF5QnVmZmVyKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ3Z4aHIubG9hZFN0cmluZyhzZWxmLnVybCwgb3B0aW9ucykudGhlbihzdWNjZXNzKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoZmVhdHVyZUFycmF5cykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYWxsRmVhdHVyZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcyA9IGZlYXR1cmVBcnJheXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBmZWF0dXJlQXJyYXlzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IGZlYXR1cmVBcnJheXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzID0gYWxsRmVhdHVyZXMuY29uY2F0KGZlYXR1cmVBcnJheXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChhbGxGZWF0dXJlcylcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGdldEluZGV4KCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgaXNJbmRlZWRJbmRleGlibGUgPSB0aGlzLmlzSW5kZXhhYmxlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4ZWQgPT09IHVuZGVmaW5lZCAmJiBpc0luZGVlZEluZGV4aWJsZSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5sb2FkSW5kZXgoKS50aGVuKGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpOyAgIC8vIElzIGVpdGhlciBhbHJlYWR5IGxvYWRlZCwgb3IgdGhlcmUgaXNuJ3Qgb25lXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZEhlYWRlcigpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmhlYWRlcikge1xyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmhlYWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGZvcmNlIGEgbG9hZCBvZiB0aGUgaW5kZXggZmlyc3RcclxuXHJcbiAgICAgICAgICAgICAgIHNlbGYuIGdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoaW5kZXgpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIGZpbGUgaGVhZGVyIChub3QgSFRUUCBoZWFkZXIpIGZvciBhbiBpbmRleGVkIGZpbGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gLS0gbm90ZSB0aGlzIHdpbGwgZmFpbCBpZiB0aGUgZmlsZSBoZWFkZXIgaXMgPiA2NWtiIGluIHNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogc2VsZi5jb25maWcuaGVhZGVycywgICAgICAgICAgIC8vIGh0dHAgaGVhZGVycywgbm90IGZpbGUgaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmd6OiBpbmRleC50YWJpeCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiAwLCBzaXplOiA2NTAwMH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLmNvbmZpZy53aXRoQ3JlZGVudGlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhlYWRlciA9IHNlbGYucGFyc2VyLnBhcnNlSGVhZGVyKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VsZi5oZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvY2FsRmlsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWd2eGhyLmxvYWRTdHJpbmdGcm9tRmlsZShzZWxmLmxvY2FsRmlsZSwgb3B0aW9ucykudGhlbihzdWNjZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkU3RyaW5nKHNlbGYudXJsLCBvcHRpb25zKS50aGVuKHN1Y2Nlc3MpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9hZEZlYXR1cmVzTm9JbmRleCh1bmRlZmluZWQpLnRoZW4oZnVuY3Rpb24gKGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gc2VsZi5oZWFkZXIgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXIuZmVhdHVyZXMgPSBmZWF0dXJlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoaGVhZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bGZpbGxcclxuICAgICAqIEBwYXJhbSByYW5nZSAtLSBnZW5vbWljIHJhbmdlIHRvIGxvYWQuICBGb3IgdXNlIHdpdGggaW5kZXhlZCBzb3VyY2UgKG9wdGlvbmFsKVxyXG4gICAgICovXHJcbiAgICByZWFkRmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmxvYWRGZWF0dXJlc1dpdGhJbmRleChjaHIsIHN0YXJ0LCBlbmQpLnRoZW4ocGFja0ZlYXR1cmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlbGYubG9hZEZlYXR1cmVzTm9JbmRleCgpLnRoZW4ocGFja0ZlYXR1cmVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcGFja0ZlYXR1cmVzKGZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHBhY2tcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoZmVhdHVyZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKmpzL2ZlYXR1cmUvRmVhdHVyZVBhcnNlcnMuanMqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IG1heEZlYXR1cmVDb3VudCA9IE51bWJlci5NQVhfVkFMVUU7ICAgIC8vIEZvciBmdXR1cmUgdXNlLCAgY29udHJvbHMgZG93bnNhbXBsaW5nXHJcblxyXG5jb25zdCBnZmZOYW1lRmllbGRzID0gW1wiTmFtZVwiLCBcImdlbmVfbmFtZVwiLCBcImdlbmVcIiwgXCJnZW5lX2lkXCIsIFwiYWxpYXNcIiwgXCJsb2N1c1wiXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZmFjdG9yeSBmdW5jdGlvbi4gIFJldHVybiBhIHBhcnNlciBmb3IgdGhlIGdpdmVuIGZpbGUgZm9ybWF0LlxyXG4gICAgICovXHJcbmNsYXNzIEZlYXR1cmVQYXJzZXJ7XHJcbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXQsIGRlY29kZV9mdW5jLCBjb25maWcpIHtcclxuXHJcbiAgICAgICAgdmFyIGN1c3RvbUZvcm1hdDtcclxuXHJcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgdGhpcy5uYW1lRmllbGQgPSBjb25maWcgPyBjb25maWcubmFtZUZpZWxkIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuc2tpcFJvd3MgPSAwOyAgIC8vIFRoZSBudW1iZXIgb2YgZml4ZWQgaGVhZGVyIHJvd3MgdG8gc2tpcC4gIE92ZXJyaWRlIGZvciBzcGVjaWZpYyB0eXBlcyBhcyBuZWVkZVxyXG5cclxuICAgICAgICBpZiAoZGVjb2RlX2Z1bmMpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcblxyXG4gICAgICAgICAgICB0aGlzLmRlY29kZSA9ZnVuY3Rpb24odG9rZW5zLGlnbm9yZSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmVhdHVyZT17Y2hyOnRva2Vuc1swXSxzdGFydDpwYXJzZUludCh0b2tlbnNbMV0pLGVuZDpwYXJzZUludCh0b2tlbnNbMl0pfVxyXG4gICAgICAgICAgICAgICAgZGVjb2RlX2Z1bmModG9rZW5zLnNsaWNlKDMpLGZlYXR1cmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcbiAgICAgICAgICAgIH0gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb25maWcuZGVjb2RlX2Z1bmN0aW9uPT09XCJnZW5lcmljXCIpe1xyXG4gICAgICAgICAgICAgdGhpcy5kZWNvZGUgPWZ1bmN0aW9uKHRva2VucyxpZ25vcmUpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZlYXR1cmU9e2Nocjp0b2tlbnNbMF0sc3RhcnQ6cGFyc2VJbnQodG9rZW5zWzFdKSxlbmQ6cGFyc2VJbnQodG9rZW5zWzJdKX1cclxuICAgICAgICAgICAgICAgIGZlYXR1cmUuZGF0YT10b2tlbnMuc2xpY2UoMyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuICAgICAgICAgICAgfSA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gRmVhdHVyZVBhcnNlci5kZWNvZGVCZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gL1xccysvO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHJcblxyXG4gICAgICAgLyogc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgY2FzZSBcIm5hcnJvd3BlYWtcIjpcclxuICAgICAgICAgICAgY2FzZSBcImJyb2FkcGVha1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwicGVha3NcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID0gdGhpcy5kZWNvZGVQZWFrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImJlZGdyYXBoXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlQmVkR3JhcGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwid2lnXCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlV2lnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSAvXFxzKy87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImdmZjNcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZmZcIiA6XHJcbiAgICAgICAgICAgIGNhc2UgXCJndGZcIiA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlR0ZGO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJhbmV1XCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlQW5ldTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gXCJcXHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZnVzaW9uanVuY3NwYW5cIjpcclxuICAgICAgICAgICAgICAgIC8vIGJoYWFzLCBuZWVkZWQgZm9yIEZ1c2lvbkluc3BlY3RvciB2aWV3XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlRnVzaW9uSnVuY1NwYW47XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IC9cXHMrLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZ3RleGd3YXNcIjpcclxuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFJvd3MgPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlY29kZUd0ZXhHV0FTO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXIgPSBcIlxcdFwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyZWZmbGF0XCI6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVjb2RlUmVmZmxhdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVyID0gXCJcXHRcIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG5cclxuICAgICAgICAgICAgICAgY3VzdG9tRm9ybWF0ID0gaWd2LmJyb3dzZXIuZ2V0Rm9ybWF0KGZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VzdG9tRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZSA9IGRlY29kZUN1c3RvbTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGN1c3RvbUZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGltaXRlciA9IGN1c3RvbUZvcm1hdC5kZWxpbWl0ZXIgfHwgXCJcXHRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIH0qL1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgcGFyc2VIZWFkZXIoZGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpLFxyXG4gICAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGxpbmUsXHJcbiAgICAgICAgICAgIGksXHJcbiAgICAgICAgICAgIGhlYWRlcjtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRyYWNrXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcIiNcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiYnJvd3NlclwiKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRyYWNrXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5wYXJzZVRyYWNrTGluZShsaW5lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcIiMjZ2ZmLXZlcnNpb24gM1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gXCJnZmYzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXIpIGhlYWRlciA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcltcImZvcm1hdFwiXSA9IFwiZ2ZmM1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyPXt9O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlcjtcclxuICAgIH07XHJcblxyXG4gICAgcGFyc2VGZWF0dXJlcyhkYXRhLGNocixzdGFydCxlbmQpIHtcclxuXHJcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgdmFyIHdpZyxcclxuICAgICAgICAgICAgZmVhdHVyZSxcclxuICAgICAgICAgICAgbGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpLFxyXG4gICAgICAgICAgICBsZW4gPSBsaW5lcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHRva2VucyxcclxuICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBbXSxcclxuICAgICAgICAgICAgbGluZSxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgY250ID0gMCxcclxuICAgICAgICAgICAgaixcclxuICAgICAgICAgICAgZGVjb2RlID0gdGhpcy5kZWNvZGUsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0LFxyXG4gICAgICAgICAgICBkZWxpbWl0ZXIgPSB0aGlzLmRlbGltaXRlciB8fCBcIlxcdFwiO1xyXG5cclxuXHJcbiAgICAgICAgZm9yIChpID0gdGhpcy5za2lwUm93czsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRyYWNrXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcIiNcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiYnJvd3NlclwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIndpZ1wiICYmIGxpbmUuc3RhcnRzV2l0aChcImZpeGVkU3RlcFwiKSkge1xyXG4gICAgICAgICAgICAgICAgd2lnID0gdGhpcy5wYXJzZUZpeGVkU3RlcChsaW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ3aWdcIiAmJiBsaW5lLnN0YXJ0c1dpdGgoXCJ2YXJpYWJsZVN0ZXBcIikpIHtcclxuICAgICAgICAgICAgICAgIHdpZyA9IHRoaXMucGFyc2VWYXJpYWJsZVN0ZXAobGluZSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9rZW5zID0gbGluZXNbaV0uc3BsaXQoZGVsaW1pdGVyKTtcclxuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCAxKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmUgPSB0aGlzLmRlY29kZSh0b2tlbnMsIHdpZyk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmNociAhPT1jaHIgfHwgZmVhdHVyZS5lbmQ8c3RhcnQgfHwgZmVhdHVyZS5zdGFydD5lbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFsbEZlYXR1cmVzLmxlbmd0aCA8IG1heEZlYXR1cmVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbEZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNlcnZvaXIgc2FtcGxpbmcsICBjb25kaXRpb25hbGx5IHJlcGxhY2UgZXhpc3RpbmcgZmVhdHVyZSB3aXRoIG5ldyBvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBtYXhGZWF0dXJlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXNbal0gPSBmZWF0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYWxsRmVhdHVyZXM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VGaXhlZFN0ZXAobGluZSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgvXFxzKy8pLFxyXG4gICAgICAgICAgICBjYyA9IHRva2Vuc1sxXS5zcGxpdChcIj1cIilbMV0sXHJcbiAgICAgICAgICAgIHNzID0gcGFyc2VJbnQodG9rZW5zWzJdLnNwbGl0KFwiPVwiKVsxXSwgMTApLFxyXG4gICAgICAgICAgICBzdGVwID0gcGFyc2VJbnQodG9rZW5zWzNdLnNwbGl0KFwiPVwiKVsxXSwgMTApLFxyXG4gICAgICAgICAgICBzcGFuID0gKHRva2Vucy5sZW5ndGggPiA0KSA/IHBhcnNlSW50KHRva2Vuc1s0XS5zcGxpdChcIj1cIilbMV0sIDEwKSA6IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB7Zm9ybWF0OiBcImZpeGVkU3RlcFwiLCBjaHJvbTogY2MsIHN0YXJ0OiBzcywgc3RlcDogc3RlcCwgc3Bhbjogc3BhbiwgaW5kZXg6IDB9O1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcGFyc2VWYXJpYWJsZVN0ZXAobGluZSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgvXFxzKy8pLFxyXG4gICAgICAgICAgICBjYyA9IHRva2Vuc1sxXS5zcGxpdChcIj1cIilbMV0sXHJcbiAgICAgICAgICAgIHNwYW4gPSB0b2tlbnMubGVuZ3RoID4gMiA/IHBhcnNlSW50KHRva2Vuc1syXS5zcGxpdChcIj1cIilbMV0sIDEwKSA6IDE7XHJcbiAgICAgICAgcmV0dXJuIHtmb3JtYXQ6IFwidmFyaWFibGVTdGVwXCIsIGNocm9tOiBjYywgc3Bhbjogc3Bhbn1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlVHJhY2tMaW5lKGxpbmUpIHtcclxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9LFxyXG4gICAgICAgICAgICB0b2tlbnMgPSBsaW5lLnNwbGl0KC8oPzpcIikoW15cIl0rKSg/OlwiKXwoW15cXHNcIl0rKSg/PVxccyt8JCkvZyksXHJcbiAgICAgICAgICAgIHRtcCA9IFtdLFxyXG4gICAgICAgICAgICBpLCB0aywgY3VycjtcclxuXHJcbiAgICAgICAgLy8gQ2xlYW4gdXAgdG9rZW5zIGFycmF5XHJcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXRva2Vuc1tpXSB8fCB0b2tlbnNbaV0udHJpbSgpLmxlbmd0aCA9PT0gMCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICB0ayA9IHRva2Vuc1tpXS50cmltKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGsuZW5kc1dpdGgoXCI9XCIpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY3VyciA9IHRrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHRtcC5wdXNoKGN1cnIgKyB0ayk7XHJcbiAgICAgICAgICAgICAgICBjdXJyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG1wLnB1c2godGspO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHRtcC5mb3JFYWNoKGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgaWYgKCFzdHIpIHJldHVybjtcclxuICAgICAgICAgICAgdmFyIGt2ID0gc3RyLnNwbGl0KCc9JywgMik7XHJcbiAgICAgICAgICAgIGlmIChrdi5sZW5ndGggPT0gMikge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllc1trdlswXV0gPSBrdlsxXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgdGhlIFwic3RhbmRhcmRcIiBVQ1NDIGJlZCBmb3JtYXRcclxuICAgICAqIEBwYXJhbSB0b2tlbnNcclxuICAgICAqIEBwYXJhbSBpZ25vcmVcclxuICAgICAqIEByZXR1cm5zIGRlY29kZWQgZmVhdHVyZSwgb3IgbnVsbCBpZiB0aGlzIGlzIG5vdCBhIHZhbGlkIHJlY29yZFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGVjb2RlQmVkKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHIsIHN0YXJ0LCBlbmQsIGlkLCBuYW1lLCB0bXAsIGlkTmFtZSwgZXhvbkNvdW50LCBleG9uU2l6ZXMsIGV4b25TdGFydHMsIGV4b25zLCBleG9uLCBmZWF0dXJlLFxyXG4gICAgICAgICAgICBlU3RhcnQsIGVFbmQ7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1swXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1sxXSk7XHJcbiAgICAgICAgZW5kID0gdG9rZW5zLmxlbmd0aCA+IDIgPyBwYXJzZUludCh0b2tlbnNbMl0pIDogc3RhcnQgKyAxO1xyXG5cclxuICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBzY29yZTogMTAwMH07XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMykge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVzZSBhcmUgdmVyeSBzcGVjaWFsIHJ1bGVzIGZvciB0aGUgZ2VuY29kZSBnZW5lIGZpbGVzLlxyXG4gICAgICAgICAgICB0bXAgPSB0b2tlbnNbM10ucmVwbGFjZSgvXCIvZywgJycpO1xyXG4gICAgICAgICAgICBpZE5hbWUgPSB0bXAuc3BsaXQoJzsnKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZE5hbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrdiA9IGlkTmFtZVtpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGt2WzBdID09IFwiZ2VuZV9pZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBrdlsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChrdlswXSA9PSBcImdlbmVfbmFtZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGt2WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBpZCA/IGlkIDogdG1wO1xyXG4gICAgICAgICAgICBmZWF0dXJlLm5hbWUgPSBuYW1lID8gbmFtZSA6IHRtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNCkge1xyXG4gICAgICAgICAgICBmZWF0dXJlLnNjb3JlID0gcGFyc2VGbG9hdCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDUpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5zdHJhbmQgPSB0b2tlbnNbNV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gNikge1xyXG4gICAgICAgICAgICBmZWF0dXJlLmNkU3RhcnQgPSBwYXJzZUludCh0b2tlbnNbNl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDcpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5jZEVuZCA9IHBhcnNlSW50KHRva2Vuc1s3XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gOCkge1xyXG4gICAgICAgICAgICBpZiAodG9rZW5zWzhdICE9PSBcIi5cIiAmJiB0b2tlbnNbOF0gIT09IFwiMFwiKVxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZS5jb2xvciA9IGlndi5jcmVhdGVDb2xvclN0cmluZyh0b2tlbnNbOF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDExKSB7XHJcbiAgICAgICAgICAgIGV4b25Db3VudCA9IHBhcnNlSW50KHRva2Vuc1s5XSk7XHJcbiAgICAgICAgICAgIGV4b25TaXplcyA9IHRva2Vuc1sxMF0uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgZXhvblN0YXJ0cyA9IHRva2Vuc1sxMV0uc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgZXhvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbkNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVTdGFydCA9IHN0YXJ0ICsgcGFyc2VJbnQoZXhvblN0YXJ0c1tpXSk7XHJcbiAgICAgICAgICAgICAgICBlRW5kID0gZVN0YXJ0ICsgcGFyc2VJbnQoZXhvblNpemVzW2ldKTtcclxuICAgICAgICAgICAgICAgIHZhciBleG9uID0ge3N0YXJ0OiBlU3RhcnQsIGVuZDogZUVuZH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuY2RTdGFydCA+IGVFbmQgfHwgZmVhdHVyZS5jZEVuZCA8IGZlYXR1cmUuY2RTdGFydCkgZXhvbi51dHIgPSB0cnVlOyAgIC8vIEVudGlyZSBleG9uIGlzIFVUUlxyXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuY2RTdGFydCA+PSBlU3RhcnQgJiYgZmVhdHVyZS5jZFN0YXJ0IDw9IGVFbmQpIGV4b24uY2RTdGFydCA9IGZlYXR1cmUuY2RTdGFydDtcclxuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmNkRW5kID49IGVTdGFydCAmJiBmZWF0dXJlLmNkRW5kIDw9IGVFbmQpIGV4b24uY2RFbmQgPSBmZWF0dXJlLmNkRW5kO1xyXG5cclxuICAgICAgICAgICAgICAgIGV4b25zLnB1c2goZXhvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZlYXR1cmUuZXhvbnMgPSBleG9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZlYXR1cmUucG9wdXBEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5uYW1lKSBkYXRhLnB1c2goe25hbWU6IFwiTmFtZVwiLCB2YWx1ZTogZmVhdHVyZS5uYW1lfSk7XHJcbiAgICAgICAgICAgIGlmIChcIitcIiA9PT0gZmVhdHVyZS5zdHJhbmQgfHwgXCItXCIgPT09IGZlYXR1cmUuc3RyYW5kKSBkYXRhLnB1c2goe25hbWU6IFwiU3RyYW5kXCIsIHZhbHVlOiBmZWF0dXJlLnN0cmFuZH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgYSBVQ1NDIFwicmVmZmxhdFwiIHJlY29yZFxyXG4gICAgICogQHBhcmFtIHRva2Vuc1xyXG4gICAgICogQHBhcmFtIGlnbm9yZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVSZWZmbGF0KHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMTApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZSA9IHtcclxuICAgICAgICAgICAgICAgIGNocjogdG9rZW5zWzJdLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBhcnNlSW50KHRva2Vuc1s0XSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IHBhcnNlSW50KHRva2Vuc1s1XSksXHJcbiAgICAgICAgICAgICAgICBpZDogdG9rZW5zWzFdLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogdG9rZW5zWzBdLFxyXG4gICAgICAgICAgICAgICAgc3RyYW5kOiB0b2tlbnNbM10sXHJcbiAgICAgICAgICAgICAgICBjZFN0YXJ0OiBwYXJzZUludCh0b2tlbnNbNl0pLFxyXG4gICAgICAgICAgICAgICAgY2RFbmQ6IHBhcnNlSW50KHRva2Vuc1s3XSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhvbkNvdW50ID0gcGFyc2VJbnQodG9rZW5zWzhdKSxcclxuICAgICAgICAgICAgZXhvblN0YXJ0cyA9IHRva2Vuc1s5XS5zcGxpdCgnLCcpLFxyXG4gICAgICAgICAgICBleG9uRW5kcyA9IHRva2Vuc1sxMF0uc3BsaXQoJywnKSxcclxuICAgICAgICAgICAgZXhvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9uQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBleG9ucy5wdXNoKHtzdGFydDogcGFyc2VJbnQoZXhvblN0YXJ0c1tpXSksIGVuZDogcGFyc2VJbnQoZXhvbkVuZHNbaV0pfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmZWF0dXJlLmV4b25zID0gZXhvbnM7XHJcblxyXG4gICAgICAgIGZlYXR1cmUucG9wdXBEYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW3tuYW1lOiBcIk5hbWVcIiwgdmFsdWU6IGZlYXR1cmUubmFtZX1dO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlUGVhayh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgdG9rZW5Db3VudCwgY2hyLCBzdGFydCwgZW5kLCBzdHJhbmQsIG5hbWUsIHNjb3JlLCBxVmFsdWUsIHNpZ25hbCwgcFZhbHVlO1xyXG5cclxuICAgICAgICB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICBpZiAodG9rZW5Db3VudCA8IDkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMV0pO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1syXSk7XHJcbiAgICAgICAgbmFtZSA9IHRva2Vuc1szXTtcclxuICAgICAgICBzY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzRdKTtcclxuICAgICAgICBzdHJhbmQgPSB0b2tlbnNbNV0udHJpbSgpO1xyXG4gICAgICAgIHNpZ25hbCA9IHBhcnNlRmxvYXQodG9rZW5zWzZdKTtcclxuICAgICAgICBwVmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1s3XSk7XHJcbiAgICAgICAgcVZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbOF0pO1xyXG5cclxuICAgICAgICBpZiAoc2NvcmUgPT09IDApIHNjb3JlID0gc2lnbmFsO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjaHI6IGNociwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgbmFtZTogbmFtZSwgc2NvcmU6IHNjb3JlLCBzdHJhbmQ6IHN0cmFuZCwgc2lnbmFsOiBzaWduYWwsXHJcbiAgICAgICAgICAgIHBWYWx1ZTogcFZhbHVlLCBxVmFsdWU6IHFWYWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZUJlZEdyYXBoKHRva2VucywgaWdub3JlKSB7XHJcblxyXG4gICAgICAgIHZhciBjaHIsIHN0YXJ0LCBlbmQsIHZhbHVlO1xyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA8IDMpIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMV0pO1xyXG4gICAgICAgIGVuZCA9IHBhcnNlSW50KHRva2Vuc1syXSk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbM10pO1xyXG5cclxuICAgICAgICByZXR1cm4ge2NocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCB2YWx1ZTogdmFsdWV9O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVXaWcodG9rZW5zLCB3aWcpIHtcclxuXHJcbiAgICAgICAgdmFyIHNzLFxyXG4gICAgICAgICAgICBlZSxcclxuICAgICAgICAgICAgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICh3aWcuZm9ybWF0ID09PSBcImZpeGVkU3RlcFwiKSB7XHJcblxyXG4gICAgICAgICAgICBzcyA9ICh3aWcuaW5kZXggKiB3aWcuc3RlcCkgKyB3aWcuc3RhcnQ7XHJcbiAgICAgICAgICAgIGVlID0gc3MgKyB3aWcuc3BhbjtcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHRva2Vuc1swXSk7XHJcbiAgICAgICAgICAgICsrKHdpZy5pbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgPyBudWxsIDoge2Nocjogd2lnLmNocm9tLCBzdGFydDogc3MsIGVuZDogZWUsIHZhbHVlOiB2YWx1ZX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHdpZy5mb3JtYXQgPT09IFwidmFyaWFibGVTdGVwXCIpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgICAgICBzcyA9IHBhcnNlSW50KHRva2Vuc1swXSwgMTApO1xyXG4gICAgICAgICAgICBlZSA9IHNzICsgd2lnLnNwYW47XHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0b2tlbnNbMV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpID8gbnVsbCA6IHtjaHI6IHdpZy5jaHJvbSwgc3RhcnQ6IHNzLCBlbmQ6IGVlLCB2YWx1ZTogdmFsdWV9O1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVCZWRHcmFwaCh0b2tlbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZGVjb2RlQW5ldSh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgY2hyLCBzdGFydCwgZW5kLCBmZWF0dXJlO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPCA0KSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzFdO1xyXG4gICAgICAgIHN0YXJ0ID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICBlbmQgPSB0b2tlbnMubGVuZ3RoID4gMyA/IHBhcnNlSW50KHRva2Vuc1szXSkgOiBzdGFydCArIDE7XHJcblxyXG4gICAgICAgIGZlYXR1cmUgPSB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xyXG5cclxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDQpIHtcclxuICAgICAgICAgICAgZmVhdHVyZS5zY29yZSA9IHBhcnNlRmxvYXQodG9rZW5zWzRdKTtcclxuICAgICAgICAgICAgZmVhdHVyZS52YWx1ZSA9IGZlYXR1cmUuc2NvcmU7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZmVhdHVyZS5wb3B1cERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbe25hbWU6IFwiTmFtZVwiLCB2YWx1ZTogZmVhdHVyZS5uYW1lfV07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGVGdXNpb25KdW5jU3Bhbih0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICBGb3JtYXQ6XHJcblxyXG4gICAgICAgICAwICAgICAgICNzY2FmZm9sZFxyXG4gICAgICAgICAxICAgICAgIGZ1c2lvbl9icmVha19uYW1lXHJcbiAgICAgICAgIDIgICAgICAgYnJlYWtfbGVmdFxyXG4gICAgICAgICAzICAgICAgIGJyZWFrX3JpZ2h0XHJcbiAgICAgICAgIDQgICAgICAgbnVtX2p1bmN0aW9uX3JlYWRzXHJcbiAgICAgICAgIDUgICAgICAgbnVtX3NwYW5uaW5nX2ZyYWdzXHJcbiAgICAgICAgIDYgICAgICAgc3Bhbm5pbmdfZnJhZ19jb29yZHNcclxuXHJcbiAgICAgICAgIDAgICAgICAgQjNHTlQxLS1OUFNSMVxyXG4gICAgICAgICAxICAgICAgIEIzR05UMS0tTlBTUjF8MjIwMy0xMDE4MlxyXG4gICAgICAgICAyICAgICAgIDIyMDNcclxuICAgICAgICAgMyAgICAgICAxMDE4MlxyXG4gICAgICAgICA0ICAgICAgIDE4OVxyXG4gICAgICAgICA1ICAgICAgIDExMzhcclxuICAgICAgICAgNiAgICAgICAxODYwLTEzNzU3LDE3OTgtMTM4MTksMTM5MS0xODEyNywxNDQzLTE3MTc0LC4uLlxyXG5cclxuICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgXHJcblxyXG4gICAgICAgIHZhciBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgdmFyIGZ1c2lvbl9uYW1lID0gdG9rZW5zWzFdO1xyXG4gICAgICAgIHZhciBqdW5jdGlvbl9sZWZ0ID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICB2YXIganVuY3Rpb25fcmlnaHQgPSBwYXJzZUludCh0b2tlbnNbM10pO1xyXG4gICAgICAgIHZhciBudW1fanVuY3Rpb25fcmVhZHMgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIHZhciBudW1fc3Bhbm5pbmdfZnJhZ3MgPSBwYXJzZUludCh0b2tlbnNbNV0pO1xyXG5cclxuICAgICAgICB2YXIgc3Bhbm5pbmdfZnJhZ19jb29yZHNfdGV4dCA9IHRva2Vuc1s2XTtcclxuXHJcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB7XHJcbiAgICAgICAgICAgIGNocjogY2hyLFxyXG4gICAgICAgICAgICBuYW1lOiBmdXNpb25fbmFtZSxcclxuICAgICAgICAgICAganVuY3Rpb25fbGVmdDoganVuY3Rpb25fbGVmdCxcclxuICAgICAgICAgICAganVuY3Rpb25fcmlnaHQ6IGp1bmN0aW9uX3JpZ2h0LFxyXG4gICAgICAgICAgICBudW1fanVuY3Rpb25fcmVhZHM6IG51bV9qdW5jdGlvbl9yZWFkcyxcclxuICAgICAgICAgICAgbnVtX3NwYW5uaW5nX2ZyYWdzOiBudW1fc3Bhbm5pbmdfZnJhZ3MsXHJcbiAgICAgICAgICAgIHNwYW5uaW5nX2ZyYWdfY29vcmRzOiBbXSxcclxuXHJcbiAgICAgICAgICAgIHN0YXJ0OiAtMSxcclxuICAgICAgICAgICAgZW5kOiAtMVxyXG4gICAgICAgIH07IC8vIHNldCBzdGFydCBhbmQgZW5kIGxhdGVyIGJhc2VkIG9uIG1pbi9tYXggb2Ygc3BhbiBjb29yZHNcclxuXHJcbiAgICAgICAgdmFyIG1pbl9jb29yZCA9IGp1bmN0aW9uX2xlZnQ7XHJcbiAgICAgICAgdmFyIG1heF9jb29yZCA9IGp1bmN0aW9uX3JpZ2h0O1xyXG5cclxuICAgICAgICBpZiAobnVtX3NwYW5uaW5nX2ZyYWdzID4gMCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvb3JkX3BhaXJzID0gc3Bhbm5pbmdfZnJhZ19jb29yZHNfdGV4dC5zcGxpdCgnLCcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZF9wYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwbGl0X2Nvb3JkcyA9IGNvb3JkX3BhaXJzW2ldLnNwbGl0KCctJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNwYW5fbGVmdCA9IHNwbGl0X2Nvb3Jkc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBzcGFuX3JpZ2h0ID0gc3BsaXRfY29vcmRzWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzcGFuX2xlZnQgPCBtaW5fY29vcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5fY29vcmQgPSBzcGFuX2xlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbl9yaWdodCA+IG1heF9jb29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heF9jb29yZCA9IHNwYW5fcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnNwYW5uaW5nX2ZyYWdfY29vcmRzLnB1c2goe2xlZnQ6IHNwYW5fbGVmdCwgcmlnaHQ6IHNwYW5fcmlnaHR9KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZlYXR1cmUuc3RhcnQgPSBtaW5fY29vcmQ7XHJcbiAgICAgICAgZmVhdHVyZS5lbmQgPSBtYXhfY29vcmQ7XHJcblxyXG5cclxuICAgICAgICBmZWF0dXJlLnBvcHVwRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt7bmFtZTogXCJOYW1lXCIsIHZhbHVlOiBmZWF0dXJlLm5hbWV9XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gZmVhdHVyZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGRlY29kZUd0ZXhHV0FTKHRva2VucywgaWdub3JlKSB7XHJcblxyXG5cclxuICAgICAgICB2YXIgdG9rZW5Db3VudCwgY2hyLCBzdGFydCwgZW5kLCBzdHJhbmQsIG5hbWUsIHNjb3JlLCBxVmFsdWUsIHNpZ25hbCwgcFZhbHVlO1xyXG5cclxuICAgICAgICB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICBpZiAodG9rZW5Db3VudCA8IDgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaHIgPSB0b2tlbnNbMF07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbMV0pIC0gMTtcclxuICAgICAgICBlbmQgPSBwYXJzZUludCh0b2tlbnNbM10uc3BsaXQoJzonKVsxXSk7XHJcbiAgICAgICAgLy9uYW1lID0gdG9rZW5zWzNdO1xyXG4gICAgICAgIC8vc2NvcmUgPSBwYXJzZUZsb2F0KHRva2Vuc1s0XSk7XHJcbiAgICAgICAgLy9zdHJhbmQgPSB0b2tlbnNbNV0udHJpbSgpO1xyXG4gICAgICAgIC8vc2lnbmFsID0gcGFyc2VGbG9hdCh0b2tlbnNbNl0pO1xyXG4gICAgICAgIHBWYWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzVdKTtcclxuICAgICAgICAvL3FWYWx1ZSA9IHBhcnNlRmxvYXQodG9rZW5zWzhdKTtcclxuXHJcbiAgICAgICAgLy9yZXR1cm4ge2NocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBuYW1lOiBuYW1lLCBzY29yZTogc2NvcmUsIHN0cmFuZDogc3RyYW5kLCBzaWduYWw6IHNpZ25hbCxcclxuICAgICAgICAvLyAgICBwVmFsdWU6IHBWYWx1ZSwgcVZhbHVlOiBxVmFsdWV9O1xyXG4gICAgICAgIHJldHVybiB7Y2hyOiBjaHIsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIHB2YWx1ZTogcFZhbHVlfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSBhIHNpbmdsZSBnZmYgcmVjb3JkICgxIGxpbmUgaW4gZmlsZSkuICBBZ2dyZWdhdGlvbnMgc3VjaCBhcyBnZW5lIG1vZGVscyBhcmUgY29uc3RydWN0ZWQgYXQgYSBoaWdoZXIgbGV2ZWwuXHJcbiAgICAgKiAgICAgIGN0ZzEyMyAuIG1STkEgICAgICAgICAgICAxMDUwICA5MDAwICAuICArICAuICBJRD1tUk5BMDAwMDE7UGFyZW50PWdlbmUwMDAwMVxyXG4gICAgICogQHBhcmFtIHRva2Vuc1xyXG4gICAgICogQHBhcmFtIGlnbm9yZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVHRkYodG9rZW5zLCBpZ25vcmUpIHtcclxuXHJcbiAgICAgICAgdmFyIHRva2VuQ291bnQsIGNociwgc3RhcnQsIGVuZCwgc3RyYW5kLCB0eXBlLCBzY29yZSwgcGhhc2UsIGF0dHJpYnV0ZVN0cmluZywgaWQsIHBhcmVudCwgY29sb3IsIG5hbWUsXHJcbiAgICAgICAgICAgIHRyYW5zY3JpcHRfaWQsIGksXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xyXG5cclxuICAgICAgICB0b2tlbkNvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICBpZiAodG9rZW5Db3VudCA8IDkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAgICAgLy8gTm90IGEgdmFsaWQgZ2ZmIHJlY29yZFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgIHR5cGUgPSB0b2tlbnNbMl07XHJcbiAgICAgICAgc3RhcnQgPSBwYXJzZUludCh0b2tlbnNbM10pIC0gMTtcclxuICAgICAgICBlbmQgPSBwYXJzZUludCh0b2tlbnNbNF0pO1xyXG4gICAgICAgIHNjb3JlID0gXCIuXCIgPT09IHRva2Vuc1s1XSA/IDAgOiBwYXJzZUZsb2F0KHRva2Vuc1s1XSk7XHJcbiAgICAgICAgc3RyYW5kID0gdG9rZW5zWzZdO1xyXG4gICAgICAgIHBoYXNlID0gXCIuXCIgPT09IHRva2Vuc1s3XSA/IDAgOiBwYXJzZUludCh0b2tlbnNbN10pO1xyXG4gICAgICAgIGF0dHJpYnV0ZVN0cmluZyA9IHRva2Vuc1s4XTtcclxuXHJcbiAgICAgICAgLy8gRmluZCBJRCBhbmQgUGFyZW50LCBvciB0cmFuc2NyaXB0X2lkXHJcbiAgICAgICAgdmFyIGRlbGltID0gKCdnZmYzJyA9PT0gZm9ybWF0KSA/ICc9JyA6IC9cXHMrLztcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIGF0dHJpYnV0ZVN0cmluZy5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGt2KSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0ga3YudHJpbSgpLnNwbGl0KGRlbGltLCAyKSwga2V5LCB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHQubGVuZ3RoID09IDIpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IHRbMF0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0WzFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIC8vU3RyaXAgb2ZmIHF1b3RlcywgaWYgYW55XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXCInKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKFwiSURcIiA9PT0gdFswXSkgaWQgPSB0WzFdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJQYXJlbnRcIiA9PT0gdFswXSkgcGFyZW50ID0gdFsxXTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiY29sb3JcIiA9PT0gdFswXS50b0xvd2VyQ2FzZSgpKSBjb2xvciA9IGlndi5jcmVhdGVDb2xvclN0cmluZyh0WzFdKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwidHJhbnNjcmlwdF9pZFwiID09PSB0WzBdKSBpZCA9IHRbMV07ICAgICAvLyBndGYgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBGaW5kIG5hbWUgKGxhYmVsKSBwcm9wZXJ0eVxyXG4gICAgICAgIGlmICh0aGlzLm5hbWVGaWVsZCkge1xyXG4gICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlc1t0aGlzLm5hbWVGaWVsZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2ZmTmFtZUZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoZ2ZmTmFtZUZpZWxkc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVGaWVsZCA9IGdmZk5hbWVGaWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJpYnV0ZXNbdGhpcy5uYW1lRmllbGRdO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZDogaWQsXHJcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxyXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICBjaHI6IGNocixcclxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgc2NvcmU6IHNjb3JlLFxyXG4gICAgICAgICAgICBzdHJhbmQ6IHN0cmFuZCxcclxuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVTdHJpbmc6IGF0dHJpYnV0ZVN0cmluZyxcclxuICAgICAgICAgICAgcG9wdXBEYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga3ZzID0gdGhpcy5hdHRyaWJ1dGVTdHJpbmcuc3BsaXQoJzsnKSxcclxuICAgICAgICAgICAgICAgICAgICBwZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGtleSwgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBrdnMuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGt2LnRyaW0oKS5zcGxpdChkZWxpbSwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID09PSAyICYmIHRbMV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB0WzBdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0WzFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9TdHJpcCBvZmYgcXVvdGVzLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykgJiYgdmFsdWUuZW5kc1dpdGgoJ1wiJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLnB1c2goe25hbWU6IGtleSwgdmFsdWU6IHZhbHVlfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSB0aGUgXCJzdGFuZGFyZFwiIFVDU0MgYmVkIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHRva2Vuc1xyXG4gICAgICogQHBhcmFtIGlnbm9yZVxyXG4gICAgICogQHJldHVybnMgZGVjb2RlZCBmZWF0dXJlLCBvciBudWxsIGlmIHRoaXMgaXMgbm90IGEgdmFsaWQgcmVjb3JkXHJcbiAgICAgKi9cclxuICAgIGRlY29kZUN1c3RvbSh0b2tlbnMsIGlnbm9yZSkge1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZSxcclxuICAgICAgICAgICAgY2hyLCBzdGFydCwgZW5kLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSB0aGlzLmZvcm1hdCwgICAgICAgICAvLyBcInRoaXNcIiByZWZlcnMgdG8gRmVhdHVyZVBhcnNlciBpbnN0YW5jZVxyXG4gICAgICAgICAgICBjb29yZHMgPSBmb3JtYXQuY29vcmRzIHx8IDA7XHJcblxyXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoIDwgMykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIGNociA9IHRva2Vuc1tmb3JtYXQuY2hyXTtcclxuICAgICAgICBzdGFydCA9IHBhcnNlSW50KHRva2Vuc1tmb3JtYXQuc3RhcnRdKSAtIGNvb3JkcztcclxuICAgICAgICBlbmQgPSBmb3JtYXQuZW5kICE9PSB1bmRlZmluZWQgPyBwYXJzZUludCh0b2tlbnNbZm9ybWF0LmVuZF0pIDogc3RhcnQgKyAxO1xyXG5cclxuICAgICAgICBmZWF0dXJlID0ge2NocjogY2hyLCBzdGFydDogc3RhcnQsIGVuZDogZW5kfTtcclxuXHJcbiAgICAgICAgaWYgKGZvcm1hdC5maWVsZHMpIHtcclxuICAgICAgICAgICAgZm9ybWF0LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSBmb3JtYXQuY2hyICYmIGluZGV4ICE9IGZvcm1hdC5zdGFydCAmJiBpbmRleCAhPSBmb3JtYXQuZW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVtmaWVsZF0gPSB0b2tlbnNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqanMvZmVhdHVyZS9mZWF0dXJlQ2FjaGUuanMqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT2JqZWN0IGZvciBjYWNoaW5nIGxpc3RzIG9mIGZlYXR1cmVzLiAgU3VwcG9ydHMgZWZmZWNpZW50IHF1ZXJpZXMgZm9yIHN1Yi1yYW5nZSAgKGNociwgc3RhcnQsIGVuZClcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZUxpc3RcclxuICAgICAqIEBwYXJhbSBUaGUgZ2Vub21pYyByYW5nZSBzcGFubmVkIGJ5IGZlYXR1cmVMaXN0IChvcHRpb25hbClcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcblxyXG5jbGFzcyBGZWF0dXJlQ2FjaGV7XHJcbiAgICBjb25zdHJ1Y3RvcihmZWF0dXJlTGlzdCwgcmFuZ2UpIHtcclxuICAgICAgICB0aGlzLnRyZWVNYXAgPSBGZWF0dXJlQ2FjaGUuYnVpbGRUcmVlTWFwKGZlYXR1cmVMaXN0KTtcclxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcXVlcnlGZWF0dXJlcyhjaHIsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgXHJcblxyXG4gICAgICAgIHZhciBmZWF0dXJlTGlzdCwgaW50ZXJ2YWxGZWF0dXJlcywgZmVhdHVyZSwgbGVuLCBpLCB0cmVlLCBpbnRlcnZhbHM7XHJcblxyXG4gICAgICAgIHRyZWUgPSB0aGlzLnRyZWVNYXBbY2hyXTtcclxuXHJcbiAgICAgICAgaWYgKCF0cmVlKSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIGludGVydmFscyA9IHRyZWUuZmluZE92ZXJsYXBwaW5nKHN0YXJ0LCBlbmQpO1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJ2YWxzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRyaW0gdGhlIGxpc3Qgb2YgZmVhdHVyZXMgaW4gdGhlIGludGVydmFscyB0byB0aG9zZVxyXG4gICAgICAgICAgICAvLyBvdmVybGFwcGluZyB0aGUgcmVxdWVzdGVkIHJhbmdlLlxyXG4gICAgICAgICAgICAvLyBBc3N1bXB0aW9uOiBmZWF0dXJlcyBhcmUgc29ydGVkIGJ5IHN0YXJ0IHBvc2l0aW9uXHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgaW50ZXJ2YWxzLmZvckVhY2goZnVuY3Rpb24gKGludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlcnZhbEZlYXR1cmVzID0gaW50ZXJ2YWwudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBsZW4gPSBpbnRlcnZhbEZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUgPSBpbnRlcnZhbEZlYXR1cmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnN0YXJ0ID4gZW5kKSBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWF0dXJlLmVuZCA+PSBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTGlzdC5wdXNoKGZlYXR1cmUpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVMaXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIGFsbEZlYXR1cmVzKCkge1xyXG5cclxuICAgICAgICB2YXIgYWxsRmVhdHVyZXMgPSBbXTtcclxuICAgICAgICB2YXIgdHJlZU1hcCA9IHRoaXMudHJlZU1hcDtcclxuICAgICAgICBpZiAodHJlZU1hcCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdHJlZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyZWVNYXAuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZSA9IHRyZWVNYXBba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB0cmVlLm1hcEludGVydmFscyhmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMgPSBhbGxGZWF0dXJlcy5jb25jYXQoaW50ZXJ2YWwudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGxGZWF0dXJlcztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGJ1aWxkVHJlZU1hcChmZWF0dXJlTGlzdCkge1xyXG5cclxuICAgICAgICB2YXIgZmVhdHVyZUNhY2hlID0ge30sXHJcbiAgICAgICAgICAgIGNocm9tb3NvbWVzID0gW10sXHJcbiAgICAgICAgICAgIHRyZWVNYXAgPSB7fSxcclxuICAgICAgICAgICAgZ2Vub21lID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKGZlYXR1cmVMaXN0KSB7XHJcblxyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNociA9IGZlYXR1cmUuY2hyLFxyXG4gICAgICAgICAgICAgICAgICAgIGdlbmVMaXN0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBcIm9mZmljaWFsXCIgbmFtZVxyXG4gICAgICAgICAgICAgICAgaWYoZ2Vub21lKSBjaHIgPSBnZW5vbWUuZ2V0Q2hyb21vc29tZU5hbWUoY2hyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZW5lTGlzdCA9IGZlYXR1cmVDYWNoZVtjaHJdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZ2VuZUxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaHJvbW9zb21lcy5wdXNoKGNocik7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VuZUxpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlQ2FjaGVbY2hyXSA9IGdlbmVMaXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGdlbmVMaXN0LnB1c2goZmVhdHVyZSk7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgYnVpbGQgaW50ZXJ2YWwgdHJlZSBmb3IgZWFjaCBjaHJvbW9zb21lXHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNocm9tb3NvbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hyID0gY2hyb21vc29tZXNbaV07XHJcbiAgICAgICAgICAgICAgICB0cmVlTWFwW2Nocl0gPUZlYXR1cmVDYWNoZS5idWlsZEludGVydmFsVHJlZShmZWF0dXJlQ2FjaGVbY2hyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cmVlTWFwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGFuIGludGVydmFsIHRyZWUgZnJvbSB0aGUgZmVhdHVyZSBsaXN0IGZvciBmYXN0IGludGVydmFsIGJhc2VkIHF1ZXJpZXMuICAgV2UgbHVtcCBmZWF0dXJlcyBpbiBncm91cHNcclxuICAgICAqIG9mIDEwLCBvciB0b3RhbCBzaXplIC8gMTAwLCAgIHRvIHJlZHVjZSBzaXplIG9mIHRoZSB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlTGlzdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYnVpbGRJbnRlcnZhbFRyZWUoZmVhdHVyZUxpc3QpIHtcclxuXHJcbiAgICAgICAgdmFyIGksIGUsIGlTdGFydCwgaUVuZCwgdHJlZSwgY2h1bmtTaXplLCBsZW4sIHN1YkFycmF5O1xyXG5cclxuICAgICAgICB0cmVlID0gbmV3IEludGVydmFsVHJlZSgpO1xyXG4gICAgICAgIGxlbiA9IGZlYXR1cmVMaXN0Lmxlbmd0aDtcclxuXHJcbiAgICAgICAgY2h1bmtTaXplID0gTWF0aC5tYXgoMTAsIE1hdGgucm91bmQobGVuIC8gMTAwKSk7XHJcblxyXG4gICAgICAgIGZlYXR1cmVMaXN0LnNvcnQoZnVuY3Rpb24gKGYxLCBmMikge1xyXG4gICAgICAgICAgICByZXR1cm4gKGYxLnN0YXJ0ID09PSBmMi5zdGFydCA/IDAgOiAoZjEuc3RhcnQgPiBmMi5zdGFydCA/IDEgOiAtMSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IGNodW5rU2l6ZSkge1xyXG4gICAgICAgICAgICBlID0gTWF0aC5taW4obGVuLCBpICsgY2h1bmtTaXplKTtcclxuICAgICAgICAgICAgc3ViQXJyYXkgPSBmZWF0dXJlTGlzdC5zbGljZShpLCBlKTtcclxuICAgICAgICAgICAgaVN0YXJ0ID0gc3ViQXJyYXlbMF0uc3RhcnQ7XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIGlFbmQgPSBpU3RhcnQ7XHJcbiAgICAgICAgICAgIHN1YkFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGlFbmQgPSBNYXRoLm1heChpRW5kLCBmZWF0dXJlLmVuZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0cmVlLmluc2VydChpU3RhcnQsIGlFbmQsIHN1YkFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcbi8vKioqKipqcy9pbnRlcnZhbFRyZWUuanMqKioqKioqKioqKipcclxuXHJcblxyXG5jb25zdCBCTEFDSyA9IDE7XHJcbmNvbnN0IFJFRCA9IDI7XHJcblxyXG5sZXQgTklMID0ge31cclxuTklMLmNvbG9yID0gQkxBQ0s7XHJcbk5JTC5wYXJlbnQgPSBOSUw7XHJcbk5JTC5sZWZ0ID0gTklMO1xyXG5OSUwucmlnaHQgPSBOSUw7XHJcblxyXG4gIFxyXG5jbGFzcyBJbnRlcnZhbFRyZWV7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgICAgXHJcbiAgICAgICAgdGhpcy5yb290ID0gTklMO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpbnNlcnQoc3RhcnQsIGVuZCwgdmFsdWUpIHtcclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsID0gbmV3IEludGVydmFsKHN0YXJ0LCBlbmQsIHZhbHVlKTtcclxuICAgICAgICB2YXIgeCA9IG5ldyBOb2RlKGludGVydmFsKTtcclxuICAgICAgICB0aGlzLnRyZWVJbnNlcnQoeCk7XHJcbiAgICAgICAgeC5jb2xvciA9IFJFRDtcclxuICAgICAgICB3aGlsZSAoeCAhPSB0aGlzLnJvb3QgJiYgeC5wYXJlbnQuY29sb3IgPT0gUkVEKSB7XHJcbiAgICAgICAgICAgIGlmICh4LnBhcmVudCA9PSB4LnBhcmVudC5wYXJlbnQubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB4LnBhcmVudC5wYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeS5jb2xvciA9PSBSRUQpIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHkuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0geC5wYXJlbnQucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnRSb3RhdGUoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHRSb3RhdGUoeC5wYXJlbnQucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0geC5wYXJlbnQucGFyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeS5jb2xvciA9PSBSRUQpIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5jb2xvciA9IEJMQUNLO1xyXG4gICAgICAgICAgICAgICAgICAgIHkuY29sb3IgPSBCTEFDSztcclxuICAgICAgICAgICAgICAgICAgICB4LnBhcmVudC5wYXJlbnQuY29sb3IgPSBSRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHgucGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0geC5wYXJlbnQubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0geC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHRSb3RhdGUoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHgucGFyZW50LmNvbG9yID0gQkxBQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wYXJlbnQucGFyZW50LmNvbG9yID0gUkVEO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFJvdGF0ZSh4LnBhcmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucm9vdC5jb2xvciA9IEJMQUNLO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgLSBxdWVyeSBpbnRlcnZhbFxyXG4gICAgICogQHBhcmFtIGVuZCAtIHF1ZXJ5IGludGVydmFsXHJcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBhbGwgaW50ZXJ2YWxzIG92ZXJsYXBwaW5nIHRoZSBxdWVyeSByZWdpb25cclxuICAgICAqL1xyXG4gICAgZmluZE92ZXJsYXBwaW5nKHN0YXJ0LCBlbmQpIHtcclxuXHJcblxyXG4gICAgICAgIHZhciBzZWFyY2hJbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydCwgZW5kLCAwKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gTklMKSByZXR1cm4gW107XHJcblxyXG4gICAgICAgIHZhciBpbnRlcnZhbHMgPSB0aGlzLnNlYXJjaEFsbChzZWFyY2hJbnRlcnZhbCwgdGhpcy5yb290LCBbXSk7XHJcblxyXG4gICAgICAgIGlmKGludGVydmFscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGludGVydmFscy5zb3J0KGZ1bmN0aW9uKGkxLCBpMikge1xyXG4gICAgICAgICAgICAgICAgIHJldHVybiBpMS5sb3cgLSBpMi5sb3c7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGludGVydmFscztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIER1bXAgaW5mbyBvbiBpbnRlcnZhbHMgdG8gY29uc29sZS4gIEZvciBkZWJ1Z2dpbmcuXHJcbiAgICAgKi9cclxuICAgIGxvZ0ludGVydmFscygpIHtcclxuXHJcbiAgICAgICAgbG9nTm9kZSh0aGlzLnJvb3QsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBsb2dOb2RlKG5vZGUsIGluZGVudCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHNwYWNlID0gXCJcIjtcclxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8aW5kZW50OyBpKyspIHNwYWNlICs9IFwiIFwiO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzcGFjZSArIG5vZGUuaW50ZXJ2YWwubG93ICsgXCIgXCIgKyBub2RlLmludGVydmFsLmhpZ2gpOyAvLyArIFwiIFwiICsgKG5vZGUuaW50ZXJ2YWwudmFsdWUgPyBub2RlLmludGVydmFsLnZhbHVlIDogXCIgbnVsbFwiKSk7XHJcblxyXG4gICAgICAgICAgICBpbmRlbnQgKz0gNTtcclxuXHJcbiAgICAgICAgICAgIGlmKG5vZGUubGVmdCAhPSBOSUwpIGxvZ05vZGUobm9kZS5sZWZ0LCBpbmRlbnQpO1xyXG4gICAgICAgICAgICBpZihub2RlLnJpZ2h0ICE9IE5JTCkgbG9nTm9kZShub2RlLnJpZ2h0LCBpbmRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIG1hcEludGVydmFscyhmdW5jKSB7XHJcblxyXG4gICAgICAgIGFwcGx5SW50ZXJ2YWwodGhpcy5yb290KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYXBwbHlJbnRlcnZhbChub2RlKSB7XHJcblxyXG4gICAgICAgICAgICBmdW5jKG5vZGUuaW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAgICAgaWYobm9kZS5sZWZ0ICE9IE5JTCkgYXBwbHlJbnRlcnZhbChub2RlLmxlZnQpO1xyXG4gICAgICAgICAgICBpZihub2RlLnJpZ2h0ICE9IE5JTCkgYXBwbHlJbnRlcnZhbChub2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2VhcmNoQWxsKGludGVydmFsLCBub2RlLCByZXN1bHRzKSB7XHJcblxyXG4gICAgICAgIGlmIChub2RlLmludGVydmFsLm92ZXJsYXBzKGludGVydmFsKSkge1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobm9kZS5pbnRlcnZhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobm9kZS5sZWZ0ICE9IE5JTCAmJiBub2RlLmxlZnQubWF4ID49IGludGVydmFsLmxvdykge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEFsbChpbnRlcnZhbCwgbm9kZS5sZWZ0LCByZXN1bHRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlLnJpZ2h0ICE9IE5JTCAmJiBub2RlLnJpZ2h0Lm1pbiA8PSBpbnRlcnZhbC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoQWxsKGludGVydmFsLCBub2RlLnJpZ2h0LCByZXN1bHRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIGxlZnRSb3RhdGUoeCkge1xyXG4gICAgICAgIHZhciB5ID0geC5yaWdodDtcclxuICAgICAgICB4LnJpZ2h0ID0geS5sZWZ0O1xyXG4gICAgICAgIGlmICh5LmxlZnQgIT0gTklMKSB7XHJcbiAgICAgICAgICAgIHkubGVmdC5wYXJlbnQgPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB5LnBhcmVudCA9IHgucGFyZW50O1xyXG4gICAgICAgIGlmICh4LnBhcmVudCA9PSBOSUwpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0geTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoeC5wYXJlbnQubGVmdCA9PSB4KSB7XHJcbiAgICAgICAgICAgICAgICB4LnBhcmVudC5sZWZ0ID0geTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHgucGFyZW50LnJpZ2h0ID0geTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB5LmxlZnQgPSB4O1xyXG4gICAgICAgIHgucGFyZW50ID0geTtcclxuXHJcbiAgICAgICAgdGhpcy5hcHBseVVwZGF0ZSh4KTtcclxuICAgICAgICAvLyBubyBuZWVkIHRvIGFwcGx5IHVwZGF0ZSBvbiB5LCBzaW5jZSBpdCdsbCB5IGlzIGFuIGFuY2VzdG9yXHJcbiAgICAgICAgLy8gb2YgeCwgYW5kIHdpbGwgYmUgdG91Y2hlZCBieSBhcHBseVVwZGF0ZSgpLlxyXG4gICAgfVxyXG5cclxuXHJcbiAgICByaWdodFJvdGF0ZSh4KSB7XHJcbiAgICAgICAgdmFyIHkgPSB4LmxlZnQ7XHJcbiAgICAgICAgeC5sZWZ0ID0geS5yaWdodDtcclxuICAgICAgICBpZiAoeS5yaWdodCAhPSBOSUwpIHtcclxuICAgICAgICAgICAgeS5yaWdodC5wYXJlbnQgPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB5LnBhcmVudCA9IHgucGFyZW50O1xyXG4gICAgICAgIGlmICh4LnBhcmVudCA9PSBOSUwpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0geTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoeC5wYXJlbnQucmlnaHQgPT0geCkge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJlbnQucmlnaHQgPSB5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeC5wYXJlbnQubGVmdCA9IHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeS5yaWdodCA9IHg7XHJcbiAgICAgICAgeC5wYXJlbnQgPSB5O1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5hcHBseVVwZGF0ZSh4KTtcclxuICAgICAgICAvLyBubyBuZWVkIHRvIGFwcGx5IHVwZGF0ZSBvbiB5LCBzaW5jZSBpdCdsbCB5IGlzIGFuIGFuY2VzdG9yXHJcbiAgICAgICAgLy8gb2YgeCwgYW5kIHdpbGwgYmUgdG91Y2hlZCBieSBhcHBseVVwZGF0ZSgpLlxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIE5vdGU6ICBEb2VzIG5vdCBtYWludGFpbiBSQiBjb25zdHJhaW50cywgIHRoaXMgaXMgZG9uZSBwb3N0IGluc2VydFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4ICBhIE5vZGVcclxuICAgICAqL1xyXG4gICB0cmVlSW5zZXJ0KHgpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdDtcclxuICAgICAgICB2YXIgeSA9IE5JTDtcclxuICAgICAgICB3aGlsZSAobm9kZSAhPSBOSUwpIHtcclxuICAgICAgICAgICAgeSA9IG5vZGU7XHJcbiAgICAgICAgICAgIGlmICh4LmludGVydmFsLmxvdyA8PSBub2RlLmludGVydmFsLmxvdykge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHgucGFyZW50ID0geTtcclxuXHJcbiAgICAgICAgaWYgKHkgPT0gTklMKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHg7XHJcbiAgICAgICAgICAgIHgubGVmdCA9IHgucmlnaHQgPSBOSUw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHguaW50ZXJ2YWwubG93IDw9IHkuaW50ZXJ2YWwubG93KSB7XHJcbiAgICAgICAgICAgICAgICB5LmxlZnQgPSB4O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeS5yaWdodCA9IHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYXBwbHlVcGRhdGUoeCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEFwcGxpZXMgdGhlIHN0YXRpc3RpYyB1cGRhdGUgb24gdGhlIG5vZGUgYW5kIGl0cyBhbmNlc3RvcnMuXHJcbiAgICBhcHBseVVwZGF0ZSAobm9kZSkge1xyXG4gICAgICAgIHdoaWxlIChub2RlICE9IE5JTCkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZU1heCA9IG5vZGUubGVmdC5tYXggPiBub2RlLnJpZ2h0Lm1heCA/IG5vZGUubGVmdC5tYXggOiBub2RlLnJpZ2h0Lm1heDtcclxuICAgICAgICAgICAgdmFyIGludGVydmFsSGlnaCA9IG5vZGUuaW50ZXJ2YWwuaGlnaDtcclxuICAgICAgICAgICAgbm9kZS5tYXggPSBub2RlTWF4ID4gaW50ZXJ2YWxIaWdoID8gbm9kZU1heCA6IGludGVydmFsSGlnaDtcclxuXHJcbiAgICAgICAgICAgIHZhciBub2RlTWluID0gbm9kZS5sZWZ0Lm1pbiA8IG5vZGUucmlnaHQubWluID8gbm9kZS5sZWZ0Lm1pbiA6IG5vZGUucmlnaHQubWluO1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWxMb3cgPSBub2RlLmludGVydmFsLmxvdztcclxuICAgICAgICAgICAgbm9kZS5taW4gPSBub2RlTWluIDwgaW50ZXJ2YWxMb3cgPyBub2RlTWluIDogaW50ZXJ2YWxMb3c7XHJcblxyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbmNsYXNzIEludGVydmFsIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvdywgaGlnaCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmxvdyA9IGxvdztcclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzID09IG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMubG93ID09IG90aGVySW50ZXJ2YWwubG93ICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PSBvdGhlckludGVydmFsLmhpZ2gpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG93IDwgb3RoZXIubG93KVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgaWYgKHRoaXMubG93ID4gb3RoZXIubG93KVxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGlnaCA8IG90aGVyLmhpZ2gpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAodGhpcy5oaWdoID4gb3RoZXIuaGlnaClcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcblxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgaW50ZXJ2YWwgb3ZlcmxhcHMgdGhlIG90aGVyLlxyXG4gICAgICovXHJcbiAgICBvdmVybGFwcyhvdGhlcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5sb3cgPD0gb3RoZXIuaGlnaCAmJiBvdGhlci5sb3cgPD0gdGhpcy5oaWdoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vYWxlcnQoZSk7XHJcbiAgICAgICAgICAgIGlndi5wcmVzZW50QWxlcnQoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5jbGFzcyBOb2Rle1xyXG4gICAgY29uc3RydWN0b3IoaW50ZXJ2YWwpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IE5JTDtcclxuICAgICAgICB0aGlzLmxlZnQgPSBOSUw7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IE5JTDtcclxuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IFJFRDtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgR2Vub21pY0ludGVydmFse1xyXG5cclxuXHRjb25zdHJ1Y3RvcihjaHIsIHN0YXJ0LCBlbmQsIGZlYXR1cmVzKSB7XHJcbiAgICAgICAgdGhpcy5jaHIgPSBjaHI7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xyXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcclxuICAgIH1cclxuXHJcbiAgICBjb250YWlucyAoY2hyLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hyID09IGNociAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0IDw9IHN0YXJ0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuZW5kID49IGVuZDtcclxuICAgIH1cclxuXHJcbiAgICBjb250YWluc1JhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hyID09PSByYW5nZS5jaHIgJiZcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA8PSByYW5nZS5zdGFydCAmJlxyXG4gICAgICAgICAgICB0aGlzLmVuZCA+PSByYW5nZS5lbmQ7XHJcbiAgICB9XHJcbiAgICByYW5nZXNUb0dldChyYW5nZSl7XHJcbiAgICAgICAgbGV0IG5lZWRzX3JhbmdlPWZhbHNlO1xyXG4gICAgICAgIGxldCByYW5nZXM9e307XHJcbiAgICAgICAgaWYgKHRoaXMuY2hyICE9PSByYW5nZS5jaHIpe1xyXG4gICAgICAgICAgICByYW5nZXMuYWxsPVtyYW5nZS5zdGFydCxyYW5nZS5lbmRdO1xyXG4gICAgICAgICAgICBuZWVkc19yYW5nZT10cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0PXJhbmdlLnN0YXJ0O1xyXG4gICAgICAgICAgICB0aGlzLmVuZD1yYW5nZS5lbmQ7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNleyAgIFxyXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQ8dGhpcy5zdGFydCl7XHJcbiAgICAgICAgICAgICAgICByYW5nZXMubGVmdD1bcmFuZ2Uuc3RhcnQsdGhpcy5zdGFydF07XHJcbiAgICAgICAgICAgICAgICBuZWVkc19yYW5nZT10cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydD1yYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kPnRoaXMuZW5kKXtcclxuICAgICAgICAgICAgICAgIHJhbmdlcy5yaWdodD1bdGhpcy5lbmQscmFuZ2UuZW5kXTtcclxuICAgICAgICAgICAgICAgIG5lZWRzX3JhbmdlPXRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuZD1yYW5nZS5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZWVkc19yYW5nZSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5jbGFzcyBGYXN0YVNlcXVlbmNle1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG5cclxuICAgICAgICB0aGlzLmZpbGUgPSB1cmw7XHJcbiAgICAgICAgdGhpcy5pbmRleGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pbmRleGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhGaWxlID0gdGhpcy5maWxlICsgXCIuZmFpXCI7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgaW5pdCgpe1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGlmIChzZWxmLmluZGV4ZWQpIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5nZXRJbmRleCgpLnRoZW4oZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yZGVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnBMZW5ndGggPSBzZWxmLmluZGV4W2Nock5hbWVdLnNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXNbY2hyTmFtZV0gPSBuZXcgaWd2LkNocm9tb3NvbWUoY2hyTmFtZSwgb3JkZXIrKywgYnBMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGluZGV4LCBnZXR0aW5nIGNociBuYW1lcyBhcyBhIHNpZGUgZWZmZWN0LiAgUmVhbGx5IGJhZCBwcmFjdGljZVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9hZEFsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U2VxdWVuY2UoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmluZGV4ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VxdWVuY2VJbmRleGVkKGNociwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0U2VxdWVuY2VOb25JbmRleGVkLnRoaXMoY2hyLCBzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXRTZXF1ZW5jZUluZGV4ZWQoY2hyLCBzdGFydCwgZW5kKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2VsZi5pbnRlcnZhbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbnRlcnZhbCAmJiBpbnRlcnZhbC5jb250YWlucyhjaHIsIHN0YXJ0LCBlbmQpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVsZmlsbChnZXRTZXF1ZW5jZUZyb21JbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDYWNoZSBtaXNzOiBcIiArIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkID8gXCJuaWxcIiA6IGludGVydmFsLmNociArIFwiOlwiICsgaW50ZXJ2YWwuc3RhcnQgKyBcIi1cIiArIGludGVydmFsLmVuZCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBxdWVyeSwgdG8gbWluaW11bSBvZiAxMDBrYlxyXG4gICAgICAgICAgICAgICAgdmFyIHFzdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHFlbmQgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGVuZCAtIHN0YXJ0KSA8IDEwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKGVuZCAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gTWF0aC5yb3VuZChzdGFydCArIHcgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBxc3RhcnQgPSBNYXRoLm1heCgwLCBjZW50ZXIgLSA1MDAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcWVuZCA9IGNlbnRlciArIDUwMDAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLnJlYWRTZXF1ZW5jZShjaHIsIHFzdGFydCwgcWVuZCkudGhlbihmdW5jdGlvbiAoc2VxQnl0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmludGVydmFsID0gbmV3IEdlbm9taWNJbnRlcnZhbChjaHIsIHFzdGFydCwgcWVuZCwgc2VxQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bGZpbGwoZ2V0U2VxdWVuY2VGcm9tSW50ZXJ2YWwoc2VsZi5pbnRlcnZhbCwgc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VxdWVuY2VGcm9tSW50ZXJ2YWwoaW50ZXJ2YWwsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCAtIGludGVydmFsLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBlbmQgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBzZXEgPSBpbnRlcnZhbC5mZWF0dXJlcyA/IGludGVydmFsLmZlYXR1cmVzLnN1YnN0cihvZmZzZXQsIG4pIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0U2VxdWVuY2VOb25JbmRleGVkKGNociwgc3RhcnQsIGVuZCkge1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZXEgPSBzZWxmLnNlcXVlbmNlc1tjaHJdO1xyXG4gICAgICAgICAgICBpZiAoc2VxICYmIHNlcS5sZW5ndGggPiBlbmQpIHtcclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwoc2VxLnN1YnN0cmluZyhzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW5kZXgoKSB7XHJcblxyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKHNlbGYuaW5kZXgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWd2eGhyLmxvYWQoc2VsZi5pbmRleEZpbGUse30pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBkYXRhLnNwbGl0KFwiXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVObyA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzID0gW107ICAgICAvLyBUT0RPIC0tIGVsaW1pbmF0ZSB0aGlzIHNpZGUgZWZmZWN0ICEhISFcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmluZGV4ID0ge307ICAgICAgICAgICAgICAgLy8gVE9ETyAtLSBkaXR0b1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lTm8gPCBsZW4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lc1tsaW5lTm8rK10uc3BsaXQoXCJcXHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuVG9rZW5zID0gdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5Ub2tlbnMgPT0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGluZGV4IGxpbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hyID0gdG9rZW5zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludCh0b2tlbnNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcGFyc2VJbnQodG9rZW5zWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlc1BlckxpbmUgPSBwYXJzZUludCh0b2tlbnNbM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ5dGVzUGVyTGluZSA9IHBhcnNlSW50KHRva2Vuc1s0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4RW50cnkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSwgcG9zaXRpb246IHBvc2l0aW9uLCBiYXNlc1BlckxpbmU6IGJhc2VzUGVyTGluZSwgYnl0ZXNQZXJMaW5lOiBieXRlc1BlckxpbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lTmFtZXMucHVzaChjaHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleFtjaHJdID0gaW5kZXhFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChzZWxmLmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEFsbCgpe1xyXG5cclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZU5hbWVzID0gW107XHJcbiAgICAgICAgICAgIHNlbGYuY2hyb21vc29tZXMgPSB7fTtcclxuICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGlndnhoci5sb2FkKHNlbGYuZmlsZSwge1xyXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBzZWxmLndpdGhDcmVkZW50aWFsc1xyXG5cclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGRhdGEuc3BsaXRMaW5lcygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lTm8gPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRMaW5lLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXEgPSBcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSAwO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobGluZU5vIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBsaW5lc1tsaW5lTm8rK10udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5zdGFydHNXaXRoKFwiI1wiKSB8fCBuZXh0TGluZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHRMaW5lLnN0YXJ0c1dpdGgoXCI+XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNocm9tb3NvbWVOYW1lcy5wdXNoKGN1cnJlbnRDaHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZXNbY3VycmVudENocl0gPSBjdXJyZW50U2VxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaHJvbW9zb21lc1tjdXJyZW50Q2hyXSA9IG5ldyBpZ3YuQ2hyb21vc29tZShjdXJyZW50Q2hyLCBvcmRlcisrLCBjdXJyZW50U2VxLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENociA9IG5leHRMaW5lLnN1YnN0cigxKS5zcGxpdChcIlxcXFxzK1wiKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlcSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2VxICs9IG5leHRMaW5lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKCk7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZWFkU2VxdWVuY2UoY2hyLCBxc3RhcnQsIHFlbmQpIHtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlYWQgc2VxdWVuY2UgXCIgKyBjaHIgKyBcIjpcIiArIHFzdGFydCArIFwiLVwiICsgcWVuZCk7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBzZWxmLmdldEluZGV4KCkudGhlbihmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlkeEVudHJ5ID0gc2VsZi5pbmRleFtjaHJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpZHhFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gaW5kZXggZW50cnkgZm9yIGNocjogXCIgKyBjaHIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUYWcgaW50ZXJ2YWwgd2l0aCBudWxsIHNvIHdlIGRvbid0IHRyeSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW50ZXJ2YWwgPSBuZXcgR2Vub21pY0ludGVydmFsKGNociwgcXN0YXJ0LCBxZW5kLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KDAsIHFzdGFydCk7ICAgIC8vIHFzdGFydCBzaG91bGQgbmV2ZXIgYmUgPCAwXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGlkeEVudHJ5LnNpemUsIHFlbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlc1BlckxpbmUgPSBpZHhFbnRyeS5ieXRlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VzUGVyTGluZSA9IGlkeEVudHJ5LmJhc2VzUGVyTGluZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBpZHhFbnRyeS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbkVuZEJ5dGVzID0gYnl0ZXNQZXJMaW5lIC0gYmFzZXNQZXJMaW5lO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lID0gTWF0aC5mbG9vcihzdGFydCAvIGJhc2VzUGVyTGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZExpbmUgPSBNYXRoLmZsb29yKGVuZCAvIGJhc2VzUGVyTGluZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlMCA9IHN0YXJ0TGluZSAqIGJhc2VzUGVyTGluZTsgICAvLyBCYXNlIGF0IGJlZ2lubmluZyBvZiBzdGFydCBsaW5lXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCAtIGJhc2UwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRCeXRlID0gcG9zaXRpb24gKyBzdGFydExpbmUgKiBieXRlc1BlckxpbmUgKyBvZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlMSA9IGVuZExpbmUgKiBiYXNlc1BlckxpbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldDEgPSBlbmQgLSBiYXNlMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQnl0ZSA9IHBvc2l0aW9uICsgZW5kTGluZSAqIGJ5dGVzUGVyTGluZSArIG9mZnNldDEgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlQ291bnQgPSBlbmRCeXRlIC0gc3RhcnRCeXRlICsgMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZUNvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHNlbGYuZmlsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZToge3N0YXJ0OiBzdGFydEJ5dGUsIHNpemU6IGJ5dGVDb3VudH1cclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChhbGxCeXRlcykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5CYXNlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUJ5dGVzID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BvcyA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNQb3MgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsQnl0ZXNMZW5ndGggPSBhbGxCeXRlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbkJhc2VzID0gTWF0aC5taW4oZW5kIC0gc3RhcnQsIGJhc2VzUGVyTGluZSAtIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXFCeXRlcyArPSBhbGxCeXRlcy5zdWJzdHIoc3JjUG9zLCBuQmFzZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUG9zICs9IChuQmFzZXMgKyBuRW5kQnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzUG9zICs9IG5CYXNlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNyY1BvcyA8IGFsbEJ5dGVzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuQmFzZXMgPSBNYXRoLm1pbihiYXNlc1BlckxpbmUsIGFsbEJ5dGVzTGVuZ3RoIC0gc3JjUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUJ5dGVzICs9IGFsbEJ5dGVzLnN1YnN0cihzcmNQb3MsIG5CYXNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQb3MgKz0gKG5CYXNlcyArIG5FbmRCeXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNQb3MgKz0gbkJhc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHNlcUJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCB7RmVhdHVyZVNvdXJjZSxGYXN0YVNlcXVlbmNlLEJpZ0JlZEZlYXR1cmVTb3VyY2UsVGFiaXhCZWRGZWF0dXJlU291cmNlfSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/feature.js\n");

/***/ }),

/***/ "./src/igvxhr.js":
/*!***********************!*\
  !*** ./src/igvxhr.js ***!
  \***********************/
/*! exports provided: igvxhr, unbgzf */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Zlib, XMLHttpRequest) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"igvxhr\", function() { return igvxhr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unbgzf\", function() { return unbgzf; });\n/* harmony import */ var _vendor_inflate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/inflate.js */ \"./src/vendor/inflate.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\nlet is_node=false;\r\ntry{\r\n    navigator;\r\n}catch(e){\r\n    is_node=true;\r\n}\r\n\r\nif (!Zlib.Zlib){\r\n\tZlib.Zlib=Zlib;\r\n}\r\n\r\nconst NONE = 0;\r\nconst GZIP = 1;\r\nconst BGZF = 2;\r\nclass igvxhr {\r\n   \r\n    // Compression types\r\n   \r\n\r\n    static load(url, options) {\r\n\r\n       \r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            var xhr = new XMLHttpRequest(),\r\n                sendData = options.sendData,\r\n                method = options.method || (sendData ? \"POST\" : \"GET\"),\r\n                range = options.range,\r\n                responseType = options.responseType,\r\n                contentType = options.contentType,\r\n                mimeType = options.mimeType,\r\n                headers = options.headers,\r\n                isSafari = is_node?false:navigator.vendor.indexOf(\"Apple\") == 0 && /\\sSafari\\//.test(navigator.userAgent),\r\n                withCredentials = options.withCredentials,\r\n                header_keys, key, value, i;\r\n\r\n            // Support for GCS paths.\r\n           //url = url.startsWith(\"gs://\") ? igv.Google.translateGoogleCloudURL(url) : url;\r\n        \r\n\r\n           /* if (igv.Google.isGoogleURL(url)) {\r\n\r\n                url = igv.Google.addApiKey(url);\r\n\r\n                // Add google headers (e.g. oAuth)\r\n                headers = headers || {};\r\n                igv.Google.addGoogleHeaders(headers);\r\n\r\n                // Hack to prevent caching for google storage files.  Get weird net:err-cache errors otherwise\r\n                if (range) {\r\n                    url += url.includes(\"?\") ? \"&\" : \"?\";\r\n                    url += \"someRandomSeed=\" + Math.random().toString(36);\r\n                }\r\n            }\r\n            */\r\n    \r\n\r\n            xhr.open(method, url);\r\n\r\n            if (range) {\r\n                var rangeEnd = range.size ? range.start + range.size - 1 : \"\";\r\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + range.start + \"-\" + rangeEnd);\r\n            }\r\n            if (contentType) {\r\n                xhr.setRequestHeader(\"Content-Type\", contentType);\r\n            }\r\n            if (mimeType) {\r\n                xhr.overrideMimeType(mimeType);\r\n            }\r\n            if (responseType) {\r\n                xhr.responseType = responseType;\r\n            }\r\n            if (headers) {\r\n                header_keys = Object.keys(headers);\r\n                for (i = 0; i < header_keys.length; i++) {\r\n                    key = header_keys[i];\r\n                    value = headers[key];\r\n                    // console.log(\"Adding to header: \" + key + \"=\" + value);\r\n                    xhr.setRequestHeader(key, value);\r\n                }\r\n            }\r\n\r\n            // NOTE: using withCredentials with servers that return \"*\" for access-allowed-origin will fail\r\n            if (withCredentials === true) {\r\n                xhr.withCredentials = true;\r\n            }\r\n            xhr.timeout=30000;\r\n\r\n            xhr.onload = function (event) {\r\n                // when the url points to a local file, the status is 0 but that is no error\r\n                if (xhr.status == 0 || (xhr.status >= 200 && xhr.status <= 300)) {\r\n\r\n                    if (range && xhr.status != 206) {\r\n                        handleError(\"ERROR: range-byte header was ignored for url: \" + url);\r\n                    }\r\n                    else {\r\n                      \r\n                        fulfill(xhr.response,xhr);\r\n                     \r\n                    }\r\n                }\r\n                else {\r\n\r\n                    //\r\n                    if (xhr.status === 416) {\r\n                        //  Tried to read off the end of the file.   This shouldn't happen, but if it does return an\r\n                        handleError(\"Unsatisfiable range\");\r\n                    }\r\n                    else {// TODO -- better error handling\r\n                        handleError(\"Error accessing resource: \" + xhr.status);\r\n                    }\r\n\r\n                }\r\n\r\n            };\r\n\r\n            xhr.onerror = function (event) {\r\n               handleError(\"Error accessing resource: \" + url + \" Status: \" + xhr.status);    \r\n            }\r\n\r\n\r\n            xhr.ontimeout = function (event) {\r\n                handleError(\"Timed out\");\r\n            };\r\n\r\n            xhr.onabort = function (event) {\r\n                console.log(\"Aborted\");\r\n                reject(new igv.AbortLoad());\r\n            };\r\n\r\n            try {\r\n               \r\n                xhr.send(sendData);\r\n                \r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n\r\n\r\n            function handleError(message) {\r\n                if (reject) {\r\n                    reject(message);\r\n                }\r\n                else {\r\n                    throw Error(message);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    static loadArrayBuffer (url, options) {\r\n\r\n        if (options === undefined) options = {};\r\n        options.responseType = \"arraybuffer\";\r\n        return igvxhr.load(url, options);\r\n    };\r\n\r\n    static loadJson (url, options) {\r\n\r\n        var method = options.method || (options.sendData ? \"POST\" : \"GET\");\r\n\r\n        if (method == \"POST\") options.contentType = \"application/json\";\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            igvxhr.load(url, options).then(\r\n                function (result) {\r\n                    if (result) {\r\n                        fulfill(JSON.parse(result));\r\n                    }\r\n                    else {\r\n                        fulfill(result);\r\n                    }\r\n                }).catch(reject);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Load a \"raw\" string.\r\n     */\r\n    static loadString(url, options) {\r\n\r\n        var compression, fn, idx;\r\n\r\n        if (options === undefined) options = {};\r\n\r\n        // Strip parameters from url\r\n        // TODO -- handle local files with ?\r\n        idx = url.indexOf(\"?\");\r\n        fn = idx > 0 ? url.substring(0, idx) : url;\r\n\r\n        if (options.bgz) {\r\n            compression = BGZF;\r\n        }\r\n        else if (fn.endsWith(\".gz\")) {\r\n            compression = GZIP;\r\n        }\r\n        else {\r\n            compression = NONE;\r\n        }\r\n\r\n        if (compression === NONE) {\r\n            options.mimeType = 'text/plain; charset=x-user-defined';\r\n            return igvxhr.load(url, options);\r\n        }\r\n        else {\r\n            options.responseType = \"arraybuffer\";\r\n\r\n            return new Promise(function (fulfill, reject) {\r\n\r\n                igvxhr.load(url, options).then(\r\n                    function (data) {\r\n                        var result = igvxhr.arrayBufferToString(data, compression);\r\n                        fulfill(result);\r\n                    }).catch(reject)\r\n            })\r\n        }\r\n\r\n    };\r\n\r\n    static loadStringFromFile(localfile, options) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n\r\n            var fileReader = new FileReader(),\r\n                range = options.range;\r\n\r\n\r\n            fileReader.onload = function (e) {\r\n\r\n                var compression, result;\r\n\r\n                if (options.bgz) {\r\n                    compression = BGZF;\r\n                }\r\n                else if (localfile.name.endsWith(\".gz\")) {\r\n\r\n                    compression = GZIP;\r\n                }\r\n                else {\r\n                    compression = NONE;\r\n                }\r\n\r\n                result = igvxhr.arrayBufferToString(fileReader.result, compression);\r\n\r\n                fulfill(result, localfile);\r\n\r\n            };\r\n\r\n            fileReader.onerror = function (e) {\r\n                console.log(\"reject uploading local file \" + localfile.name);\r\n                reject(null, fileReader);\r\n            };\r\n\r\n            fileReader.readAsArrayBuffer(localfile);\r\n\r\n        });\r\n    }\r\n\r\n    static isCrossDomain(url) {\r\n\r\n        var origin = window.location.origin;\r\n\r\n        return !url.startsWith(origin);\r\n\r\n    }\r\n\r\n    static arrayBufferToString (arraybuffer, compression) {\r\n\r\n        var plain, inflate;\r\n\r\n        if (compression === GZIP) {\r\n            inflate = new Zlib.Zlib.Gunzip(new Uint8Array(arraybuffer));\r\n            plain = inflate.decompress();\r\n        }\r\n        else if (compression === BGZF) {\r\n            plain = new Uint8Array(unbgzf(arraybuffer));\r\n        }\r\n        else {\r\n            plain = new Uint8Array(arraybuffer);\r\n        }\r\n\r\n        var result = \"\";\r\n        for (var i = 0, len = plain.length; i < len; i++) {\r\n            result = result + String.fromCharCode(plain[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\n\r\n//**********js/bam/bgzf.js***************************************\r\n\r\n\r\nconst BLOCK_HEADER_LENGTH = 18;\r\nconst BLOCK_LENGTH_OFFSET = 16;  // Location in the gzip block of the total block size (actually total block size - 1)\r\nconst BLOCK_FOOTER_LENGTH = 8; // Number of bytes that follow the deflated data\r\nconst MAX_COMPRESSED_BLOCK_SIZE = 64 * 1024; // We require that a compressed block (including header and footer, be <= this)\r\nconst GZIP_OVERHEAD = BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 2; // Gzip overhead is the header, the footer, and the block size (encoded as a short).\r\nconst GZIP_ID1 = 31;   // Magic number\r\nconst GZIP_ID2 = 139;  // Magic number\r\nconst GZIP_FLG = 4; // FEXTRA flag means there are optional fields\r\n\r\n\r\n    // Uncompress data,  assumed to be series of bgzipped blocks\r\n    // Code is based heavily on bam.js, part of the Dalliance Genome Explorer,  (c) Thomas Down 2006-2001.\r\nlet unbgzf = function (data, lim) {\r\n\r\n        var oBlockList = [],\r\n            ptr = [0],\r\n            totalSize = 0;\r\n\r\n        lim = lim || data.byteLength - 18;\r\n\r\n        while (ptr[0] < lim) {\r\n\r\n            var ba = new Uint8Array(data, ptr[0], 18);\r\n\r\n            var xlen = (ba[11] << 8) | (ba[10]);\r\n            var si1 = ba[12];\r\n            var si2 = ba[13];\r\n            var slen = (ba[15] << 8) | (ba[14]);\r\n            var bsize = (ba[17] << 8) | (ba[16]) + 1;\r\n\r\n            var start = 12 + xlen + ptr[0];    // Start of CDATA\r\n            var length = data.byteLength - start;\r\n\r\n            if (length < (bsize + 8)) break;\r\n\r\n            var unc = Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_0__[\"jszlib_inflate_buffer\"])(data, start, length, ptr);\r\n\r\n            ptr[0] += 8;    // Skipping CRC-32 and size of uncompressed data\r\n\r\n            totalSize += unc.byteLength;\r\n            oBlockList.push(unc);\r\n        }\r\n\r\n        // Concatenate decompressed blocks\r\n        if (oBlockList.length == 1) {\r\n            return oBlockList[0];\r\n        } else {\r\n            var out = new Uint8Array(totalSize);\r\n            var cursor = 0;\r\n            for (var i = 0; i < oBlockList.length; ++i) {\r\n                var b = new Uint8Array(oBlockList[i]);\r\n                Object(_vendor_inflate_js__WEBPACK_IMPORTED_MODULE_0__[\"arrayCopy\"])(b, 0, out, cursor, b.length);\r\n                cursor += b.length;\r\n            }\r\n            return out.buffer;\r\n        }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./src/vendor/zlib_and_gzip.min.js */ \"./src/vendor/zlib_and_gzip.min.js\"), __webpack_require__(/*! xhr2 */ \"xhr2\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaWd2eGhyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2lndnhoci5qcz8wZjQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuaW1wb3J0IHtqc3psaWJfaW5mbGF0ZV9idWZmZXIsYXJyYXlDb3B5fSBmcm9tIFwiLi92ZW5kb3IvaW5mbGF0ZS5qc1wiO1xyXG5cclxuXHJcbmxldCBpc19ub2RlPWZhbHNlO1xyXG50cnl7XHJcbiAgICBuYXZpZ2F0b3I7XHJcbn1jYXRjaChlKXtcclxuICAgIGlzX25vZGU9dHJ1ZTtcclxufVxyXG5cclxuaWYgKCFabGliLlpsaWIpe1xyXG5cdFpsaWIuWmxpYj1abGliO1xyXG59XHJcblxyXG5jb25zdCBOT05FID0gMDtcclxuY29uc3QgR1pJUCA9IDE7XHJcbmNvbnN0IEJHWkYgPSAyO1xyXG5jbGFzcyBpZ3Z4aHIge1xyXG4gICBcclxuICAgIC8vIENvbXByZXNzaW9uIHR5cGVzXHJcbiAgIFxyXG5cclxuICAgIHN0YXRpYyBsb2FkKHVybCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgIFxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXHJcbiAgICAgICAgICAgICAgICBzZW5kRGF0YSA9IG9wdGlvbnMuc2VuZERhdGEsXHJcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAoc2VuZERhdGEgPyBcIlBPU1RcIiA6IFwiR0VUXCIpLFxyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBvcHRpb25zLnJhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IG9wdGlvbnMubWltZVR5cGUsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgaXNTYWZhcmkgPSBpc19ub2RlP2ZhbHNlOm5hdmlnYXRvci52ZW5kb3IuaW5kZXhPZihcIkFwcGxlXCIpID09IDAgJiYgL1xcc1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxcclxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyX2tleXMsIGtleSwgdmFsdWUsIGk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0IGZvciBHQ1MgcGF0aHMuXHJcbiAgICAgICAgICAgLy91cmwgPSB1cmwuc3RhcnRzV2l0aChcImdzOi8vXCIpID8gaWd2Lkdvb2dsZS50cmFuc2xhdGVHb29nbGVDbG91ZFVSTCh1cmwpIDogdXJsO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICAgICAvKiBpZiAoaWd2Lkdvb2dsZS5pc0dvb2dsZVVSTCh1cmwpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdXJsID0gaWd2Lkdvb2dsZS5hZGRBcGlLZXkodXJsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgZ29vZ2xlIGhlYWRlcnMgKGUuZy4gb0F1dGgpXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGlndi5Hb29nbGUuYWRkR29vZ2xlSGVhZGVycyhoZWFkZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHByZXZlbnQgY2FjaGluZyBmb3IgZ29vZ2xlIHN0b3JhZ2UgZmlsZXMuICBHZXQgd2VpcmQgbmV0OmVyci1jYWNoZSBlcnJvcnMgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gdXJsLmluY2x1ZGVzKFwiP1wiKSA/IFwiJlwiIDogXCI/XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwic29tZVJhbmRvbVNlZWQ9XCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgXHJcblxyXG4gICAgICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciByYW5nZUVuZCA9IHJhbmdlLnNpemUgPyByYW5nZS5zdGFydCArIHJhbmdlLnNpemUgLSAxIDogXCJcIjtcclxuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgXCJieXRlcz1cIiArIHJhbmdlLnN0YXJ0ICsgXCItXCIgKyByYW5nZUVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbWVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyX2tleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoZWFkZXJfa2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGhlYWRlcl9rZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaGVhZGVyc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiQWRkaW5nIHRvIGhlYWRlcjogXCIgKyBrZXkgKyBcIj1cIiArIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTk9URTogdXNpbmcgd2l0aENyZWRlbnRpYWxzIHdpdGggc2VydmVycyB0aGF0IHJldHVybiBcIipcIiBmb3IgYWNjZXNzLWFsbG93ZWQtb3JpZ2luIHdpbGwgZmFpbFxyXG4gICAgICAgICAgICBpZiAod2l0aENyZWRlbnRpYWxzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4aHIudGltZW91dD0zMDAwMDtcclxuXHJcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHVybCBwb2ludHMgdG8gYSBsb2NhbCBmaWxlLCB0aGUgc3RhdHVzIGlzIDAgYnV0IHRoYXQgaXMgbm8gZXJyb3JcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDAgfHwgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPD0gMzAwKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UgJiYgeGhyLnN0YXR1cyAhPSAyMDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFUlJPUjogcmFuZ2UtYnl0ZSBoZWFkZXIgd2FzIGlnbm9yZWQgZm9yIHVybDogXCIgKyB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHhoci5yZXNwb25zZSx4aHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gNDE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBUcmllZCB0byByZWFkIG9mZiB0aGUgZW5kIG9mIHRoZSBmaWxlLiAgIFRoaXMgc2hvdWxkbid0IGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMgcmV0dXJuIGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKFwiVW5zYXRpc2ZpYWJsZSByYW5nZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7Ly8gVE9ETyAtLSBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJFcnJvciBhY2Nlc3NpbmcgcmVzb3VyY2U6IFwiICsgeGhyLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICBoYW5kbGVFcnJvcihcIkVycm9yIGFjY2Vzc2luZyByZXNvdXJjZTogXCIgKyB1cmwgKyBcIiBTdGF0dXM6IFwiICsgeGhyLnN0YXR1cyk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoXCJUaW1lZCBvdXRcIik7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBYm9ydGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBpZ3YuQWJvcnRMb2FkKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChzZW5kRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGxvYWRBcnJheUJ1ZmZlciAodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBvcHRpb25zLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgICAgICByZXR1cm4gaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvYWRKc29uICh1cmwsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IChvcHRpb25zLnNlbmREYXRhID8gXCJQT1NUXCIgOiBcIkdFVFwiKTtcclxuXHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PSBcIlBPU1RcIikgb3B0aW9ucy5jb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgaWd2eGhyLmxvYWQodXJsLCBvcHRpb25zKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChKU09OLnBhcnNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBcInJhd1wiIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxvYWRTdHJpbmcodXJsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBjb21wcmVzc2lvbiwgZm4sIGlkeDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBTdHJpcCBwYXJhbWV0ZXJzIGZyb20gdXJsXHJcbiAgICAgICAgLy8gVE9ETyAtLSBoYW5kbGUgbG9jYWwgZmlsZXMgd2l0aCA/XHJcbiAgICAgICAgaWR4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xyXG4gICAgICAgIGZuID0gaWR4ID4gMCA/IHVybC5zdWJzdHJpbmcoMCwgaWR4KSA6IHVybDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmd6KSB7XHJcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZm4uZW5kc1dpdGgoXCIuZ3pcIikpIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBHWklQO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBOT05FO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBOT05FKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIHJldHVybiBpZ3Z4aHIubG9hZCh1cmwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlndnhoci5sb2FkKHVybCwgb3B0aW9ucykudGhlbihcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaWd2eGhyLmFycmF5QnVmZmVyVG9TdHJpbmcoZGF0YSwgY29tcHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBsb2FkU3RyaW5nRnJvbUZpbGUobG9jYWxmaWxlLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCksXHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IG9wdGlvbnMucmFuZ2U7XHJcblxyXG5cclxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiwgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJneikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gQkdaRjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsZmlsZS5uYW1lLmVuZHNXaXRoKFwiLmd6XCIpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gR1pJUDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uID0gTk9ORTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpZ3Z4aHIuYXJyYXlCdWZmZXJUb1N0cmluZyhmaWxlUmVhZGVyLnJlc3VsdCwgY29tcHJlc3Npb24pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bGZpbGwocmVzdWx0LCBsb2NhbGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlamVjdCB1cGxvYWRpbmcgbG9jYWwgZmlsZSBcIiArIGxvY2FsZmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChudWxsLCBmaWxlUmVhZGVyKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIobG9jYWxmaWxlKTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGlzQ3Jvc3NEb21haW4odXJsKSB7XHJcblxyXG4gICAgICAgIHZhciBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xyXG5cclxuICAgICAgICByZXR1cm4gIXVybC5zdGFydHNXaXRoKG9yaWdpbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBhcnJheUJ1ZmZlclRvU3RyaW5nIChhcnJheWJ1ZmZlciwgY29tcHJlc3Npb24pIHtcclxuXHJcbiAgICAgICAgdmFyIHBsYWluLCBpbmZsYXRlO1xyXG5cclxuICAgICAgICBpZiAoY29tcHJlc3Npb24gPT09IEdaSVApIHtcclxuICAgICAgICAgICAgaW5mbGF0ZSA9IG5ldyBabGliLlpsaWIuR3VuemlwKG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSk7XHJcbiAgICAgICAgICAgIHBsYWluID0gaW5mbGF0ZS5kZWNvbXByZXNzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXByZXNzaW9uID09PSBCR1pGKSB7XHJcbiAgICAgICAgICAgIHBsYWluID0gbmV3IFVpbnQ4QXJyYXkodW5iZ3pmKGFycmF5YnVmZmVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwbGFpbiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwbGFpbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBsYWluW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG4vLyoqKioqKioqKipqcy9iYW0vYmd6Zi5qcyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5cclxuXHJcbmNvbnN0IEJMT0NLX0hFQURFUl9MRU5HVEggPSAxODtcclxuY29uc3QgQkxPQ0tfTEVOR1RIX09GRlNFVCA9IDE2OyAgLy8gTG9jYXRpb24gaW4gdGhlIGd6aXAgYmxvY2sgb2YgdGhlIHRvdGFsIGJsb2NrIHNpemUgKGFjdHVhbGx5IHRvdGFsIGJsb2NrIHNpemUgLSAxKVxyXG5jb25zdCBCTE9DS19GT09URVJfTEVOR1RIID0gODsgLy8gTnVtYmVyIG9mIGJ5dGVzIHRoYXQgZm9sbG93IHRoZSBkZWZsYXRlZCBkYXRhXHJcbmNvbnN0IE1BWF9DT01QUkVTU0VEX0JMT0NLX1NJWkUgPSA2NCAqIDEwMjQ7IC8vIFdlIHJlcXVpcmUgdGhhdCBhIGNvbXByZXNzZWQgYmxvY2sgKGluY2x1ZGluZyBoZWFkZXIgYW5kIGZvb3RlciwgYmUgPD0gdGhpcylcclxuY29uc3QgR1pJUF9PVkVSSEVBRCA9IEJMT0NLX0hFQURFUl9MRU5HVEggKyBCTE9DS19GT09URVJfTEVOR1RIICsgMjsgLy8gR3ppcCBvdmVyaGVhZCBpcyB0aGUgaGVhZGVyLCB0aGUgZm9vdGVyLCBhbmQgdGhlIGJsb2NrIHNpemUgKGVuY29kZWQgYXMgYSBzaG9ydCkuXHJcbmNvbnN0IEdaSVBfSUQxID0gMzE7ICAgLy8gTWFnaWMgbnVtYmVyXHJcbmNvbnN0IEdaSVBfSUQyID0gMTM5OyAgLy8gTWFnaWMgbnVtYmVyXHJcbmNvbnN0IEdaSVBfRkxHID0gNDsgLy8gRkVYVFJBIGZsYWcgbWVhbnMgdGhlcmUgYXJlIG9wdGlvbmFsIGZpZWxkc1xyXG5cclxuXHJcbiAgICAvLyBVbmNvbXByZXNzIGRhdGEsICBhc3N1bWVkIHRvIGJlIHNlcmllcyBvZiBiZ3ppcHBlZCBibG9ja3NcclxuICAgIC8vIENvZGUgaXMgYmFzZWQgaGVhdmlseSBvbiBiYW0uanMsIHBhcnQgb2YgdGhlIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXIsICAoYykgVGhvbWFzIERvd24gMjAwNi0yMDAxLlxyXG5sZXQgdW5iZ3pmID0gZnVuY3Rpb24gKGRhdGEsIGxpbSkge1xyXG5cclxuICAgICAgICB2YXIgb0Jsb2NrTGlzdCA9IFtdLFxyXG4gICAgICAgICAgICBwdHIgPSBbMF0sXHJcbiAgICAgICAgICAgIHRvdGFsU2l6ZSA9IDA7XHJcblxyXG4gICAgICAgIGxpbSA9IGxpbSB8fCBkYXRhLmJ5dGVMZW5ndGggLSAxODtcclxuXHJcbiAgICAgICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgcHRyWzBdLCAxOCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgeGxlbiA9IChiYVsxMV0gPDwgOCkgfCAoYmFbMTBdKTtcclxuICAgICAgICAgICAgdmFyIHNpMSA9IGJhWzEyXTtcclxuICAgICAgICAgICAgdmFyIHNpMiA9IGJhWzEzXTtcclxuICAgICAgICAgICAgdmFyIHNsZW4gPSAoYmFbMTVdIDw8IDgpIHwgKGJhWzE0XSk7XHJcbiAgICAgICAgICAgIHZhciBic2l6ZSA9IChiYVsxN10gPDwgOCkgfCAoYmFbMTZdKSArIDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAxMiArIHhsZW4gKyBwdHJbMF07ICAgIC8vIFN0YXJ0IG9mIENEQVRBXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBzdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCAoYnNpemUgKyA4KSkgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIHN0YXJ0LCBsZW5ndGgsIHB0cik7XHJcblxyXG4gICAgICAgICAgICBwdHJbMF0gKz0gODsgICAgLy8gU2tpcHBpbmcgQ1JDLTMyIGFuZCBzaXplIG9mIHVuY29tcHJlc3NlZCBkYXRhXHJcblxyXG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29uY2F0ZW5hdGUgZGVjb21wcmVzc2VkIGJsb2Nrc1xyXG4gICAgICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XHJcbiAgICAgICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQge2lndnhocix1bmJnemZ9O1xyXG5cclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/igvxhr.js\n");

/***/ }),

/***/ "./src/indexes/image_gen_index.js":
/*!****************************************!*\
  !*** ./src/indexes/image_gen_index.js ***!
  \****************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_image_gen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/image_gen.js */ \"./src/node/image_gen.js\");\n\r\n\r\nvar file= process.argv[2];\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\nvar contents = fs.readFileSync(file);\r\nvar json = JSON.parse(contents);\r\n\r\nif (!json.config.folder){\r\n\tjson.config.folder=\"images\";\r\n}\r\n\r\nif (!fs.existsSync(json.config.folder)){\r\n    fs.mkdirSync(json.config.folder);\r\n}\r\n\r\nlet ig = new _node_image_gen_js__WEBPACK_IMPORTED_MODULE_0__[\"MLVImageGen\"](json.tracks,json.config);\r\nig.drawImages();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXhlcy9pbWFnZV9nZW5faW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXhlcy9pbWFnZV9nZW5faW5kZXguanM/ODA5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01MVkltYWdlR2VufSBmcm9tIFwiLi4vbm9kZS9pbWFnZV9nZW4uanNcIjtcclxuXHJcbnZhciBmaWxlPSBwcm9jZXNzLmFyZ3ZbMl07XHJcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxudmFyIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGZpbGUpO1xyXG52YXIganNvbiA9IEpTT04ucGFyc2UoY29udGVudHMpO1xyXG5cclxuaWYgKCFqc29uLmNvbmZpZy5mb2xkZXIpe1xyXG5cdGpzb24uY29uZmlnLmZvbGRlcj1cImltYWdlc1wiO1xyXG59XHJcblxyXG5pZiAoIWZzLmV4aXN0c1N5bmMoanNvbi5jb25maWcuZm9sZGVyKSl7XHJcbiAgICBmcy5ta2RpclN5bmMoanNvbi5jb25maWcuZm9sZGVyKTtcclxufVxyXG5cclxubGV0IGlnID0gbmV3IE1MVkltYWdlR2VuKGpzb24udHJhY2tzLGpzb24uY29uZmlnKTtcclxuaWcuZHJhd0ltYWdlcygpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/indexes/image_gen_index.js\n");

/***/ }),

/***/ "./src/node/image_gen.js":
/*!*******************************!*\
  !*** ./src/node/image_gen.js ***!
  \*******************************/
/*! exports provided: MLVImageGen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVImageGen\", function() { return MLVImageGen; });\n/* harmony import */ var _tracks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tracks.js */ \"./src/tracks.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\n\r\nconst Canvas = __webpack_require__(/*! canvas */ \"canvas\");\r\nconst path = __webpack_require__(/*! path */ \"path\")\r\n\r\nclass MLVImageGen {\r\n   constructor (tracks,config) {\r\n           this.show_scale=true;\r\n\t\tif (!config){\r\n\t\t\tthis.config =config={};\r\n\t\t}\r\n\t\telse{\r\n\t\t\tthis.config=config;\r\n\t\t}\r\n\t\tthis.config.height=this.config.height?this.config.height:200;\r\n\t\tthis.config.width=this.config.width?this.config.width:300;\r\n\t\tif (!this.config.type){\r\n\t\t\tthis.config.type=\"png\";\r\n\t\t}\r\n\t\tthis.c_type=\"png\";\r\n\t\tthis.stream=\"createPNGStream\";\r\n\t\tif (config.type===\"svg\"){ \r\n\t\t\tthis.c_type=\"svg\";\r\n\r\n\t\t}\r\n           if (config.type===\"pdf\"){\r\n\t\t\tthis.stream=\"createPDFStream\";\r\n\t\t\tthis.c_type=\"pdf\";\r\n\t\t}\r\n\t\tthis.fixed_height_mode=false;\r\n\t\tif (config.fixed_height_mode){\r\n\t\t\tthis.fixed_height_mode=true;\r\n\t\t}\r\n        \t\r\n            \r\n           \r\n\t\t\r\n\r\n           \r\n\t\tthis.tracks={};\r\n\t\tthis.track_order=[];\r\n\t\tfor (let t_config of tracks){\r\n\t\t\tlet track=_tracks_js__WEBPACK_IMPORTED_MODULE_0__[\"MLVTrack\"].getTrack(t_config);\r\n\t\t\tthis.tracks[track.config.track_id]=track;\r\n\t\t\tthis.track_order.push(track.config.track_id);\r\n\t\t}\r\n\t\tfor (let t_id of this.track_order){\r\n    \t\t\tlet track = this.tracks[t_id];\r\n    \t\t\t//if this track is linked to the scale of another\r\n    \t\t\t//get pointer to the track\r\n    \t\t\tlet link_to = track.config['scale_link_to'];\r\n    \t\t\tif (link_to){\r\n\t\t\t\tlet other_track = this.tracks[link_to];\r\n\t\t\t\tif (other_track){\r\n\t\t\t\t\ttrack.scale_link_to=other_track;\r\n\t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n  \r\n       \tthis.index=0;\r\n    }\r\n\r\n\tgetTracksHeight(){\r\n    \t\tlet h =3;\r\n    \t\tfor (let t in this.tracks){\r\n\t\t\th+=this.tracks[t].config.height+3;\r\n    \t\t}\r\n    \t\treturn h;\r\n\t}\t\r\n\r\n\r\n\r\n    drawImages(){\r\n\t\tlet loc = this.config.images;\r\n\t\tif (this.index<loc.length){\r\n\t\t\tlet info=loc[this.index];\r\n\t\t\tlet h_region=null;\r\n\t\t\tif (info.highlight){\r\n\t\t\t\th_region={\r\n\t\t\t\t\tchr:info.loc[0],\r\n\t\t\t\t\tstart:info.highlight[1],\r\n\t\t\t\t\tend:info.highlight[2],\r\n\t\t\t\t\tcolor:info.highloght[3]?info.highlight[3]:\"blue\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet stub = info.stub;\r\n\t\t\tif (!stub){\r\n\t\t\t\tstub=info.loc[0]+\"_\"+info.loc[1]+\"_\"+info.loc[2];\r\n\t\t\t}\r\n\t\t\tlet file = path.resolve(this.config.folder,stub+\".\"+this.config.type);\t\r\n\t\t\tthis.drawImage(info.loc[0],info.loc[1],info.loc[2],file,h_region);\r\n\t\t\t\t\r\n\t\t}\r\n    \t}\r\n\r\n   \r\n    \r\n\tdrawImage(chr,start,end,file,region){\r\n\t\tconsole.log(file);\r\n        \tlet bpPerPixel=(end-start)/this.config.width;\r\n\t   \tlet self = this;\r\n\t\tlet height = this.fixed_height_mode?this.getTracksHeight():this.config.height;\r\n\t\tthis.canvas=Canvas.createCanvas(this.config.width,height,this.c_type);\r\n\t\tthis.ctx = this.canvas.getContext('2d');\r\n\t\t\r\n        \tthis.getAllFeatures(chr, start, end,{pixelWidth:this.config.width,bpPerPixel:bpPerPixel})\r\n                .then(function (all_features) {\r\n                    if (all_features) {             \r\n                        var options ={\r\n                             context: self.ctx,\r\n                             bpStart: start,\r\n                             bpPerPixel: bpPerPixel,\r\n                             pixelWidth:self.config.width,\r\n                             pixelHeight: height,\r\n                        };\r\n                        let top=3;\r\n                        self.groups={};\r\n\t\t\t\t\r\n\t\t\t\t  self.ctx.clearRect(0, 0, self.config.width, self.config.height);\r\n\t\t\t\t  if (self.config.background_color && self.config.type===\"png\"){\r\n\t\t\t\t\tself.fillStyle=this.config.background_color;\r\n\t\t\t\t\tself.ctx.fillRect(0,0,this.config.width,height);\r\n\t\t\t\t  }\r\n                        for (let i in all_features){\r\n                        \tlet track = self.tracks[self.track_order[i]];\r\n                        \toptions.features=all_features[i];\r\n                        \tlet group = track.config.group\r\n                        \tif (group){\r\n                        \t\tif (!self.groups[group]){\r\n                        \t\t\tself.groups[group]={top:top,height:track.config.height,label_offset:15}\r\n\t\t\t\t\t\t\ttop+=track.config.height;\r\n                        \t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tself.groups[group].label_offset+=15;\r\n\t\t\t\t\t\t}\r\n                        \t\toptions.top=self.groups[group].top;\r\n                        \t\toptions.height=self.groups[group].height;\r\n\r\n                        \t}\r\n                        \telse{\r\n                        \t\toptions.top =top\r\n                        \t}\r\n\t\t\t\t\tlet disc = self.fixed_height_mode || track.config.discrete || group;\r\n\t\t\t\t\tif (disc){\r\n\t\t\t\t\t\tself.ctx.save();\r\n\t\t\t\t\t\tself.ctx.rect(0,options.top,options.pixelWidth,track.config.height);\r\n\t\t\t\t\t\tself.ctx.clip();\r\n\t\t\t\t\t\tself.ctx.beginPath();\r\n\r\n\t\t\t\t\t}\r\n                           let offset=track.drawFeatures(options);\r\n\t\t\t\t\tif (track.config.type !== \"ruler\"){\r\n\t\t\t\t\t\tself.ctx.fillStyle = \"black\";\r\n\t\t\t\t\t\tif (self.config.label_font_size){\r\n\t\t\t\t\t\t\tself.ctx.font=self.config.label_font_size+\"px Arial\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\tself.ctx.font=\"10px Arial\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlet t_w= self.ctx.measureText(track.config.short_label).width+5;\r\n\t\t\t\t\t\tlet l_offset=15;\r\n\t\t\t\t\t\tif (group){\r\n\t\t\t\t\t\t\tl_offset=self.groups[group].label_offset;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tself.ctx.fillText(track.config.short_label,self.config.width-t_w,options.top+l_offset);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (disc){\r\n\t\t\t\t\t\tself.ctx.restore();\r\n\t\t\t\t\t\tif (!group){\r\n\t\t\t\t\t\t\ttop+=track.config.height+3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n                         \telse if (offset){\r\n                         \t  \ttop=offset+3;\r\n                           }\r\n                           if (self.show_scale){\r\n\t\t\t\t\t\tself.ctx.font=\"10px Arial\";\r\n                            \ttrack.drawScale(options.pixelHeight,self.ctx)\r\n                           }\r\n                                      \r\n                        }\r\n                        if (region){\r\n\t\t\t\t\tlet start= (region.start-options.bpStart)/options.bpPerPixel;\r\n    \t\t\t\t\tstart = start<0?0:start;\r\n\t\t\t\t\tlet width = (region.end-region.start)/options.bpPerPixel;\r\n    \t\t\t\t\twidth =width>options.pixelWidth?options.pixelWidth:width;\r\n\t\t\t\t\tself.ctx.globalAlpha=0.1;\r\n\t\t\t\t\tself.ctx.fillStyle=region.color;\r\n    \t\t\t\t\tself.ctx.fillRect(start,0,width,options.pixelHeight);\r\n    \t\t\t\t\tself.ctx.globalAlpha=1.0;\r\n                        }\r\n                        \r\n                    \r\n                    }\r\n\t\t                \r\n\t\t\t\t\r\n\t\t\t\tif (self.config.type===\"svg\"){\r\n\t\t\t\t\tfs.writeFileSync(file, self.canvas.toBuffer())\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tconst out = fs.createWriteStream(file);\r\n\t\t\t\t\tconst stream = self.canvas[self.stream]();\r\n\t\t\t\t\tstream.pipe(out);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\t\r\n\r\n\t\t\t\tself.index++;\r\n\t\t\t\tself.drawImages();\r\n                })\r\n                .catch(function (error) {\r\n                    console.log(error.toString());\r\n\t\t\t    self.index++;\r\n                    self.drawImages();\r\n                });\r\n     \t}\r\n\r\n\tgetAllFeatures(chr,bpStart,bpEnd,data) {\r\n      \tlet promises = [];\r\n        \tfor (let track_id  of this.track_order){\r\n        \t\tlet track = this.tracks[track_id];\r\n        \t\tpromises.push(track.getFeatures(chr,bpStart,bpEnd,false,data));       \r\n        \t}\r\n\r\n        \treturn Promise.all(promises);\r\n\r\n           \r\n    \t}\r\n\r\n}\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbm9kZS9pbWFnZV9nZW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbm9kZS9pbWFnZV9nZW4uanM/OGIyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuaW1wb3J0IHtNTFZUcmFja30gZnJvbSBcIi4uL3RyYWNrcy5qc1wiO1xyXG5jb25zdCBDYW52YXMgPSByZXF1aXJlKFwiY2FudmFzXCIpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIilcclxuXHJcbmNsYXNzIE1MVkltYWdlR2VuIHtcclxuICAgY29uc3RydWN0b3IgKHRyYWNrcyxjb25maWcpIHtcclxuICAgICAgICAgICB0aGlzLnNob3dfc2NhbGU9dHJ1ZTtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0dGhpcy5jb25maWcgPWNvbmZpZz17fTtcclxuXHRcdH1cclxuXHRcdGVsc2V7XHJcblx0XHRcdHRoaXMuY29uZmlnPWNvbmZpZztcclxuXHRcdH1cclxuXHRcdHRoaXMuY29uZmlnLmhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ/dGhpcy5jb25maWcuaGVpZ2h0OjIwMDtcclxuXHRcdHRoaXMuY29uZmlnLndpZHRoPXRoaXMuY29uZmlnLndpZHRoP3RoaXMuY29uZmlnLndpZHRoOjMwMDtcclxuXHRcdGlmICghdGhpcy5jb25maWcudHlwZSl7XHJcblx0XHRcdHRoaXMuY29uZmlnLnR5cGU9XCJwbmdcIjtcclxuXHRcdH1cclxuXHRcdHRoaXMuY190eXBlPVwicG5nXCI7XHJcblx0XHR0aGlzLnN0cmVhbT1cImNyZWF0ZVBOR1N0cmVhbVwiO1xyXG5cdFx0aWYgKGNvbmZpZy50eXBlPT09XCJzdmdcIil7IFxyXG5cdFx0XHR0aGlzLmNfdHlwZT1cInN2Z1wiO1xyXG5cclxuXHRcdH1cclxuICAgICAgICAgICBpZiAoY29uZmlnLnR5cGU9PT1cInBkZlwiKXtcclxuXHRcdFx0dGhpcy5zdHJlYW09XCJjcmVhdGVQREZTdHJlYW1cIjtcclxuXHRcdFx0dGhpcy5jX3R5cGU9XCJwZGZcIjtcclxuXHRcdH1cclxuXHRcdHRoaXMuZml4ZWRfaGVpZ2h0X21vZGU9ZmFsc2U7XHJcblx0XHRpZiAoY29uZmlnLmZpeGVkX2hlaWdodF9tb2RlKXtcclxuXHRcdFx0dGhpcy5maXhlZF9oZWlnaHRfbW9kZT10cnVlO1xyXG5cdFx0fVxyXG4gICAgICAgIFx0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgIFxyXG5cdFx0XHJcblxyXG4gICAgICAgICAgIFxyXG5cdFx0dGhpcy50cmFja3M9e307XHJcblx0XHR0aGlzLnRyYWNrX29yZGVyPVtdO1xyXG5cdFx0Zm9yIChsZXQgdF9jb25maWcgb2YgdHJhY2tzKXtcclxuXHRcdFx0bGV0IHRyYWNrPU1MVlRyYWNrLmdldFRyYWNrKHRfY29uZmlnKTtcclxuXHRcdFx0dGhpcy50cmFja3NbdHJhY2suY29uZmlnLnRyYWNrX2lkXT10cmFjaztcclxuXHRcdFx0dGhpcy50cmFja19vcmRlci5wdXNoKHRyYWNrLmNvbmZpZy50cmFja19pZCk7XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCB0X2lkIG9mIHRoaXMudHJhY2tfb3JkZXIpe1xyXG4gICAgXHRcdFx0bGV0IHRyYWNrID0gdGhpcy50cmFja3NbdF9pZF07XHJcbiAgICBcdFx0XHQvL2lmIHRoaXMgdHJhY2sgaXMgbGlua2VkIHRvIHRoZSBzY2FsZSBvZiBhbm90aGVyXHJcbiAgICBcdFx0XHQvL2dldCBwb2ludGVyIHRvIHRoZSB0cmFja1xyXG4gICAgXHRcdFx0bGV0IGxpbmtfdG8gPSB0cmFjay5jb25maWdbJ3NjYWxlX2xpbmtfdG8nXTtcclxuICAgIFx0XHRcdGlmIChsaW5rX3RvKXtcclxuXHRcdFx0XHRsZXQgb3RoZXJfdHJhY2sgPSB0aGlzLnRyYWNrc1tsaW5rX3RvXTtcclxuXHRcdFx0XHRpZiAob3RoZXJfdHJhY2spe1xyXG5cdFx0XHRcdFx0dHJhY2suc2NhbGVfbGlua190bz1vdGhlcl90cmFjaztcclxuXHRcdFx0XHR9XHJcbiAgICBcdFx0XHR9XHJcbiAgICBcdFx0fVxyXG4gIFxyXG4gICAgICAgXHR0aGlzLmluZGV4PTA7XHJcbiAgICB9XHJcblxyXG5cdGdldFRyYWNrc0hlaWdodCgpe1xyXG4gICAgXHRcdGxldCBoID0zO1xyXG4gICAgXHRcdGZvciAobGV0IHQgaW4gdGhpcy50cmFja3Mpe1xyXG5cdFx0XHRoKz10aGlzLnRyYWNrc1t0XS5jb25maWcuaGVpZ2h0KzM7XHJcbiAgICBcdFx0fVxyXG4gICAgXHRcdHJldHVybiBoO1xyXG5cdH1cdFxyXG5cclxuXHJcblxyXG4gICAgZHJhd0ltYWdlcygpe1xyXG5cdFx0bGV0IGxvYyA9IHRoaXMuY29uZmlnLmltYWdlcztcclxuXHRcdGlmICh0aGlzLmluZGV4PGxvYy5sZW5ndGgpe1xyXG5cdFx0XHRsZXQgaW5mbz1sb2NbdGhpcy5pbmRleF07XHJcblx0XHRcdGxldCBoX3JlZ2lvbj1udWxsO1xyXG5cdFx0XHRpZiAoaW5mby5oaWdobGlnaHQpe1xyXG5cdFx0XHRcdGhfcmVnaW9uPXtcclxuXHRcdFx0XHRcdGNocjppbmZvLmxvY1swXSxcclxuXHRcdFx0XHRcdHN0YXJ0OmluZm8uaGlnaGxpZ2h0WzFdLFxyXG5cdFx0XHRcdFx0ZW5kOmluZm8uaGlnaGxpZ2h0WzJdLFxyXG5cdFx0XHRcdFx0Y29sb3I6aW5mby5oaWdobG9naHRbM10/aW5mby5oaWdobGlnaHRbM106XCJibHVlXCJcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IHN0dWIgPSBpbmZvLnN0dWI7XHJcblx0XHRcdGlmICghc3R1Yil7XHJcblx0XHRcdFx0c3R1Yj1pbmZvLmxvY1swXStcIl9cIitpbmZvLmxvY1sxXStcIl9cIitpbmZvLmxvY1syXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgZmlsZSA9IHBhdGgucmVzb2x2ZSh0aGlzLmNvbmZpZy5mb2xkZXIsc3R1YitcIi5cIit0aGlzLmNvbmZpZy50eXBlKTtcdFxyXG5cdFx0XHR0aGlzLmRyYXdJbWFnZShpbmZvLmxvY1swXSxpbmZvLmxvY1sxXSxpbmZvLmxvY1syXSxmaWxlLGhfcmVnaW9uKTtcclxuXHRcdFx0XHRcclxuXHRcdH1cclxuICAgIFx0fVxyXG5cclxuICAgXHJcbiAgICBcclxuXHRkcmF3SW1hZ2UoY2hyLHN0YXJ0LGVuZCxmaWxlLHJlZ2lvbil7XHJcblx0XHRjb25zb2xlLmxvZyhmaWxlKTtcclxuICAgICAgICBcdGxldCBicFBlclBpeGVsPShlbmQtc3RhcnQpL3RoaXMuY29uZmlnLndpZHRoO1xyXG5cdCAgIFx0bGV0IHNlbGYgPSB0aGlzO1xyXG5cdFx0bGV0IGhlaWdodCA9IHRoaXMuZml4ZWRfaGVpZ2h0X21vZGU/dGhpcy5nZXRUcmFja3NIZWlnaHQoKTp0aGlzLmNvbmZpZy5oZWlnaHQ7XHJcblx0XHR0aGlzLmNhbnZhcz1DYW52YXMuY3JlYXRlQ2FudmFzKHRoaXMuY29uZmlnLndpZHRoLGhlaWdodCx0aGlzLmNfdHlwZSk7XHJcblx0XHR0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcclxuICAgICAgICBcdHRoaXMuZ2V0QWxsRmVhdHVyZXMoY2hyLCBzdGFydCwgZW5kLHtwaXhlbFdpZHRoOnRoaXMuY29uZmlnLndpZHRoLGJwUGVyUGl4ZWw6YnBQZXJQaXhlbH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYWxsX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbF9mZWF0dXJlcykgeyAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBzZWxmLmN0eCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicFN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicFBlclBpeGVsOiBicFBlclBpeGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsV2lkdGg6c2VsZi5jb25maWcud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxIZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvcD0zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmdyb3Vwcz17fTtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQgIHNlbGYuY3R4LmNsZWFyUmVjdCgwLCAwLCBzZWxmLmNvbmZpZy53aWR0aCwgc2VsZi5jb25maWcuaGVpZ2h0KTtcclxuXHRcdFx0XHQgIGlmIChzZWxmLmNvbmZpZy5iYWNrZ3JvdW5kX2NvbG9yICYmIHNlbGYuY29uZmlnLnR5cGU9PT1cInBuZ1wiKXtcclxuXHRcdFx0XHRcdHNlbGYuZmlsbFN0eWxlPXRoaXMuY29uZmlnLmJhY2tncm91bmRfY29sb3I7XHJcblx0XHRcdFx0XHRzZWxmLmN0eC5maWxsUmVjdCgwLDAsdGhpcy5jb25maWcud2lkdGgsaGVpZ2h0KTtcclxuXHRcdFx0XHQgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBhbGxfZmVhdHVyZXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCB0cmFjayA9IHNlbGYudHJhY2tzW3NlbGYudHJhY2tfb3JkZXJbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdG9wdGlvbnMuZmVhdHVyZXM9YWxsX2ZlYXR1cmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGxldCBncm91cCA9IHRyYWNrLmNvbmZpZy5ncm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGlmIChncm91cCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRpZiAoIXNlbGYuZ3JvdXBzW2dyb3VwXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRcdHNlbGYuZ3JvdXBzW2dyb3VwXT17dG9wOnRvcCxoZWlnaHQ6dHJhY2suY29uZmlnLmhlaWdodCxsYWJlbF9vZmZzZXQ6MTV9XHJcblx0XHRcdFx0XHRcdFx0dG9wKz10cmFjay5jb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNle1xyXG5cdFx0XHRcdFx0XHRcdHNlbGYuZ3JvdXBzW2dyb3VwXS5sYWJlbF9vZmZzZXQrPTE1O1xyXG5cdFx0XHRcdFx0XHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRvcHRpb25zLnRvcD1zZWxmLmdyb3Vwc1tncm91cF0udG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdFx0b3B0aW9ucy5oZWlnaHQ9c2VsZi5ncm91cHNbZ3JvdXBdLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0XHRvcHRpb25zLnRvcCA9dG9wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0fVxyXG5cdFx0XHRcdFx0bGV0IGRpc2MgPSBzZWxmLmZpeGVkX2hlaWdodF9tb2RlIHx8IHRyYWNrLmNvbmZpZy5kaXNjcmV0ZSB8fCBncm91cDtcclxuXHRcdFx0XHRcdGlmIChkaXNjKXtcclxuXHRcdFx0XHRcdFx0c2VsZi5jdHguc2F2ZSgpO1xyXG5cdFx0XHRcdFx0XHRzZWxmLmN0eC5yZWN0KDAsb3B0aW9ucy50b3Asb3B0aW9ucy5waXhlbFdpZHRoLHRyYWNrLmNvbmZpZy5oZWlnaHQpO1xyXG5cdFx0XHRcdFx0XHRzZWxmLmN0eC5jbGlwKCk7XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldD10cmFjay5kcmF3RmVhdHVyZXMob3B0aW9ucyk7XHJcblx0XHRcdFx0XHRpZiAodHJhY2suY29uZmlnLnR5cGUgIT09IFwicnVsZXJcIil7XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcclxuXHRcdFx0XHRcdFx0aWYgKHNlbGYuY29uZmlnLmxhYmVsX2ZvbnRfc2l6ZSl7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5jdHguZm9udD1zZWxmLmNvbmZpZy5sYWJlbF9mb250X3NpemUrXCJweCBBcmlhbFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2V7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5jdHguZm9udD1cIjEwcHggQXJpYWxcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRsZXQgdF93PSBzZWxmLmN0eC5tZWFzdXJlVGV4dCh0cmFjay5jb25maWcuc2hvcnRfbGFiZWwpLndpZHRoKzU7XHJcblx0XHRcdFx0XHRcdGxldCBsX29mZnNldD0xNTtcclxuXHRcdFx0XHRcdFx0aWYgKGdyb3VwKXtcclxuXHRcdFx0XHRcdFx0XHRsX29mZnNldD1zZWxmLmdyb3Vwc1tncm91cF0ubGFiZWxfb2Zmc2V0O1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LmZpbGxUZXh0KHRyYWNrLmNvbmZpZy5zaG9ydF9sYWJlbCxzZWxmLmNvbmZpZy53aWR0aC10X3csb3B0aW9ucy50b3ArbF9vZmZzZXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKGRpc2Mpe1xyXG5cdFx0XHRcdFx0XHRzZWxmLmN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdFx0XHRcdGlmICghZ3JvdXApe1xyXG5cdFx0XHRcdFx0XHRcdHRvcCs9dHJhY2suY29uZmlnLmhlaWdodCszO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcdGVsc2UgaWYgKG9mZnNldCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcdCAgXHR0b3A9b2Zmc2V0KzM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2hvd19zY2FsZSl7XHJcblx0XHRcdFx0XHRcdHNlbGYuY3R4LmZvbnQ9XCIxMHB4IEFyaWFsXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHRyYWNrLmRyYXdTY2FsZShvcHRpb25zLnBpeGVsSGVpZ2h0LHNlbGYuY3R4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ2lvbil7XHJcblx0XHRcdFx0XHRsZXQgc3RhcnQ9IChyZWdpb24uc3RhcnQtb3B0aW9ucy5icFN0YXJ0KS9vcHRpb25zLmJwUGVyUGl4ZWw7XHJcbiAgICBcdFx0XHRcdFx0c3RhcnQgPSBzdGFydDwwPzA6c3RhcnQ7XHJcblx0XHRcdFx0XHRsZXQgd2lkdGggPSAocmVnaW9uLmVuZC1yZWdpb24uc3RhcnQpL29wdGlvbnMuYnBQZXJQaXhlbDtcclxuICAgIFx0XHRcdFx0XHR3aWR0aCA9d2lkdGg+b3B0aW9ucy5waXhlbFdpZHRoP29wdGlvbnMucGl4ZWxXaWR0aDp3aWR0aDtcclxuXHRcdFx0XHRcdHNlbGYuY3R4Lmdsb2JhbEFscGhhPTAuMTtcclxuXHRcdFx0XHRcdHNlbGYuY3R4LmZpbGxTdHlsZT1yZWdpb24uY29sb3I7XHJcbiAgICBcdFx0XHRcdFx0c2VsZi5jdHguZmlsbFJlY3Qoc3RhcnQsMCx3aWR0aCxvcHRpb25zLnBpeGVsSGVpZ2h0KTtcclxuICAgIFx0XHRcdFx0XHRzZWxmLmN0eC5nbG9iYWxBbHBoYT0xLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cdFx0ICAgICAgICAgICAgICAgIFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChzZWxmLmNvbmZpZy50eXBlPT09XCJzdmdcIil7XHJcblx0XHRcdFx0XHRmcy53cml0ZUZpbGVTeW5jKGZpbGUsIHNlbGYuY2FudmFzLnRvQnVmZmVyKCkpXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZXtcclxuXHRcdFx0XHRcdGNvbnN0IG91dCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGUpO1xyXG5cdFx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gc2VsZi5jYW52YXNbc2VsZi5zdHJlYW1dKCk7XHJcblx0XHRcdFx0XHRzdHJlYW0ucGlwZShvdXQpO1xyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0XHRcclxuXHJcblx0XHRcdFx0c2VsZi5pbmRleCsrO1xyXG5cdFx0XHRcdHNlbGYuZHJhd0ltYWdlcygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvci50b1N0cmluZygpKTtcclxuXHRcdFx0ICAgIHNlbGYuaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRyYXdJbWFnZXMoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgIFx0fVxyXG5cclxuXHRnZXRBbGxGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxkYXRhKSB7XHJcbiAgICAgIFx0bGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgXHRmb3IgKGxldCB0cmFja19pZCAgb2YgdGhpcy50cmFja19vcmRlcil7XHJcbiAgICAgICAgXHRcdGxldCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrX2lkXTtcclxuICAgICAgICBcdFx0cHJvbWlzZXMucHVzaCh0cmFjay5nZXRGZWF0dXJlcyhjaHIsYnBTdGFydCxicEVuZCxmYWxzZSxkYXRhKSk7ICAgICAgIFxyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XHJcblxyXG4gICAgICAgICAgIFxyXG4gICAgXHR9XHJcblxyXG59XHJcblxyXG5leHBvcnQge01MVkltYWdlR2VufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/node/image_gen.js\n");

/***/ }),

/***/ "./src/tracks.js":
/*!***********************!*\
  !*** ./src/tracks.js ***!
  \***********************/
/*! exports provided: MLVTrack, MLVWigTrack, MLVBedTrack, RulerTrack, MLVBigBedTrack, Graphics */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(__webpack_provided_$_dot_extend) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVTrack\", function() { return MLVTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVWigTrack\", function() { return MLVWigTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVBedTrack\", function() { return MLVBedTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RulerTrack\", function() { return RulerTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MLVBigBedTrack\", function() { return MLVBigBedTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graphics\", function() { return Graphics; });\n/* harmony import */ var _bigwig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bigwig.js */ \"./src/bigwig.js\");\n/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ \"./src/feature.js\");\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MLVTrack{\r\n\tconstructor(config){\r\n\t\tthis.config=config;\r\n\t}\r\n\r\n\t_setFeatureSource(){\r\n\t\t//overriden by tracks with feature sources\r\n\t}\r\n\r\n\tdrawScale(ctx){\r\n\t\t//overidden in tracks with scale\r\n\t}\r\n\r\n\tgetConfig(){\r\n\t\treturn __webpack_provided_$_dot_extend(true, {}, this.config);\r\n\t}\r\n\r\n\tsetConfigAttribute(attribute,value){\r\n\t\tthis.config[attribute]=value;\r\n    \tif (attribute===\"url\"){\r\n    \t\tthis._setFeatureSource();\r\n    \t}\r\n    }\r\n    getFeatureAt(genomicLocation, chr,yOffset, bpPerPixel){\r\n    \treturn null;\r\n    }\r\n\r\n    setConfig(config){\r\n    \tif (this.config.url !== config.url){\r\n    \t\tthis.config=config;\r\n    \t\tthis._setFeatureSource();\r\n    \t}\r\n    \telse{\r\n    \t\tthis._setFeatureSource();\r\n    \t}\r\n    }\r\n\r\n     /**\r\n\t* Reteives the features requested, the default is just to get the features\r\n\t* from the feature source \r\n\t* @param {string} chr - The chromosome \r\n\t* @param {integer} start - The start of the range from which to obtain features\r\n\t* @param {integer} end - The end of the range from which to obtain features \r\n\t* @param {boolean} force - If true then cached features should not be used\r\n\t* but fresh features retrieved\r\n\t* @param {Object} data - contains bp  ber pixel and width of the canvas \r\n\t*/\r\n\tgetFeatures (chr, bpStart, bpEnd,force,data) {\r\n\t\treturn this.feature_source.getFeatures(chr,bpStart,bpEnd,force,data);\r\n\t}\r\n\r\n\r\n\tstatic calculateLabel(url){\r\n\t\tif (typeof url !== \"string\"){\r\n\t\t\turl = url[0];\r\n\t\t}\r\n\t\tlet arr =url.split(\"/\");\r\n\t\tlet label= arr[arr.length-1];\r\n\t\tarr= label.split(\".\");\r\n\t\tlabel = arr[0];\r\n\t\treturn label;\r\n\t}\r\n\r\n\taddExtraControls(div,panel){\r\n\t}\r\n\r\n\tstatic getTypeFromURL(url){\r\n\t\tlet config={}\r\n\t\tif (typeof url !== \"string\"){\r\n\t\t\treturn config;\r\n\t\t}\r\n\t\t\tif (url.endsWith(\"bw\")){\r\n\t\t\t\tconfig.type=\"bigwig\";\r\n\t\t\t\tconfig.format=\"wig\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".bed.gz\")){\r\n\t\t\t\tconfig.type=\"bed\";\r\n\t\t\t\tconfig.format=\"feature\"\r\n\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".bb\") && !(config.type)){\r\n\t\t\t\tconfig.type=\"bigbed\";\r\n\t\t\t\tconfig.format=\"feature\"\r\n\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".fasta\")){\r\n\t\t\t\tconfig.type=\"fasta\";\r\n\t\t\t\tconfig.format=\"sequence\";\r\n\t\t\t}\r\n\t\t\telse if (url.endsWith(\".bam\")){\r\n\t\t\t\tconfig.type=\"bam\";\r\n\t\t\t\tconfig.format=\"alignment\";\r\n\t\t\t}\r\n\t\treturn config;\r\n\r\n\t}\r\n\r\n\tstatic parseConfig(con){\r\n\t\tlet config = __webpack_provided_$_dot_extend(true, {},con);\r\n\t\t\r\n\t\tif (!(config.type) && config.url){\r\n\t\t\tlet info = MLVTrack.getTypeFromURL(config.url);\r\n\t\t\tif (info.type){\r\n\t\t\t\tconfig.type=info.type;\r\n\t\t\t\tconfig.format=info.format;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!config.short_label && config.url){\r\n\t\t\tconfig.short_label=MLVTrack.calculateLabel(config.url);\r\n\t\t}\r\n\t\t\r\n\t\tif (!config.track_id){\r\n\t\t\tconfig.track_id=config.url;\r\n\t\t}\r\n\r\n\t\tif (config.format===\"feature\"){\r\n\t\t\tconfig.displayMode = config.displayMode || \"COLLAPSED\";    // COLLAPSED | EXPANDED | SQUISHED\r\n        \tconfig.labelDisplayMode = \"SLANT\";\r\n        \tconfig.squishedCallHeight = config.squishedCallHeight || 30;\r\n        \tconfig.expandedCallHeight = config.expandedCallHeight || 15;\r\n        \tconfig.featureHeight=config.featureHeight || 12;\r\n\t\t}\r\n\r\n\t\tif (config.format===\"wig\"){\r\n\t\t\tif (!config.scale){\r\n\t\t\t\tconfig.scale=\"dynamic\";\r\n\t\t\t}\r\n\t\t\tif (!config.min_y){\r\n\t\t\t\tconfig.min_y=0;\r\n\t\t\t}\r\n\t\t\tif (!config.maxy_y){\r\n\t\t\t\tconfig.max_y=100;\r\n\t\t\t}\r\n\t\t\tif (!config.height){\r\n\t\t\t\tconfig.height=100;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (config.type===\"bam\"){\r\n\t\t\tif (!config.featureHeight){\r\n\t\t\t\tconfig.featureHeight=12;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!config.color){\r\n\t\t\tif (config.type===\"bam\"){\r\n\t\t\t\tconfig.color=\"#D3D3D3\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tconfig.color=\"black\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!config.opacity){\r\n\t\t\tconfig.opacity=1.0;\r\n\t\t}\r\n\t\treturn config;\r\n\t}\r\n\r\n\r\n\t\r\n\tstatic getTrack(config){\r\n\r\n\t\tconfig=MLVTrack.parseConfig(config);\r\n\t\t\r\n\t\tif (config.type===\"bigwig\"){\r\n\t\t\treturn new MLVWigTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"bed\"){\r\n\t\t\treturn new MLVBedTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"ucsc\"){\r\n\t\t\treturn new UCSCTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"line\"){\r\n\t\t\treturn new LineTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"bigbed\"){\r\n\t\t\treturn new MLVBigBedTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"ruler\"){\r\n\t\t\treturn new RulerTrack(config);\r\n\t\t}\r\n\t\telse if (config.type===\"fasta\"){\r\n\t\t\treturn new SequenceTrack(config);\r\n\t\t}\r\n\t\t\r\n\t\telse{\r\n\t\t\t\r\n\t\t\tlet class_type = MLVTrack.custom_tracks[config.type];\r\n\t\t\tif (class_type){\r\n\t\t\t\treturn new class_type(config);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\t\t\r\n}\r\n\r\nMLVTrack.custom_tracks={};\r\n\r\n\r\n\r\n\r\n\r\n//*******************js/rulerTrack.js**********************\r\n\r\n\r\nclass RulerTrack extends MLVTrack{\r\n\tconstructor(config){\r\n\t\tif (!config){\r\n\t\t\tconfig={\"track_id\":\"ruler\"+RulerTrack.count,format:\"ruler\",short_label:\"Ruler\",type:\"ruler\"};\r\n\t\t}\r\n\t\tsuper(config);\r\n        this.height = 30;\r\n        this.config.height=30;\r\n        this.name = \"\";\r\n       \r\n        this.disableButtons = true;\r\n        this.ignoreTrackMenu = true;\r\n        this.order = -Number.MAX_VALUE;\r\n      \r\n        RulerTrack.count++;\r\n    }\r\n\r\n    getFeatures(chr, bpStart, bpEnd) {\r\n\r\n        return new Promise(function (fulfill, reject) {\r\n            fulfill([]);\r\n        });\r\n    }\r\n\r\n    drawFeatures(options) {\r\n\r\n        var fontStyle,\r\n            ctx = options.context,\r\n            range,\r\n            ts,\r\n            spacing,\r\n            nTick,\r\n            x;\r\n\r\n        fontStyle = { textAlign: 'center', font: '10px PT Sans', fillStyle: \"rgba(64, 64, 64, 1)\", strokeStyle: \"rgba(64, 64, 64, 1)\" };\r\n\r\n        range = Math.floor(1100 * options.bpPerPixel);\r\n        ts = RulerTrack.findSpacing(range);\r\n        spacing = ts.majorTick;\r\n\r\n        // Find starting point closest to the current origin\r\n        nTick = Math.floor(options.bpStart / spacing) - 1;\r\n        x = 0;\r\n\t\tlet y_pos=options.top+this.height;\r\n        //canvas.setProperties({textAlign: 'center'});\r\n        Graphics.setProperties(ctx, fontStyle );\r\n        while (x < options.pixelWidth) {\r\n\r\n            var l = Math.floor(nTick * spacing),\r\n                shim = 2;\r\n\r\n            x = Math.round(((l - 1) - options.bpStart + 0.5) / options.bpPerPixel);\r\n            var chrPosition = formatNumber(l / ts.unitMultiplier, 0) + \" \" + ts.majorUnit;\r\n\r\n            if (nTick % 1 == 0) {\r\n                Graphics.fillText(ctx, chrPosition, x, y_pos - 15);\r\n            }\r\n\r\n            Graphics.strokeLine(ctx, x, y_pos - 10, x, y_pos - shim);\r\n\r\n            nTick++;\r\n        }\r\n        Graphics.strokeLine(ctx, 0, y_pos - shim, options.pixelWidth, y_pos - shim);\r\n\r\n\r\n        function formatNumber(anynum, decimal) {\r\n            //decimal  - the number of decimals after the digit from 0 to 3\r\n            //-- Returns the passed number as a string in the xxx,xxx.xx format.\r\n            //anynum = eval(obj.value);\r\n            var divider = 10;\r\n            switch (decimal) {\r\n                case 0:\r\n                    divider = 1;\r\n                    break;\r\n                case 1:\r\n                    divider = 10;\r\n                    break;\r\n                case 2:\r\n                    divider = 100;\r\n                    break;\r\n                default:       //for 3 decimal places\r\n                    divider = 1000;\r\n            }\r\n\r\n            var workNum = Math.abs((Math.round(anynum * divider) / divider));\r\n\r\n            var workStr = \"\" + workNum\r\n\r\n            if (workStr.indexOf(\".\") == -1) {\r\n                workStr += \".\"\r\n            }\r\n\r\n            var dStr = workStr.substr(0, workStr.indexOf(\".\"));\r\n            var dNum = dStr - 0\r\n            var pStr = workStr.substr(workStr.indexOf(\".\"))\r\n\r\n            while (pStr.length - 1 < decimal) {\r\n                pStr += \"0\"\r\n            }\r\n\r\n            if (pStr == '.') pStr = '';\r\n\r\n            //--- Adds a comma in the thousands place.\r\n            if (dNum >= 1000) {\r\n                var dLen = dStr.length\r\n                dStr = parseInt(\"\" + (dNum / 1000)) + \",\" + dStr.substring(dLen - 3, dLen)\r\n            }\r\n\r\n            //-- Adds a comma in the millions place.\r\n            if (dNum >= 1000000) {\r\n                dLen = dStr.length\r\n                dStr = parseInt(\"\" + (dNum / 1000000)) + \",\" + dStr.substring(dLen - 7, dLen)\r\n            }\r\n            var retval = dStr + pStr\r\n            //-- Put numbers in parentheses if negative.\r\n            if (anynum < 0) {\r\n                retval = \"(\" + retval + \")\";\r\n            }\r\n\r\n            //You could include a dollar sign in the return value.\r\n            //retval =  \"$\"+retval\r\n            return retval;\r\n        }\r\n        return y_pos;\r\n\r\n\r\n    }\r\n    static findSpacing(maxValue) {\r\n\r\n        if (maxValue < 10) {\r\n            return new TickSpacing(1, \"\", 1);\r\n        }\r\n\r\n\r\n        // Now man zeroes?\r\n        var nZeroes = Math.floor(log10(maxValue));\r\n        var majorUnit = \"\";\r\n        var unitMultiplier = 1;\r\n        if (nZeroes > 9) {\r\n            majorUnit = \"gb\";\r\n            unitMultiplier = 1000000000;\r\n        }\r\n        if (nZeroes > 6) {\r\n            majorUnit = \"mb\";\r\n            unitMultiplier = 1000000;\r\n        } else if (nZeroes > 3) {\r\n            majorUnit = \"kb\";\r\n            unitMultiplier = 1000;\r\n        }\r\n\r\n        var nMajorTicks = maxValue / Math.pow(10, nZeroes - 1);\r\n        if (nMajorTicks < 25) {\r\n            return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);\r\n        } else {\r\n            return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);\r\n        }\r\n\r\n        function log10(x) {\r\n            var dn = Math.log(10);\r\n            return Math.log(x) / dn;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nRulerTrack.count=0;\r\n\r\nclass TickSpacing{\r\n\tconstructor(majorTick, majorUnit, unitMultiplier) {\r\n        this.majorTick = majorTick;\r\n        this.majorUnit = majorUnit;\r\n        this.unitMultiplier = unitMultiplier;\r\n    }\r\n\r\n}\r\n\r\n \r\nclass MLVBedTrack extends MLVTrack{\r\n\tconstructor(config){\r\n\t\tsuper(config);\r\n\t\tthis._setFeatureSource();\r\n\t\tthis.filter_function=null;\r\n\t\tthis.color_function=null;\r\n\t\t\r\n\t}\r\n\r\n\t_setFeatureSource(){\r\n\t\tthis.feature_source= new _feature_js__WEBPACK_IMPORTED_MODULE_1__[\"TabixBedFeatureSource\"](this.config)\r\n\t}\r\n\r\n\tsetFilterFunction(func){\r\n\t\tthis.filter_function=func;\r\n\t}\r\n\tsetColorFunction(func){\r\n\t\tthis.color_function=func;\r\n\t}\r\n\r\n\tgetCurrentFeatures(chr,start,end){\r\n\t\treturn this.feature_source.featureCache.queryFeatures(chr,start,end);\r\n\t}\r\n\t\r\n\tdrawFeatures(options) {\r\n\t\tlet max_y_val=0;\r\n        var track = this,\r\n        \tpy,\r\n            featureList = options.features,\r\n            ctx = options.context,\r\n            bpPerPixel = options.bpPerPixel,\r\n            bpStart = options.bpStart,\r\n            pixelWidth = options.pixelWidth,\r\n            pixelHeight = options.pixelHeight,\r\n            offset=0,\r\n            bpEnd = bpStart + pixelWidth * bpPerPixel + 1;\r\n\t \tlet top=0;\r\n       \tif(options.top){\r\n           top=options.top;\r\n       \t}\r\n       \tthis.top=top;\r\n        let conf = this.config;\r\n        let windowX = 0;\r\n        let windowX1 = windowX + pixelWidth;\r\n\r\n        this.config.squishedCallHeight = this.config.featureHeight+10;\r\n        this.config.expandedCallHeight = (this.config.featureHeight/2)+2;\r\n        let ki=null;\r\n        if (featureList.length>50000){\r\n        \tki=Math.round(featureList.length/50000)+1;\r\n        }\r\n\r\n\r\n\r\n        if (featureList) {\r\n        \tlet opacity = this.config.opacity?this.config.opacity:1;\r\n        \tctx.globalAlpha=opacity;\r\n\r\n            for (var gene, i = 0, len = featureList.length; i < len; i++) {\r\n            \tif (ki && i%ki!==0){\r\n            \t\tcontinue;\r\n            \t}\r\n                gene = featureList[i];\r\n                if (this.filter_function && !this.filter_function(gene)){\r\n                \tgene.display=false;\r\n                \tcontinue;\r\n                }\r\n                gene.display=true;\r\n                if (gene.end < bpStart) continue;\r\n                if (gene.start > bpEnd) break;\r\n                let coord = this.calculateFeatureCoordinates(gene, bpStart,bpPerPixel);\r\n                let h = conf.featureHeight\r\n                if (conf.displayMode === \"SQUISHED\" && gene.row != undefined) {\r\n            \t\th = conf.featureHeight / 2;\r\n            \t\tpy = conf.expandedCallHeight * gene.row + 2;\r\n        \t\t} else if (conf.displayMode === \"EXPANDED\" && gene.row != undefined) {\r\n            \t\tpy = conf.squishedCallHeight * gene.row + 5;\r\n        \t\t} else {\r\n             // collapsed\r\n           \t\t\t py = 5;\r\n        \t\t}\r\n        \t\tpy+=top;\r\n        \t\tif (py+h>max_y_val){\r\n        \t\t\tmax_y_val=py+h;\r\n        \t\t}\r\n        \t\tcoord.py=py;\r\n        \t\tcoord.h=h;\r\n        \t\tlet info={bpPerPixel:bpPerPixel,bpStart:bpStart,pixelWidth:pixelWidth}\r\n        \t\tif (this.color_function){\r\n        \t\t\tgene.color=this.color_function(gene);\r\n        \t\t}\r\n        \t\t\r\n                this.renderFeature(gene,coord,ctx,info);\r\n                this.renderFeatureLabel(ctx, gene, coord.px, coord.px1, py, windowX, windowX1);\r\n            }\r\n            ctx.globalAlpha=1;\r\n        }\r\n        else {\r\n            console.log(\"No feature list\");\r\n        }\r\n        this.bottom=max_y_val;\r\n        if (this.config.displayMode===\"COLLAPSED\"){\r\n        \tmax_y_val+=25;\r\n        }\t\r\n    \treturn max_y_val;\r\n    }\r\n        \r\n           \r\n\r\n    \r\n  \r\n\t /**\r\n     * @param ctx       the canvas 2d context\r\n     * @param feature\r\n     * @param featureX  feature start x-coordinate\r\n     * @param featureX1 feature end x-coordinate\r\n     * @param featureY  feature y-coordinate\r\n     * @param windowX   visible window start x-coordinate\r\n     * @param windowX1  visible window end x-coordinate\r\n     */\r\n  \r\n\r\n\r\n\r\n\trenderFeatureLabel(ctx, feature, featureX, featureX1, featureY, windowX, windowX1) {\r\n\t\tlet info = this.config;\r\n        var geneColor, geneFontStyle, transform,\r\n            boxX, boxX1,    // label should be centered between these two x-coordinates\r\n            labelX, labelY,\r\n            textFitsInBox;\r\n\r\n        // feature outside of viewable window\r\n        if (featureX1 < windowX || featureX > windowX1) {\r\n            boxX = featureX;\r\n            boxX1 = featureX1;\r\n        } else {\r\n            // center label within visible portion of the feature\r\n            boxX = Math.max(featureX, windowX);\r\n            boxX1 = Math.min(featureX1, windowX1);\r\n        }\r\n       \r\n\r\n        //if (igv.browser.selection && \"genes\" === this.config.type && feature.name !== undefined) {\r\n            // TODO -- for gtex, figure out a better way to do this\r\n            //geneColor = igv.browser.selection.colorForGene(feature.name);\r\n      //  }\r\n\r\n        textFitsInBox = (boxX1 - boxX) > ctx.measureText(feature.name).width;\r\n        //geneColor=\"black\";\r\n\r\n        if ((textFitsInBox || geneColor) && info.displayMode != \"SQUISHED\" && feature.name !== undefined) {\r\n            geneFontStyle = {\r\n                font: '10px PT Sans',\r\n                textAlign: 'center',\r\n                fillStyle: geneColor || info.color,\r\n                strokeStyle: geneColor || info.color\r\n            };\r\n\r\n            if (info.displayMode === \"COLLAPSED\" && info.labelDisplayMode === \"SLANT\") {\r\n                transform = {rotate: {angle: 45}};\r\n                delete geneFontStyle.textAlign;\r\n            }\r\n\r\n            labelX = boxX + ((boxX1 - boxX) / 2);\r\n            labelY = getFeatureLabelY(featureY, transform);\r\n\r\n            Graphics.fillText(ctx, feature.name, labelX, labelY, geneFontStyle, transform);\r\n        }\r\n        function getFeatureLabelY(featureY, transform) {\r\n        \treturn transform ? featureY + info.featureHeight+14 : featureY + info.featureHeight+7;\r\n    \t}\r\n    }\r\n\r\n\r\n\r\n\tcalculateFeatureCoordinates(feature, bpStart, xScale) {\r\n    \tvar px = Math.round((feature.start - bpStart) / xScale),\r\n        px1 = Math.round((feature.end - bpStart) / xScale),\r\n        pw = px1 - px;\r\n\r\n        if (pw < 3) {\r\n        \tpw = 3;\r\n            px -= 1;\r\n        }\r\n\r\n        return {\r\n        \tpx: px,\r\n            px1: px1,\r\n            pw: pw\r\n        };\r\n\t}\r\n\r\n\t/**\r\n     * Renders the feature to the canvas\r\n     * @param feature - The feature itself\r\n     * @param coord An object containing information on where to draw the feature\r\n     * px1,px2 the left and right pixels - pw - the width\r\n     * py the top, h - the height\r\n     * @param ctx - The context to draw the feature\r\n     * @param info - An object containing information about the genomic location\r\n     * bpStart.bpPerPixel and pixelWidth\r\n     * \r\n     */\r\n\t\r\n\trenderFeature(feature, coord,ctx,info){\r\n\t\tvar e,x, cy, direction, exon, ePx, ePx1, ePxU, ePw, py2, h2, \r\n            step = 20,\r\n            color = this.config.color;\r\n        if (feature.color) {\r\n            color = feature.color;\r\n        }\r\n  \r\n        ctx.fillStyle = color;\r\n        ctx.strokeStyle = color;\r\n\r\n\r\n        cy = coord.py + coord.h / 2;\r\n        h2 = coord.h / 2;\r\n        py2 = cy - h2 / 2;\r\n\r\n\t\tlet exonCount = feature.exons ? feature.exons.length : 0;\r\n\t\t\tif (exonCount == 0) {\r\n            \t// single-exon transcript\r\n            \tctx.fillRect(coord.px, coord.py, coord.pw, coord.h);\r\n        \t}\r\n        else{\r\n            // multi-exon transcript\r\n            coord.px=Math.max(coord.px,0);\r\n            coord.px1=Math.min(coord.px1,info.pixelWidth);\r\n            Graphics.strokeLine(ctx, coord.px + 1, cy, coord.px1 - 1, cy); // center line for introns\r\n            direction = feature.strand == '+' ? 1 : -1;\r\n            \r\n           \r\n          \r\n            for ( x=coord.px + step / 2; x <  coord.px1; x += step) {\r\n\r\n                // draw arrowheads along central line indicating transcribed orientation\r\n                Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\r\n                Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\r\n            }\r\n            for (e = 0; e < exonCount; e++) {\r\n                // draw the exons\r\n                exon = feature.exons[e];\r\n                ePx = Math.round((exon.start - info.bpStart) / info.bpPerPixel);\r\n                ePx1 = Math.round((exon.end - info.bpStart) / info.bpPerPixel);\r\n                ePw = Math.max(1, ePx1 - ePx);\r\n\r\n                if (exon.utr) {\r\n                    ctx.fillRect(ePx, py2, ePw, h2); // Entire exon is UTR\r\n                }\r\n                else {\r\n                    if (exon.cdStart) {\r\n                        ePxU = Math.round((exon.cdStart - info.bpStart) / info.bpPerPixel);\r\n                        ctx.fillRect(ePx, py2, ePxU - ePx, h2); // start is UTR\r\n                        ePw -= (ePxU - ePx);\r\n                        ePx = ePxU;\r\n\r\n                    }\r\n                    if (exon.cdEnd) {\r\n                        ePxU = Math.round((exon.cdEnd - info.bpStart) / info.bpPerPixel);\r\n                        ctx.fillRect(ePxU, py2, ePx1 - ePxU, h2); // start is UTR\r\n                        ePw -= (ePx1 - ePxU);\r\n                        ePx1 = ePxU;\r\n                    }\r\n\r\n                    ctx.fillRect(ePx, coord.py, ePw, coord.h);\r\n\r\n                    // Arrows\r\n                    if (ePw > step + 5) {\r\n                        ctx.fillStyle = \"white\";\r\n                        ctx.strokeStyle = \"white\";\r\n                        for (x = ePx + step / 2; x < ePx1; x += step) {\r\n                            // draw arrowheads along central line indicating transcribed orientation\r\n                            Graphics.strokeLine(ctx, x - direction * 2, cy - 2, x, cy);\r\n                            Graphics.strokeLine(ctx, x - direction * 2, cy + 2, x, cy);\r\n                        }\r\n                        ctx.fillStyle = color;\r\n                        ctx.strokeStyle = color;\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\t}\r\n\r\n\tgetFeatureAt(genomicLocation, chr, coord, bpPerPixel) {\r\n\t\tlet yOffset=coord.y-this.top;\r\n        // We use the featureCache property rather than method to avoid async load.  If the\r\n        // feature is not already loaded this won't work,  but the user wouldn't be mousing over it either.\r\n        if (this.feature_source.featureCache) {\r\n\r\n          \r\n               var tolerance = 2 * bpPerPixel,  // We need some tolerance around genomicLocation, start with +/- 2 pixels\r\n                featureList = this.feature_source.featureCache.queryFeatures(chr, genomicLocation - tolerance, genomicLocation + tolerance),\r\n                row;\r\n\r\n            if (this.config.displayMode != \"COLLAPSED\") {\r\n                row = (Math.floor)(this.config.displayMode === \"SQUISHED\" ? yOffset / this.config.expandedCallHeight : yOffset / this.config.squishedCallHeight);\r\n            }\r\n\r\n\r\n            if (featureList && featureList.length > 0) {\r\n\r\n\r\n                var popupData = [];\r\n                for (let feature of featureList){\r\n                    if (feature.end >= genomicLocation - tolerance &&\r\n                        feature.start <= genomicLocation + tolerance) {\r\n\r\n                        // If row number is specified use it\r\n                        if ((row === undefined || feature.row === undefined || row === feature.row)&&  feature.display) {\r\n                           return feature;\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n               \r\n            }\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n}\r\n\r\n\r\nclass MLVBigBedTrack extends MLVBedTrack{\r\n\tconstructor(config){\r\n\t\tsuper(config);\r\n\t\t\r\n\t}\r\n\t_setFeatureSource(){\r\n\t\tthis.feature_source=new _feature_js__WEBPACK_IMPORTED_MODULE_1__[\"BigBedFeatureSource\"](this.config);\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nclass MLVWigTrack extends MLVTrack{\r\n\tconstructor(config){\r\n\t\tsuper(config);\r\n\t\tthis._setFeatureSource();\r\n\t}\r\n\r\n\t_setFeatureSource(){\r\n\t\tthis.feature_source=new _bigwig_js__WEBPACK_IMPORTED_MODULE_0__[\"BWSource\"](this.config);\t\r\n\t}\r\n\r\n\r\n\tdrawScale(pixel_height,ctx){\r\n\t\tif (this.config.scale_link_to){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet bot= pixel_height;\r\n\t\tlet top = 0;\r\n\t\tif (this.scale_link_to){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (this.config.discrete){\r\n\t\t\ttop=this.top;\r\n\t\t\tbot = this.bottom;\r\n\t\t}\r\n\t\tlet range=this.max_y-this.min_y;\r\n\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(0,top);\r\n\t\tctx.lineTo(0,bot);\r\n\t\tctx.moveTo(0,top);\r\n\t\tctx.lineTo(20,top);\r\n\t\tctx.moveTo(0,bot);\r\n\t\tctx.lineTo(20,bot);\r\n\t\tctx.font=\"12px Arial\";\r\n\t\tctx.stroke();\r\n\t\tctx.textBaseline=\"top\";\r\n\t\tctx.fillText(this.max_y.toFixed(2),20,top);\r\n\t\tctx.textBaseline=\"alphabetic\";\r\n\t\tctx.fillText(this.min_y,20,bot);\r\n\r\n\t}\r\n\t\r\n\tdrawFeatures(options) {\r\n\t\tlet self = this,\r\n\t    features = options.features,\r\n\t    color=self.config.color,\r\n\t    ctx = options.context,\r\n\t    bpPerPixel = options.bpPerPixel,\r\n\t    bpStart = options.bpStart,\r\n\t    pixelWidth = options.pixelWidth,\r\n\t    pixelHeight =options.pixelHeight,\r\n\t    y_offset=this.config.discrete?options.top:0,\r\n\t    bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\r\n\t    featureValueMinimum,\r\n\t    featureValueMaximum,\r\n\t    featureValueRange,\r\n\t    $dataRangeTrackLabel,\r\n\t    str,\r\n\t    min,\r\n\t    max;\r\n\t    if (this.config.group){\r\n\t    \t\tpixelHeight=options.height;\r\n\t    }\r\n\t    else if(this.config.discrete){\r\n\t    \t\tpixelHeight=this.config.height;\t\r\n\t    }\r\n\t          \r\n\t    if (!color){\r\n\t    \tcolor=\"black\";       \r\n\t    }\r\n\t    self.prev_coords={x:0,y:0};\r\n\t\t\r\n\t    if (features) {\r\n\t    \tif (self.scale_link_to){\r\n\t    \t\tlet t = self.scale_link_to.config;\r\n\t            if (t){\r\n\t            \tself.config.scale=t.scale;\r\n\t                self.max_y=self.scale_link_to.max_y;\r\n\t                self.min_y=self.scale_link_to.min_y;\r\n\t            }\r\n\t       }\r\n\t       else if ( (self.max_y === undefined && self.config.scale===\"automatic\") || self.config.scale===\"dynamic\"){\r\n\t                var s = autoscale(features);\r\n\t                self.min_y = s.min;\r\n\t                self.max_y = s.max;\r\n\t            }\r\n\t            else if (self.config.scale===\"fixed\") {\r\n\t                self.min_y = self.config.min_y;\r\n\t                self.max_y=self.config.max_y;\r\n\t            }\r\n\t          \r\n\t            featureValueRange = self.max_y - self.min_y;\r\n\r\n\t            //$dataRangeTrackLabel = $(this.trackView.trackDiv).find('.igv-data-range-track-label');\r\n\t            //\r\n\t            //min = (Math.floor(track.dataRange.min) === track.dataRange.min) ? track.dataRange.min : track.dataRange.min.toFixed(2);\r\n\t            //max = (Math.floor(track.dataRange.max) === track.dataRange.max) ? track.dataRange.max : track.dataRange.max.toFixed(2);\r\n\t            //str = '[' + min + ' - ' + max + ']';\r\n\t            //\r\n\t            //$dataRangeTrackLabel.text(str);\r\n\t            let prev_x=0;\r\n\t            let prev_y=0;\r\n\t            ctx.globalAlpha   = this.config.opacity?this.config.opacity:1;\r\n\t            if (self.is_line){  \r\n\t                let y = (1.0 - self.config.value / featureValueRange)*pixelHeight;\r\n\t                Graphics.strokeLine(ctx,0,y,pixelWidth,y,{\"strokeStyle\":self.config.color,\"lineWidth\":self.config.width?self.config.width:1});\r\n\t             }\r\n\t            else{\r\n\t            \tfeatures.forEach(renderFeature);\r\n\t            }\r\n\t            ctx.globalAlpha=1\r\n\t        }\r\n\t         \r\n\t        function renderFeature(feature, index, featureList) {\r\n\r\n\t            var yUnitless,\r\n\t                heightUnitLess,\r\n\t                x,\r\n\t                y,\r\n\t                width,\r\n\t                height,\r\n\t                rectEnd,\r\n\t                rectBaseline;\r\n\r\n\t            if (feature.end < bpStart) return;\r\n\t            if (feature.start > bpEnd) return;\r\n\r\n\t            x = Math.floor((feature.start - bpStart) / bpPerPixel);\r\n\t            rectEnd = Math.floor((feature.end - bpStart) / bpPerPixel);\r\n\t            width = Math.max(0, rectEnd - x);\r\n\r\n\t            //height = ((feature.value - featureValueMinimum) / featureValueRange) * pixelHeight;\r\n\t            //rectBaseline = pixelHeight - height;\r\n\t            //canvas.fillRect(rectOrigin, rectBaseline, rectWidth, rectHeight, {fillStyle: track.color});\r\n\r\n\t            if (signsDiffer(self.min_y, self.max_y)) {\r\n\r\n\t                if (feature.value < 0) {\r\n\t                    yUnitless = self.max_y/ featureValueRange;\r\n\t                    heightUnitLess = -feature.value / featureValueRange;\r\n\t                } else {\r\n\t                    yUnitless = ((self.max_y - feature.value) / featureValueRange);\r\n\t                    heightUnitLess = feature.value / featureValueRange;\r\n\t                }\r\n\r\n\t            }\r\n\t            else if (self.min_y < 0) {\r\n\t                yUnitless = 0;\r\n\t                heightUnitLess = -feature.value / featureValueRange;\r\n\t            }\r\n\t            else {\r\n\t                yUnitless = 1.0 - ((feature.value-self.min_y) / featureValueRange);\r\n\t                heightUnitLess = (feature.value+self.min_y) / featureValueRange;\r\n\t            }\r\n\r\n\t           \ty = (yUnitless*pixelHeight)+y_offset;\r\n\t            y=y<y_offset?y_offset:y;\r\n\t            height=heightUnitLess * pixelHeight;\r\n\t            height=height>pixelHeight?pixelHeight:height\r\n\r\n\t            //canvas.fillRect(x, yUnitless * pixelHeight, width, heightUnitLess * pixelHeight, { fillStyle: igv.randomRGB(64, 255) });\r\n\t            if (self.config.display==='line'){\r\n\t                 if (self.prev_coords.x){\r\n\t                    Graphics.strokeLine(ctx,x,y,self.prev_coords.x,self.prev_coords.y,{\"strokeStyle\":color,\"lineWidth\":3});\r\n\r\n\t                }\r\n\t                self.prev_coords.x=x;\r\n\t                self.prev_coords.y=y;\r\n\t            }\r\n\t            else{\r\n\t                Graphics.fillRect(ctx, x, y, width, height, {fillStyle: color});\r\n\t            }\r\n\t        }\r\n\t         function autoscale(features) {\r\n        var min = 0,\r\n            max = -Number.MAX_VALUE;\r\n\r\n        features.forEach(function (f) {\r\n            min = Math.min(min, f.value);\r\n            max = Math.max(max, f.value);\r\n        });\r\n\r\n        return {min: min, max: max};\r\n\r\n    }\r\n\r\n    function signsDiffer(a, b) {\r\n        return (a > 0 && b < 0 || a < 0 && b > 0);\r\n    }\r\n    this.top=y_offset;\r\n    this.bottom=y_offset+pixelHeight;\r\n    if (this.config.discrete){\r\n    \treturn this.bottom;\r\n    }\r\n    else{\r\n    \tthis.top=0;\r\n    \tthis.bottom=0;\r\n    }\r\n\r\n\t    \r\n}\r\n}\r\n class LineTrack extends MLVWigTrack{\r\n\t constructor(config){\r\n\t\t super(config);\r\n\t\t this.is_line=true;\r\n\t }\r\n\t \r\n\t getFeatures(chr, bpStart, bpEnd) {\r\n\t\t return new Promise(function (fulfill, reject) {\r\n\t\t\t fulfill([]);\r\n\t     });\r\n\t }\r\n\t \r\n\t \r\n }\r\n\r\n\r\n\r\n\r\nclass SequenceTrack extends MLVTrack{\r\n    constructor(config){\r\n\t\tsuper(config) \r\n        this._setFeatureSource(config);\r\n        this.sequenceType = config.sequenceType || \"dna\";  \r\n        this.height = 15;\r\n    }\r\n\r\n    _setFeatureSource(config){\r\n    \tthis.feature_source = new _feature_js__WEBPACK_IMPORTED_MODULE_1__[\"FastaSequence\"](config.url);\r\n    }\r\n\r\n\r\n\r\n    getFeatures(chr, bpStart, bpEnd,force,data) {\r\n\t\tlet self = this;\r\n        return new Promise(function (fulfill, reject) {\r\n            if (data.bpPerPixel > 1/*igv.browser.trackViewportWidthBP() > 30000*/) {\r\n                fulfill(null);\r\n            }\r\n            else {\r\n                self.feature_source.getSequence(chr, bpStart, bpEnd).then(fulfill).catch(reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    drawFeatures(options) {\r\n\r\n        var sequence = options.features,\r\n            ctx = options.context,\r\n            bpPerPixel = options.bpPerPixel,\r\n            bpStart = options.bpStart,\r\n            pixelWidth = options.pixelWidth,\r\n            bpEnd = bpStart + pixelWidth * bpPerPixel + 1,\r\n            len, w, y, pos, offset, b, p0, p1, pc, c;\r\n\r\n        let y_pos1=options.top;\r\n        let y_pos2=y_pos1+5;\r\n\r\n        if (sequence) {\r\n\r\n            len = sequence.length;\r\n            w = 1 / bpPerPixel;\r\n\r\n            y = y_pos1+this.height / 2;\r\n            for (pos = bpStart; pos <= bpEnd; pos++) {\r\n\r\n                offset = pos - bpStart;\r\n                if (offset < len) {\r\n//                            var b = sequence.charAt(offset);\r\n                    b = sequence[offset];\r\n                    p0 = Math.floor(offset * w);\r\n                    p1 = Math.floor((offset + 1) * w);\r\n                    pc = Math.round((p0 + p1) / 2);\r\n\r\n                    if (this.color) {\r\n                        c = this.color;\r\n                    }\r\n                    else if (\"dna\" === this.sequenceType) {\r\n                        c = Graphics.nucleotideColors[b];\r\n                    }\r\n                    else {\r\n                        c = \"rgb(0, 0, 150)\";\r\n                    }\r\n\r\n                    if (!c) c = \"gray\";\r\n\r\n                    if (bpPerPixel >0.15) {\r\n\r\n                        Graphics.fillRect(ctx, p0, y_pos1, p1 - p0, 10, {fillStyle: c});\r\n                    }\r\n                    else {\r\n\r\n                        Graphics.strokeText(ctx, b, pc, y, {\r\n                            strokeStyle: c,\r\n                            font: 'normal 10px Arial',\r\n                            textAlign: 'center'\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n      return y_pos1+10;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n//*******js/ifv-canvas.js***********************\r\n\r\n\r\nclass Graphics{\r\n\r\n\r\n       static setProperties(ctx, properties) {\r\n\r\n            for (var key in properties) {\r\n                if (properties.hasOwnProperty(key)) {\r\n                    var value = properties[key];\r\n                    ctx[key] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        static strokeLine (ctx, x1, y1, x2, y2, properties) {\r\n\r\n            x1 = Math.floor(x1) + 0.5;\r\n            y1 = Math.floor(y1) + 0.5;\r\n            x2 = Math.floor(x2) + 0.5;\r\n            y2 = Math.floor(y2) + 0.5;\r\n\r\n            //log(\"stroke line, prop: \" + properties);\r\n\r\n            ctx.save();\r\n            if (properties) Graphics.setProperties(ctx, properties);\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(x1, y1);\r\n            ctx.lineTo(x2, y2);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n\r\n        static fillRect(ctx, x, y, w, h, properties) {\r\n\r\n            var c;\r\n            x = Math.round(x);\r\n            y = Math.round(y);\r\n\r\n            if (properties) {\r\n                ctx.save();\r\n                Graphics.setProperties(ctx, properties);\r\n            }\r\n            \r\n            ctx.fillRect(x, y, w, h);\r\n\r\n            if (properties) ctx.restore();\r\n        }\r\n\r\n        static fillPolygon(ctx, x, y, properties) {\r\n            ctx.save();\r\n            if (properties)   Graphics.setProperties(ctx, properties);\r\n            Graphics.doPath(ctx, x, y);\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        static strokePolygon(ctx, x, y, properties) {\r\n            ctx.save();\r\n            if (properties)   Graphics.setProperties(ctx, properties);\r\n            Graphics.doPath(ctx, x, y);\r\n            ctx.stroke();\r\n            ctx.restore();\r\n        }\r\n\r\n        static fillText(ctx, text, x, y, properties, transforms) {\r\n\r\n            if (properties) {\r\n                ctx.save();\r\n                Graphics.setProperties(ctx, properties);\r\n            }\r\n\r\n\r\n            ctx.save();\r\n\r\n            ctx.translate(x, y);\r\n            if (transforms) {\r\n\r\n                for (var transform in transforms) {\r\n                    var value = transforms[transform];\r\n\r\n                    // TODO: Add error checking for robustness\r\n                    if (transform == 'translate') {\r\n                        ctx.translate(value['x'], value['y']);\r\n                    }\r\n                    if (transform == 'rotate') {\r\n                        ctx.rotate(value['angle'] * Math.PI / 180);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            ctx.fillText(text, 0, 0);\r\n            ctx.restore();\r\n\r\n            if (properties) ctx.restore();\r\n\r\n        }\r\n\r\n        static strokeText(ctx, text, x, y, properties, transforms) {\r\n\r\n\r\n            ctx.save();\r\n            if (properties) {\r\n                Graphics.setProperties(ctx, properties);\r\n            }\r\n\r\n\r\n            ctx.translate(x, y);\r\n            if (transforms) {\r\n\r\n                for (var transform in transforms) {\r\n                    var value = transforms[transform];\r\n\r\n                    // TODO: Add error checking for robustness\r\n                    if (transform == 'translate') {\r\n                        ctx.translate(value['x'], value['y']);\r\n                    }\r\n                    if (transform == 'rotate') {\r\n                        ctx.rotate(value['angle'] * Math.PI / 180);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            ctx.strokeText(text, 0, 0);\r\n            ctx.restore();\r\n\r\n        }\r\n\r\n        static strokeCircle(ctx, x, y, radius) {\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\r\n            ctx.stroke();\r\n        }\r\n\r\n        static fillCircle (ctx, x, y, radius) {\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\r\n            ctx.fill();\r\n        }\r\n\r\n        static drawArrowhead(ctx, x, y, size, lineWidth) {\r\n\r\n            ctx.save();\r\n            if (!size) {\r\n                size = 5;\r\n            }\r\n            if (lineWidth) {\r\n                ctx.lineWidth = lineWidth;\r\n            }\r\n            ctx.beginPath();\r\n            ctx.moveTo(x, y - size / 2);\r\n            ctx.lineTo(x, y + size / 2);\r\n            ctx.lineTo(x + size, y);\r\n            ctx.lineTo(x, y - size / 2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.restore();\r\n        }\r\n\r\n        static dashedLine(ctx, x1, y1, x2, y2, dashLen, properties) {\r\n            ctx.save();\r\n            x1 = Math.round(x1);\r\n            y1 = Math.round(y1);\r\n            x2 = Math.round(x2);\r\n            y2 = Math.round(y2);\r\n            dashLen = Math.round(dashLen);\r\n            log(\"dashedLine\");\r\n            if (properties) Graphics.setProperties(ctx, properties);\r\n\r\n            if (dashLen == undefined) dashLen = 2;\r\n            ctx.moveTo(x1, y1);\r\n\r\n            var dX = x2 - x1;\r\n            var dY = y2 - y1;\r\n            var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);\r\n            var dashX = dX / dashes;\r\n            var dashY = dY / dashes;\r\n\r\n            var q = 0;\r\n            while (q++ < dashes) {\r\n                x1 += dashX;\r\n                y1 += dashY;\r\n                ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x1, y1);\r\n            }\r\n            ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](x2, y2);\r\n\r\n            ctx.restore();\r\n        }\r\n\r\n\r\n    \r\n\r\n        static doPath(ctx, x, y) {\r\n\r\n\r\n        \tvar i, len = x.length;\r\n        \tfor (i = 0; i < len; i++) {\r\n        \t\tx[i] = Math.round(x[i]);\r\n        \t\ty[i] = Math.round(y[i]);\r\n        \t}\r\n\r\n        \tctx.beginPath();\r\n        \tctx.moveTo(x[0], y[0]);\r\n        \tfor (i = 1; i < len; i++) {\r\n        \t\tctx.lineTo(x[i], y[i]);\r\n        \t}\r\n        \tctx.closePath();\r\n        }\r\n\r\n}\r\n\r\nGraphics.nucleotideColors={\r\n\t\"A\":\"green\",\r\n\t\"T\":\"red\",\r\n\t\"G\":\"black\",\r\n\t\"C\":\"blue\",\r\n\t\"a\":\"green\",\r\n\t\"t\":\"red\",\r\n\t\"c\":\"black\",\r\n\t\"g\":\"blue\"\r\n\r\n}\r\n\r\n\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! extend */ \"extend\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHJhY2tzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3RyYWNrcy5qcz8yOWQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgQnJvYWQgSW5zdGl0dXRlXHJcbiAqXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxyXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXHJcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gKlxyXG4gKlxyXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAqIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcblxyXG5cclxuXHJcblxyXG5pbXBvcnQge0JXU291cmNlfSBmcm9tIFwiLi9iaWd3aWcuanNcIjtcclxuaW1wb3J0IHtGZWF0dXJlU291cmNlLEZhc3RhU2VxdWVuY2UsQmlnQmVkRmVhdHVyZVNvdXJjZSxUYWJpeEJlZEZlYXR1cmVTb3VyY2V9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcclxuXHJcblxyXG5jbGFzcyBNTFZUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0dGhpcy5jb25maWc9Y29uZmlnO1xyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdC8vb3ZlcnJpZGVuIGJ5IHRyYWNrcyB3aXRoIGZlYXR1cmUgc291cmNlc1xyXG5cdH1cclxuXHJcblx0ZHJhd1NjYWxlKGN0eCl7XHJcblx0XHQvL292ZXJpZGRlbiBpbiB0cmFja3Mgd2l0aCBzY2FsZVxyXG5cdH1cclxuXHJcblx0Z2V0Q29uZmlnKCl7XHJcblx0XHRyZXR1cm4gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuY29uZmlnKTtcclxuXHR9XHJcblxyXG5cdHNldENvbmZpZ0F0dHJpYnV0ZShhdHRyaWJ1dGUsdmFsdWUpe1xyXG5cdFx0dGhpcy5jb25maWdbYXR0cmlidXRlXT12YWx1ZTtcclxuICAgIFx0aWYgKGF0dHJpYnV0ZT09PVwidXJsXCIpe1xyXG4gICAgXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuICAgIFx0fVxyXG4gICAgfVxyXG4gICAgZ2V0RmVhdHVyZUF0KGdlbm9taWNMb2NhdGlvbiwgY2hyLHlPZmZzZXQsIGJwUGVyUGl4ZWwpe1xyXG4gICAgXHRyZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRDb25maWcoY29uZmlnKXtcclxuICAgIFx0aWYgKHRoaXMuY29uZmlnLnVybCAhPT0gY29uZmlnLnVybCl7XHJcbiAgICBcdFx0dGhpcy5jb25maWc9Y29uZmlnO1xyXG4gICAgXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuICAgIFx0fVxyXG4gICAgXHRlbHNle1xyXG4gICAgXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuICAgIFx0fVxyXG4gICAgfVxyXG5cclxuICAgICAvKipcclxuXHQqIFJldGVpdmVzIHRoZSBmZWF0dXJlcyByZXF1ZXN0ZWQsIHRoZSBkZWZhdWx0IGlzIGp1c3QgdG8gZ2V0IHRoZSBmZWF0dXJlc1xyXG5cdCogZnJvbSB0aGUgZmVhdHVyZSBzb3VyY2UgXHJcblx0KiBAcGFyYW0ge3N0cmluZ30gY2hyIC0gVGhlIGNocm9tb3NvbWUgXHJcblx0KiBAcGFyYW0ge2ludGVnZXJ9IHN0YXJ0IC0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSBmcm9tIHdoaWNoIHRvIG9idGFpbiBmZWF0dXJlc1xyXG5cdCogQHBhcmFtIHtpbnRlZ2VyfSBlbmQgLSBUaGUgZW5kIG9mIHRoZSByYW5nZSBmcm9tIHdoaWNoIHRvIG9idGFpbiBmZWF0dXJlcyBcclxuXHQqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgLSBJZiB0cnVlIHRoZW4gY2FjaGVkIGZlYXR1cmVzIHNob3VsZCBub3QgYmUgdXNlZFxyXG5cdCogYnV0IGZyZXNoIGZlYXR1cmVzIHJldHJpZXZlZFxyXG5cdCogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBjb250YWlucyBicCAgYmVyIHBpeGVsIGFuZCB3aWR0aCBvZiB0aGUgY2FudmFzIFxyXG5cdCovXHJcblx0Z2V0RmVhdHVyZXMgKGNociwgYnBTdGFydCwgYnBFbmQsZm9yY2UsZGF0YSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZ2V0RmVhdHVyZXMoY2hyLGJwU3RhcnQsYnBFbmQsZm9yY2UsZGF0YSk7XHJcblx0fVxyXG5cclxuXHJcblx0c3RhdGljIGNhbGN1bGF0ZUxhYmVsKHVybCl7XHJcblx0XHRpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIil7XHJcblx0XHRcdHVybCA9IHVybFswXTtcclxuXHRcdH1cclxuXHRcdGxldCBhcnIgPXVybC5zcGxpdChcIi9cIik7XHJcblx0XHRsZXQgbGFiZWw9IGFyclthcnIubGVuZ3RoLTFdO1xyXG5cdFx0YXJyPSBsYWJlbC5zcGxpdChcIi5cIik7XHJcblx0XHRsYWJlbCA9IGFyclswXTtcclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9XHJcblxyXG5cdGFkZEV4dHJhQ29udHJvbHMoZGl2LHBhbmVsKXtcclxuXHR9XHJcblxyXG5cdHN0YXRpYyBnZXRUeXBlRnJvbVVSTCh1cmwpe1xyXG5cdFx0bGV0IGNvbmZpZz17fVxyXG5cdFx0aWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpe1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnO1xyXG5cdFx0fVxyXG5cdFx0XHRpZiAodXJsLmVuZHNXaXRoKFwiYndcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmlnd2lnXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cIndpZ1wiO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHVybC5lbmRzV2l0aChcIi5iZWQuZ3pcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmVkXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIlxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh1cmwuZW5kc1dpdGgoXCIuYmJcIikgJiYgIShjb25maWcudHlwZSkpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiYmlnYmVkXCI7XHJcblx0XHRcdFx0Y29uZmlnLmZvcm1hdD1cImZlYXR1cmVcIlxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh1cmwuZW5kc1dpdGgoXCIuZmFzdGFcIikpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPVwiZmFzdGFcIjtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PVwic2VxdWVuY2VcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh1cmwuZW5kc1dpdGgoXCIuYmFtXCIpKXtcclxuXHRcdFx0XHRjb25maWcudHlwZT1cImJhbVwiO1xyXG5cdFx0XHRcdGNvbmZpZy5mb3JtYXQ9XCJhbGlnbm1lbnRcIjtcclxuXHRcdFx0fVxyXG5cdFx0cmV0dXJuIGNvbmZpZztcclxuXHJcblx0fVxyXG5cclxuXHRzdGF0aWMgcGFyc2VDb25maWcoY29uKXtcclxuXHRcdGxldCBjb25maWcgPSAkLmV4dGVuZCh0cnVlLCB7fSxjb24pO1xyXG5cdFx0XHJcblx0XHRpZiAoIShjb25maWcudHlwZSkgJiYgY29uZmlnLnVybCl7XHJcblx0XHRcdGxldCBpbmZvID0gTUxWVHJhY2suZ2V0VHlwZUZyb21VUkwoY29uZmlnLnVybCk7XHJcblx0XHRcdGlmIChpbmZvLnR5cGUpe1xyXG5cdFx0XHRcdGNvbmZpZy50eXBlPWluZm8udHlwZTtcclxuXHRcdFx0XHRjb25maWcuZm9ybWF0PWluZm8uZm9ybWF0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAoIWNvbmZpZy5zaG9ydF9sYWJlbCAmJiBjb25maWcudXJsKXtcclxuXHRcdFx0Y29uZmlnLnNob3J0X2xhYmVsPU1MVlRyYWNrLmNhbGN1bGF0ZUxhYmVsKGNvbmZpZy51cmwpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRpZiAoIWNvbmZpZy50cmFja19pZCl7XHJcblx0XHRcdGNvbmZpZy50cmFja19pZD1jb25maWcudXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb25maWcuZm9ybWF0PT09XCJmZWF0dXJlXCIpe1xyXG5cdFx0XHRjb25maWcuZGlzcGxheU1vZGUgPSBjb25maWcuZGlzcGxheU1vZGUgfHwgXCJDT0xMQVBTRURcIjsgICAgLy8gQ09MTEFQU0VEIHwgRVhQQU5ERUQgfCBTUVVJU0hFRFxyXG4gICAgICAgIFx0Y29uZmlnLmxhYmVsRGlzcGxheU1vZGUgPSBcIlNMQU5UXCI7XHJcbiAgICAgICAgXHRjb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0ID0gY29uZmlnLnNxdWlzaGVkQ2FsbEhlaWdodCB8fCAzMDtcclxuICAgICAgICBcdGNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgPSBjb25maWcuZXhwYW5kZWRDYWxsSGVpZ2h0IHx8IDE1O1xyXG4gICAgICAgIFx0Y29uZmlnLmZlYXR1cmVIZWlnaHQ9Y29uZmlnLmZlYXR1cmVIZWlnaHQgfHwgMTI7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5mb3JtYXQ9PT1cIndpZ1wiKXtcclxuXHRcdFx0aWYgKCFjb25maWcuc2NhbGUpe1xyXG5cdFx0XHRcdGNvbmZpZy5zY2FsZT1cImR5bmFtaWNcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWNvbmZpZy5taW5feSl7XHJcblx0XHRcdFx0Y29uZmlnLm1pbl95PTA7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFjb25maWcubWF4eV95KXtcclxuXHRcdFx0XHRjb25maWcubWF4X3k9MTAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghY29uZmlnLmhlaWdodCl7XHJcblx0XHRcdFx0Y29uZmlnLmhlaWdodD0xMDA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChjb25maWcudHlwZT09PVwiYmFtXCIpe1xyXG5cdFx0XHRpZiAoIWNvbmZpZy5mZWF0dXJlSGVpZ2h0KXtcclxuXHRcdFx0XHRjb25maWcuZmVhdHVyZUhlaWdodD0xMjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY29uZmlnLmNvbG9yKXtcclxuXHRcdFx0aWYgKGNvbmZpZy50eXBlPT09XCJiYW1cIil7XHJcblx0XHRcdFx0Y29uZmlnLmNvbG9yPVwiI0QzRDNEM1wiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2V7XHJcblx0XHRcdFx0Y29uZmlnLmNvbG9yPVwiYmxhY2tcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKCFjb25maWcub3BhY2l0eSl7XHJcblx0XHRcdGNvbmZpZy5vcGFjaXR5PTEuMDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb25maWc7XHJcblx0fVxyXG5cclxuXHJcblx0XHJcblx0c3RhdGljIGdldFRyYWNrKGNvbmZpZyl7XHJcblxyXG5cdFx0Y29uZmlnPU1MVlRyYWNrLnBhcnNlQ29uZmlnKGNvbmZpZyk7XHJcblx0XHRcclxuXHRcdGlmIChjb25maWcudHlwZT09PVwiYmlnd2lnXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IE1MVldpZ1RyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChjb25maWcudHlwZT09PVwiYmVkXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IE1MVkJlZFRyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChjb25maWcudHlwZT09PVwidWNzY1wiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBVQ1NDVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbmZpZy50eXBlPT09XCJsaW5lXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IExpbmVUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29uZmlnLnR5cGU9PT1cImJpZ2JlZFwiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBNTFZCaWdCZWRUcmFjayhjb25maWcpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoY29uZmlnLnR5cGU9PT1cInJ1bGVyXCIpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJ1bGVyVHJhY2soY29uZmlnKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGNvbmZpZy50eXBlPT09XCJmYXN0YVwiKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBTZXF1ZW5jZVRyYWNrKGNvbmZpZyk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGVsc2V7XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgY2xhc3NfdHlwZSA9IE1MVlRyYWNrLmN1c3RvbV90cmFja3NbY29uZmlnLnR5cGVdO1xyXG5cdFx0XHRpZiAoY2xhc3NfdHlwZSl7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBjbGFzc190eXBlKGNvbmZpZyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cdFx0XHJcbn1cclxuXHJcbk1MVlRyYWNrLmN1c3RvbV90cmFja3M9e307XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8qKioqKioqKioqKioqKioqKioqanMvcnVsZXJUcmFjay5qcyoqKioqKioqKioqKioqKioqKioqKipcclxuXHJcblxyXG5jbGFzcyBSdWxlclRyYWNrIGV4dGVuZHMgTUxWVHJhY2t7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdGlmICghY29uZmlnKXtcclxuXHRcdFx0Y29uZmlnPXtcInRyYWNrX2lkXCI6XCJydWxlclwiK1J1bGVyVHJhY2suY291bnQsZm9ybWF0OlwicnVsZXJcIixzaG9ydF9sYWJlbDpcIlJ1bGVyXCIsdHlwZTpcInJ1bGVyXCJ9O1xyXG5cdFx0fVxyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDMwO1xyXG4gICAgICAgIHRoaXMuY29uZmlnLmhlaWdodD0zMDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xyXG4gICAgICAgXHJcbiAgICAgICAgdGhpcy5kaXNhYmxlQnV0dG9ucyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVUcmFja01lbnUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMub3JkZXIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgXHJcbiAgICAgICAgUnVsZXJUcmFjay5jb3VudCsrO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZlYXR1cmVzKGNociwgYnBTdGFydCwgYnBFbmQpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVsZmlsbChbXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIGZvbnRTdHlsZSxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgICAgdHMsXHJcbiAgICAgICAgICAgIHNwYWNpbmcsXHJcbiAgICAgICAgICAgIG5UaWNrLFxyXG4gICAgICAgICAgICB4O1xyXG5cclxuICAgICAgICBmb250U3R5bGUgPSB7IHRleHRBbGlnbjogJ2NlbnRlcicsIGZvbnQ6ICcxMHB4IFBUIFNhbnMnLCBmaWxsU3R5bGU6IFwicmdiYSg2NCwgNjQsIDY0LCAxKVwiLCBzdHJva2VTdHlsZTogXCJyZ2JhKDY0LCA2NCwgNjQsIDEpXCIgfTtcclxuXHJcbiAgICAgICAgcmFuZ2UgPSBNYXRoLmZsb29yKDExMDAgKiBvcHRpb25zLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgIHRzID0gUnVsZXJUcmFjay5maW5kU3BhY2luZyhyYW5nZSk7XHJcbiAgICAgICAgc3BhY2luZyA9IHRzLm1ham9yVGljaztcclxuXHJcbiAgICAgICAgLy8gRmluZCBzdGFydGluZyBwb2ludCBjbG9zZXN0IHRvIHRoZSBjdXJyZW50IG9yaWdpblxyXG4gICAgICAgIG5UaWNrID0gTWF0aC5mbG9vcihvcHRpb25zLmJwU3RhcnQgLyBzcGFjaW5nKSAtIDE7XHJcbiAgICAgICAgeCA9IDA7XHJcblx0XHRsZXQgeV9wb3M9b3B0aW9ucy50b3ArdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgLy9jYW52YXMuc2V0UHJvcGVydGllcyh7dGV4dEFsaWduOiAnY2VudGVyJ30pO1xyXG4gICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBmb250U3R5bGUgKTtcclxuICAgICAgICB3aGlsZSAoeCA8IG9wdGlvbnMucGl4ZWxXaWR0aCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGwgPSBNYXRoLmZsb29yKG5UaWNrICogc3BhY2luZyksXHJcbiAgICAgICAgICAgICAgICBzaGltID0gMjtcclxuXHJcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKCgobCAtIDEpIC0gb3B0aW9ucy5icFN0YXJ0ICsgMC41KSAvIG9wdGlvbnMuYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgIHZhciBjaHJQb3NpdGlvbiA9IGZvcm1hdE51bWJlcihsIC8gdHMudW5pdE11bHRpcGxpZXIsIDApICsgXCIgXCIgKyB0cy5tYWpvclVuaXQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoblRpY2sgJSAxID09IDApIHtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxUZXh0KGN0eCwgY2hyUG9zaXRpb24sIHgsIHlfcG9zIC0gMTUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCwgeV9wb3MgLSAxMCwgeCwgeV9wb3MgLSBzaGltKTtcclxuXHJcbiAgICAgICAgICAgIG5UaWNrKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCAwLCB5X3BvcyAtIHNoaW0sIG9wdGlvbnMucGl4ZWxXaWR0aCwgeV9wb3MgLSBzaGltKTtcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihhbnludW0sIGRlY2ltYWwpIHtcclxuICAgICAgICAgICAgLy9kZWNpbWFsICAtIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgYWZ0ZXIgdGhlIGRpZ2l0IGZyb20gMCB0byAzXHJcbiAgICAgICAgICAgIC8vLS0gUmV0dXJucyB0aGUgcGFzc2VkIG51bWJlciBhcyBhIHN0cmluZyBpbiB0aGUgeHh4LHh4eC54eCBmb3JtYXQuXHJcbiAgICAgICAgICAgIC8vYW55bnVtID0gZXZhbChvYmoudmFsdWUpO1xyXG4gICAgICAgICAgICB2YXIgZGl2aWRlciA9IDEwO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGRlY2ltYWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlciA9IDEwMDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgIC8vZm9yIDMgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVyID0gMTAwMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHdvcmtOdW0gPSBNYXRoLmFicygoTWF0aC5yb3VuZChhbnludW0gKiBkaXZpZGVyKSAvIGRpdmlkZXIpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB3b3JrU3RyID0gXCJcIiArIHdvcmtOdW1cclxuXHJcbiAgICAgICAgICAgIGlmICh3b3JrU3RyLmluZGV4T2YoXCIuXCIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JrU3RyICs9IFwiLlwiXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkU3RyID0gd29ya1N0ci5zdWJzdHIoMCwgd29ya1N0ci5pbmRleE9mKFwiLlwiKSk7XHJcbiAgICAgICAgICAgIHZhciBkTnVtID0gZFN0ciAtIDBcclxuICAgICAgICAgICAgdmFyIHBTdHIgPSB3b3JrU3RyLnN1YnN0cih3b3JrU3RyLmluZGV4T2YoXCIuXCIpKVxyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHBTdHIubGVuZ3RoIC0gMSA8IGRlY2ltYWwpIHtcclxuICAgICAgICAgICAgICAgIHBTdHIgKz0gXCIwXCJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHBTdHIgPT0gJy4nKSBwU3RyID0gJyc7XHJcblxyXG4gICAgICAgICAgICAvLy0tLSBBZGRzIGEgY29tbWEgaW4gdGhlIHRob3VzYW5kcyBwbGFjZS5cclxuICAgICAgICAgICAgaWYgKGROdW0gPj0gMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRMZW4gPSBkU3RyLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgZFN0ciA9IHBhcnNlSW50KFwiXCIgKyAoZE51bSAvIDEwMDApKSArIFwiLFwiICsgZFN0ci5zdWJzdHJpbmcoZExlbiAtIDMsIGRMZW4pXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLS0gQWRkcyBhIGNvbW1hIGluIHRoZSBtaWxsaW9ucyBwbGFjZS5cclxuICAgICAgICAgICAgaWYgKGROdW0gPj0gMTAwMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgZExlbiA9IGRTdHIubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBkU3RyID0gcGFyc2VJbnQoXCJcIiArIChkTnVtIC8gMTAwMDAwMCkpICsgXCIsXCIgKyBkU3RyLnN1YnN0cmluZyhkTGVuIC0gNywgZExlbilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gZFN0ciArIHBTdHJcclxuICAgICAgICAgICAgLy8tLSBQdXQgbnVtYmVycyBpbiBwYXJlbnRoZXNlcyBpZiBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgaWYgKGFueW51bSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IFwiKFwiICsgcmV0dmFsICsgXCIpXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vWW91IGNvdWxkIGluY2x1ZGUgYSBkb2xsYXIgc2lnbiBpbiB0aGUgcmV0dXJuIHZhbHVlLlxyXG4gICAgICAgICAgICAvL3JldHZhbCA9ICBcIiRcIityZXR2YWxcclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHlfcG9zO1xyXG5cclxuXHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZmluZFNwYWNpbmcobWF4VmFsdWUpIHtcclxuXHJcbiAgICAgICAgaWYgKG1heFZhbHVlIDwgMTApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaWNrU3BhY2luZygxLCBcIlwiLCAxKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBOb3cgbWFuIHplcm9lcz9cclxuICAgICAgICB2YXIgblplcm9lcyA9IE1hdGguZmxvb3IobG9nMTAobWF4VmFsdWUpKTtcclxuICAgICAgICB2YXIgbWFqb3JVbml0ID0gXCJcIjtcclxuICAgICAgICB2YXIgdW5pdE11bHRpcGxpZXIgPSAxO1xyXG4gICAgICAgIGlmIChuWmVyb2VzID4gOSkge1xyXG4gICAgICAgICAgICBtYWpvclVuaXQgPSBcImdiXCI7XHJcbiAgICAgICAgICAgIHVuaXRNdWx0aXBsaWVyID0gMTAwMDAwMDAwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5aZXJvZXMgPiA2KSB7XHJcbiAgICAgICAgICAgIG1ham9yVW5pdCA9IFwibWJcIjtcclxuICAgICAgICAgICAgdW5pdE11bHRpcGxpZXIgPSAxMDAwMDAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoblplcm9lcyA+IDMpIHtcclxuICAgICAgICAgICAgbWFqb3JVbml0ID0gXCJrYlwiO1xyXG4gICAgICAgICAgICB1bml0TXVsdGlwbGllciA9IDEwMDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbk1ham9yVGlja3MgPSBtYXhWYWx1ZSAvIE1hdGgucG93KDEwLCBuWmVyb2VzIC0gMSk7XHJcbiAgICAgICAgaWYgKG5NYWpvclRpY2tzIDwgMjUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaWNrU3BhY2luZyhNYXRoLnBvdygxMCwgblplcm9lcyAtIDEpLCBtYWpvclVuaXQsIHVuaXRNdWx0aXBsaWVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRpY2tTcGFjaW5nKE1hdGgucG93KDEwLCBuWmVyb2VzKSAvIDIsIG1ham9yVW5pdCwgdW5pdE11bHRpcGxpZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9nMTAoeCkge1xyXG4gICAgICAgICAgICB2YXIgZG4gPSBNYXRoLmxvZygxMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIGRuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblJ1bGVyVHJhY2suY291bnQ9MDtcclxuXHJcbmNsYXNzIFRpY2tTcGFjaW5ne1xyXG5cdGNvbnN0cnVjdG9yKG1ham9yVGljaywgbWFqb3JVbml0LCB1bml0TXVsdGlwbGllcikge1xyXG4gICAgICAgIHRoaXMubWFqb3JUaWNrID0gbWFqb3JUaWNrO1xyXG4gICAgICAgIHRoaXMubWFqb3JVbml0ID0gbWFqb3JVbml0O1xyXG4gICAgICAgIHRoaXMudW5pdE11bHRpcGxpZXIgPSB1bml0TXVsdGlwbGllcjtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbiBcclxuY2xhc3MgTUxWQmVkVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuXHRjb25zdHJ1Y3Rvcihjb25maWcpe1xyXG5cdFx0c3VwZXIoY29uZmlnKTtcclxuXHRcdHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoKTtcclxuXHRcdHRoaXMuZmlsdGVyX2Z1bmN0aW9uPW51bGw7XHJcblx0XHR0aGlzLmNvbG9yX2Z1bmN0aW9uPW51bGw7XHJcblx0XHRcclxuXHR9XHJcblxyXG5cdF9zZXRGZWF0dXJlU291cmNlKCl7XHJcblx0XHR0aGlzLmZlYXR1cmVfc291cmNlPSBuZXcgVGFiaXhCZWRGZWF0dXJlU291cmNlKHRoaXMuY29uZmlnKVxyXG5cdH1cclxuXHJcblx0c2V0RmlsdGVyRnVuY3Rpb24oZnVuYyl7XHJcblx0XHR0aGlzLmZpbHRlcl9mdW5jdGlvbj1mdW5jO1xyXG5cdH1cclxuXHRzZXRDb2xvckZ1bmN0aW9uKGZ1bmMpe1xyXG5cdFx0dGhpcy5jb2xvcl9mdW5jdGlvbj1mdW5jO1xyXG5cdH1cclxuXHJcblx0Z2V0Q3VycmVudEZlYXR1cmVzKGNocixzdGFydCxlbmQpe1xyXG5cdFx0cmV0dXJuIHRoaXMuZmVhdHVyZV9zb3VyY2UuZmVhdHVyZUNhY2hlLnF1ZXJ5RmVhdHVyZXMoY2hyLHN0YXJ0LGVuZCk7XHJcblx0fVxyXG5cdFxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgbWF4X3lfdmFsPTA7XHJcbiAgICAgICAgdmFyIHRyYWNrID0gdGhpcyxcclxuICAgICAgICBcdHB5LFxyXG4gICAgICAgICAgICBmZWF0dXJlTGlzdCA9IG9wdGlvbnMuZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuICAgICAgICAgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuICAgICAgICAgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuICAgICAgICAgICAgcGl4ZWxIZWlnaHQgPSBvcHRpb25zLnBpeGVsSGVpZ2h0LFxyXG4gICAgICAgICAgICBvZmZzZXQ9MCxcclxuICAgICAgICAgICAgYnBFbmQgPSBicFN0YXJ0ICsgcGl4ZWxXaWR0aCAqIGJwUGVyUGl4ZWwgKyAxO1xyXG5cdCBcdGxldCB0b3A9MDtcclxuICAgICAgIFx0aWYob3B0aW9ucy50b3Ape1xyXG4gICAgICAgICAgIHRvcD1vcHRpb25zLnRvcDtcclxuICAgICAgIFx0fVxyXG4gICAgICAgXHR0aGlzLnRvcD10b3A7XHJcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZztcclxuICAgICAgICBsZXQgd2luZG93WCA9IDA7XHJcbiAgICAgICAgbGV0IHdpbmRvd1gxID0gd2luZG93WCArIHBpeGVsV2lkdGg7XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnLnNxdWlzaGVkQ2FsbEhlaWdodCA9IHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQrMTA7XHJcbiAgICAgICAgdGhpcy5jb25maWcuZXhwYW5kZWRDYWxsSGVpZ2h0ID0gKHRoaXMuY29uZmlnLmZlYXR1cmVIZWlnaHQvMikrMjtcclxuICAgICAgICBsZXQga2k9bnVsbDtcclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QubGVuZ3RoPjUwMDAwKXtcclxuICAgICAgICBcdGtpPU1hdGgucm91bmQoZmVhdHVyZUxpc3QubGVuZ3RoLzUwMDAwKSsxO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBpZiAoZmVhdHVyZUxpc3QpIHtcclxuICAgICAgICBcdGxldCBvcGFjaXR5ID0gdGhpcy5jb25maWcub3BhY2l0eT90aGlzLmNvbmZpZy5vcGFjaXR5OjE7XHJcbiAgICAgICAgXHRjdHguZ2xvYmFsQWxwaGE9b3BhY2l0eTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGdlbmUsIGkgPSAwLCBsZW4gPSBmZWF0dXJlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBcdGlmIChraSAmJiBpJWtpIT09MCl7XHJcbiAgICAgICAgICAgIFx0XHRjb250aW51ZTtcclxuICAgICAgICAgICAgXHR9XHJcbiAgICAgICAgICAgICAgICBnZW5lID0gZmVhdHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJfZnVuY3Rpb24gJiYgIXRoaXMuZmlsdGVyX2Z1bmN0aW9uKGdlbmUpKXtcclxuICAgICAgICAgICAgICAgIFx0Z2VuZS5kaXNwbGF5PWZhbHNlO1xyXG4gICAgICAgICAgICAgICAgXHRjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdlbmUuZGlzcGxheT10cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmUuZW5kIDwgYnBTdGFydCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VuZS5zdGFydCA+IGJwRW5kKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IHRoaXMuY2FsY3VsYXRlRmVhdHVyZUNvb3JkaW5hdGVzKGdlbmUsIGJwU3RhcnQsYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGNvbmYuZmVhdHVyZUhlaWdodFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmYuZGlzcGxheU1vZGUgPT09IFwiU1FVSVNIRURcIiAmJiBnZW5lLnJvdyAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgXHRcdGggPSBjb25mLmZlYXR1cmVIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBcdFx0cHkgPSBjb25mLmV4cGFuZGVkQ2FsbEhlaWdodCAqIGdlbmUucm93ICsgMjtcclxuICAgICAgICBcdFx0fSBlbHNlIGlmIChjb25mLmRpc3BsYXlNb2RlID09PSBcIkVYUEFOREVEXCIgJiYgZ2VuZS5yb3cgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIFx0XHRweSA9IGNvbmYuc3F1aXNoZWRDYWxsSGVpZ2h0ICogZ2VuZS5yb3cgKyA1O1xyXG4gICAgICAgIFx0XHR9IGVsc2Uge1xyXG4gICAgICAgICAgICAgLy8gY29sbGFwc2VkXHJcbiAgICAgICAgICAgXHRcdFx0IHB5ID0gNTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRweSs9dG9wO1xyXG4gICAgICAgIFx0XHRpZiAocHkraD5tYXhfeV92YWwpe1xyXG4gICAgICAgIFx0XHRcdG1heF95X3ZhbD1weStoO1xyXG4gICAgICAgIFx0XHR9XHJcbiAgICAgICAgXHRcdGNvb3JkLnB5PXB5O1xyXG4gICAgICAgIFx0XHRjb29yZC5oPWg7XHJcbiAgICAgICAgXHRcdGxldCBpbmZvPXticFBlclBpeGVsOmJwUGVyUGl4ZWwsYnBTdGFydDpicFN0YXJ0LHBpeGVsV2lkdGg6cGl4ZWxXaWR0aH1cclxuICAgICAgICBcdFx0aWYgKHRoaXMuY29sb3JfZnVuY3Rpb24pe1xyXG4gICAgICAgIFx0XHRcdGdlbmUuY29sb3I9dGhpcy5jb2xvcl9mdW5jdGlvbihnZW5lKTtcclxuICAgICAgICBcdFx0fVxyXG4gICAgICAgIFx0XHRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZShnZW5lLGNvb3JkLGN0eCxpbmZvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmVhdHVyZUxhYmVsKGN0eCwgZ2VuZSwgY29vcmQucHgsIGNvb3JkLnB4MSwgcHksIHdpbmRvd1gsIHdpbmRvd1gxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGE9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gZmVhdHVyZSBsaXN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJvdHRvbT1tYXhfeV92YWw7XHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRpc3BsYXlNb2RlPT09XCJDT0xMQVBTRURcIil7XHJcbiAgICAgICAgXHRtYXhfeV92YWwrPTI1O1xyXG4gICAgICAgIH1cdFxyXG4gICAgXHRyZXR1cm4gbWF4X3lfdmFsO1xyXG4gICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgIFxyXG5cclxuICAgIFxyXG4gIFxyXG5cdCAvKipcclxuICAgICAqIEBwYXJhbSBjdHggICAgICAgdGhlIGNhbnZhcyAyZCBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZmVhdHVyZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVYICBmZWF0dXJlIHN0YXJ0IHgtY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGZlYXR1cmVYMSBmZWF0dXJlIGVuZCB4LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlWSAgZmVhdHVyZSB5LWNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSB3aW5kb3dYICAgdmlzaWJsZSB3aW5kb3cgc3RhcnQgeC1jb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gd2luZG93WDEgIHZpc2libGUgd2luZG93IGVuZCB4LWNvb3JkaW5hdGVcclxuICAgICAqL1xyXG4gIFxyXG5cclxuXHJcblxyXG5cdHJlbmRlckZlYXR1cmVMYWJlbChjdHgsIGZlYXR1cmUsIGZlYXR1cmVYLCBmZWF0dXJlWDEsIGZlYXR1cmVZLCB3aW5kb3dYLCB3aW5kb3dYMSkge1xyXG5cdFx0bGV0IGluZm8gPSB0aGlzLmNvbmZpZztcclxuICAgICAgICB2YXIgZ2VuZUNvbG9yLCBnZW5lRm9udFN0eWxlLCB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIGJveFgsIGJveFgxLCAgICAvLyBsYWJlbCBzaG91bGQgYmUgY2VudGVyZWQgYmV0d2VlbiB0aGVzZSB0d28geC1jb29yZGluYXRlc1xyXG4gICAgICAgICAgICBsYWJlbFgsIGxhYmVsWSxcclxuICAgICAgICAgICAgdGV4dEZpdHNJbkJveDtcclxuXHJcbiAgICAgICAgLy8gZmVhdHVyZSBvdXRzaWRlIG9mIHZpZXdhYmxlIHdpbmRvd1xyXG4gICAgICAgIGlmIChmZWF0dXJlWDEgPCB3aW5kb3dYIHx8IGZlYXR1cmVYID4gd2luZG93WDEpIHtcclxuICAgICAgICAgICAgYm94WCA9IGZlYXR1cmVYO1xyXG4gICAgICAgICAgICBib3hYMSA9IGZlYXR1cmVYMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBjZW50ZXIgbGFiZWwgd2l0aGluIHZpc2libGUgcG9ydGlvbiBvZiB0aGUgZmVhdHVyZVxyXG4gICAgICAgICAgICBib3hYID0gTWF0aC5tYXgoZmVhdHVyZVgsIHdpbmRvd1gpO1xyXG4gICAgICAgICAgICBib3hYMSA9IE1hdGgubWluKGZlYXR1cmVYMSwgd2luZG93WDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgIFxyXG5cclxuICAgICAgICAvL2lmIChpZ3YuYnJvd3Nlci5zZWxlY3Rpb24gJiYgXCJnZW5lc1wiID09PSB0aGlzLmNvbmZpZy50eXBlICYmIGZlYXR1cmUubmFtZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLS0gZm9yIGd0ZXgsIGZpZ3VyZSBvdXQgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcclxuICAgICAgICAgICAgLy9nZW5lQ29sb3IgPSBpZ3YuYnJvd3Nlci5zZWxlY3Rpb24uY29sb3JGb3JHZW5lKGZlYXR1cmUubmFtZSk7XHJcbiAgICAgIC8vICB9XHJcblxyXG4gICAgICAgIHRleHRGaXRzSW5Cb3ggPSAoYm94WDEgLSBib3hYKSA+IGN0eC5tZWFzdXJlVGV4dChmZWF0dXJlLm5hbWUpLndpZHRoO1xyXG4gICAgICAgIC8vZ2VuZUNvbG9yPVwiYmxhY2tcIjtcclxuXHJcbiAgICAgICAgaWYgKCh0ZXh0Rml0c0luQm94IHx8IGdlbmVDb2xvcikgJiYgaW5mby5kaXNwbGF5TW9kZSAhPSBcIlNRVUlTSEVEXCIgJiYgZmVhdHVyZS5uYW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZ2VuZUZvbnRTdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgIGZvbnQ6ICcxMHB4IFBUIFNhbnMnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogZ2VuZUNvbG9yIHx8IGluZm8uY29sb3IsXHJcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogZ2VuZUNvbG9yIHx8IGluZm8uY29sb3JcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbmZvLmRpc3BsYXlNb2RlID09PSBcIkNPTExBUFNFRFwiICYmIGluZm8ubGFiZWxEaXNwbGF5TW9kZSA9PT0gXCJTTEFOVFwiKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSB7cm90YXRlOiB7YW5nbGU6IDQ1fX07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZ2VuZUZvbnRTdHlsZS50ZXh0QWxpZ247XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhYmVsWCA9IGJveFggKyAoKGJveFgxIC0gYm94WCkgLyAyKTtcclxuICAgICAgICAgICAgbGFiZWxZID0gZ2V0RmVhdHVyZUxhYmVsWShmZWF0dXJlWSwgdHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgICAgIEdyYXBoaWNzLmZpbGxUZXh0KGN0eCwgZmVhdHVyZS5uYW1lLCBsYWJlbFgsIGxhYmVsWSwgZ2VuZUZvbnRTdHlsZSwgdHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RmVhdHVyZUxhYmVsWShmZWF0dXJlWSwgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgXHRyZXR1cm4gdHJhbnNmb3JtID8gZmVhdHVyZVkgKyBpbmZvLmZlYXR1cmVIZWlnaHQrMTQgOiBmZWF0dXJlWSArIGluZm8uZmVhdHVyZUhlaWdodCs3O1xyXG4gICAgXHR9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcblx0Y2FsY3VsYXRlRmVhdHVyZUNvb3JkaW5hdGVzKGZlYXR1cmUsIGJwU3RhcnQsIHhTY2FsZSkge1xyXG4gICAgXHR2YXIgcHggPSBNYXRoLnJvdW5kKChmZWF0dXJlLnN0YXJ0IC0gYnBTdGFydCkgLyB4U2NhbGUpLFxyXG4gICAgICAgIHB4MSA9IE1hdGgucm91bmQoKGZlYXR1cmUuZW5kIC0gYnBTdGFydCkgLyB4U2NhbGUpLFxyXG4gICAgICAgIHB3ID0gcHgxIC0gcHg7XHJcblxyXG4gICAgICAgIGlmIChwdyA8IDMpIHtcclxuICAgICAgICBcdHB3ID0gMztcclxuICAgICAgICAgICAgcHggLT0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgXHRweDogcHgsXHJcbiAgICAgICAgICAgIHB4MTogcHgxLFxyXG4gICAgICAgICAgICBwdzogcHdcclxuICAgICAgICB9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBmZWF0dXJlIHRvIHRoZSBjYW52YXNcclxuICAgICAqIEBwYXJhbSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgaXRzZWxmXHJcbiAgICAgKiBAcGFyYW0gY29vcmQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb24gd2hlcmUgdG8gZHJhdyB0aGUgZmVhdHVyZVxyXG4gICAgICogcHgxLHB4MiB0aGUgbGVmdCBhbmQgcmlnaHQgcGl4ZWxzIC0gcHcgLSB0aGUgd2lkdGhcclxuICAgICAqIHB5IHRoZSB0b3AsIGggLSB0aGUgaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdG8gZHJhdyB0aGUgZmVhdHVyZVxyXG4gICAgICogQHBhcmFtIGluZm8gLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2Vub21pYyBsb2NhdGlvblxyXG4gICAgICogYnBTdGFydC5icFBlclBpeGVsIGFuZCBwaXhlbFdpZHRoXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG5cdFxyXG5cdHJlbmRlckZlYXR1cmUoZmVhdHVyZSwgY29vcmQsY3R4LGluZm8pe1xyXG5cdFx0dmFyIGUseCwgY3ksIGRpcmVjdGlvbiwgZXhvbiwgZVB4LCBlUHgxLCBlUHhVLCBlUHcsIHB5MiwgaDIsIFxyXG4gICAgICAgICAgICBzdGVwID0gMjAsXHJcbiAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb25maWcuY29sb3I7XHJcbiAgICAgICAgaWYgKGZlYXR1cmUuY29sb3IpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBmZWF0dXJlLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG5cclxuICAgICAgICBjeSA9IGNvb3JkLnB5ICsgY29vcmQuaCAvIDI7XHJcbiAgICAgICAgaDIgPSBjb29yZC5oIC8gMjtcclxuICAgICAgICBweTIgPSBjeSAtIGgyIC8gMjtcclxuXHJcblx0XHRsZXQgZXhvbkNvdW50ID0gZmVhdHVyZS5leG9ucyA/IGZlYXR1cmUuZXhvbnMubGVuZ3RoIDogMDtcclxuXHRcdFx0aWYgKGV4b25Db3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgIFx0Ly8gc2luZ2xlLWV4b24gdHJhbnNjcmlwdFxyXG4gICAgICAgICAgICBcdGN0eC5maWxsUmVjdChjb29yZC5weCwgY29vcmQucHksIGNvb3JkLnB3LCBjb29yZC5oKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAvLyBtdWx0aS1leG9uIHRyYW5zY3JpcHRcclxuICAgICAgICAgICAgY29vcmQucHg9TWF0aC5tYXgoY29vcmQucHgsMCk7XHJcbiAgICAgICAgICAgIGNvb3JkLnB4MT1NYXRoLm1pbihjb29yZC5weDEsaW5mby5waXhlbFdpZHRoKTtcclxuICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsIGNvb3JkLnB4ICsgMSwgY3ksIGNvb3JkLnB4MSAtIDEsIGN5KTsgLy8gY2VudGVyIGxpbmUgZm9yIGludHJvbnNcclxuICAgICAgICAgICAgZGlyZWN0aW9uID0gZmVhdHVyZS5zdHJhbmQgPT0gJysnID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICBcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKCB4PWNvb3JkLnB4ICsgc3RlcCAvIDI7IHggPCAgY29vcmQucHgxOyB4ICs9IHN0ZXApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGFycm93aGVhZHMgYWxvbmcgY2VudHJhbCBsaW5lIGluZGljYXRpbmcgdHJhbnNjcmliZWQgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgLSAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCAtIGRpcmVjdGlvbiAqIDIsIGN5ICsgMiwgeCwgY3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGUgPCBleG9uQ291bnQ7IGUrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZHJhdyB0aGUgZXhvbnNcclxuICAgICAgICAgICAgICAgIGV4b24gPSBmZWF0dXJlLmV4b25zW2VdO1xyXG4gICAgICAgICAgICAgICAgZVB4ID0gTWF0aC5yb3VuZCgoZXhvbi5zdGFydCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgZVB4MSA9IE1hdGgucm91bmQoKGV4b24uZW5kIC0gaW5mby5icFN0YXJ0KSAvIGluZm8uYnBQZXJQaXhlbCk7XHJcbiAgICAgICAgICAgICAgICBlUHcgPSBNYXRoLm1heCgxLCBlUHgxIC0gZVB4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZXhvbi51dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBweTIsIGVQdywgaDIpOyAvLyBFbnRpcmUgZXhvbiBpcyBVVFJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleG9uLmNkU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB4VSA9IE1hdGgucm91bmQoKGV4b24uY2RTdGFydCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4LCBweTIsIGVQeFUgLSBlUHgsIGgyKTsgLy8gc3RhcnQgaXMgVVRSXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQdyAtPSAoZVB4VSAtIGVQeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeCA9IGVQeFU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhvbi5jZEVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlUHhVID0gTWF0aC5yb3VuZCgoZXhvbi5jZEVuZCAtIGluZm8uYnBTdGFydCkgLyBpbmZvLmJwUGVyUGl4ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoZVB4VSwgcHkyLCBlUHgxIC0gZVB4VSwgaDIpOyAvLyBzdGFydCBpcyBVVFJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVB3IC09IChlUHgxIC0gZVB4VSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVQeDEgPSBlUHhVO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGVQeCwgY29vcmQucHksIGVQdywgY29vcmQuaCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFycm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlUHcgPiBzdGVwICsgNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeCA9IGVQeCArIHN0ZXAgLyAyOyB4IDwgZVB4MTsgeCArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3IGFycm93aGVhZHMgYWxvbmcgY2VudHJhbCBsaW5lIGluZGljYXRpbmcgdHJhbnNjcmliZWQgb3JpZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzLnN0cm9rZUxpbmUoY3R4LCB4IC0gZGlyZWN0aW9uICogMiwgY3kgLSAyLCB4LCBjeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5zdHJva2VMaW5lKGN0eCwgeCAtIGRpcmVjdGlvbiAqIDIsIGN5ICsgMiwgeCwgY3kpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblx0fVxyXG5cclxuXHRnZXRGZWF0dXJlQXQoZ2Vub21pY0xvY2F0aW9uLCBjaHIsIGNvb3JkLCBicFBlclBpeGVsKSB7XHJcblx0XHRsZXQgeU9mZnNldD1jb29yZC55LXRoaXMudG9wO1xyXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgZmVhdHVyZUNhY2hlIHByb3BlcnR5IHJhdGhlciB0aGFuIG1ldGhvZCB0byBhdm9pZCBhc3luYyBsb2FkLiAgSWYgdGhlXHJcbiAgICAgICAgLy8gZmVhdHVyZSBpcyBub3QgYWxyZWFkeSBsb2FkZWQgdGhpcyB3b24ndCB3b3JrLCAgYnV0IHRoZSB1c2VyIHdvdWxkbid0IGJlIG1vdXNpbmcgb3ZlciBpdCBlaXRoZXIuXHJcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZV9zb3VyY2UuZmVhdHVyZUNhY2hlKSB7XHJcblxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgICAgIHZhciB0b2xlcmFuY2UgPSAyICogYnBQZXJQaXhlbCwgIC8vIFdlIG5lZWQgc29tZSB0b2xlcmFuY2UgYXJvdW5kIGdlbm9taWNMb2NhdGlvbiwgc3RhcnQgd2l0aCArLy0gMiBwaXhlbHNcclxuICAgICAgICAgICAgICAgIGZlYXR1cmVMaXN0ID0gdGhpcy5mZWF0dXJlX3NvdXJjZS5mZWF0dXJlQ2FjaGUucXVlcnlGZWF0dXJlcyhjaHIsIGdlbm9taWNMb2NhdGlvbiAtIHRvbGVyYW5jZSwgZ2Vub21pY0xvY2F0aW9uICsgdG9sZXJhbmNlKSxcclxuICAgICAgICAgICAgICAgIHJvdztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5kaXNwbGF5TW9kZSAhPSBcIkNPTExBUFNFRFwiKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgPSAoTWF0aC5mbG9vcikodGhpcy5jb25maWcuZGlzcGxheU1vZGUgPT09IFwiU1FVSVNIRURcIiA/IHlPZmZzZXQgLyB0aGlzLmNvbmZpZy5leHBhbmRlZENhbGxIZWlnaHQgOiB5T2Zmc2V0IC8gdGhpcy5jb25maWcuc3F1aXNoZWRDYWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChmZWF0dXJlTGlzdCAmJiBmZWF0dXJlTGlzdC5sZW5ndGggPiAwKSB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3B1cERhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGZlYXR1cmUgb2YgZmVhdHVyZUxpc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmVuZCA+PSBnZW5vbWljTG9jYXRpb24gLSB0b2xlcmFuY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5zdGFydCA8PSBnZW5vbWljTG9jYXRpb24gKyB0b2xlcmFuY2UpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdyBudW1iZXIgaXMgc3BlY2lmaWVkIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmUucm93ID09PSB1bmRlZmluZWQgfHwgcm93ID09PSBmZWF0dXJlLnJvdykmJiAgZmVhdHVyZS5kaXNwbGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuXHJcbmNsYXNzIE1MVkJpZ0JlZFRyYWNrIGV4dGVuZHMgTUxWQmVkVHJhY2t7XHJcblx0Y29uc3RydWN0b3IoY29uZmlnKXtcclxuXHRcdHN1cGVyKGNvbmZpZyk7XHJcblx0XHRcclxuXHR9XHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9bmV3IEJpZ0JlZEZlYXR1cmVTb3VyY2UodGhpcy5jb25maWcpO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBNTFZXaWdUcmFjayBleHRlbmRzIE1MVlRyYWNre1xyXG5cdGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpO1xyXG5cdFx0dGhpcy5fc2V0RmVhdHVyZVNvdXJjZSgpO1xyXG5cdH1cclxuXHJcblx0X3NldEZlYXR1cmVTb3VyY2UoKXtcclxuXHRcdHRoaXMuZmVhdHVyZV9zb3VyY2U9bmV3IEJXU291cmNlKHRoaXMuY29uZmlnKTtcdFxyXG5cdH1cclxuXHJcblxyXG5cdGRyYXdTY2FsZShwaXhlbF9oZWlnaHQsY3R4KXtcclxuXHRcdGlmICh0aGlzLmNvbmZpZy5zY2FsZV9saW5rX3RvKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGJvdD0gcGl4ZWxfaGVpZ2h0O1xyXG5cdFx0bGV0IHRvcCA9IDA7XHJcblx0XHRpZiAodGhpcy5zY2FsZV9saW5rX3RvKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0XHRcdHRvcD10aGlzLnRvcDtcclxuXHRcdFx0Ym90ID0gdGhpcy5ib3R0b207XHJcblx0XHR9XHJcblx0XHRsZXQgcmFuZ2U9dGhpcy5tYXhfeS10aGlzLm1pbl95O1xyXG5cclxuXHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdGN0eC5tb3ZlVG8oMCx0b3ApO1xyXG5cdFx0Y3R4LmxpbmVUbygwLGJvdCk7XHJcblx0XHRjdHgubW92ZVRvKDAsdG9wKTtcclxuXHRcdGN0eC5saW5lVG8oMjAsdG9wKTtcclxuXHRcdGN0eC5tb3ZlVG8oMCxib3QpO1xyXG5cdFx0Y3R4LmxpbmVUbygyMCxib3QpO1xyXG5cdFx0Y3R4LmZvbnQ9XCIxMnB4IEFyaWFsXCI7XHJcblx0XHRjdHguc3Ryb2tlKCk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lPVwidG9wXCI7XHJcblx0XHRjdHguZmlsbFRleHQodGhpcy5tYXhfeS50b0ZpeGVkKDIpLDIwLHRvcCk7XHJcblx0XHRjdHgudGV4dEJhc2VsaW5lPVwiYWxwaGFiZXRpY1wiO1xyXG5cdFx0Y3R4LmZpbGxUZXh0KHRoaXMubWluX3ksMjAsYm90KTtcclxuXHJcblx0fVxyXG5cdFxyXG5cdGRyYXdGZWF0dXJlcyhvcHRpb25zKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXMsXHJcblx0ICAgIGZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuXHQgICAgY29sb3I9c2VsZi5jb25maWcuY29sb3IsXHJcblx0ICAgIGN0eCA9IG9wdGlvbnMuY29udGV4dCxcclxuXHQgICAgYnBQZXJQaXhlbCA9IG9wdGlvbnMuYnBQZXJQaXhlbCxcclxuXHQgICAgYnBTdGFydCA9IG9wdGlvbnMuYnBTdGFydCxcclxuXHQgICAgcGl4ZWxXaWR0aCA9IG9wdGlvbnMucGl4ZWxXaWR0aCxcclxuXHQgICAgcGl4ZWxIZWlnaHQgPW9wdGlvbnMucGl4ZWxIZWlnaHQsXHJcblx0ICAgIHlfb2Zmc2V0PXRoaXMuY29uZmlnLmRpc2NyZXRlP29wdGlvbnMudG9wOjAsXHJcblx0ICAgIGJwRW5kID0gYnBTdGFydCArIHBpeGVsV2lkdGggKiBicFBlclBpeGVsICsgMSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWluaW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlTWF4aW11bSxcclxuXHQgICAgZmVhdHVyZVZhbHVlUmFuZ2UsXHJcblx0ICAgICRkYXRhUmFuZ2VUcmFja0xhYmVsLFxyXG5cdCAgICBzdHIsXHJcblx0ICAgIG1pbixcclxuXHQgICAgbWF4O1xyXG5cdCAgICBpZiAodGhpcy5jb25maWcuZ3JvdXApe1xyXG5cdCAgICBcdFx0cGl4ZWxIZWlnaHQ9b3B0aW9ucy5oZWlnaHQ7XHJcblx0ICAgIH1cclxuXHQgICAgZWxzZSBpZih0aGlzLmNvbmZpZy5kaXNjcmV0ZSl7XHJcblx0ICAgIFx0XHRwaXhlbEhlaWdodD10aGlzLmNvbmZpZy5oZWlnaHQ7XHRcclxuXHQgICAgfVxyXG5cdCAgICAgICAgICBcclxuXHQgICAgaWYgKCFjb2xvcil7XHJcblx0ICAgIFx0Y29sb3I9XCJibGFja1wiOyAgICAgICBcclxuXHQgICAgfVxyXG5cdCAgICBzZWxmLnByZXZfY29vcmRzPXt4OjAseTowfTtcclxuXHRcdFxyXG5cdCAgICBpZiAoZmVhdHVyZXMpIHtcclxuXHQgICAgXHRpZiAoc2VsZi5zY2FsZV9saW5rX3RvKXtcclxuXHQgICAgXHRcdGxldCB0ID0gc2VsZi5zY2FsZV9saW5rX3RvLmNvbmZpZztcclxuXHQgICAgICAgICAgICBpZiAodCl7XHJcblx0ICAgICAgICAgICAgXHRzZWxmLmNvbmZpZy5zY2FsZT10LnNjYWxlO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95PXNlbGYuc2NhbGVfbGlua190by5tYXhfeTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feT1zZWxmLnNjYWxlX2xpbmtfdG8ubWluX3k7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICB9XHJcblx0ICAgICAgIGVsc2UgaWYgKCAoc2VsZi5tYXhfeSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuY29uZmlnLnNjYWxlPT09XCJhdXRvbWF0aWNcIikgfHwgc2VsZi5jb25maWcuc2NhbGU9PT1cImR5bmFtaWNcIil7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBzID0gYXV0b3NjYWxlKGZlYXR1cmVzKTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5taW5feSA9IHMubWluO1xyXG5cdCAgICAgICAgICAgICAgICBzZWxmLm1heF95ID0gcy5tYXg7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLnNjYWxlPT09XCJmaXhlZFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYubWluX3kgPSBzZWxmLmNvbmZpZy5taW5feTtcclxuXHQgICAgICAgICAgICAgICAgc2VsZi5tYXhfeT1zZWxmLmNvbmZpZy5tYXhfeTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGZlYXR1cmVWYWx1ZVJhbmdlID0gc2VsZi5tYXhfeSAtIHNlbGYubWluX3k7XHJcblxyXG5cdCAgICAgICAgICAgIC8vJGRhdGFSYW5nZVRyYWNrTGFiZWwgPSAkKHRoaXMudHJhY2tWaWV3LnRyYWNrRGl2KS5maW5kKCcuaWd2LWRhdGEtcmFuZ2UtdHJhY2stbGFiZWwnKTtcclxuXHQgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgIC8vbWluID0gKE1hdGguZmxvb3IodHJhY2suZGF0YVJhbmdlLm1pbikgPT09IHRyYWNrLmRhdGFSYW5nZS5taW4pID8gdHJhY2suZGF0YVJhbmdlLm1pbiA6IHRyYWNrLmRhdGFSYW5nZS5taW4udG9GaXhlZCgyKTtcclxuXHQgICAgICAgICAgICAvL21heCA9IChNYXRoLmZsb29yKHRyYWNrLmRhdGFSYW5nZS5tYXgpID09PSB0cmFjay5kYXRhUmFuZ2UubWF4KSA/IHRyYWNrLmRhdGFSYW5nZS5tYXggOiB0cmFjay5kYXRhUmFuZ2UubWF4LnRvRml4ZWQoMik7XHJcblx0ICAgICAgICAgICAgLy9zdHIgPSAnWycgKyBtaW4gKyAnIC0gJyArIG1heCArICddJztcclxuXHQgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgIC8vJGRhdGFSYW5nZVRyYWNrTGFiZWwudGV4dChzdHIpO1xyXG5cdCAgICAgICAgICAgIGxldCBwcmV2X3g9MDtcclxuXHQgICAgICAgICAgICBsZXQgcHJldl95PTA7XHJcblx0ICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhICAgPSB0aGlzLmNvbmZpZy5vcGFjaXR5P3RoaXMuY29uZmlnLm9wYWNpdHk6MTtcclxuXHQgICAgICAgICAgICBpZiAoc2VsZi5pc19saW5lKXsgIFxyXG5cdCAgICAgICAgICAgICAgICBsZXQgeSA9ICgxLjAgLSBzZWxmLmNvbmZpZy52YWx1ZSAvIGZlYXR1cmVWYWx1ZVJhbmdlKSpwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgsMCx5LHBpeGVsV2lkdGgseSx7XCJzdHJva2VTdHlsZVwiOnNlbGYuY29uZmlnLmNvbG9yLFwibGluZVdpZHRoXCI6c2VsZi5jb25maWcud2lkdGg/c2VsZi5jb25maWcud2lkdGg6MX0pO1xyXG5cdCAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZXtcclxuXHQgICAgICAgICAgICBcdGZlYXR1cmVzLmZvckVhY2gocmVuZGVyRmVhdHVyZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYT0xXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICAgXHJcblx0ICAgICAgICBmdW5jdGlvbiByZW5kZXJGZWF0dXJlKGZlYXR1cmUsIGluZGV4LCBmZWF0dXJlTGlzdCkge1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgeVVuaXRsZXNzLFxyXG5cdCAgICAgICAgICAgICAgICBoZWlnaHRVbml0TGVzcyxcclxuXHQgICAgICAgICAgICAgICAgeCxcclxuXHQgICAgICAgICAgICAgICAgeSxcclxuXHQgICAgICAgICAgICAgICAgd2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodCxcclxuXHQgICAgICAgICAgICAgICAgcmVjdEVuZCxcclxuXHQgICAgICAgICAgICAgICAgcmVjdEJhc2VsaW5lO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoZmVhdHVyZS5lbmQgPCBicFN0YXJ0KSByZXR1cm47XHJcblx0ICAgICAgICAgICAgaWYgKGZlYXR1cmUuc3RhcnQgPiBicEVuZCkgcmV0dXJuO1xyXG5cclxuXHQgICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoZmVhdHVyZS5zdGFydCAtIGJwU3RhcnQpIC8gYnBQZXJQaXhlbCk7XHJcblx0ICAgICAgICAgICAgcmVjdEVuZCA9IE1hdGguZmxvb3IoKGZlYXR1cmUuZW5kIC0gYnBTdGFydCkgLyBicFBlclBpeGVsKTtcclxuXHQgICAgICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHJlY3RFbmQgLSB4KTtcclxuXHJcblx0ICAgICAgICAgICAgLy9oZWlnaHQgPSAoKGZlYXR1cmUudmFsdWUgLSBmZWF0dXJlVmFsdWVNaW5pbXVtKSAvIGZlYXR1cmVWYWx1ZVJhbmdlKSAqIHBpeGVsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgIC8vcmVjdEJhc2VsaW5lID0gcGl4ZWxIZWlnaHQgLSBoZWlnaHQ7XHJcblx0ICAgICAgICAgICAgLy9jYW52YXMuZmlsbFJlY3QocmVjdE9yaWdpbiwgcmVjdEJhc2VsaW5lLCByZWN0V2lkdGgsIHJlY3RIZWlnaHQsIHtmaWxsU3R5bGU6IHRyYWNrLmNvbG9yfSk7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChzaWduc0RpZmZlcihzZWxmLm1pbl95LCBzZWxmLm1heF95KSkge1xyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUudmFsdWUgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB5VW5pdGxlc3MgPSBzZWxmLm1heF95LyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzID0gLWZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9ICgoc2VsZi5tYXhfeSAtIGZlYXR1cmUudmFsdWUpIC8gZmVhdHVyZVZhbHVlUmFuZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSBmZWF0dXJlLnZhbHVlIC8gZmVhdHVyZVZhbHVlUmFuZ2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYubWluX3kgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IDA7XHJcblx0ICAgICAgICAgICAgICAgIGhlaWdodFVuaXRMZXNzID0gLWZlYXR1cmUudmFsdWUgLyBmZWF0dXJlVmFsdWVSYW5nZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHlVbml0bGVzcyA9IDEuMCAtICgoZmVhdHVyZS52YWx1ZS1zZWxmLm1pbl95KSAvIGZlYXR1cmVWYWx1ZVJhbmdlKTtcclxuXHQgICAgICAgICAgICAgICAgaGVpZ2h0VW5pdExlc3MgPSAoZmVhdHVyZS52YWx1ZStzZWxmLm1pbl95KSAvIGZlYXR1cmVWYWx1ZVJhbmdlO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICBcdHkgPSAoeVVuaXRsZXNzKnBpeGVsSGVpZ2h0KSt5X29mZnNldDtcclxuXHQgICAgICAgICAgICB5PXk8eV9vZmZzZXQ/eV9vZmZzZXQ6eTtcclxuXHQgICAgICAgICAgICBoZWlnaHQ9aGVpZ2h0VW5pdExlc3MgKiBwaXhlbEhlaWdodDtcclxuXHQgICAgICAgICAgICBoZWlnaHQ9aGVpZ2h0PnBpeGVsSGVpZ2h0P3BpeGVsSGVpZ2h0OmhlaWdodFxyXG5cclxuXHQgICAgICAgICAgICAvL2NhbnZhcy5maWxsUmVjdCh4LCB5VW5pdGxlc3MgKiBwaXhlbEhlaWdodCwgd2lkdGgsIGhlaWdodFVuaXRMZXNzICogcGl4ZWxIZWlnaHQsIHsgZmlsbFN0eWxlOiBpZ3YucmFuZG9tUkdCKDY0LCAyNTUpIH0pO1xyXG5cdCAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5kaXNwbGF5PT09J2xpbmUnKXtcclxuXHQgICAgICAgICAgICAgICAgIGlmIChzZWxmLnByZXZfY29vcmRzLngpe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlTGluZShjdHgseCx5LHNlbGYucHJldl9jb29yZHMueCxzZWxmLnByZXZfY29vcmRzLnkse1wic3Ryb2tlU3R5bGVcIjpjb2xvcixcImxpbmVXaWR0aFwiOjN9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc2VsZi5wcmV2X2Nvb3Jkcy54PXg7XHJcblx0ICAgICAgICAgICAgICAgIHNlbGYucHJldl9jb29yZHMueT15O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBlbHNle1xyXG5cdCAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHtmaWxsU3R5bGU6IGNvbG9yfSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgIGZ1bmN0aW9uIGF1dG9zY2FsZShmZWF0dXJlcykge1xyXG4gICAgICAgIHZhciBtaW4gPSAwLFxyXG4gICAgICAgICAgICBtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGYudmFsdWUpO1xyXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGYudmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge21pbjogbWluLCBtYXg6IG1heH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNpZ25zRGlmZmVyKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGEgPiAwICYmIGIgPCAwIHx8IGEgPCAwICYmIGIgPiAwKTtcclxuICAgIH1cclxuICAgIHRoaXMudG9wPXlfb2Zmc2V0O1xyXG4gICAgdGhpcy5ib3R0b209eV9vZmZzZXQrcGl4ZWxIZWlnaHQ7XHJcbiAgICBpZiAodGhpcy5jb25maWcuZGlzY3JldGUpe1xyXG4gICAgXHRyZXR1cm4gdGhpcy5ib3R0b207XHJcbiAgICB9XHJcbiAgICBlbHNle1xyXG4gICAgXHR0aGlzLnRvcD0wO1xyXG4gICAgXHR0aGlzLmJvdHRvbT0wO1xyXG4gICAgfVxyXG5cclxuXHQgICAgXHJcbn1cclxufVxyXG4gY2xhc3MgTGluZVRyYWNrIGV4dGVuZHMgTUxWV2lnVHJhY2t7XHJcblx0IGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHQgc3VwZXIoY29uZmlnKTtcclxuXHRcdCB0aGlzLmlzX2xpbmU9dHJ1ZTtcclxuXHQgfVxyXG5cdCBcclxuXHQgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCkge1xyXG5cdFx0IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XHJcblx0XHRcdCBmdWxmaWxsKFtdKTtcclxuXHQgICAgIH0pO1xyXG5cdCB9XHJcblx0IFxyXG5cdCBcclxuIH1cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNlcXVlbmNlVHJhY2sgZXh0ZW5kcyBNTFZUcmFja3tcclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XHJcblx0XHRzdXBlcihjb25maWcpIFxyXG4gICAgICAgIHRoaXMuX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlVHlwZSA9IGNvbmZpZy5zZXF1ZW5jZVR5cGUgfHwgXCJkbmFcIjsgIFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTU7XHJcbiAgICB9XHJcblxyXG4gICAgX3NldEZlYXR1cmVTb3VyY2UoY29uZmlnKXtcclxuICAgIFx0dGhpcy5mZWF0dXJlX3NvdXJjZSA9IG5ldyBGYXN0YVNlcXVlbmNlKGNvbmZpZy51cmwpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZ2V0RmVhdHVyZXMoY2hyLCBicFN0YXJ0LCBicEVuZCxmb3JjZSxkYXRhKSB7XHJcblx0XHRsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuYnBQZXJQaXhlbCA+IDEvKmlndi5icm93c2VyLnRyYWNrVmlld3BvcnRXaWR0aEJQKCkgPiAzMDAwMCovKSB7XHJcbiAgICAgICAgICAgICAgICBmdWxmaWxsKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5mZWF0dXJlX3NvdXJjZS5nZXRTZXF1ZW5jZShjaHIsIGJwU3RhcnQsIGJwRW5kKS50aGVuKGZ1bGZpbGwpLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZHJhd0ZlYXR1cmVzKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNlcXVlbmNlID0gb3B0aW9ucy5mZWF0dXJlcyxcclxuICAgICAgICAgICAgY3R4ID0gb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgICBicFBlclBpeGVsID0gb3B0aW9ucy5icFBlclBpeGVsLFxyXG4gICAgICAgICAgICBicFN0YXJ0ID0gb3B0aW9ucy5icFN0YXJ0LFxyXG4gICAgICAgICAgICBwaXhlbFdpZHRoID0gb3B0aW9ucy5waXhlbFdpZHRoLFxyXG4gICAgICAgICAgICBicEVuZCA9IGJwU3RhcnQgKyBwaXhlbFdpZHRoICogYnBQZXJQaXhlbCArIDEsXHJcbiAgICAgICAgICAgIGxlbiwgdywgeSwgcG9zLCBvZmZzZXQsIGIsIHAwLCBwMSwgcGMsIGM7XHJcblxyXG4gICAgICAgIGxldCB5X3BvczE9b3B0aW9ucy50b3A7XHJcbiAgICAgICAgbGV0IHlfcG9zMj15X3BvczErNTtcclxuXHJcbiAgICAgICAgaWYgKHNlcXVlbmNlKSB7XHJcblxyXG4gICAgICAgICAgICBsZW4gPSBzZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHcgPSAxIC8gYnBQZXJQaXhlbDtcclxuXHJcbiAgICAgICAgICAgIHkgPSB5X3BvczErdGhpcy5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICBmb3IgKHBvcyA9IGJwU3RhcnQ7IHBvcyA8PSBicEVuZDsgcG9zKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwb3MgLSBicFN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHNlcXVlbmNlLmNoYXJBdChvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzZXF1ZW5jZVtvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAwID0gTWF0aC5mbG9vcihvZmZzZXQgKiB3KTtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IE1hdGguZmxvb3IoKG9mZnNldCArIDEpICogdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGMgPSBNYXRoLnJvdW5kKChwMCArIHAxKSAvIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJkbmFcIiA9PT0gdGhpcy5zZXF1ZW5jZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzLm51Y2xlb3RpZGVDb2xvcnNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gXCJyZ2IoMCwgMCwgMTUwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjKSBjID0gXCJncmF5XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChicFBlclBpeGVsID4wLjE1KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5maWxsUmVjdChjdHgsIHAwLCB5X3BvczEsIHAxIC0gcDAsIDEwLCB7ZmlsbFN0eWxlOiBjfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3Muc3Ryb2tlVGV4dChjdHgsIGIsIHBjLCB5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQ6ICdub3JtYWwgMTBweCBBcmlhbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgcmV0dXJuIHlfcG9zMSsxMDtcclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLy8qKioqKioqanMvaWZ2LWNhbnZhcy5qcyoqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5cclxuY2xhc3MgR3JhcGhpY3N7XHJcblxyXG5cclxuICAgICAgIHN0YXRpYyBzZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIHN0cm9rZUxpbmUgKGN0eCwgeDEsIHkxLCB4MiwgeTIsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5mbG9vcih4MSkgKyAwLjU7XHJcbiAgICAgICAgICAgIHkxID0gTWF0aC5mbG9vcih5MSkgKyAwLjU7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5mbG9vcih4MikgKyAwLjU7XHJcbiAgICAgICAgICAgIHkyID0gTWF0aC5mbG9vcih5MikgKyAwLjU7XHJcblxyXG4gICAgICAgICAgICAvL2xvZyhcInN0cm9rZSBsaW5lLCBwcm9wOiBcIiArIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsUmVjdChjdHgsIHgsIHksIHcsIGgsIHByb3BlcnRpZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcclxuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZmlsbFBvbHlnb24oY3R4LCB4LCB5LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSAgIEdyYXBoaWNzLnNldFByb3BlcnRpZXMoY3R4LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgR3JhcGhpY3MuZG9QYXRoKGN0eCwgeCwgeSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlUG9seWdvbihjdHgsIHgsIHksIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICBHcmFwaGljcy5kb1BhdGgoY3R4LCB4LCB5KTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGZpbGxUZXh0KGN0eCwgdGV4dCwgeCwgeSwgcHJvcGVydGllcywgdHJhbnNmb3Jtcykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljcy5zZXRQcm9wZXJ0aWVzKGN0eCwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm0gaW4gdHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRkIGVycm9yIGNoZWNraW5nIGZvciByb2J1c3RuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHZhbHVlWyd4J10sIHZhbHVlWyd5J10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICdyb3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodmFsdWVbJ2FuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgMCwgMCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlVGV4dChjdHgsIHRleHQsIHgsIHksIHByb3BlcnRpZXMsIHRyYW5zZm9ybXMpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm0gaW4gdHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybXNbdHJhbnNmb3JtXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWRkIGVycm9yIGNoZWNraW5nIGZvciByb2J1c3RuZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSA9PSAndHJhbnNsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHZhbHVlWyd4J10sIHZhbHVlWyd5J10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtID09ICdyb3RhdGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUodmFsdWVbJ2FuZ2xlJ10gKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgc3Ryb2tlQ2lyY2xlKGN0eCwgeCwgeSwgcmFkaXVzKSB7XHJcblxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRpYyBmaWxsQ2lyY2xlIChjdHgsIHgsIHksIHJhZGl1cykge1xyXG5cclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGljIGRyYXdBcnJvd2hlYWQoY3R4LCB4LCB5LCBzaXplLCBsaW5lV2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICghc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSAtIHNpemUgLyAyKTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBzaXplLCB5KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGF0aWMgZGFzaGVkTGluZShjdHgsIHgxLCB5MSwgeDIsIHkyLCBkYXNoTGVuLCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHgxID0gTWF0aC5yb3VuZCh4MSk7XHJcbiAgICAgICAgICAgIHkxID0gTWF0aC5yb3VuZCh5MSk7XHJcbiAgICAgICAgICAgIHgyID0gTWF0aC5yb3VuZCh4Mik7XHJcbiAgICAgICAgICAgIHkyID0gTWF0aC5yb3VuZCh5Mik7XHJcbiAgICAgICAgICAgIGRhc2hMZW4gPSBNYXRoLnJvdW5kKGRhc2hMZW4pO1xyXG4gICAgICAgICAgICBsb2coXCJkYXNoZWRMaW5lXCIpO1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykgR3JhcGhpY3Muc2V0UHJvcGVydGllcyhjdHgsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhc2hMZW4gPT0gdW5kZWZpbmVkKSBkYXNoTGVuID0gMjtcclxuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRYID0geDIgLSB4MTtcclxuICAgICAgICAgICAgdmFyIGRZID0geTIgLSB5MTtcclxuICAgICAgICAgICAgdmFyIGRhc2hlcyA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKSAvIGRhc2hMZW4pO1xyXG4gICAgICAgICAgICB2YXIgZGFzaFggPSBkWCAvIGRhc2hlcztcclxuICAgICAgICAgICAgdmFyIGRhc2hZID0gZFkgLyBkYXNoZXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChxKysgPCBkYXNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHgxICs9IGRhc2hYO1xyXG4gICAgICAgICAgICAgICAgeTEgKz0gZGFzaFk7XHJcbiAgICAgICAgICAgICAgICBjdHhbcSAlIDIgPT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKHgxLCB5MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4W3EgJSAyID09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXSh4MiwgeTIpO1xyXG5cclxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIFxyXG5cclxuICAgICAgICBzdGF0aWMgZG9QYXRoKGN0eCwgeCwgeSkge1xyXG5cclxuXHJcbiAgICAgICAgXHR2YXIgaSwgbGVuID0geC5sZW5ndGg7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBcdFx0eFtpXSA9IE1hdGgucm91bmQoeFtpXSk7XHJcbiAgICAgICAgXHRcdHlbaV0gPSBNYXRoLnJvdW5kKHlbaV0pO1xyXG4gICAgICAgIFx0fVxyXG5cclxuICAgICAgICBcdGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBcdGN0eC5tb3ZlVG8oeFswXSwgeVswXSk7XHJcbiAgICAgICAgXHRmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBcdFx0Y3R4LmxpbmVUbyh4W2ldLCB5W2ldKTtcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcblxyXG59XHJcblxyXG5HcmFwaGljcy5udWNsZW90aWRlQ29sb3JzPXtcclxuXHRcIkFcIjpcImdyZWVuXCIsXHJcblx0XCJUXCI6XCJyZWRcIixcclxuXHRcIkdcIjpcImJsYWNrXCIsXHJcblx0XCJDXCI6XCJibHVlXCIsXHJcblx0XCJhXCI6XCJncmVlblwiLFxyXG5cdFwidFwiOlwicmVkXCIsXHJcblx0XCJjXCI6XCJibGFja1wiLFxyXG5cdFwiZ1wiOlwiYmx1ZVwiXHJcblxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCB7TUxWVHJhY2ssTUxWV2lnVHJhY2ssTUxWQmVkVHJhY2ssUnVsZXJUcmFjayxNTFZCaWdCZWRUcmFjayxHcmFwaGljc30iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/tracks.js\n");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: Utils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($, XMLHttpRequest) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Utils\", function() { return Utils; });\n/*\r\n * The MIT License (MIT)\r\n *\r\n * Copyright (c) 2014 Broad Institute\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\nlet parseUri_options = {\r\n        strictMode: false,\r\n        key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\r\n        q: {\r\n            name: \"queryKey\",\r\n            parser: /(?:^|&)([^&=]*)=?([^&]*)/g\r\n        },\r\n        parser: {\r\n            strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n            loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\r\n        }\r\n    };\r\n\r\n\r\n\r\nclass Utils{\r\n\r\n    \r\n    static addAlphaToRGB(rgbString, alpha) {\r\n\r\n        if (rgbString.startsWith(\"rgb\")) {\r\n            return rgbString.replace(\"rgb\", \"rgba\").replace(\")\", \", \" + alpha + \")\");\r\n        } else {\r\n            console.log(rgbString + \" is not an rgb style string\");\r\n            return rgbString;\r\n        }\r\n\r\n    }\r\n\r\n    static presentAlert(track_div,error){\r\n        let div= $(\"<div>\").css({\"position\":\"absolute\",\"background-color\":\"white\"}).attr(\"class\",\"mlv-alert\").appendTo(track_div);\r\n        let div1= $(\"<div>\").css({\"display\":\"flex\",\"justify-content\":\"center\"}).appendTo(div);\r\n        div1.append($('<i class=\"fas fa-exclamation-circle\"></i>').css({color:\"red\",\"font-size\":\"16px\",\"text-align\":\"center\",}));\r\n        div.append($(\"<div>\"+error+\"</div>\").css({color:\"red\",\"font-size\":\"14px\",\"text-align\":\"center\"}));\r\n        let left = Math.round((track_div.width()/2)-(div.width()/2));\r\n        let top =Math.round((track_div.height()/2)-(div.height()/2));\r\n        div.css({\"left\":left+\"px\",top:top+\"px\"});\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n   \r\n\r\n    static spinner(size) {\r\n\r\n        // spinner\r\n        var $container,\r\n            $spinner;\r\n\r\n        $spinner = $('<i class=\"fa fa-lg fa-spinner fa-spin igv-spinner\">').css({position:\"absolute\",top:\"50%\",left:\"50%\"});\r\n        if (size) {\r\n            $spinner.css(\"font-size\", size);\r\n        }\r\n\r\n    \r\n\r\n        return $spinner[0];\r\n    }\r\n\r\n    /**\r\n     * Find spinner\r\n     */\r\n    static getSpinnerObjectWithParentElement(parentElement) {\r\n        return parentElement.find(\"div.igv-spinner-container\");\r\n    };\r\n\r\n    /**\r\n     * Start the spinner for the parent element, if it has one\r\n     */\r\n    static startSpinnerAtParentElement(parentElement) {\r\n       parentElement.children(\".fa-spinner\").show();  \r\n\r\n    };\r\n\r\n    /**\r\n     * Stop the spinner for the parent element, if it has one\r\n     * @param parentElement\r\n     */\r\n    static stopSpinnerAtParentElement (parentElement) {\r\n        parentElement.children(\".fa-spinner\").hide();\r\n       \r\n\r\n    }\r\n\r\n    static parseUri(str) {\r\n\r\n        var o = parseUri_options,\r\n            m = o.parser[o.strictMode ? \"strict\" : \"loose\"].exec(str),\r\n            uri = {},\r\n            i = 14;\r\n\r\n        while (i--) uri[o.key[i]] = m[i] || \"\";\r\n\r\n        uri[o.q.name] = {};\r\n        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\r\n            if ($1) uri[o.q.name][$1] = $2;\r\n        });\r\n\r\n        return uri;\r\n    }\r\n    \r\n    \r\n    \r\n  \r\n    static domElementRectAsString(element) {\r\n        return \" x \" + element.clientLeft + \" y \" + element.clientTop + \" w \" + element.clientWidth + \" h \" + element.clientHeight;\r\n    };\r\n\r\n    static isNumber(n) {\r\n\r\n        if (\"\" === n) {\r\n\r\n            return false\r\n        } else if (undefined === n) {\r\n\r\n            return false;\r\n        } else {\r\n\r\n            return !isNaN(parseFloat(n)) && isFinite(n);\r\n        }\r\n\r\n    };\r\n\r\n    static guid  () {\r\n        return (\"0000\" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\r\n    };\r\n\r\n    // Returns a random number between min (inclusive) and max (exclusive)\r\n    static random(min, max) {\r\n        return Math.random() * (max - min) + min;\r\n    };\r\n\r\n    // StackOverflow: http://stackoverflow.com/a/10810674/116169\r\n    static numberFormatter(rawNumber) {\r\n\r\n        var dec = String(rawNumber).split(/[.,]/),\r\n            sep = ',',\r\n            decsep = '.';\r\n\r\n        return dec[0].split('').reverse().reduce(function (prev, now, i) {\r\n                return i % 3 === 0 ? prev + sep + now : prev + now;\r\n            }).split('').reverse().join('') + (dec[1] ? decsep + dec[1] : '');\r\n    };\r\n\r\n    static numberUnFormatter (formatedNumber) {\r\n\r\n        return formatedNumber.split(\",\").join().replace(\",\", \"\", \"g\");\r\n    };\r\n\r\n    /**\r\n     * Translate the mouse coordinates for the event to the coordinates for the given target element\r\n     * @param e\r\n     * @param target\r\n     * @returns {{x: number, y: number}}\r\n     */\r\n    static translateMouseCoordinates(e, target) {\r\n\r\n        var eFixed = $.event.fix(e),   // Sets pageX and pageY for browsers that don't support them\r\n            posx = eFixed.pageX - $(target).offset().left,\r\n            posy = eFixed.pageY - $(target).offset().top;\r\n\r\n        return {x: posx, y: posy}\r\n\r\n    };\r\n\r\n    /**\r\n     * Format markup for popover text from an array of name value pairs [{name, value}]\r\n     */\r\n    static formatPopoverText (nameValueArray) {\r\n\r\n        var markup = \"<table class=\\\"igv-popover-table\\\">\";\r\n\r\n        nameValueArray.forEach(function (nameValue) {\r\n\r\n            if (nameValue.name) {\r\n                //markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</td></tr>\";\r\n                markup += \"<tr><td class=\\\"igv-popover-td\\\">\" + \"<div class=\\\"igv-popoverNameValue\\\">\" + \"<span class=\\\"igv-popoverName\\\">\" + nameValue.name + \"</span>\" + \"<span class=\\\"igv-popoverValue\\\">\" + nameValue.value + \"</span>\" + \"</div>\" + \"</td></tr>\";\r\n            }\r\n            else {\r\n                // not a name/value pair\r\n                markup += \"<tr><td>\" + nameValue.toString() + \"</td></tr>\";\r\n            }\r\n        });\r\n\r\n        markup += \"</table>\";\r\n        return markup;\r\n\r\n\r\n    };\r\n\r\n    static throttle(fn, threshhold, scope) {\r\n        threshhold || (threshhold = 200);\r\n        var last, deferTimer;\r\n\r\n        return function () {\r\n            var context = scope || this;\r\n\r\n            var now = +new Date,\r\n                args = arguments;\r\n            if (last && now < last + threshhold) {\r\n                // hold on to it\r\n                clearTimeout(deferTimer);\r\n                deferTimer = setTimeout(function () {\r\n                    last = now;\r\n                    fn.apply(context, args);\r\n                }, threshhold);\r\n            } else {\r\n                last = now;\r\n                fn.apply(context, args);\r\n            }\r\n        }\r\n    };\r\n\r\n    static splitStringRespectingQuotes(string, delim) {\r\n\r\n        var tokens = [],\r\n            len = string.length,\r\n            i,\r\n            n = 0,\r\n            quote = false,\r\n            c;\r\n\r\n        if (len > 0) {\r\n\r\n            tokens[n] = string.charAt(0);\r\n            for (i = 1; i < len; i++) {\r\n                c = string.charAt(i);\r\n                if (c === '\"') {\r\n                    quote = !quote;\r\n                }\r\n                else if (!quote && c === delim) {\r\n                    n++;\r\n                    tokens[n] = \"\";\r\n                }\r\n                else {\r\n                    tokens[n] += c;\r\n                }\r\n            }\r\n        }\r\n        return tokens;\r\n    };\r\n\r\n    /**\r\n     * Extend jQuery's ajax function to handle binary requests.   Credit to Henry Algus:\r\n     *\r\n     * http://www.henryalgus.com/reading-binary-files-using-jquery-ajax/\r\n     */\r\n   static addAjaxExtensions () {\r\n\r\n        // use this transport for \"binary\" data type\r\n        $.ajaxTransport(\"+binary\", function (options, originalOptions, jqXHR) {\r\n\r\n            return {\r\n                // create new XMLHttpRequest\r\n                send: function (_, callback) {\r\n                    // setup all variables\r\n                    var xhr = new XMLHttpRequest(),\r\n                        url = options.url,\r\n                        type = options.type,\r\n                        responseType = \"arraybuffer\",\r\n                        data = options.data || null;\r\n\r\n                    xhr.addEventListener('load', function () {\r\n                        var data = {};\r\n                        data[options.dataType] = xhr.response;\r\n                        // make callback and send data\r\n                        callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders());\r\n                    });\r\n\r\n                    xhr.open(type, url);\r\n                    xhr.responseType = responseType;\r\n\r\n                    if (options.headers) {\r\n                        for (var prop in options.headers) {\r\n                            if (options.headers.hasOwnProperty(prop)) {\r\n                                xhr.setRequestHeader(prop, options.headers[prop]);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // TODO -- set any other options values\r\n                },\r\n                abort: function () {\r\n                    jqXHR.abort();\r\n                }\r\n            };\r\n\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Test if the given value is a string or number.  Not using typeof as it fails on boxed primitives.\r\n     *\r\n     * @param value\r\n     * @returns boolean\r\n     */\r\n    static isStringOrNumber(value) {\r\n        return (value.substring || value.toFixed) ? true : false\r\n    };\r\n\r\n    static constrainBBox($child, $parent) {\r\n\r\n        var delta,\r\n            topLeft,\r\n            bboxChild = {},\r\n            bboxParent = {};\r\n\r\n        bboxParent.left = bboxParent.top = 0;\r\n        bboxParent.right = $parent.outerWidth();\r\n        bboxParent.bottom = $parent.outerHeight();\r\n\r\n        topLeft = $child.offset();\r\n\r\n        bboxChild.left = topLeft.left - $parent.offset().left;\r\n        bboxChild.top = topLeft.top - $parent.offset().top;\r\n        bboxChild.right = bboxChild.left + $child.outerWidth();\r\n        bboxChild.bottom = bboxChild.top + $child.outerHeight();\r\n\r\n        delta = bboxChild.bottom - bboxParent.bottom;\r\n        if (delta > 0) {\r\n\r\n            // clamp to trackContainer bottom\r\n            topLeft.top -= delta;\r\n\r\n            bboxChild.top -= delta;\r\n            bboxChild.bottom -= delta;\r\n\r\n            delta = bboxChild.top - bboxParent.top;\r\n            if (delta < 0) {\r\n                topLeft.top -= delta;\r\n            }\r\n\r\n        }\r\n\r\n        return topLeft;\r\n\r\n    };\r\n\r\n    static log(message) {\r\n        if (igv.enableLogging && console && console.log) {\r\n            console.log(message);\r\n        }\r\n    };\r\n\r\n\r\n}\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! xhr2 */ \"xhr2\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMuanM/MDI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IEJyb2FkIEluc3RpdHV0ZVxyXG4gKlxyXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG4gKlxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICpcclxuICpcclxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gKiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxubGV0IHBhcnNlVXJpX29wdGlvbnMgPSB7XHJcbiAgICAgICAgc3RyaWN0TW9kZTogZmFsc2UsXHJcbiAgICAgICAga2V5OiBbXCJzb3VyY2VcIiwgXCJwcm90b2NvbFwiLCBcImF1dGhvcml0eVwiLCBcInVzZXJJbmZvXCIsIFwidXNlclwiLCBcInBhc3N3b3JkXCIsIFwiaG9zdFwiLCBcInBvcnRcIiwgXCJyZWxhdGl2ZVwiLCBcInBhdGhcIiwgXCJkaXJlY3RvcnlcIiwgXCJmaWxlXCIsIFwicXVlcnlcIiwgXCJhbmNob3JcIl0sXHJcbiAgICAgICAgcToge1xyXG4gICAgICAgICAgICBuYW1lOiBcInF1ZXJ5S2V5XCIsXHJcbiAgICAgICAgICAgIHBhcnNlcjogLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nXHJcbiAgICAgICAgfSxcclxuICAgICAgICBwYXJzZXI6IHtcclxuICAgICAgICAgICAgc3RyaWN0OiAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSk/KCgoKD86W14/I1xcL10qXFwvKSopKFtePyNdKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLFxyXG4gICAgICAgICAgICBsb29zZTogL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG5cclxuY2xhc3MgVXRpbHN7XHJcblxyXG4gICAgXHJcbiAgICBzdGF0aWMgYWRkQWxwaGFUb1JHQihyZ2JTdHJpbmcsIGFscGhhKSB7XHJcblxyXG4gICAgICAgIGlmIChyZ2JTdHJpbmcuc3RhcnRzV2l0aChcInJnYlwiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmdiU3RyaW5nLnJlcGxhY2UoXCJyZ2JcIiwgXCJyZ2JhXCIpLnJlcGxhY2UoXCIpXCIsIFwiLCBcIiArIGFscGhhICsgXCIpXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJnYlN0cmluZyArIFwiIGlzIG5vdCBhbiByZ2Igc3R5bGUgc3RyaW5nXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmdiU3RyaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHByZXNlbnRBbGVydCh0cmFja19kaXYsZXJyb3Ipe1xyXG4gICAgICAgIGxldCBkaXY9ICQoXCI8ZGl2PlwiKS5jc3Moe1wicG9zaXRpb25cIjpcImFic29sdXRlXCIsXCJiYWNrZ3JvdW5kLWNvbG9yXCI6XCJ3aGl0ZVwifSkuYXR0cihcImNsYXNzXCIsXCJtbHYtYWxlcnRcIikuYXBwZW5kVG8odHJhY2tfZGl2KTtcclxuICAgICAgICBsZXQgZGl2MT0gJChcIjxkaXY+XCIpLmNzcyh7XCJkaXNwbGF5XCI6XCJmbGV4XCIsXCJqdXN0aWZ5LWNvbnRlbnRcIjpcImNlbnRlclwifSkuYXBwZW5kVG8oZGl2KTtcclxuICAgICAgICBkaXYxLmFwcGVuZCgkKCc8aSBjbGFzcz1cImZhcyBmYS1leGNsYW1hdGlvbi1jaXJjbGVcIj48L2k+JykuY3NzKHtjb2xvcjpcInJlZFwiLFwiZm9udC1zaXplXCI6XCIxNnB4XCIsXCJ0ZXh0LWFsaWduXCI6XCJjZW50ZXJcIix9KSk7XHJcbiAgICAgICAgZGl2LmFwcGVuZCgkKFwiPGRpdj5cIitlcnJvcitcIjwvZGl2PlwiKS5jc3Moe2NvbG9yOlwicmVkXCIsXCJmb250LXNpemVcIjpcIjE0cHhcIixcInRleHQtYWxpZ25cIjpcImNlbnRlclwifSkpO1xyXG4gICAgICAgIGxldCBsZWZ0ID0gTWF0aC5yb3VuZCgodHJhY2tfZGl2LndpZHRoKCkvMiktKGRpdi53aWR0aCgpLzIpKTtcclxuICAgICAgICBsZXQgdG9wID1NYXRoLnJvdW5kKCh0cmFja19kaXYuaGVpZ2h0KCkvMiktKGRpdi5oZWlnaHQoKS8yKSk7XHJcbiAgICAgICAgZGl2LmNzcyh7XCJsZWZ0XCI6bGVmdCtcInB4XCIsdG9wOnRvcCtcInB4XCJ9KTtcclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICBcclxuXHJcbiAgICBzdGF0aWMgc3Bpbm5lcihzaXplKSB7XHJcblxyXG4gICAgICAgIC8vIHNwaW5uZXJcclxuICAgICAgICB2YXIgJGNvbnRhaW5lcixcclxuICAgICAgICAgICAgJHNwaW5uZXI7XHJcblxyXG4gICAgICAgICRzcGlubmVyID0gJCgnPGkgY2xhc3M9XCJmYSBmYS1sZyBmYS1zcGlubmVyIGZhLXNwaW4gaWd2LXNwaW5uZXJcIj4nKS5jc3Moe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCI1MCVcIixsZWZ0OlwiNTAlXCJ9KTtcclxuICAgICAgICBpZiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAkc3Bpbm5lci5jc3MoXCJmb250LXNpemVcIiwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIFxyXG5cclxuICAgICAgICByZXR1cm4gJHNwaW5uZXJbMF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHNwaW5uZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNwaW5uZXJPYmplY3RXaXRoUGFyZW50RWxlbWVudChwYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudEVsZW1lbnQuZmluZChcImRpdi5pZ3Ytc3Bpbm5lci1jb250YWluZXJcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgdGhlIHNwaW5uZXIgZm9yIHRoZSBwYXJlbnQgZWxlbWVudCwgaWYgaXQgaGFzIG9uZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3RhcnRTcGlubmVyQXRQYXJlbnRFbGVtZW50KHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4oXCIuZmEtc3Bpbm5lclwiKS5zaG93KCk7ICBcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0aGUgc3Bpbm5lciBmb3IgdGhlIHBhcmVudCBlbGVtZW50LCBpZiBpdCBoYXMgb25lXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50RWxlbWVudFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3RvcFNwaW5uZXJBdFBhcmVudEVsZW1lbnQgKHBhcmVudEVsZW1lbnQpIHtcclxuICAgICAgICBwYXJlbnRFbGVtZW50LmNoaWxkcmVuKFwiLmZhLXNwaW5uZXJcIikuaGlkZSgpO1xyXG4gICAgICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZVVyaShzdHIpIHtcclxuXHJcbiAgICAgICAgdmFyIG8gPSBwYXJzZVVyaV9vcHRpb25zLFxyXG4gICAgICAgICAgICBtID0gby5wYXJzZXJbby5zdHJpY3RNb2RlID8gXCJzdHJpY3RcIiA6IFwibG9vc2VcIl0uZXhlYyhzdHIpLFxyXG4gICAgICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICAgICAgaSA9IDE0O1xyXG5cclxuICAgICAgICB3aGlsZSAoaS0tKSB1cmlbby5rZXlbaV1dID0gbVtpXSB8fCBcIlwiO1xyXG5cclxuICAgICAgICB1cmlbby5xLm5hbWVdID0ge307XHJcbiAgICAgICAgdXJpW28ua2V5WzEyXV0ucmVwbGFjZShvLnEucGFyc2VyLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xyXG4gICAgICAgICAgICBpZiAoJDEpIHVyaVtvLnEubmFtZV1bJDFdID0gJDI7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB1cmk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgXHJcbiAgXHJcbiAgICBzdGF0aWMgZG9tRWxlbWVudFJlY3RBc1N0cmluZyhlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiIHggXCIgKyBlbGVtZW50LmNsaWVudExlZnQgKyBcIiB5IFwiICsgZWxlbWVudC5jbGllbnRUb3AgKyBcIiB3IFwiICsgZWxlbWVudC5jbGllbnRXaWR0aCArIFwiIGggXCIgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGlzTnVtYmVyKG4pIHtcclxuXHJcbiAgICAgICAgaWYgKFwiXCIgPT09IG4pIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH0gZWxzZSBpZiAodW5kZWZpbmVkID09PSBuKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGd1aWQgICgpIHtcclxuICAgICAgICByZXR1cm4gKFwiMDAwMFwiICsgKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygzNiwgNCkgPDwgMCkudG9TdHJpbmcoMzYpKS5zbGljZSgtNCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJldHVybnMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSlcclxuICAgIHN0YXRpYyByYW5kb20obWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTdGFja092ZXJmbG93OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMDgxMDY3NC8xMTYxNjlcclxuICAgIHN0YXRpYyBudW1iZXJGb3JtYXR0ZXIocmF3TnVtYmVyKSB7XHJcblxyXG4gICAgICAgIHZhciBkZWMgPSBTdHJpbmcocmF3TnVtYmVyKS5zcGxpdCgvWy4sXS8pLFxyXG4gICAgICAgICAgICBzZXAgPSAnLCcsXHJcbiAgICAgICAgICAgIGRlY3NlcCA9ICcuJztcclxuXHJcbiAgICAgICAgcmV0dXJuIGRlY1swXS5zcGxpdCgnJykucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgbm93LCBpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAlIDMgPT09IDAgPyBwcmV2ICsgc2VwICsgbm93IDogcHJldiArIG5vdztcclxuICAgICAgICAgICAgfSkuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSArIChkZWNbMV0gPyBkZWNzZXAgKyBkZWNbMV0gOiAnJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHN0YXRpYyBudW1iZXJVbkZvcm1hdHRlciAoZm9ybWF0ZWROdW1iZXIpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdGVkTnVtYmVyLnNwbGl0KFwiLFwiKS5qb2luKCkucmVwbGFjZShcIixcIiwgXCJcIiwgXCJnXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zbGF0ZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgZm9yIHRoZSBldmVudCB0byB0aGUgY29vcmRpbmF0ZXMgZm9yIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIGVcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNsYXRlTW91c2VDb29yZGluYXRlcyhlLCB0YXJnZXQpIHtcclxuXHJcbiAgICAgICAgdmFyIGVGaXhlZCA9ICQuZXZlbnQuZml4KGUpLCAgIC8vIFNldHMgcGFnZVggYW5kIHBhZ2VZIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlbVxyXG4gICAgICAgICAgICBwb3N4ID0gZUZpeGVkLnBhZ2VYIC0gJCh0YXJnZXQpLm9mZnNldCgpLmxlZnQsXHJcbiAgICAgICAgICAgIHBvc3kgPSBlRml4ZWQucGFnZVkgLSAkKHRhcmdldCkub2Zmc2V0KCkudG9wO1xyXG5cclxuICAgICAgICByZXR1cm4ge3g6IHBvc3gsIHk6IHBvc3l9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdCBtYXJrdXAgZm9yIHBvcG92ZXIgdGV4dCBmcm9tIGFuIGFycmF5IG9mIG5hbWUgdmFsdWUgcGFpcnMgW3tuYW1lLCB2YWx1ZX1dXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JtYXRQb3BvdmVyVGV4dCAobmFtZVZhbHVlQXJyYXkpIHtcclxuXHJcbiAgICAgICAgdmFyIG1hcmt1cCA9IFwiPHRhYmxlIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlci10YWJsZVxcXCI+XCI7XHJcblxyXG4gICAgICAgIG5hbWVWYWx1ZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKG5hbWVWYWx1ZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKG5hbWVWYWx1ZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvL21hcmt1cCArPSBcIjx0cj48dGQgY2xhc3M9XFxcImlndi1wb3BvdmVyLXRkXFxcIj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyTmFtZVxcXCI+XCIgKyBuYW1lVmFsdWUubmFtZSArIFwiPC9zcGFuPlwiICsgXCI8c3BhbiBjbGFzcz1cXFwiaWd2LXBvcG92ZXJWYWx1ZVxcXCI+XCIgKyBuYW1lVmFsdWUudmFsdWUgKyBcIjwvc3Bhbj5cIiArIFwiPC90ZD48L3RyPlwiO1xyXG4gICAgICAgICAgICAgICAgbWFya3VwICs9IFwiPHRyPjx0ZCBjbGFzcz1cXFwiaWd2LXBvcG92ZXItdGRcXFwiPlwiICsgXCI8ZGl2IGNsYXNzPVxcXCJpZ3YtcG9wb3Zlck5hbWVWYWx1ZVxcXCI+XCIgKyBcIjxzcGFuIGNsYXNzPVxcXCJpZ3YtcG9wb3Zlck5hbWVcXFwiPlwiICsgbmFtZVZhbHVlLm5hbWUgKyBcIjwvc3Bhbj5cIiArIFwiPHNwYW4gY2xhc3M9XFxcImlndi1wb3BvdmVyVmFsdWVcXFwiPlwiICsgbmFtZVZhbHVlLnZhbHVlICsgXCI8L3NwYW4+XCIgKyBcIjwvZGl2PlwiICsgXCI8L3RkPjwvdHI+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBuYW1lL3ZhbHVlIHBhaXJcclxuICAgICAgICAgICAgICAgIG1hcmt1cCArPSBcIjx0cj48dGQ+XCIgKyBuYW1lVmFsdWUudG9TdHJpbmcoKSArIFwiPC90ZD48L3RyPlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1hcmt1cCArPSBcIjwvdGFibGU+XCI7XHJcbiAgICAgICAgcmV0dXJuIG1hcmt1cDtcclxuXHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgdGhyb3R0bGUoZm4sIHRocmVzaGhvbGQsIHNjb3BlKSB7XHJcbiAgICAgICAgdGhyZXNoaG9sZCB8fCAodGhyZXNoaG9sZCA9IDIwMCk7XHJcbiAgICAgICAgdmFyIGxhc3QsIGRlZmVyVGltZXI7XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gc2NvcGUgfHwgdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBub3cgPSArbmV3IERhdGUsXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICBpZiAobGFzdCAmJiBub3cgPCBsYXN0ICsgdGhyZXNoaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaG9sZCBvbiB0byBpdFxyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgZGVmZXJUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aHJlc2hob2xkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxhc3QgPSBub3c7XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIHNwbGl0U3RyaW5nUmVzcGVjdGluZ1F1b3RlcyhzdHJpbmcsIGRlbGltKSB7XHJcblxyXG4gICAgICAgIHZhciB0b2tlbnMgPSBbXSxcclxuICAgICAgICAgICAgbGVuID0gc3RyaW5nLmxlbmd0aCxcclxuICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgbiA9IDAsXHJcbiAgICAgICAgICAgIHF1b3RlID0gZmFsc2UsXHJcbiAgICAgICAgICAgIGM7XHJcblxyXG4gICAgICAgIGlmIChsZW4gPiAwKSB7XHJcblxyXG4gICAgICAgICAgICB0b2tlbnNbbl0gPSBzdHJpbmcuY2hhckF0KDApO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGMgPSBzdHJpbmcuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9ICFxdW90ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFxdW90ZSAmJiBjID09PSBkZWxpbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbbl0gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW25dICs9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmQgalF1ZXJ5J3MgYWpheCBmdW5jdGlvbiB0byBoYW5kbGUgYmluYXJ5IHJlcXVlc3RzLiAgIENyZWRpdCB0byBIZW5yeSBBbGd1czpcclxuICAgICAqXHJcbiAgICAgKiBodHRwOi8vd3d3LmhlbnJ5YWxndXMuY29tL3JlYWRpbmctYmluYXJ5LWZpbGVzLXVzaW5nLWpxdWVyeS1hamF4L1xyXG4gICAgICovXHJcbiAgIHN0YXRpYyBhZGRBamF4RXh0ZW5zaW9ucyAoKSB7XHJcblxyXG4gICAgICAgIC8vIHVzZSB0aGlzIHRyYW5zcG9ydCBmb3IgXCJiaW5hcnlcIiBkYXRhIHR5cGVcclxuICAgICAgICAkLmFqYXhUcmFuc3BvcnQoXCIrYmluYXJ5XCIsIGZ1bmN0aW9uIChvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKF8sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0dXAgYWxsIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gb3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBvcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtvcHRpb25zLmRhdGFUeXBlXSA9IHhoci5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBjYWxsYmFjayBhbmQgc2VuZCBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0LCBkYXRhLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4aHIub3Blbih0eXBlLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihwcm9wLCBvcHRpb25zLmhlYWRlcnNbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIC0tIHNldCBhbnkgb3RoZXIgb3B0aW9ucyB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpxWEhSLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3QgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nIG9yIG51bWJlci4gIE5vdCB1c2luZyB0eXBlb2YgYXMgaXQgZmFpbHMgb24gYm94ZWQgcHJpbWl0aXZlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIGJvb2xlYW5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzU3RyaW5nT3JOdW1iZXIodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlLnN1YnN0cmluZyB8fCB2YWx1ZS50b0ZpeGVkKSA/IHRydWUgOiBmYWxzZVxyXG4gICAgfTtcclxuXHJcbiAgICBzdGF0aWMgY29uc3RyYWluQkJveCgkY2hpbGQsICRwYXJlbnQpIHtcclxuXHJcbiAgICAgICAgdmFyIGRlbHRhLFxyXG4gICAgICAgICAgICB0b3BMZWZ0LFxyXG4gICAgICAgICAgICBiYm94Q2hpbGQgPSB7fSxcclxuICAgICAgICAgICAgYmJveFBhcmVudCA9IHt9O1xyXG5cclxuICAgICAgICBiYm94UGFyZW50LmxlZnQgPSBiYm94UGFyZW50LnRvcCA9IDA7XHJcbiAgICAgICAgYmJveFBhcmVudC5yaWdodCA9ICRwYXJlbnQub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgIGJib3hQYXJlbnQuYm90dG9tID0gJHBhcmVudC5vdXRlckhlaWdodCgpO1xyXG5cclxuICAgICAgICB0b3BMZWZ0ID0gJGNoaWxkLm9mZnNldCgpO1xyXG5cclxuICAgICAgICBiYm94Q2hpbGQubGVmdCA9IHRvcExlZnQubGVmdCAtICRwYXJlbnQub2Zmc2V0KCkubGVmdDtcclxuICAgICAgICBiYm94Q2hpbGQudG9wID0gdG9wTGVmdC50b3AgLSAkcGFyZW50Lm9mZnNldCgpLnRvcDtcclxuICAgICAgICBiYm94Q2hpbGQucmlnaHQgPSBiYm94Q2hpbGQubGVmdCArICRjaGlsZC5vdXRlcldpZHRoKCk7XHJcbiAgICAgICAgYmJveENoaWxkLmJvdHRvbSA9IGJib3hDaGlsZC50b3AgKyAkY2hpbGQub3V0ZXJIZWlnaHQoKTtcclxuXHJcbiAgICAgICAgZGVsdGEgPSBiYm94Q2hpbGQuYm90dG9tIC0gYmJveFBhcmVudC5ib3R0b207XHJcbiAgICAgICAgaWYgKGRlbHRhID4gMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gY2xhbXAgdG8gdHJhY2tDb250YWluZXIgYm90dG9tXHJcbiAgICAgICAgICAgIHRvcExlZnQudG9wIC09IGRlbHRhO1xyXG5cclxuICAgICAgICAgICAgYmJveENoaWxkLnRvcCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYmJveENoaWxkLmJvdHRvbSAtPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGRlbHRhID0gYmJveENoaWxkLnRvcCAtIGJib3hQYXJlbnQudG9wO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BMZWZ0LnRvcCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0b3BMZWZ0O1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgc3RhdGljIGxvZyhtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlndi5lbmFibGVMb2dnaW5nICYmIGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG59XHJcblxyXG5leHBvcnQge1V0aWxzfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils.js\n");

/***/ }),

/***/ "./src/vendor/inflate.js":
/*!*******************************!*\
  !*** ./src/vendor/inflate.js ***!
  \*******************************/
/*! exports provided: jszlib_inflate_buffer, arrayCopy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jszlib_inflate_buffer\", function() { return jszlib_inflate_buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"arrayCopy\", function() { return arrayCopy; });\n/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS=15; // 32K LZ77 window\nvar DEF_WBITS=MAX_WBITS;\nvar MAX_MEM_LEVEL=9;\nvar MANY=1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT=0x20;\n\nvar Z_NO_FLUSH=0;\nvar Z_PARTIAL_FLUSH=1;\nvar Z_SYNC_FLUSH=2;\nvar Z_FULL_FLUSH=3;\nvar Z_FINISH=4;\n\nvar Z_DEFLATED=8;\n\nvar Z_OK=0;\nvar Z_STREAM_END=1;\nvar Z_NEED_DICT=2;\nvar Z_ERRNO=-1;\nvar Z_STREAM_ERROR=-2;\nvar Z_DATA_ERROR=-3;\nvar Z_MEM_ERROR=-4;\nvar Z_BUF_ERROR=-5;\nvar Z_VERSION_ERROR=-6;\n\nvar METHOD=0;   // waiting for method byte\nvar FLAG=1;     // waiting for flag byte\nvar DICT4=2;    // four dictionary check bytes to go\nvar DICT3=3;    // three dictionary check bytes to go\nvar DICT2=4;    // two dictionary check bytes to go\nvar DICT1=5;    // one dictionary check byte to go\nvar DICT0=6;    // waiting for inflateSetDictionary\nvar BLOCKS=7;   // decompressing blocks\nvar CHECK4=8;   // four check bytes to go\nvar CHECK3=9;   // three check bytes to go\nvar CHECK2=10;  // two check bytes to go\nvar CHECK1=11;  // one check byte to go\nvar DONE=12;    // finished check, done\nvar BAD=13;     // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE=0;  // get type bits (3, including end bit)\nvar IB_LENS=1;  // get lengths for stored\nvar IB_STORED=2;// processing stored block\nvar IB_TABLE=3; // get table lengths\nvar IB_BTREE=4; // get bit lengths tree for a dynamic block\nvar IB_DTREE=5; // get length, distance trees for a dynamic block\nvar IB_CODES=6; // processing fixed or dynamic block\nvar IB_DRY=7;   // output remaining window bytes\nvar IB_DONE=8;  // finished last block, done\nvar IB_BAD=9;   // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,192,\n    80,7,10, 0,8,96, 0,8,32, 0,9,160,\n    0,8,0, 0,8,128, 0,8,64, 0,9,224,\n    80,7,6, 0,8,88, 0,8,24, 0,9,144,\n    83,7,59, 0,8,120, 0,8,56, 0,9,208,\n    81,7,17, 0,8,104, 0,8,40, 0,9,176,\n    0,8,8, 0,8,136, 0,8,72, 0,9,240,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,200,\n    81,7,13, 0,8,100, 0,8,36, 0,9,168,\n    0,8,4, 0,8,132, 0,8,68, 0,9,232,\n    80,7,8, 0,8,92, 0,8,28, 0,9,152,\n    84,7,83, 0,8,124, 0,8,60, 0,9,216,\n    82,7,23, 0,8,108, 0,8,44, 0,9,184,\n    0,8,12, 0,8,140, 0,8,76, 0,9,248,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,196,\n    81,7,11, 0,8,98, 0,8,34, 0,9,164,\n    0,8,2, 0,8,130, 0,8,66, 0,9,228,\n    80,7,7, 0,8,90, 0,8,26, 0,9,148,\n    84,7,67, 0,8,122, 0,8,58, 0,9,212,\n    82,7,19, 0,8,106, 0,8,42, 0,9,180,\n    0,8,10, 0,8,138, 0,8,74, 0,9,244,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,204,\n    81,7,15, 0,8,102, 0,8,38, 0,9,172,\n    0,8,6, 0,8,134, 0,8,70, 0,9,236,\n    80,7,9, 0,8,94, 0,8,30, 0,9,156,\n    84,7,99, 0,8,126, 0,8,62, 0,9,220,\n    82,7,27, 0,8,110, 0,8,46, 0,9,188,\n    0,8,14, 0,8,142, 0,8,78, 0,9,252,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,194,\n    80,7,10, 0,8,97, 0,8,33, 0,9,162,\n    0,8,1, 0,8,129, 0,8,65, 0,9,226,\n    80,7,6, 0,8,89, 0,8,25, 0,9,146,\n    83,7,59, 0,8,121, 0,8,57, 0,9,210,\n    81,7,17, 0,8,105, 0,8,41, 0,9,178,\n    0,8,9, 0,8,137, 0,8,73, 0,9,242,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,202,\n    81,7,13, 0,8,101, 0,8,37, 0,9,170,\n    0,8,5, 0,8,133, 0,8,69, 0,9,234,\n    80,7,8, 0,8,93, 0,8,29, 0,9,154,\n    84,7,83, 0,8,125, 0,8,61, 0,9,218,\n    82,7,23, 0,8,109, 0,8,45, 0,9,186,\n    0,8,13, 0,8,141, 0,8,77, 0,9,250,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,198,\n    81,7,11, 0,8,99, 0,8,35, 0,9,166,\n    0,8,3, 0,8,131, 0,8,67, 0,9,230,\n    80,7,7, 0,8,91, 0,8,27, 0,9,150,\n    84,7,67, 0,8,123, 0,8,59, 0,9,214,\n    82,7,19, 0,8,107, 0,8,43, 0,9,182,\n    0,8,11, 0,8,139, 0,8,75, 0,9,246,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,206,\n    81,7,15, 0,8,103, 0,8,39, 0,9,174,\n    0,8,7, 0,8,135, 0,8,71, 0,9,238,\n    80,7,9, 0,8,95, 0,8,31, 0,9,158,\n    84,7,99, 0,8,127, 0,8,63, 0,9,222,\n    82,7,27, 0,8,111, 0,8,47, 0,9,190,\n    0,8,15, 0,8,143, 0,8,79, 0,9,254,\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,193,\n\n    80,7,10, 0,8,96, 0,8,32, 0,9,161,\n    0,8,0, 0,8,128, 0,8,64, 0,9,225,\n    80,7,6, 0,8,88, 0,8,24, 0,9,145,\n    83,7,59, 0,8,120, 0,8,56, 0,9,209,\n    81,7,17, 0,8,104, 0,8,40, 0,9,177,\n    0,8,8, 0,8,136, 0,8,72, 0,9,241,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,201,\n    81,7,13, 0,8,100, 0,8,36, 0,9,169,\n    0,8,4, 0,8,132, 0,8,68, 0,9,233,\n    80,7,8, 0,8,92, 0,8,28, 0,9,153,\n    84,7,83, 0,8,124, 0,8,60, 0,9,217,\n    82,7,23, 0,8,108, 0,8,44, 0,9,185,\n    0,8,12, 0,8,140, 0,8,76, 0,9,249,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,197,\n    81,7,11, 0,8,98, 0,8,34, 0,9,165,\n    0,8,2, 0,8,130, 0,8,66, 0,9,229,\n    80,7,7, 0,8,90, 0,8,26, 0,9,149,\n    84,7,67, 0,8,122, 0,8,58, 0,9,213,\n    82,7,19, 0,8,106, 0,8,42, 0,9,181,\n    0,8,10, 0,8,138, 0,8,74, 0,9,245,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,205,\n    81,7,15, 0,8,102, 0,8,38, 0,9,173,\n    0,8,6, 0,8,134, 0,8,70, 0,9,237,\n    80,7,9, 0,8,94, 0,8,30, 0,9,157,\n    84,7,99, 0,8,126, 0,8,62, 0,9,221,\n    82,7,27, 0,8,110, 0,8,46, 0,9,189,\n    0,8,14, 0,8,142, 0,8,78, 0,9,253,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,195,\n    80,7,10, 0,8,97, 0,8,33, 0,9,163,\n    0,8,1, 0,8,129, 0,8,65, 0,9,227,\n    80,7,6, 0,8,89, 0,8,25, 0,9,147,\n    83,7,59, 0,8,121, 0,8,57, 0,9,211,\n    81,7,17, 0,8,105, 0,8,41, 0,9,179,\n    0,8,9, 0,8,137, 0,8,73, 0,9,243,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,203,\n    81,7,13, 0,8,101, 0,8,37, 0,9,171,\n    0,8,5, 0,8,133, 0,8,69, 0,9,235,\n    80,7,8, 0,8,93, 0,8,29, 0,9,155,\n    84,7,83, 0,8,125, 0,8,61, 0,9,219,\n    82,7,23, 0,8,109, 0,8,45, 0,9,187,\n    0,8,13, 0,8,141, 0,8,77, 0,9,251,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,199,\n    81,7,11, 0,8,99, 0,8,35, 0,9,167,\n    0,8,3, 0,8,131, 0,8,67, 0,9,231,\n    80,7,7, 0,8,91, 0,8,27, 0,9,151,\n    84,7,67, 0,8,123, 0,8,59, 0,9,215,\n    82,7,19, 0,8,107, 0,8,43, 0,9,183,\n    0,8,11, 0,8,139, 0,8,75, 0,9,247,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,207,\n    81,7,15, 0,8,103, 0,8,39, 0,9,175,\n    0,8,7, 0,8,135, 0,8,71, 0,9,239,\n    80,7,9, 0,8,95, 0,8,31, 0,9,159,\n    84,7,99, 0,8,127, 0,8,63, 0,9,223,\n    82,7,27, 0,8,111, 0,8,47, 0,9,191,\n    0,8,15, 0,8,143, 0,8,79, 0,9,255\n];\nvar fixed_td = [\n    80,5,1, 87,5,257, 83,5,17, 91,5,4097,\n    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,\n    80,5,3, 88,5,513, 84,5,33, 92,5,8193,\n    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,\n    80,5,2, 87,5,385, 83,5,25, 91,5,6145,\n    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,\n    80,5,4, 88,5,769, 84,5,49, 92,5,12289,\n    82,5,13, 90,5,3073, 86,5,193, 192,5,24577\n];\n\n  // Tables for deflate from PKZIP's appnote.txt.\n  var cplens = [ // Copy lengths for literal codes 257..285\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n  ];\n\n  // see note #13 above about 258\n  var cplext = [ // Extra bits for literal codes 257..285\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid\n  ];\n\n var cpdist = [ // Copy offsets for distance codes 0..29\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n  ];\n\n  var cpdext = [ // Extra bits for distance codes\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {\n}\n\n\nZStream.prototype.inflateInit = function(w, nowrap) {\n    if (!w) {\n\tw = DEF_WBITS;\n    }\n    if (nowrap) {\n\tnowrap = false;\n    }\n    this.istate = new Inflate();\n    return this.istate.inflateInit(this, nowrap?-w:w);\n}\n\nZStream.prototype.inflate = function(f) {\n    if(this.istate==null) return Z_STREAM_ERROR;\n    return this.istate.inflate(this, f);\n}\n\nZStream.prototype.inflateEnd = function(){\n    if(this.istate==null) return Z_STREAM_ERROR;\n    var ret=istate.inflateEnd(this);\n    this.istate = null;\n    return ret;\n}\nZStream.prototype.inflateSync = function(){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSync(this);\n}\nZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSetDictionary(this, dictionary, dictLength);\n}\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n    this.was = [0];\n}\n\nInflate.prototype.inflateReset = function(z) {\n    if(z == null || z.istate == null) return Z_STREAM_ERROR;\n    \n    z.total_in = z.total_out = 0;\n    z.msg = null;\n    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;\n    z.istate.blocks.reset(z, null);\n    return Z_OK;\n}\n\nInflate.prototype.inflateEnd = function(z){\n    if(this.blocks != null)\n      this.blocks.free(z);\n    this.blocks=null;\n    return Z_OK;\n}\n\nInflate.prototype.inflateInit = function(z, w){\n    z.msg = null;\n    this.blocks = null;\n\n    // handle undocumented nowrap option (no zlib header or check)\n    let nowrap = 0;\n    if(w < 0){\n      w = - w;\n      nowrap = 1;\n    }\n\n    // set window size\n    if(w<8 ||w>15){\n      this.inflateEnd(z);\n      return Z_STREAM_ERROR;\n    }\n    this.wbits=w;\n\n    z.istate.blocks=new InfBlocks(z, \n\t\t\t\t  z.istate.nowrap!=0 ? null : this,\n\t\t\t\t  1<<w);\n\n    // reset state\n    this.inflateReset(z);\n    return Z_OK;\n  }\n\nInflate.prototype.inflate = function(z, f){\n    var r, b;\n\n    if(z == null || z.istate == null || z.next_in == null)\n      return Z_STREAM_ERROR;\n    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n    r = Z_BUF_ERROR;\n    while (true){\n      switch (z.istate.mode){\n      case METHOD:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){\n          z.istate.mode = BAD;\n          z.msg=\"unknown compression method\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        if((z.istate.method>>4)+8>z.istate.wbits){\n          z.istate.mode = BAD;\n          z.msg=\"invalid window size\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        z.istate.mode=FLAG;\n      case FLAG:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        b = (z.next_in[z.next_in_index++])&0xff;\n\n        if((((z.istate.method << 8)+b) % 31)!=0){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        if((b&PRESET_DICT)==0){\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=DICT3;\n      case DICT3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode=DICT2;\n      case DICT2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode=DICT1;\n      case DICT1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++]&0xff);\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0;       // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if(r == Z_DATA_ERROR){\n          z.istate.mode = BAD;\n          z.istate.marker = 0;     // can try inflateSync\n          break;\n        }\n        if(r == Z_OK){\n          r = f;\n        }\n        if(r != Z_STREAM_END){\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if(z.istate.nowrap!=0){\n          z.istate.mode=DONE;\n          break;\n        }\n        z.istate.mode=CHECK4;\n      case CHECK4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=CHECK3;\n      case CHECK3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);\n\n        if(((z.istate.was[0])) != ((z.istate.need))){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n      }\n    }\n  }\n\n\nInflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {\n    var index=0;\n    var length = dictLength;\n    if(z==null || z.istate == null|| z.istate.mode != DICT0)\n      return Z_STREAM_ERROR;\n\n    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){\n      return Z_DATA_ERROR;\n    }\n\n    z.adler = z._adler.adler32(0, null, 0, 0);\n\n    if(length >= (1<<z.istate.wbits)){\n      length = (1<<z.istate.wbits)-1;\n      index=dictLength - length;\n    }\n    z.istate.blocks.set_dictionary(dictionary, index, length);\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n  }\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255]\n\nInflate.prototype.inflateSync = function(z){\n    var n;       // number of bytes to look at\n    var p;       // pointer to bytes\n    var m;       // number of marker bytes found in a row\n    var r, w;   // temporaries to save total_in and total_out\n\n    // set up\n    if(z == null || z.istate == null)\n      return Z_STREAM_ERROR;\n    if(z.istate.mode != BAD){\n      z.istate.mode = BAD;\n      z.istate.marker = 0;\n    }\n    if((n=z.avail_in)==0)\n      return Z_BUF_ERROR;\n    p=z.next_in_index;\n    m=z.istate.marker;\n\n    // search\n    while (n!=0 && m < 4){\n      if(z.next_in[p] == mark[m]){\n        m++;\n      }\n      else if(z.next_in[p]!=0){\n        m = 0;\n      }\n      else{\n        m = 4 - m;\n      }\n      p++; n--;\n    }\n\n    // restore\n    z.total_in += p-z.next_in_index;\n    z.next_in_index = p;\n    z.avail_in = n;\n    z.istate.marker = m;\n\n    // return no joy or set up to restart on a new block\n    if(m != 4){\n      return Z_DATA_ERROR;\n    }\n    r=z.total_in;  w=z.total_out;\n    this.inflateReset(z);\n    z.total_in=r;  z.total_out = w;\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n  // but removes the length bytes of the resulting empty stored block. When\n  // decompressing, PPP checks that at the end of input packet, inflate is\n  // waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function(z){\n    if(z == null || z.istate == null || z.istate.blocks == null)\n      return Z_STREAM_ERROR;\n    return z.istate.blocks.sync_point();\n}\n\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n    this.hufts=new Int32Array(MANY*3);\n    this.window=new Uint8Array(w);\n    this.end=w;\n    this.checkfn = checkfn;\n    this.mode = IB_TYPE;\n    this.reset(z, null);\n\n    this.left = 0;            // if STORED, bytes left to copy \n\n    this.table = 0;           // table lengths (14 bits) \n    this.index = 0;           // index into blens (or border) \n    this.blens = null;         // bit lengths of codes \n    this.bb=new Int32Array(1); // bit length tree depth \n    this.tb=new Int32Array(1); // bit length decoding tree \n\n    this.codes = new InfCodes();\n\n    this.last = 0;            // true if this block is the last block \n\n  // mode independent information \n    this.bitk = 0;            // bits in bit buffer \n    this.bitb = 0;            // bit buffer \n    this.read = 0;            // window read pointer \n    this.write = 0;           // window write pointer \n    this.check = 0;          // check on output \n\n    this.inftree=new InfTree();\n}\n\n\n\n\nInfBlocks.prototype.reset = function(z, c){\n    if(c) c[0]=this.check;\n    if(this.mode==IB_CODES){\n      this.codes.free(z);\n    }\n    this.mode=IB_TYPE;\n    this.bitk=0;\n    this.bitb=0;\n    this.read=this.write=0;\n\n    if(this.checkfn)\n      z.adler=this.check=z._adler.adler32(0, null, 0, 0);\n  }\n\n InfBlocks.prototype.proc = function(z, r){\n    var t;              // temporary storage\n    var b;              // bit buffer\n    var k;              // bits in bit buffer\n    var p;              // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n\n    // copy input/output information to locals (UPDATE macro restores)\n    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}\n    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}\n\n    // process input based on current state\n    while(true){\n      switch (this.mode){\n      case IB_TYPE:\n\n\twhile(k<(3)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\tt = (b & 7);\n\tthis.last = t & 1;\n\n\tswitch (t >>> 1){\n        case 0:                         // stored \n          {b>>>=(3);k-=(3);}\n          t = k & 7;                    // go to byte boundary\n\n          {b>>>=(t);k-=(t);}\n          this.mode = IB_LENS;                  // get length of stored block\n          break;\n        case 1:                         // fixed\n          {\n              var bl=new Int32Array(1);\n\t      var bd=new Int32Array(1);\n              var tl=[];\n\t      var td=[];\n\n\t      inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n          }\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_CODES;\n          break;\n        case 2:                         // dynamic\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_TABLE;\n          break;\n        case 3:                         // illegal\n\n          {b>>>=(3);k-=(3);}\n          this.mode = BAD;\n          z.msg = \"invalid block type\";\n          r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tbreak;\n      case IB_LENS:\n\twhile(k<(32)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){\n\t  this.mode = BAD;\n\t  z.msg = \"invalid stored block lengths\";\n\t  r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tthis.left = (b & 0xffff);\n\tb = k = 0;                       // dump bits\n\tthis.mode = left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_STORED:\n\tif (n == 0){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tif(m==0){\n\t  if(q==end&&read!=0){\n\t    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);\n\t  }\n\t  if(m==0){\n\t    this.write=q; \n\t    r=this.inflate_flush(z,r);\n\t    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    if(q==this.end && this.read != 0){\n\t      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    }\n\t    if(m==0){\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\tt = this.left;\n\tif(t>n) t = n;\n\tif(t>m) t = m;\n\tarrayCopy(z.next_in, p, window, q, t);\n\tp += t;  n -= t;\n\tq += t;  m -= t;\n\tif ((this.left -= t) != 0)\n\t  break;\n\tthis.mode = (this.last != 0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_TABLE:\n\n\twhile(k<(14)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.table = t = (b & 0x3fff);\n\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n\t  {\n\t    this.mode = IB_BAD;\n\t    z.msg = \"too many length or distance symbols\";\n\t    r = Z_DATA_ERROR;\n\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  }\n\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\tif(this.blens==null || this.blens.length<t){\n\t    this.blens=new Int32Array(t);\n\t}\n\telse{\n\t  for(var i=0; i<t; i++){\n              this.blens[i]=0;\n          }\n\t}\n\n\t{b>>>=(14);k-=(14);}\n\n\tthis.index = 0;\n\tthis.mode = IB_BTREE;\n      case IB_BTREE:\n\twhile (this.index < 4 + (this.table >>> 10)){\n\t  while(k<(3)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;\n\n\t  {b>>>=(3);k-=(3);}\n\t}\n\n\twhile(this.index < 19){\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n\t}\n\n\tthis.bb[0] = 7;\n\tt = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n\tif (t != Z_OK){\n\t  r = t;\n\t  if (r == Z_DATA_ERROR){\n\t    this.blens=null;\n\t    this.mode = IB_BAD;\n\t  }\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tthis.index = 0;\n\tthis.mode = IB_DTREE;\n      case IB_DTREE:\n\twhile (true){\n\t  t = this.table;\n\t  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){\n\t    break;\n\t  }\n\n\t  var h; //int[]\n\t  var i, j, c;\n\n\t  t = this.bb[0];\n\n\t  while(k<(t)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n//\t  if (this.tb[0]==-1){\n//            dlog(\"null...\");\n//\t  }\n\n\t  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];\n\t  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];\n\n\t  if (c < 16){\n\t    b>>>=(t);k-=(t);\n\t    this.blens[this.index++] = c;\n\t  }\n\t  else { // c == 16..18\n\t    i = c == 18 ? 7 : c - 14;\n\t    j = c == 18 ? 11 : 3;\n\n\t    while(k<(t+i)){\n\t      if(n!=0){\n\t\tr=Z_OK;\n\t      }\n\t      else{\n\t\tthis.bitb=b; this.bitk=k; \n\t\tz.avail_in=n;\n\t\tz.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\tthis.write=q;\n\t\treturn this.inflate_flush(z,r);\n\t      };\n\t      n--;\n\t      b|=(z.next_in[p++]&0xff)<<k;\n\t      k+=8;\n\t    }\n\n\t    b>>>=(t);k-=(t);\n\n\t    j += (b & inflate_mask[i]);\n\n\t    b>>>=(i);k-=(i);\n\n\t    i = this.index;\n\t    t = this.table;\n\t    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n\t\t(c == 16 && i < 1)){\n\t      this.blens=null;\n\t      this.mode = IB_BAD;\n\t      z.msg = \"invalid bit length repeat\";\n\t      r = Z_DATA_ERROR;\n\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\n\t    c = c == 16 ? this.blens[i-1] : 0;\n\t    do{\n\t      this.blens[i++] = c;\n\t    }\n\t    while (--j!=0);\n\t    this.index = i;\n\t  }\n\t}\n\n\tthis.tb[0]=-1;\n\t{\n\t    var bl=new Int32Array(1);\n\t    var bd=new Int32Array(1);\n\t    var tl=new Int32Array(1);\n\t    var td=new Int32Array(1);\n\t    bl[0] = 9;         // must be <= 9 for lookahead assumptions\n\t    bd[0] = 6;         // must be <= 9 for lookahead assumptions\n\n\t    t = this.table;\n\t    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), \n\t\t\t\t\t      1 + ((t >> 5) & 0x1f),\n\t\t\t\t\t      this.blens, bl, bd, tl, td, this.hufts, z);\n\n\t    if (t != Z_OK){\n\t        if (t == Z_DATA_ERROR){\n\t            this.blens=null;\n\t            this.mode = BAD;\n\t        }\n\t        r = t;\n\n\t        this.bitb=b; this.bitk=k; \n\t        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t        this.write=q;\n\t        return this.inflate_flush(z,r);\n\t    }\n\t    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n\t}\n\tthis.mode = IB_CODES;\n      case IB_CODES:\n\tthis.bitb=b; this.bitk=k;\n\tz.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\n\tif ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){\n\t  return this.inflate_flush(z, r);\n\t}\n\tr = Z_OK;\n\tthis.codes.free(z);\n\n\tp=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;\n\tq=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);\n\n\tif (this.last==0){\n\t  this.mode = IB_TYPE;\n\t  break;\n\t}\n\tthis.mode = IB_DRY;\n      case IB_DRY:\n\tthis.write=q; \n\tr = this.inflate_flush(z, r); \n\tq=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\tif (this.read != this.write){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z, r);\n\t}\n\tthis.mode = DONE;\n      case IB_DONE:\n\tr = Z_STREAM_END;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      case IB_BAD:\n\tr = Z_DATA_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      }\n    }\n  }\n\nInfBlocks.prototype.free = function(z){\n    this.reset(z, null);\n    this.window=null;\n    this.hufts=null;\n}\n\nInfBlocks.prototype.set_dictionary = function(d, start, n){\n    arrayCopy(d, start, window, 0, n);\n    this.read = this.write = n;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function(){\n    return this.mode == IB_LENS;\n}\n\n  // copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function(z, r){\n    var n;\n    var p;\n    var q;\n\n    // local copies of source and destination pointers\n    p = z.next_out_index;\n    q = this.read;\n\n    // compute number of bytes to copy as far as end of window\n    n = ((q <= this.write ? this.write : this.end) - q);\n    if (n > z.avail_out) n = z.avail_out;\n    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if(this.checkfn != null)\n      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n    // copy as far as end of window\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n\n    // see if more to copy at beginning of window\n    if (q == this.end){\n      // wrap pointers\n      q = 0;\n      if (this.write == this.end)\n        this.write = 0;\n\n      // compute bytes to copy\n      n = this.write - q;\n      if (n > z.avail_out) n = z.avail_out;\n      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n      // update counters\n      z.avail_out -= n;\n      z.total_out += n;\n\n      // update check information\n      if(this.checkfn != null)\n\tz.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n      // copy\n      arrayCopy(this.window, q, z.next_out, p, n);\n      p += n;\n      q += n;\n    }\n\n    // update pointers\n    z.next_out_index = p;\n    this.read = q;\n\n    // done\n    return r;\n  }\n\n//\n// InfCodes.java\n//\n\nvar IC_START=0;  // x: set up for LEN\nvar IC_LEN=1;    // i: get length/literal/eob next\nvar IC_LENEXT=2; // i: getting length extra (have base)\nvar IC_DIST=3;   // i: get distance next\nvar IC_DISTEXT=4;// i: getting distance extra\nvar IC_COPY=5;   // o: copying bytes in window, waiting for space\nvar IC_LIT=6;    // o: got literal, waiting for output space\nvar IC_WASH=7;   // o: got eob, possibly still output waiting\nvar IC_END=8;    // x: got eob and all data flushed\nvar IC_BADCODE=9;// x: got error\n\nfunction InfCodes() {\n}\n\nInfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {\n    this.mode=IC_START;\n    this.lbits=bl;\n    this.dbits=bd;\n    this.ltree=tl;\n    this.ltree_index=tl_index;\n    this.dtree = td;\n    this.dtree_index=td_index;\n    this.tree=null;\n}\n\nInfCodes.prototype.proc = function(s, z, r){ \n    var j;              // temporary storage\n    var t;              // temporary pointer (int[])\n    var tindex;         // temporary pointer\n    var e;              // extra bits or operation\n    var b=0;            // bit buffer\n    var k=0;            // bits in bit buffer\n    var p=0;            // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n    var f;              // pointer to copy strings from\n\n    // copy input/output information to locals (UPDATE macro restores)\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // process input and output based on current state\n    while (true){\n      switch (this.mode){\n\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:         // x: set up for LEN\n\tif (m >= 258 && n >= 10){\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  r = this.inflate_fast(this.lbits, this.dbits, \n\t\t\t   this.ltree, this.ltree_index, \n\t\t\t   this.dtree, this.dtree_index,\n\t\t\t   s, z);\n\n\t  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n\t  q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t  if (r != Z_OK){\n\t    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n\t    break;\n\t  }\n\t}\n\tthis.need = this.lbits;\n\tthis.tree = this.ltree;\n\tthis.tree_index=this.ltree_index;\n\n\tthis.mode = IC_LEN;\n      case IC_LEN:           // i: get length/literal/eob next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b&inflate_mask[j]))*3;\n\n\tb>>>=(this.tree[tindex+1]);\n\tk-=(this.tree[tindex+1]);\n\n\te=this.tree[tindex];\n\n\tif(e == 0){               // literal\n\t  this.lit = this.tree[tindex+2];\n\t  this.mode = IC_LIT;\n\t  break;\n\t}\n\tif((e & 16)!=0 ){          // length\n\t  this.get = e & 15;\n\t  this.len = this.tree[tindex+2];\n\t  this.mode = IC_LENEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tif ((e & 32)!=0){               // end of block\n\t  this.mode = IC_WASH;\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid literal/length code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_LENEXT:        // i: getting length extra (have base)\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.len += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.need = this.dbits;\n\tthis.tree = this.dtree;\n\tthis.tree_index = this.dtree_index;\n\tthis.mode = IC_DIST;\n      case IC_DIST:          // i: get distance next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b & inflate_mask[j]))*3;\n\n\tb>>=this.tree[tindex+1];\n\tk-=this.tree[tindex+1];\n\n\te = (this.tree[tindex]);\n\tif((e & 16)!=0){               // distance\n\t  this.get = e & 15;\n\t  this.dist = this.tree[tindex+2];\n\t  this.mode = IC_DISTEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid distance code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_DISTEXT:       // i: getting distance extra\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.dist += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.mode = IC_COPY;\n      case IC_COPY:          // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while(f < 0){     // modulo window size-\"while\" instead\n          f += s.end;     // of \"if\" handles invalid distances\n\t}\n\twhile (this.len!=0){\n\n\t  if(m==0){\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.write=q; r=s.inflate_flush(z,r);\n\t      q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\n\t      if(m==0){\n\t\ts.bitb=b;s.bitk=k;\n\t\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\ts.write=q;\n\t\treturn s.inflate_flush(z,r);\n\t      }  \n\t    }\n\t  }\n\n\t  s.window[q++]=s.window[f++]; m--;\n\n\t  if (f == s.end)\n            f = 0;\n\t  this.len--;\n\t}\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_LIT:           // o: got literal, waiting for output space\n\tif(m==0){\n\t  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t  if(m==0){\n\t    s.write=q; r=s.inflate_flush(z,r);\n\t    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\t      return s.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\ts.window[q++]=this.lit; m--;\n\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_WASH:           // o: got eob, possibly more output\n\tif (k > 7){        // return unused byte, if any\n\t  k -= 8;\n\t  n++;\n\t  p--;             // can always return one\n\t}\n\n\ts.write=q; r=s.inflate_flush(z,r);\n\tq=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\tif (s.read != s.write){\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  return s.inflate_flush(z,r);\n\t}\n\tthis.mode = IC_END;\n      case IC_END:\n\tr = Z_STREAM_END;\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_BADCODE:       // x: got error\n\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n      }\n    }\n  }\n\nInfCodes.prototype.free = function(z){\n    //  ZFREE(z, c);\n}\n\n  // Called with number of bytes left to write in window at least 258\n  // (the maximum string length) and number of input bytes available\n  // at least ten.  The ten bytes are six bytes for the longest length/\n  // distance pair plus four bytes for overloading the bit buffer.\n\nInfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {\n    var t;                // temporary pointer\n    var   tp;             // temporary pointer (int[])\n    var tp_index;         // temporary pointer\n    var e;                // extra bits or operation\n    var b;                // bit buffer\n    var k;                // bits in bit buffer\n    var p;                // input data pointer\n    var n;                // bytes available there\n    var q;                // output window write pointer\n    var m;                // bytes to end of window or read pointer\n    var ml;               // mask for literal/length tree\n    var md;               // mask for distance tree\n    var c;                // bytes to copy\n    var d;                // distance back to copy from\n    var r;                // copy source pointer\n\n    var tp_index_t_3;     // (tp_index+t)*3\n\n    // load input, output, bit values\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // initialize masks\n    ml = inflate_mask[bl];\n    md = inflate_mask[bd];\n\n    // do until not enough input or output space for fast loop\n    do {                          // assume called with m >= 258 && n >= 10\n      // get literal/length code\n      while(k<(20)){              // max bits for literal/length code\n\tn--;\n\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n      }\n\n      t= b&ml;\n      tp=tl; \n      tp_index=tl_index;\n      tp_index_t_3=(tp_index+t)*3;\n      if ((e = tp[tp_index_t_3]) == 0){\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\ts.window[q++] = tp[tp_index_t_3+2];\n\tm--;\n\tcontinue;\n      }\n      do {\n\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\tif((e&16)!=0){\n\t  e &= 15;\n\t  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);\n\n\t  b>>=e; k-=e;\n\n\t  // decode distance base of block to copy\n\t  while(k<(15)){           // max bits for distance code\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t  }\n\n\t  t= b&md;\n\t  tp=td;\n\t  tp_index=td_index;\n          tp_index_t_3=(tp_index+t)*3;\n\t  e = tp[tp_index_t_3];\n\n\t  do {\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    if((e&16)!=0){\n\t      // get extra bits to add to distance base\n\t      e &= 15;\n\t      while(k<(e)){         // get extra bits (up to 13)\n\t\tn--;\n\t\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t      }\n\n\t      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);\n\n\t      b>>=(e); k-=(e);\n\n\t      // do the copy\n\t      m -= c;\n\t      if (q >= d){                // offset before dest\n\t\t//  just copy\n\t\tr=q-d;\n\t\tif(q-r>0 && 2>(q-r)){           \n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t\telse{\n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t      }\n\t      else{                  // else offset after destination\n                r=q-d;\n                do{\n                  r+=s.end;          // force pointer in window\n                }while(r<0);         // covers invalid distances\n\t\te=s.end-r;\n\t\tif(c>e){             // if source crosses,\n\t\t  c-=e;              // wrapped copy\n\t\t  if(q-r>0 && e>(q-r)){           \n\t\t    do{s.window[q++] = s.window[r++];}\n\t\t    while(--e!=0);\n\t\t  }\n\t\t  else{\n\t\t    arrayCopy(s.window, r, s.window, q, e);\n\t\t    q+=e; r+=e; e=0;\n\t\t  }\n\t\t  r = 0;                  // copy rest from start of window\n\t\t}\n\n\t      }\n\n\t      // copy all or what's left\n              do{s.window[q++] = s.window[r++];}\n\t\twhile(--c!=0);\n\t      break;\n\t    }\n\t    else if((e&64)==0){\n\t      t+=tp[tp_index_t_3+2];\n\t      t+=(b&inflate_mask[e]);\n\t      tp_index_t_3=(tp_index+t)*3;\n\t      e=tp[tp_index_t_3];\n\t    }\n\t    else{\n\t      z.msg = \"invalid distance code\";\n\n\t      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\n\t      return Z_DATA_ERROR;\n\t    }\n\t  }\n\t  while(true);\n\t  break;\n\t}\n\n\tif((e&64)==0){\n\t  t+=tp[tp_index_t_3+2];\n\t  t+=(b&inflate_mask[e]);\n\t  tp_index_t_3=(tp_index+t)*3;\n\t  if((e=tp[tp_index_t_3])==0){\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    s.window[q++]=tp[tp_index_t_3+2];\n\t    m--;\n\t    break;\n\t  }\n\t}\n\telse if((e&32)!=0){\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n \n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_STREAM_END;\n\t}\n\telse{\n\t  z.msg=\"invalid literal/length code\";\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_DATA_ERROR;\n\t}\n      } \n      while(true);\n    } \n    while(m>=258 && n>= 10);\n\n    // not enough input or output--restore pointers and return\n    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n    s.bitb=b;s.bitk=k;\n    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n    s.write=q;\n\n    return Z_OK;\n}\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {\n}\n\nInfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n    // Given a list of code lengths and a maximum table size, make a set of\n    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n    // if the given code set is incomplete (the tables are still built in this\n    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n    // lengths), or Z_MEM_ERROR if not enough memory.\n\n    var a;                       // counter for codes of length k\n    var f;                       // i repeats in table every f entries\n    var g;                       // maximum code length\n    var h;                       // table level\n    var i;                       // counter, current code\n    var j;                       // counter\n    var k;                       // number of bits in current code\n    var l;                       // bits per table (returned in m)\n    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP\n    var p;                       // pointer into c[], b[], or v[]\n    var q;                       // points to current table\n    var w;                       // bits before this table == (l * h)\n    var xp;                      // pointer into x\n    var y;                       // number of dummy codes added\n    var z;                       // number of entries in current table\n\n    // Generate counts for each bit length\n\n    p = 0; i = n;\n    do {\n      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX\n    }while(i!=0);\n\n    if(this.c[0] == n){                // null input--all zero length codes\n      t[0] = -1;\n      m[0] = 0;\n      return Z_OK;\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    l = m[0];\n    for (j = 1; j <= BMAX; j++)\n      if(this.c[j]!=0) break;\n    k = j;                        // minimum code length\n    if(l < j){\n      l = j;\n    }\n    for (i = BMAX; i!=0; i--){\n      if(this.c[i]!=0) break;\n    }\n    g = i;                        // maximum code length\n    if(l > i){\n      l = i;\n    }\n    m[0] = l;\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1){\n      if ((y -= this.c[j]) < 0){\n        return Z_DATA_ERROR;\n      }\n    }\n    if ((y -= this.c[i]) < 0){\n      return Z_DATA_ERROR;\n    }\n    this.c[i] += y;\n\n    // Generate starting offsets into the value table for each length\n    this.x[1] = j = 0;\n    p = 1;  xp = 2;\n    while (--i!=0) {                 // note that i == g from above\n      this.x[xp] = (j += this.c[p]);\n      xp++;\n      p++;\n    }\n\n    // Make a table of values in order of bit lengths\n    i = 0; p = 0;\n    do {\n      if ((j = b[bindex+p]) != 0){\n        this.v[this.x[j]++] = i;\n      }\n      p++;\n    }\n    while (++i < n);\n    n = this.x[g];                     // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    this.x[0] = i = 0;                 // first Huffman code is zero\n    p = 0;                        // grab values in bit order\n    h = -1;                       // no tables yet--level -1\n    w = -l;                       // bits decoded == (l * h)\n    this.u[0] = 0;                     // just to keep compilers happy\n    q = 0;                        // ditto\n    z = 0;                        // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (; k <= g; k++){\n      a = this.c[k];\n      while (a--!=0){\n\t// here i is the Huffman code of length k bits for value *p\n\t// make tables up to required level\n        while (k > w + l){\n          h++;\n          w += l;                 // previous table always l bits\n\t  // compute minimum size table less than or equal to l bits\n          z = g - w;\n          z = (z > l) ? l : z;        // table size upper limit\n          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table\n                                      // too few codes for k-w bit table\n            f -= a + 1;               // deduct codes from patterns left\n            xp = k;\n            if(j < z){\n              while (++j < z){        // try smaller tables up to z bits\n                if((f <<= 1) <= this.c[++xp])\n                  break;              // enough codes to use up j bits\n                f -= this.c[xp];           // else deduct codes from patterns\n              }\n\t    }\n          }\n          z = 1 << j;                 // table entries for j-bit table\n\n\t  // allocate new table\n          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)\n            return Z_DATA_ERROR;       // overflow of MANY\n          }\n          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG\n          this.hn[0] += z;\n \n\t  // connect to last table, if there is one\n\t  if(h!=0){\n            this.x[h]=i;           // save pattern for backing up\n            this.r[0]=j;     // bits in this table\n            this.r[1]=l;     // bits to dump before this table\n            j=i>>>(w - l);\n            this.r[2] = (q - this.u[h-1] - j);               // offset to this table\n            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table\n          }\n          else{\n            t[0] = q;               // first table is returned result\n\t  }\n        }\n\n\t// set up table entry in r\n        this.r[1] = (k - w);\n        if (p >= n){\n          this.r[0] = 128 + 64;      // out of values--invalid code\n\t}\n        else if (v[p] < s){\n          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block\n          this.r[2] = this.v[p++];          // simple code is just the value\n        }\n        else{\n          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists\n          this.r[2]=d[this.v[p++] - s];\n        }\n\n        // fill code-like entries with r\n        f=1<<(k-w);\n        for (j=i>>>w;j<z;j+=f){\n          arrayCopy(this.r, 0, hp, (q+j)*3, 3);\n\t}\n\n\t// backwards increment the k-bit code i\n        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){\n          i ^= j;\n\t}\n        i ^= j;\n\n\t// backup over finished tables\n        mask = (1 << w) - 1;      // needed on HP, cc -O bug\n        while ((i & mask) != this.x[h]){\n          h--;                    // don't need to update q\n          w -= l;\n          mask = (1 << w) - 1;\n        }\n      }\n    }\n    // Return Z_BUF_ERROR if we were given an incomplete table\n    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\nInfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {\n    var result;\n    this.initWorkArea(19);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n    if(result == Z_DATA_ERROR){\n      z.msg = \"oversubscribed dynamic bit lengths tree\";\n    }\n    else if(result == Z_BUF_ERROR || bb[0] == 0){\n      z.msg = \"incomplete dynamic bit lengths tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n}\n\nInfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {\n    var result;\n\n    // build literal/length tree\n    this.initWorkArea(288);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n    if (result != Z_OK || bl[0] == 0){\n      if(result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed literal/length tree\";\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"incomplete literal/length tree\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    // build distance tree\n    this.initWorkArea(288);\n    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n    if (result != Z_OK || (bd[0] == 0 && nl > 257)){\n      if (result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed distance tree\";\n      }\n      else if (result == Z_BUF_ERROR) {\n        z.msg = \"incomplete distance tree\";\n        result = Z_DATA_ERROR;\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"empty distance tree with lengths\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    return Z_OK;\n}\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n    bl[0]=fixed_bl;\n    bd[0]=fixed_bd;\n    tl[0]=fixed_tl;\n    td[0]=fixed_td;\n    return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function(vsize){\n    if(this.hn==null){\n        this.hn=new Int32Array(1);\n        this.v=new Int32Array(vsize);\n        this.c=new Int32Array(BMAX+1);\n        this.r=new Int32Array(3);\n        this.u=new Int32Array(BMAX);\n        this.x=new Int32Array(BMAX+1);\n    }\n    if(this.v.length<vsize){ \n        this.v=new Int32Array(vsize); \n    }\n    for(var i=0; i<vsize; i++){this.v[i]=0;}\n    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}\n    for(var i=0; i<3; i++){this.r[i]=0;}\n//  for(int i=0; i<BMAX; i++){u[i]=0;}\n    arrayCopy(this.c, 0, this.u, 0, BMAX);\n//  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n    arrayCopy(this.c, 0, this.x, 0, BMAX+1);\n}\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = (typeof testArray.subarray === 'function');\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n    if (count == 0) {\n        return;\n    } \n    if (!src) {\n        throw \"Undef src\";\n    } else if (!dest) {\n        throw \"Undef dest\";\n    }\n\n    if (srcOffset == 0 && count == src.length) {\n        arrayCopy_fast(src, dest, destOffset);\n    } else if (hasSubarray) {\n        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); \n    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n    } else { \n        arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n    }\n\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n     for (var i = 0; i < count; ++i) {\n        dest[destOffset + i] = src[srcOffset + i];\n    }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n    dest.set(src, destOffset);\n}\n\n\n  // largest prime smaller than 65536\nvar ADLER_BASE=65521; \n  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX=5552;\n\nfunction adler32(adler, /* byte[] */ buf,  index, len){\n    if(buf == null){ return 1; }\n\n    var s1=adler&0xffff;\n    var s2=(adler>>16)&0xffff;\n    var k;\n\n    while(len > 0) {\n      k=len<ADLER_NMAX?len:ADLER_NMAX;\n      len-=k;\n      while(k>=16){\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        k-=16;\n      }\n      if(k!=0){\n        do{\n          s1+=buf[index++]&0xff; s2+=s1;\n        }\n        while(--k!=0);\n      }\n      s1%=ADLER_BASE;\n      s2%=ADLER_BASE;\n    }\n    return (s2<<16)|s1;\n}\n\n\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n    if (!start) {\n        buffer = new Uint8Array(buffer);\n    } else {\n        buffer = new Uint8Array(buffer, start, length);\n    }\n\n    var z = new ZStream();\n    z.inflateInit(DEF_WBITS, true);\n    z.next_in = buffer;\n    z.next_in_index = 0;\n    z.avail_in = buffer.length;\n\n    var oBlockList = [];\n    var totalSize = 0;\n    while (true) {\n        var obuf = new Uint8Array(32000);\n        z.next_out = obuf;\n        z.next_out_index = 0;\n        z.avail_out = obuf.length;\n        var status = z.inflate(Z_NO_FLUSH);\n        if (status != Z_OK && status != Z_STREAM_END) {\n            throw z.msg;\n        }\n        if (z.avail_out != 0) {\n            var newob = new Uint8Array(obuf.length - z.avail_out);\n            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));\n            obuf = newob;\n        }\n        oBlockList.push(obuf);\n        totalSize += obuf.length;\n        if (status == Z_STREAM_END) {\n            break;\n        }\n    }\n\n    if (afterUncOffset) {\n        afterUncOffset[0] = (start || 0) + z.next_in_index;\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0].buffer;\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = oBlockList[i];\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL2luZmxhdGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL2luZmxhdGUuanM/ODMyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBKYXZhc2NyaXB0IFpMaWJcbi8vIEJ5IFRob21hcyBEb3duIDIwMTAtMjAxMVxuLy9cbi8vIEJhc2VkIHZlcnkgaGVhdmlseSBvbiBwb3J0aW9ucyBvZiBqemxpYiAoYnkgeW1ua0BqY3JhZnQuY29tKSwgd2hvIGluXG4vLyB0dXJuIGNyZWRpdHMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlciBmb3IgdGhlIG9yaWdpbmFsIHpsaWIgY29kZS5cbi8vXG4vLyBpbmZsYXRlLmpzOiBaTGliIGluZmxhdGUgY29kZVxuLy9cblxuLy9cbi8vIFNoYXJlZCBjb25zdGFudHNcbi8vXG5cbnZhciBNQVhfV0JJVFM9MTU7IC8vIDMySyBMWjc3IHdpbmRvd1xudmFyIERFRl9XQklUUz1NQVhfV0JJVFM7XG52YXIgTUFYX01FTV9MRVZFTD05O1xudmFyIE1BTlk9MTQ0MDtcbnZhciBCTUFYID0gMTU7XG5cbi8vIHByZXNldCBkaWN0aW9uYXJ5IGZsYWcgaW4gemxpYiBoZWFkZXJcbnZhciBQUkVTRVRfRElDVD0weDIwO1xuXG52YXIgWl9OT19GTFVTSD0wO1xudmFyIFpfUEFSVElBTF9GTFVTSD0xO1xudmFyIFpfU1lOQ19GTFVTSD0yO1xudmFyIFpfRlVMTF9GTFVTSD0zO1xudmFyIFpfRklOSVNIPTQ7XG5cbnZhciBaX0RFRkxBVEVEPTg7XG5cbnZhciBaX09LPTA7XG52YXIgWl9TVFJFQU1fRU5EPTE7XG52YXIgWl9ORUVEX0RJQ1Q9MjtcbnZhciBaX0VSUk5PPS0xO1xudmFyIFpfU1RSRUFNX0VSUk9SPS0yO1xudmFyIFpfREFUQV9FUlJPUj0tMztcbnZhciBaX01FTV9FUlJPUj0tNDtcbnZhciBaX0JVRl9FUlJPUj0tNTtcbnZhciBaX1ZFUlNJT05fRVJST1I9LTY7XG5cbnZhciBNRVRIT0Q9MDsgICAvLyB3YWl0aW5nIGZvciBtZXRob2QgYnl0ZVxudmFyIEZMQUc9MTsgICAgIC8vIHdhaXRpbmcgZm9yIGZsYWcgYnl0ZVxudmFyIERJQ1Q0PTI7ICAgIC8vIGZvdXIgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QzPTM7ICAgIC8vIHRocmVlIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBESUNUMj00OyAgICAvLyB0d28gZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QxPTU7ICAgIC8vIG9uZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGUgdG8gZ29cbnZhciBESUNUMD02OyAgICAvLyB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeVxudmFyIEJMT0NLUz03OyAgIC8vIGRlY29tcHJlc3NpbmcgYmxvY2tzXG52YXIgQ0hFQ0s0PTg7ICAgLy8gZm91ciBjaGVjayBieXRlcyB0byBnb1xudmFyIENIRUNLMz05OyAgIC8vIHRocmVlIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0syPTEwOyAgLy8gdHdvIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0sxPTExOyAgLy8gb25lIGNoZWNrIGJ5dGUgdG8gZ29cbnZhciBET05FPTEyOyAgICAvLyBmaW5pc2hlZCBjaGVjaywgZG9uZVxudmFyIEJBRD0xMzsgICAgIC8vIGdvdCBhbiBlcnJvci0tc3RheSBoZXJlXG5cbnZhciBpbmZsYXRlX21hc2sgPSBbMHgwMDAwMDAwMCwgMHgwMDAwMDAwMSwgMHgwMDAwMDAwMywgMHgwMDAwMDAwNywgMHgwMDAwMDAwZiwgMHgwMDAwMDAxZiwgMHgwMDAwMDAzZiwgMHgwMDAwMDA3ZiwgMHgwMDAwMDBmZiwgMHgwMDAwMDFmZiwgMHgwMDAwMDNmZiwgMHgwMDAwMDdmZiwgMHgwMDAwMGZmZiwgMHgwMDAwMWZmZiwgMHgwMDAwM2ZmZiwgMHgwMDAwN2ZmZiwgMHgwMDAwZmZmZl07XG5cbnZhciBJQl9UWVBFPTA7ICAvLyBnZXQgdHlwZSBiaXRzICgzLCBpbmNsdWRpbmcgZW5kIGJpdClcbnZhciBJQl9MRU5TPTE7ICAvLyBnZXQgbGVuZ3RocyBmb3Igc3RvcmVkXG52YXIgSUJfU1RPUkVEPTI7Ly8gcHJvY2Vzc2luZyBzdG9yZWQgYmxvY2tcbnZhciBJQl9UQUJMRT0zOyAvLyBnZXQgdGFibGUgbGVuZ3Roc1xudmFyIElCX0JUUkVFPTQ7IC8vIGdldCBiaXQgbGVuZ3RocyB0cmVlIGZvciBhIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9EVFJFRT01OyAvLyBnZXQgbGVuZ3RoLCBkaXN0YW5jZSB0cmVlcyBmb3IgYSBkeW5hbWljIGJsb2NrXG52YXIgSUJfQ09ERVM9NjsgLy8gcHJvY2Vzc2luZyBmaXhlZCBvciBkeW5hbWljIGJsb2NrXG52YXIgSUJfRFJZPTc7ICAgLy8gb3V0cHV0IHJlbWFpbmluZyB3aW5kb3cgYnl0ZXNcbnZhciBJQl9ET05FPTg7ICAvLyBmaW5pc2hlZCBsYXN0IGJsb2NrLCBkb25lXG52YXIgSUJfQkFEPTk7ICAgLy8gb3QgYSBkYXRhIGVycm9yLS1zdHVjayBoZXJlXG5cbnZhciBmaXhlZF9ibCA9IDk7XG52YXIgZml4ZWRfYmQgPSA1O1xuXG52YXIgZml4ZWRfdGwgPSBbXG4gICAgOTYsNywyNTYsIDAsOCw4MCwgMCw4LDE2LCA4NCw4LDExNSxcbiAgICA4Miw3LDMxLCAwLDgsMTEyLCAwLDgsNDgsIDAsOSwxOTIsXG4gICAgODAsNywxMCwgMCw4LDk2LCAwLDgsMzIsIDAsOSwxNjAsXG4gICAgMCw4LDAsIDAsOCwxMjgsIDAsOCw2NCwgMCw5LDIyNCxcbiAgICA4MCw3LDYsIDAsOCw4OCwgMCw4LDI0LCAwLDksMTQ0LFxuICAgIDgzLDcsNTksIDAsOCwxMjAsIDAsOCw1NiwgMCw5LDIwOCxcbiAgICA4MSw3LDE3LCAwLDgsMTA0LCAwLDgsNDAsIDAsOSwxNzYsXG4gICAgMCw4LDgsIDAsOCwxMzYsIDAsOCw3MiwgMCw5LDI0MCxcbiAgICA4MCw3LDQsIDAsOCw4NCwgMCw4LDIwLCA4NSw4LDIyNyxcbiAgICA4Myw3LDQzLCAwLDgsMTE2LCAwLDgsNTIsIDAsOSwyMDAsXG4gICAgODEsNywxMywgMCw4LDEwMCwgMCw4LDM2LCAwLDksMTY4LFxuICAgIDAsOCw0LCAwLDgsMTMyLCAwLDgsNjgsIDAsOSwyMzIsXG4gICAgODAsNyw4LCAwLDgsOTIsIDAsOCwyOCwgMCw5LDE1MixcbiAgICA4NCw3LDgzLCAwLDgsMTI0LCAwLDgsNjAsIDAsOSwyMTYsXG4gICAgODIsNywyMywgMCw4LDEwOCwgMCw4LDQ0LCAwLDksMTg0LFxuICAgIDAsOCwxMiwgMCw4LDE0MCwgMCw4LDc2LCAwLDksMjQ4LFxuICAgIDgwLDcsMywgMCw4LDgyLCAwLDgsMTgsIDg1LDgsMTYzLFxuICAgIDgzLDcsMzUsIDAsOCwxMTQsIDAsOCw1MCwgMCw5LDE5NixcbiAgICA4MSw3LDExLCAwLDgsOTgsIDAsOCwzNCwgMCw5LDE2NCxcbiAgICAwLDgsMiwgMCw4LDEzMCwgMCw4LDY2LCAwLDksMjI4LFxuICAgIDgwLDcsNywgMCw4LDkwLCAwLDgsMjYsIDAsOSwxNDgsXG4gICAgODQsNyw2NywgMCw4LDEyMiwgMCw4LDU4LCAwLDksMjEyLFxuICAgIDgyLDcsMTksIDAsOCwxMDYsIDAsOCw0MiwgMCw5LDE4MCxcbiAgICAwLDgsMTAsIDAsOCwxMzgsIDAsOCw3NCwgMCw5LDI0NCxcbiAgICA4MCw3LDUsIDAsOCw4NiwgMCw4LDIyLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTgsIDAsOCw1NCwgMCw5LDIwNCxcbiAgICA4MSw3LDE1LCAwLDgsMTAyLCAwLDgsMzgsIDAsOSwxNzIsXG4gICAgMCw4LDYsIDAsOCwxMzQsIDAsOCw3MCwgMCw5LDIzNixcbiAgICA4MCw3LDksIDAsOCw5NCwgMCw4LDMwLCAwLDksMTU2LFxuICAgIDg0LDcsOTksIDAsOCwxMjYsIDAsOCw2MiwgMCw5LDIyMCxcbiAgICA4Miw3LDI3LCAwLDgsMTEwLCAwLDgsNDYsIDAsOSwxODgsXG4gICAgMCw4LDE0LCAwLDgsMTQyLCAwLDgsNzgsIDAsOSwyNTIsXG4gICAgOTYsNywyNTYsIDAsOCw4MSwgMCw4LDE3LCA4NSw4LDEzMSxcbiAgICA4Miw3LDMxLCAwLDgsMTEzLCAwLDgsNDksIDAsOSwxOTQsXG4gICAgODAsNywxMCwgMCw4LDk3LCAwLDgsMzMsIDAsOSwxNjIsXG4gICAgMCw4LDEsIDAsOCwxMjksIDAsOCw2NSwgMCw5LDIyNixcbiAgICA4MCw3LDYsIDAsOCw4OSwgMCw4LDI1LCAwLDksMTQ2LFxuICAgIDgzLDcsNTksIDAsOCwxMjEsIDAsOCw1NywgMCw5LDIxMCxcbiAgICA4MSw3LDE3LCAwLDgsMTA1LCAwLDgsNDEsIDAsOSwxNzgsXG4gICAgMCw4LDksIDAsOCwxMzcsIDAsOCw3MywgMCw5LDI0MixcbiAgICA4MCw3LDQsIDAsOCw4NSwgMCw4LDIxLCA4MCw4LDI1OCxcbiAgICA4Myw3LDQzLCAwLDgsMTE3LCAwLDgsNTMsIDAsOSwyMDIsXG4gICAgODEsNywxMywgMCw4LDEwMSwgMCw4LDM3LCAwLDksMTcwLFxuICAgIDAsOCw1LCAwLDgsMTMzLCAwLDgsNjksIDAsOSwyMzQsXG4gICAgODAsNyw4LCAwLDgsOTMsIDAsOCwyOSwgMCw5LDE1NCxcbiAgICA4NCw3LDgzLCAwLDgsMTI1LCAwLDgsNjEsIDAsOSwyMTgsXG4gICAgODIsNywyMywgMCw4LDEwOSwgMCw4LDQ1LCAwLDksMTg2LFxuICAgIDAsOCwxMywgMCw4LDE0MSwgMCw4LDc3LCAwLDksMjUwLFxuICAgIDgwLDcsMywgMCw4LDgzLCAwLDgsMTksIDg1LDgsMTk1LFxuICAgIDgzLDcsMzUsIDAsOCwxMTUsIDAsOCw1MSwgMCw5LDE5OCxcbiAgICA4MSw3LDExLCAwLDgsOTksIDAsOCwzNSwgMCw5LDE2NixcbiAgICAwLDgsMywgMCw4LDEzMSwgMCw4LDY3LCAwLDksMjMwLFxuICAgIDgwLDcsNywgMCw4LDkxLCAwLDgsMjcsIDAsOSwxNTAsXG4gICAgODQsNyw2NywgMCw4LDEyMywgMCw4LDU5LCAwLDksMjE0LFxuICAgIDgyLDcsMTksIDAsOCwxMDcsIDAsOCw0MywgMCw5LDE4MixcbiAgICAwLDgsMTEsIDAsOCwxMzksIDAsOCw3NSwgMCw5LDI0NixcbiAgICA4MCw3LDUsIDAsOCw4NywgMCw4LDIzLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTksIDAsOCw1NSwgMCw5LDIwNixcbiAgICA4MSw3LDE1LCAwLDgsMTAzLCAwLDgsMzksIDAsOSwxNzQsXG4gICAgMCw4LDcsIDAsOCwxMzUsIDAsOCw3MSwgMCw5LDIzOCxcbiAgICA4MCw3LDksIDAsOCw5NSwgMCw4LDMxLCAwLDksMTU4LFxuICAgIDg0LDcsOTksIDAsOCwxMjcsIDAsOCw2MywgMCw5LDIyMixcbiAgICA4Miw3LDI3LCAwLDgsMTExLCAwLDgsNDcsIDAsOSwxOTAsXG4gICAgMCw4LDE1LCAwLDgsMTQzLCAwLDgsNzksIDAsOSwyNTQsXG4gICAgOTYsNywyNTYsIDAsOCw4MCwgMCw4LDE2LCA4NCw4LDExNSxcbiAgICA4Miw3LDMxLCAwLDgsMTEyLCAwLDgsNDgsIDAsOSwxOTMsXG5cbiAgICA4MCw3LDEwLCAwLDgsOTYsIDAsOCwzMiwgMCw5LDE2MSxcbiAgICAwLDgsMCwgMCw4LDEyOCwgMCw4LDY0LCAwLDksMjI1LFxuICAgIDgwLDcsNiwgMCw4LDg4LCAwLDgsMjQsIDAsOSwxNDUsXG4gICAgODMsNyw1OSwgMCw4LDEyMCwgMCw4LDU2LCAwLDksMjA5LFxuICAgIDgxLDcsMTcsIDAsOCwxMDQsIDAsOCw0MCwgMCw5LDE3NyxcbiAgICAwLDgsOCwgMCw4LDEzNiwgMCw4LDcyLCAwLDksMjQxLFxuICAgIDgwLDcsNCwgMCw4LDg0LCAwLDgsMjAsIDg1LDgsMjI3LFxuICAgIDgzLDcsNDMsIDAsOCwxMTYsIDAsOCw1MiwgMCw5LDIwMSxcbiAgICA4MSw3LDEzLCAwLDgsMTAwLCAwLDgsMzYsIDAsOSwxNjksXG4gICAgMCw4LDQsIDAsOCwxMzIsIDAsOCw2OCwgMCw5LDIzMyxcbiAgICA4MCw3LDgsIDAsOCw5MiwgMCw4LDI4LCAwLDksMTUzLFxuICAgIDg0LDcsODMsIDAsOCwxMjQsIDAsOCw2MCwgMCw5LDIxNyxcbiAgICA4Miw3LDIzLCAwLDgsMTA4LCAwLDgsNDQsIDAsOSwxODUsXG4gICAgMCw4LDEyLCAwLDgsMTQwLCAwLDgsNzYsIDAsOSwyNDksXG4gICAgODAsNywzLCAwLDgsODIsIDAsOCwxOCwgODUsOCwxNjMsXG4gICAgODMsNywzNSwgMCw4LDExNCwgMCw4LDUwLCAwLDksMTk3LFxuICAgIDgxLDcsMTEsIDAsOCw5OCwgMCw4LDM0LCAwLDksMTY1LFxuICAgIDAsOCwyLCAwLDgsMTMwLCAwLDgsNjYsIDAsOSwyMjksXG4gICAgODAsNyw3LCAwLDgsOTAsIDAsOCwyNiwgMCw5LDE0OSxcbiAgICA4NCw3LDY3LCAwLDgsMTIyLCAwLDgsNTgsIDAsOSwyMTMsXG4gICAgODIsNywxOSwgMCw4LDEwNiwgMCw4LDQyLCAwLDksMTgxLFxuICAgIDAsOCwxMCwgMCw4LDEzOCwgMCw4LDc0LCAwLDksMjQ1LFxuICAgIDgwLDcsNSwgMCw4LDg2LCAwLDgsMjIsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOCwgMCw4LDU0LCAwLDksMjA1LFxuICAgIDgxLDcsMTUsIDAsOCwxMDIsIDAsOCwzOCwgMCw5LDE3MyxcbiAgICAwLDgsNiwgMCw4LDEzNCwgMCw4LDcwLCAwLDksMjM3LFxuICAgIDgwLDcsOSwgMCw4LDk0LCAwLDgsMzAsIDAsOSwxNTcsXG4gICAgODQsNyw5OSwgMCw4LDEyNiwgMCw4LDYyLCAwLDksMjIxLFxuICAgIDgyLDcsMjcsIDAsOCwxMTAsIDAsOCw0NiwgMCw5LDE4OSxcbiAgICAwLDgsMTQsIDAsOCwxNDIsIDAsOCw3OCwgMCw5LDI1MyxcbiAgICA5Niw3LDI1NiwgMCw4LDgxLCAwLDgsMTcsIDg1LDgsMTMxLFxuICAgIDgyLDcsMzEsIDAsOCwxMTMsIDAsOCw0OSwgMCw5LDE5NSxcbiAgICA4MCw3LDEwLCAwLDgsOTcsIDAsOCwzMywgMCw5LDE2MyxcbiAgICAwLDgsMSwgMCw4LDEyOSwgMCw4LDY1LCAwLDksMjI3LFxuICAgIDgwLDcsNiwgMCw4LDg5LCAwLDgsMjUsIDAsOSwxNDcsXG4gICAgODMsNyw1OSwgMCw4LDEyMSwgMCw4LDU3LCAwLDksMjExLFxuICAgIDgxLDcsMTcsIDAsOCwxMDUsIDAsOCw0MSwgMCw5LDE3OSxcbiAgICAwLDgsOSwgMCw4LDEzNywgMCw4LDczLCAwLDksMjQzLFxuICAgIDgwLDcsNCwgMCw4LDg1LCAwLDgsMjEsIDgwLDgsMjU4LFxuICAgIDgzLDcsNDMsIDAsOCwxMTcsIDAsOCw1MywgMCw5LDIwMyxcbiAgICA4MSw3LDEzLCAwLDgsMTAxLCAwLDgsMzcsIDAsOSwxNzEsXG4gICAgMCw4LDUsIDAsOCwxMzMsIDAsOCw2OSwgMCw5LDIzNSxcbiAgICA4MCw3LDgsIDAsOCw5MywgMCw4LDI5LCAwLDksMTU1LFxuICAgIDg0LDcsODMsIDAsOCwxMjUsIDAsOCw2MSwgMCw5LDIxOSxcbiAgICA4Miw3LDIzLCAwLDgsMTA5LCAwLDgsNDUsIDAsOSwxODcsXG4gICAgMCw4LDEzLCAwLDgsMTQxLCAwLDgsNzcsIDAsOSwyNTEsXG4gICAgODAsNywzLCAwLDgsODMsIDAsOCwxOSwgODUsOCwxOTUsXG4gICAgODMsNywzNSwgMCw4LDExNSwgMCw4LDUxLCAwLDksMTk5LFxuICAgIDgxLDcsMTEsIDAsOCw5OSwgMCw4LDM1LCAwLDksMTY3LFxuICAgIDAsOCwzLCAwLDgsMTMxLCAwLDgsNjcsIDAsOSwyMzEsXG4gICAgODAsNyw3LCAwLDgsOTEsIDAsOCwyNywgMCw5LDE1MSxcbiAgICA4NCw3LDY3LCAwLDgsMTIzLCAwLDgsNTksIDAsOSwyMTUsXG4gICAgODIsNywxOSwgMCw4LDEwNywgMCw4LDQzLCAwLDksMTgzLFxuICAgIDAsOCwxMSwgMCw4LDEzOSwgMCw4LDc1LCAwLDksMjQ3LFxuICAgIDgwLDcsNSwgMCw4LDg3LCAwLDgsMjMsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOSwgMCw4LDU1LCAwLDksMjA3LFxuICAgIDgxLDcsMTUsIDAsOCwxMDMsIDAsOCwzOSwgMCw5LDE3NSxcbiAgICAwLDgsNywgMCw4LDEzNSwgMCw4LDcxLCAwLDksMjM5LFxuICAgIDgwLDcsOSwgMCw4LDk1LCAwLDgsMzEsIDAsOSwxNTksXG4gICAgODQsNyw5OSwgMCw4LDEyNywgMCw4LDYzLCAwLDksMjIzLFxuICAgIDgyLDcsMjcsIDAsOCwxMTEsIDAsOCw0NywgMCw5LDE5MSxcbiAgICAwLDgsMTUsIDAsOCwxNDMsIDAsOCw3OSwgMCw5LDI1NVxuXTtcbnZhciBmaXhlZF90ZCA9IFtcbiAgICA4MCw1LDEsIDg3LDUsMjU3LCA4Myw1LDE3LCA5MSw1LDQwOTcsXG4gICAgODEsNSw1LCA4OSw1LDEwMjUsIDg1LDUsNjUsIDkzLDUsMTYzODUsXG4gICAgODAsNSwzLCA4OCw1LDUxMywgODQsNSwzMywgOTIsNSw4MTkzLFxuICAgIDgyLDUsOSwgOTAsNSwyMDQ5LCA4Niw1LDEyOSwgMTkyLDUsMjQ1NzcsXG4gICAgODAsNSwyLCA4Nyw1LDM4NSwgODMsNSwyNSwgOTEsNSw2MTQ1LFxuICAgIDgxLDUsNywgODksNSwxNTM3LCA4NSw1LDk3LCA5Myw1LDI0NTc3LFxuICAgIDgwLDUsNCwgODgsNSw3NjksIDg0LDUsNDksIDkyLDUsMTIyODksXG4gICAgODIsNSwxMywgOTAsNSwzMDczLCA4Niw1LDE5MywgMTkyLDUsMjQ1Nzdcbl07XG5cbiAgLy8gVGFibGVzIGZvciBkZWZsYXRlIGZyb20gUEtaSVAncyBhcHBub3RlLnR4dC5cbiAgdmFyIGNwbGVucyA9IFsgLy8gQ29weSBsZW5ndGhzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XG4gICAgICAgIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gICAgICAgIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG4gIF07XG5cbiAgLy8gc2VlIG5vdGUgIzEzIGFib3ZlIGFib3V0IDI1OFxuICB2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XG4gICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsXG4gICAgICAgIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIDExMiwgMTEyICAvLyAxMTI9PWludmFsaWRcbiAgXTtcblxuIHZhciBjcGRpc3QgPSBbIC8vIENvcHkgb2Zmc2V0cyBmb3IgZGlzdGFuY2UgY29kZXMgMC4uMjlcbiAgICAgICAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAgICAgICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gICAgICAgIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzdcbiAgXTtcblxuICB2YXIgY3BkZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBkaXN0YW5jZSBjb2Rlc1xuICAgICAgICAwLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LFxuICAgICAgICA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSxcbiAgICAgICAgMTIsIDEyLCAxMywgMTNdO1xuXG4vL1xuLy8gWlN0cmVhbS5qYXZhXG4vL1xuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xufVxuXG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVJbml0ID0gZnVuY3Rpb24odywgbm93cmFwKSB7XG4gICAgaWYgKCF3KSB7XG5cdHcgPSBERUZfV0JJVFM7XG4gICAgfVxuICAgIGlmIChub3dyYXApIHtcblx0bm93cmFwID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXN0YXRlID0gbmV3IEluZmxhdGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc3RhdGUuaW5mbGF0ZUluaXQodGhpcywgbm93cmFwPy13OncpO1xufVxuXG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlID0gZnVuY3Rpb24oZikge1xuICAgIGlmKHRoaXMuaXN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIHRoaXMuaXN0YXRlLmluZmxhdGUodGhpcywgZik7XG59XG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVFbmQgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuaXN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgdmFyIHJldD1pc3RhdGUuaW5mbGF0ZUVuZCh0aGlzKTtcbiAgICB0aGlzLmlzdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIHJldDtcbn1cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oKXtcbiAgICAvLyBpZihpc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBpc3RhdGUuaW5mbGF0ZVN5bmModGhpcyk7XG59XG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpe1xuICAgIC8vIGlmKGlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGlzdGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcbn1cblxuLypcblxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBNQVhfV0JJVFMpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBib29sZWFuIG5vd3JhcCl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBNQVhfV0JJVFMsIG5vd3JhcCk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGludCBiaXRzKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIGJpdHMsIGZhbHNlKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgaW50IGJpdHMsIGJvb2xlYW4gbm93cmFwKXtcbiAgICBkc3RhdGU9bmV3IERlZmxhdGUoKTtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVJbml0KHRoaXMsIGxldmVsLCBub3dyYXA/LWJpdHM6Yml0cyk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlKGludCBmbHVzaCl7XG4gICAgaWYoZHN0YXRlPT1udWxsKXtcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlKHRoaXMsIGZsdXNoKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVFbmQoKXtcbiAgICBpZihkc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBpbnQgcmV0PWRzdGF0ZS5kZWZsYXRlRW5kKCk7XG4gICAgZHN0YXRlPW51bGw7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVQYXJhbXMoaW50IGxldmVsLCBpbnQgc3RyYXRlZ3kpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZVBhcmFtcyh0aGlzLCBsZXZlbCwgc3RyYXRlZ3kpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZVNldERpY3Rpb25hcnkgKGJ5dGVbXSBkaWN0aW9uYXJ5LCBpbnQgZGljdExlbmd0aCl7XG4gICAgaWYoZHN0YXRlID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcbiAgfVxuXG4qL1xuXG4vKlxuICAvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gIC8vIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAgLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfb3V0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICAvLyAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gIHZvaWQgZmx1c2hfcGVuZGluZygpe1xuICAgIGludCBsZW49ZHN0YXRlLnBlbmRpbmc7XG5cbiAgICBpZihsZW4+YXZhaWxfb3V0KSBsZW49YXZhaWxfb3V0O1xuICAgIGlmKGxlbj09MCkgcmV0dXJuO1xuXG4gICAgaWYoZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aDw9ZHN0YXRlLnBlbmRpbmdfb3V0IHx8XG4gICAgICAgbmV4dF9vdXQubGVuZ3RoPD1uZXh0X291dF9pbmRleCB8fFxuICAgICAgIGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGg8KGRzdGF0ZS5wZW5kaW5nX291dCtsZW4pIHx8XG4gICAgICAgbmV4dF9vdXQubGVuZ3RoPChuZXh0X291dF9pbmRleCtsZW4pKXtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoK1wiLCBcIitkc3RhdGUucGVuZGluZ19vdXQrXG5cdFx0XHQgXCIsIFwiK25leHRfb3V0Lmxlbmd0aCtcIiwgXCIrbmV4dF9vdXRfaW5kZXgrXCIsIFwiK2xlbik7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4oXCJhdmFpbF9vdXQ9XCIrYXZhaWxfb3V0KTtcbiAgICB9XG5cbiAgICBTeXN0ZW0uYXJyYXljb3B5KGRzdGF0ZS5wZW5kaW5nX2J1ZiwgZHN0YXRlLnBlbmRpbmdfb3V0LFxuXHRcdCAgICAgbmV4dF9vdXQsIG5leHRfb3V0X2luZGV4LCBsZW4pO1xuXG4gICAgbmV4dF9vdXRfaW5kZXgrPWxlbjtcbiAgICBkc3RhdGUucGVuZGluZ19vdXQrPWxlbjtcbiAgICB0b3RhbF9vdXQrPWxlbjtcbiAgICBhdmFpbF9vdXQtPWxlbjtcbiAgICBkc3RhdGUucGVuZGluZy09bGVuO1xuICAgIGlmKGRzdGF0ZS5wZW5kaW5nPT0wKXtcbiAgICAgIGRzdGF0ZS5wZW5kaW5nX291dD0wO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAgLy8gYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAgLy8gdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAgLy8gYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfaW4gYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gIC8vIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICBpbnQgcmVhZF9idWYoYnl0ZVtdIGJ1ZiwgaW50IHN0YXJ0LCBpbnQgc2l6ZSkge1xuICAgIGludCBsZW49YXZhaWxfaW47XG5cbiAgICBpZihsZW4+c2l6ZSkgbGVuPXNpemU7XG4gICAgaWYobGVuPT0wKSByZXR1cm4gMDtcblxuICAgIGF2YWlsX2luLT1sZW47XG5cbiAgICBpZihkc3RhdGUubm9oZWFkZXI9PTApIHtcbiAgICAgIGFkbGVyPV9hZGxlci5hZGxlcjMyKGFkbGVyLCBuZXh0X2luLCBuZXh0X2luX2luZGV4LCBsZW4pO1xuICAgIH1cbiAgICBTeXN0ZW0uYXJyYXljb3B5KG5leHRfaW4sIG5leHRfaW5faW5kZXgsIGJ1Ziwgc3RhcnQsIGxlbik7XG4gICAgbmV4dF9pbl9pbmRleCAgKz0gbGVuO1xuICAgIHRvdGFsX2luICs9IGxlbjtcbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgcHVibGljIHZvaWQgZnJlZSgpe1xuICAgIG5leHRfaW49bnVsbDtcbiAgICBuZXh0X291dD1udWxsO1xuICAgIG1zZz1udWxsO1xuICAgIF9hZGxlcj1udWxsO1xuICB9XG59XG4qL1xuXG5cbi8vXG4vLyBJbmZsYXRlLmphdmFcbi8vXG5cbmZ1bmN0aW9uIEluZmxhdGUoKSB7XG4gICAgdGhpcy53YXMgPSBbMF07XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVSZXNldCA9IGZ1bmN0aW9uKHopIHtcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIFxuICAgIHoudG90YWxfaW4gPSB6LnRvdGFsX291dCA9IDA7XG4gICAgei5tc2cgPSBudWxsO1xuICAgIHouaXN0YXRlLm1vZGUgPSB6LmlzdGF0ZS5ub3dyYXAhPTAgPyBCTE9DS1MgOiBNRVRIT0Q7XG4gICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIG51bGwpO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlRW5kID0gZnVuY3Rpb24oeil7XG4gICAgaWYodGhpcy5ibG9ja3MgIT0gbnVsbClcbiAgICAgIHRoaXMuYmxvY2tzLmZyZWUoeik7XG4gICAgdGhpcy5ibG9ja3M9bnVsbDtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbih6LCB3KXtcbiAgICB6Lm1zZyA9IG51bGw7XG4gICAgdGhpcy5ibG9ja3MgPSBudWxsO1xuXG4gICAgLy8gaGFuZGxlIHVuZG9jdW1lbnRlZCBub3dyYXAgb3B0aW9uIChubyB6bGliIGhlYWRlciBvciBjaGVjaylcbiAgICBsZXQgbm93cmFwID0gMDtcbiAgICBpZih3IDwgMCl7XG4gICAgICB3ID0gLSB3O1xuICAgICAgbm93cmFwID0gMTtcbiAgICB9XG5cbiAgICAvLyBzZXQgd2luZG93IHNpemVcbiAgICBpZih3PDggfHx3PjE1KXtcbiAgICAgIHRoaXMuaW5mbGF0ZUVuZCh6KTtcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gICAgdGhpcy53Yml0cz13O1xuXG4gICAgei5pc3RhdGUuYmxvY2tzPW5ldyBJbmZCbG9ja3MoeiwgXG5cdFx0XHRcdCAgei5pc3RhdGUubm93cmFwIT0wID8gbnVsbCA6IHRoaXMsXG5cdFx0XHRcdCAgMTw8dyk7XG5cbiAgICAvLyByZXNldCBzdGF0ZVxuICAgIHRoaXMuaW5mbGF0ZVJlc2V0KHopO1xuICAgIHJldHVybiBaX09LO1xuICB9XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGUgPSBmdW5jdGlvbih6LCBmKXtcbiAgICB2YXIgciwgYjtcblxuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsIHx8IHoubmV4dF9pbiA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGYgPSBmID09IFpfRklOSVNIID8gWl9CVUZfRVJST1IgOiBaX09LO1xuICAgIHIgPSBaX0JVRl9FUlJPUjtcbiAgICB3aGlsZSAodHJ1ZSl7XG4gICAgICBzd2l0Y2ggKHouaXN0YXRlLm1vZGUpe1xuICAgICAgY2FzZSBNRVRIT0Q6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIGlmKCgoei5pc3RhdGUubWV0aG9kID0gei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSkmMHhmKSE9Wl9ERUZMQVRFRCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZz1cInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXCI7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gNTsgICAgICAgLy8gY2FuJ3QgdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoKHouaXN0YXRlLm1ldGhvZD4+NCkrOD56LmlzdGF0ZS53Yml0cyl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZz1cImludmFsaWQgd2luZG93IHNpemVcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB6LmlzdGF0ZS5tb2RlPUZMQUc7XG4gICAgICBjYXNlIEZMQUc6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIGIgPSAoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSkmMHhmZjtcblxuICAgICAgICBpZigoKCh6LmlzdGF0ZS5tZXRob2QgPDwgOCkrYikgJSAzMSkhPTApe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2cgPSBcImluY29ycmVjdCBoZWFkZXIgY2hlY2tcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKChiJlBSRVNFVF9ESUNUKT09MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gRElDVDQ7XG4gICAgICBjYXNlIERJQ1Q0OlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MjQpJjB4ZmYwMDAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDM7XG4gICAgICBjYXNlIERJQ1QzOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDE2KSYweGZmMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMjtcbiAgICAgIGNhc2UgRElDVDI6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8OCkmMHhmZjAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QxO1xuICAgICAgY2FzZSBESUNUMTpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCArPSAoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTtcbiAgICAgICAgei5hZGxlciA9IHouaXN0YXRlLm5lZWQ7XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUMDtcbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgY2FzZSBESUNUMDpcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgei5tc2cgPSBcIm5lZWQgZGljdGlvbmFyeVwiO1xuICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAgICAgICAvLyBjYW4gdHJ5IGluZmxhdGVTeW5jXG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIGNhc2UgQkxPQ0tTOlxuXG4gICAgICAgIHIgPSB6LmlzdGF0ZS5ibG9ja3MucHJvYyh6LCByKTtcbiAgICAgICAgaWYociA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5pc3RhdGUubWFya2VyID0gMDsgICAgIC8vIGNhbiB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihyID09IFpfT0spe1xuICAgICAgICAgIHIgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIgIT0gWl9TVFJFQU1fRU5EKXtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICByID0gZjtcbiAgICAgICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIHouaXN0YXRlLndhcyk7XG4gICAgICAgIGlmKHouaXN0YXRlLm5vd3JhcCE9MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZT1ET05FO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGU9Q0hFQ0s0O1xuICAgICAgY2FzZSBDSEVDSzQ6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQ9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwyNCkmMHhmZjAwMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1DSEVDSzM7XG4gICAgICBjYXNlIENIRUNLMzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwxNikmMHhmZjAwMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBDSEVDSzI7XG4gICAgICBjYXNlIENIRUNLMjpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDw4KSYweGZmMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBDSEVDSzE7XG4gICAgICBjYXNlIENIRUNLMTpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik7XG5cbiAgICAgICAgaWYoKCh6LmlzdGF0ZS53YXNbMF0pKSAhPSAoKHouaXN0YXRlLm5lZWQpKSl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW5jb3JyZWN0IGRhdGEgY2hlY2tcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRU5EO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbih6LCAgZGljdGlvbmFyeSwgZGljdExlbmd0aCkge1xuICAgIHZhciBpbmRleD0wO1xuICAgIHZhciBsZW5ndGggPSBkaWN0TGVuZ3RoO1xuICAgIGlmKHo9PW51bGwgfHwgei5pc3RhdGUgPT0gbnVsbHx8IHouaXN0YXRlLm1vZGUgIT0gRElDVDApXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG5cbiAgICBpZih6Ll9hZGxlci5hZGxlcjMyKDEsIGRpY3Rpb25hcnksIDAsIGRpY3RMZW5ndGgpIT16LmFkbGVyKXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuXG4gICAgei5hZGxlciA9IHouX2FkbGVyLmFkbGVyMzIoMCwgbnVsbCwgMCwgMCk7XG5cbiAgICBpZihsZW5ndGggPj0gKDE8PHouaXN0YXRlLndiaXRzKSl7XG4gICAgICBsZW5ndGggPSAoMTw8ei5pc3RhdGUud2JpdHMpLTE7XG4gICAgICBpbmRleD1kaWN0TGVuZ3RoIC0gbGVuZ3RoO1xuICAgIH1cbiAgICB6LmlzdGF0ZS5ibG9ja3Muc2V0X2RpY3Rpb25hcnkoZGljdGlvbmFyeSwgaW5kZXgsIGxlbmd0aCk7XG4gICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICByZXR1cm4gWl9PSztcbiAgfVxuXG4vLyAgc3RhdGljIHByaXZhdGUgYnl0ZVtdIG1hcmsgPSB7KGJ5dGUpMCwgKGJ5dGUpMCwgKGJ5dGUpMHhmZiwgKGJ5dGUpMHhmZn07XG52YXIgbWFyayA9IFswLCAwLCAyNTUsIDI1NV1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbih6KXtcbiAgICB2YXIgbjsgICAgICAgLy8gbnVtYmVyIG9mIGJ5dGVzIHRvIGxvb2sgYXRcbiAgICB2YXIgcDsgICAgICAgLy8gcG9pbnRlciB0byBieXRlc1xuICAgIHZhciBtOyAgICAgICAvLyBudW1iZXIgb2YgbWFya2VyIGJ5dGVzIGZvdW5kIGluIGEgcm93XG4gICAgdmFyIHIsIHc7ICAgLy8gdGVtcG9yYXJpZXMgdG8gc2F2ZSB0b3RhbF9pbiBhbmQgdG90YWxfb3V0XG5cbiAgICAvLyBzZXQgdXBcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBpZih6LmlzdGF0ZS5tb2RlICE9IEJBRCl7XG4gICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgei5pc3RhdGUubWFya2VyID0gMDtcbiAgICB9XG4gICAgaWYoKG49ei5hdmFpbF9pbik9PTApXG4gICAgICByZXR1cm4gWl9CVUZfRVJST1I7XG4gICAgcD16Lm5leHRfaW5faW5kZXg7XG4gICAgbT16LmlzdGF0ZS5tYXJrZXI7XG5cbiAgICAvLyBzZWFyY2hcbiAgICB3aGlsZSAobiE9MCAmJiBtIDwgNCl7XG4gICAgICBpZih6Lm5leHRfaW5bcF0gPT0gbWFya1ttXSl7XG4gICAgICAgIG0rKztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoei5uZXh0X2luW3BdIT0wKXtcbiAgICAgICAgbSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICBtID0gNCAtIG07XG4gICAgICB9XG4gICAgICBwKys7IG4tLTtcbiAgICB9XG5cbiAgICAvLyByZXN0b3JlXG4gICAgei50b3RhbF9pbiArPSBwLXoubmV4dF9pbl9pbmRleDtcbiAgICB6Lm5leHRfaW5faW5kZXggPSBwO1xuICAgIHouYXZhaWxfaW4gPSBuO1xuICAgIHouaXN0YXRlLm1hcmtlciA9IG07XG5cbiAgICAvLyByZXR1cm4gbm8gam95IG9yIHNldCB1cCB0byByZXN0YXJ0IG9uIGEgbmV3IGJsb2NrXG4gICAgaWYobSAhPSA0KXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHI9ei50b3RhbF9pbjsgIHc9ei50b3RhbF9vdXQ7XG4gICAgdGhpcy5pbmZsYXRlUmVzZXQoeik7XG4gICAgei50b3RhbF9pbj1yOyAgei50b3RhbF9vdXQgPSB3O1xuICAgIHouaXN0YXRlLm1vZGUgPSBCTE9DS1M7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIGluZmxhdGUgaXMgY3VycmVudGx5IGF0IHRoZSBlbmQgb2YgYSBibG9jayBnZW5lcmF0ZWRcbiAgLy8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJ5IG9uZSBQUFBcbiAgLy8gaW1wbGVtZW50YXRpb24gdG8gcHJvdmlkZSBhbiBhZGRpdGlvbmFsIHNhZmV0eSBjaGVjay4gUFBQIHVzZXMgWl9TWU5DX0ZMVVNIXG4gIC8vIGJ1dCByZW1vdmVzIHRoZSBsZW5ndGggYnl0ZXMgb2YgdGhlIHJlc3VsdGluZyBlbXB0eSBzdG9yZWQgYmxvY2suIFdoZW5cbiAgLy8gZGVjb21wcmVzc2luZywgUFBQIGNoZWNrcyB0aGF0IGF0IHRoZSBlbmQgb2YgaW5wdXQgcGFja2V0LCBpbmZsYXRlIGlzXG4gIC8vIHdhaXRpbmcgZm9yIHRoZXNlIGxlbmd0aCBieXRlcy5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVTeW5jUG9pbnQgPSBmdW5jdGlvbih6KXtcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCB8fCB6LmlzdGF0ZS5ibG9ja3MgPT0gbnVsbClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICByZXR1cm4gei5pc3RhdGUuYmxvY2tzLnN5bmNfcG9pbnQoKTtcbn1cblxuXG4vL1xuLy8gSW5mQmxvY2tzLmphdmFcbi8vXG5cbnZhciBJTkZCTE9DS1NfQk9SREVSID0gWzE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTVdO1xuXG5mdW5jdGlvbiBJbmZCbG9ja3MoeiwgY2hlY2tmbiwgdykge1xuICAgIHRoaXMuaHVmdHM9bmV3IEludDMyQXJyYXkoTUFOWSozKTtcbiAgICB0aGlzLndpbmRvdz1uZXcgVWludDhBcnJheSh3KTtcbiAgICB0aGlzLmVuZD13O1xuICAgIHRoaXMuY2hlY2tmbiA9IGNoZWNrZm47XG4gICAgdGhpcy5tb2RlID0gSUJfVFlQRTtcbiAgICB0aGlzLnJlc2V0KHosIG51bGwpO1xuXG4gICAgdGhpcy5sZWZ0ID0gMDsgICAgICAgICAgICAvLyBpZiBTVE9SRUQsIGJ5dGVzIGxlZnQgdG8gY29weSBcblxuICAgIHRoaXMudGFibGUgPSAwOyAgICAgICAgICAgLy8gdGFibGUgbGVuZ3RocyAoMTQgYml0cykgXG4gICAgdGhpcy5pbmRleCA9IDA7ICAgICAgICAgICAvLyBpbmRleCBpbnRvIGJsZW5zIChvciBib3JkZXIpIFxuICAgIHRoaXMuYmxlbnMgPSBudWxsOyAgICAgICAgIC8vIGJpdCBsZW5ndGhzIG9mIGNvZGVzIFxuICAgIHRoaXMuYmI9bmV3IEludDMyQXJyYXkoMSk7IC8vIGJpdCBsZW5ndGggdHJlZSBkZXB0aCBcbiAgICB0aGlzLnRiPW5ldyBJbnQzMkFycmF5KDEpOyAvLyBiaXQgbGVuZ3RoIGRlY29kaW5nIHRyZWUgXG5cbiAgICB0aGlzLmNvZGVzID0gbmV3IEluZkNvZGVzKCk7XG5cbiAgICB0aGlzLmxhc3QgPSAwOyAgICAgICAgICAgIC8vIHRydWUgaWYgdGhpcyBibG9jayBpcyB0aGUgbGFzdCBibG9jayBcblxuICAvLyBtb2RlIGluZGVwZW5kZW50IGluZm9ybWF0aW9uIFxuICAgIHRoaXMuYml0ayA9IDA7ICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyIFxuICAgIHRoaXMuYml0YiA9IDA7ICAgICAgICAgICAgLy8gYml0IGJ1ZmZlciBcbiAgICB0aGlzLnJlYWQgPSAwOyAgICAgICAgICAgIC8vIHdpbmRvdyByZWFkIHBvaW50ZXIgXG4gICAgdGhpcy53cml0ZSA9IDA7ICAgICAgICAgICAvLyB3aW5kb3cgd3JpdGUgcG9pbnRlciBcbiAgICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgLy8gY2hlY2sgb24gb3V0cHV0IFxuXG4gICAgdGhpcy5pbmZ0cmVlPW5ldyBJbmZUcmVlKCk7XG59XG5cblxuXG5cbkluZkJsb2Nrcy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbih6LCBjKXtcbiAgICBpZihjKSBjWzBdPXRoaXMuY2hlY2s7XG4gICAgaWYodGhpcy5tb2RlPT1JQl9DT0RFUyl7XG4gICAgICB0aGlzLmNvZGVzLmZyZWUoeik7XG4gICAgfVxuICAgIHRoaXMubW9kZT1JQl9UWVBFO1xuICAgIHRoaXMuYml0az0wO1xuICAgIHRoaXMuYml0Yj0wO1xuICAgIHRoaXMucmVhZD10aGlzLndyaXRlPTA7XG5cbiAgICBpZih0aGlzLmNoZWNrZm4pXG4gICAgICB6LmFkbGVyPXRoaXMuY2hlY2s9ei5fYWRsZXIuYWRsZXIzMigwLCBudWxsLCAwLCAwKTtcbiAgfVxuXG4gSW5mQmxvY2tzLnByb3RvdHlwZS5wcm9jID0gZnVuY3Rpb24oeiwgcil7XG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgIHZhciBiOyAgICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyXG4gICAgdmFyIHA7ICAgICAgICAgICAgICAvLyBpbnB1dCBkYXRhIHBvaW50ZXJcbiAgICB2YXIgbjsgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXG4gICAgdmFyIG07ICAgICAgICAgICAgICAvLyBieXRlcyB0byBlbmQgb2Ygd2luZG93IG9yIHJlYWQgcG9pbnRlclxuXG4gICAgLy8gY29weSBpbnB1dC9vdXRwdXQgaW5mb3JtYXRpb24gdG8gbG9jYWxzIChVUERBVEUgbWFjcm8gcmVzdG9yZXMpXG4gICAge3A9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXRoaXMuYml0YjtrPXRoaXMuYml0azt9XG4gICAge3E9dGhpcy53cml0ZTttPShxPHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTt9XG5cbiAgICAvLyBwcm9jZXNzIGlucHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKXtcbiAgICAgIGNhc2UgSUJfVFlQRTpcblxuXHR3aGlsZShrPCgzKSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblx0dCA9IChiICYgNyk7XG5cdHRoaXMubGFzdCA9IHQgJiAxO1xuXG5cdHN3aXRjaCAodCA+Pj4gMSl7XG4gICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmVkIFxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuICAgICAgICAgIHQgPSBrICYgNzsgICAgICAgICAgICAgICAgICAgIC8vIGdvIHRvIGJ5dGUgYm91bmRhcnlcblxuICAgICAgICAgIHtiPj4+PSh0KTtrLT0odCk7fVxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX0xFTlM7ICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxlbmd0aCBvZiBzdG9yZWQgYmxvY2tcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaXhlZFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGJsPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgICB2YXIgYmQ9bmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgICAgICAgIHZhciB0bD1bXTtcblx0ICAgICAgdmFyIHRkPVtdO1xuXG5cdCAgICAgIGluZmxhdGVfdHJlZXNfZml4ZWQoYmwsIGJkLCB0bCwgdGQsIHopO1xuICAgICAgICAgICAgICB0aGlzLmNvZGVzLmluaXQoYmxbMF0sIGJkWzBdLCB0bFswXSwgMCwgdGRbMF0sIDAsIHopO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuXG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfQ09ERVM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHluYW1pY1xuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG5cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9UQUJMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsXG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cbiAgICAgICAgICB0aGlzLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgei5tc2cgPSBcImludmFsaWQgYmxvY2sgdHlwZVwiO1xuICAgICAgICAgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQl9MRU5TOlxuXHR3aGlsZShrPCgzMikpe1xuXHQgIGlmKG4hPTApe1xuXHQgICAgcj1aX09LO1xuXHQgIH1cblx0ICBlbHNle1xuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjtcblx0ICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH07XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0aWYgKCgoKH5iKSA+Pj4gMTYpICYgMHhmZmZmKSAhPSAoYiAmIDB4ZmZmZikpe1xuXHQgIHRoaXMubW9kZSA9IEJBRDtcblx0ICB6Lm1zZyA9IFwiaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Roc1wiO1xuXHQgIHIgPSBaX0RBVEFfRVJST1I7XG5cblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdHRoaXMubGVmdCA9IChiICYgMHhmZmZmKTtcblx0YiA9IGsgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgLy8gZHVtcCBiaXRzXG5cdHRoaXMubW9kZSA9IGxlZnQhPTAgPyBJQl9TVE9SRUQgOiAodGhpcy5sYXN0IT0wID8gSUJfRFJZIDogSUJfVFlQRSk7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQl9TVE9SRUQ6XG5cdGlmIChuID09IDApe1xuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHdyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cblx0aWYobT09MCl7XG5cdCAgaWYocT09ZW5kJiZyZWFkIT0wKXtcblx0ICAgIHE9MDsgbT0ocTx0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgfVxuXHQgIGlmKG09PTApe1xuXHQgICAgdGhpcy53cml0ZT1xOyBcblx0ICAgIHI9dGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICBxPXRoaXMud3JpdGU7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0ICAgIGlmKHE9PXRoaXMuZW5kICYmIHRoaXMucmVhZCAhPSAwKXtcblx0ICAgICAgcT0wOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgICB9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0cj1aX09LO1xuXG5cdHQgPSB0aGlzLmxlZnQ7XG5cdGlmKHQ+bikgdCA9IG47XG5cdGlmKHQ+bSkgdCA9IG07XG5cdGFycmF5Q29weSh6Lm5leHRfaW4sIHAsIHdpbmRvdywgcSwgdCk7XG5cdHAgKz0gdDsgIG4gLT0gdDtcblx0cSArPSB0OyAgbSAtPSB0O1xuXHRpZiAoKHRoaXMubGVmdCAtPSB0KSAhPSAwKVxuXHQgIGJyZWFrO1xuXHR0aGlzLm1vZGUgPSAodGhpcy5sYXN0ICE9IDAgPyBJQl9EUlkgOiBJQl9UWVBFKTtcblx0YnJlYWs7XG4gICAgICBjYXNlIElCX1RBQkxFOlxuXG5cdHdoaWxlKGs8KDE0KSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLnRhYmxlID0gdCA9IChiICYgMHgzZmZmKTtcblx0aWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KVxuXHQgIHtcblx0ICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICAgIHoubXNnID0gXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1wiO1xuXHQgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdHQgPSAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZik7XG5cdGlmKHRoaXMuYmxlbnM9PW51bGwgfHwgdGhpcy5ibGVucy5sZW5ndGg8dCl7XG5cdCAgICB0aGlzLmJsZW5zPW5ldyBJbnQzMkFycmF5KHQpO1xuXHR9XG5cdGVsc2V7XG5cdCAgZm9yKHZhciBpPTA7IGk8dDsgaSsrKXtcbiAgICAgICAgICAgICAgdGhpcy5ibGVuc1tpXT0wO1xuICAgICAgICAgIH1cblx0fVxuXG5cdHtiPj4+PSgxNCk7ay09KDE0KTt9XG5cblx0dGhpcy5pbmRleCA9IDA7XG5cdHRoaXMubW9kZSA9IElCX0JUUkVFO1xuICAgICAgY2FzZSBJQl9CVFJFRTpcblx0d2hpbGUgKHRoaXMuaW5kZXggPCA0ICsgKHRoaXMudGFibGUgPj4+IDEwKSl7XG5cdCAgd2hpbGUoazwoMykpe1xuXHQgICAgaWYobiE9MCl7XG5cdCAgICAgIHI9Wl9PSztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjtcblx0ICAgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfTtcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgIGsrPTg7XG5cdCAgfVxuXG5cdCAgdGhpcy5ibGVuc1tJTkZCTE9DS1NfQk9SREVSW3RoaXMuaW5kZXgrK11dID0gYiY3O1xuXG5cdCAge2I+Pj49KDMpO2stPSgzKTt9XG5cdH1cblxuXHR3aGlsZSh0aGlzLmluZGV4IDwgMTkpe1xuXHQgIHRoaXMuYmxlbnNbSU5GQkxPQ0tTX0JPUkRFUlt0aGlzLmluZGV4KytdXSA9IDA7XG5cdH1cblxuXHR0aGlzLmJiWzBdID0gNztcblx0dCA9IHRoaXMuaW5mdHJlZS5pbmZsYXRlX3RyZWVzX2JpdHModGhpcy5ibGVucywgdGhpcy5iYiwgdGhpcy50YiwgdGhpcy5odWZ0cywgeik7XG5cdGlmICh0ICE9IFpfT0spe1xuXHQgIHIgPSB0O1xuXHQgIGlmIChyID09IFpfREFUQV9FUlJPUil7XG5cdCAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICB0aGlzLm1vZGUgPSBJQl9CQUQ7XG5cdCAgfVxuXG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgd3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblxuXHR0aGlzLmluZGV4ID0gMDtcblx0dGhpcy5tb2RlID0gSUJfRFRSRUU7XG4gICAgICBjYXNlIElCX0RUUkVFOlxuXHR3aGlsZSAodHJ1ZSl7XG5cdCAgdCA9IHRoaXMudGFibGU7XG5cdCAgaWYoISh0aGlzLmluZGV4IDwgMjU4ICsgKHQgJiAweDFmKSArICgodCA+PiA1KSAmIDB4MWYpKSl7XG5cdCAgICBicmVhaztcblx0ICB9XG5cblx0ICB2YXIgaDsgLy9pbnRbXVxuXHQgIHZhciBpLCBqLCBjO1xuXG5cdCAgdCA9IHRoaXMuYmJbMF07XG5cblx0ICB3aGlsZShrPCh0KSl7XG5cdCAgICBpZihuIT0wKXtcblx0ICAgICAgcj1aX09LO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9O1xuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgays9ODtcblx0ICB9XG5cbi8vXHQgIGlmICh0aGlzLnRiWzBdPT0tMSl7XG4vLyAgICAgICAgICAgIGRsb2coXCJudWxsLi4uXCIpO1xuLy9cdCAgfVxuXG5cdCAgdD10aGlzLmh1ZnRzWyh0aGlzLnRiWzBdKyhiICYgaW5mbGF0ZV9tYXNrW3RdKSkqMysxXTtcblx0ICBjPXRoaXMuaHVmdHNbKHRoaXMudGJbMF0rKGIgJiBpbmZsYXRlX21hc2tbdF0pKSozKzJdO1xuXG5cdCAgaWYgKGMgPCAxNil7XG5cdCAgICBiPj4+PSh0KTtrLT0odCk7XG5cdCAgICB0aGlzLmJsZW5zW3RoaXMuaW5kZXgrK10gPSBjO1xuXHQgIH1cblx0ICBlbHNlIHsgLy8gYyA9PSAxNi4uMThcblx0ICAgIGkgPSBjID09IDE4ID8gNyA6IGMgLSAxNDtcblx0ICAgIGogPSBjID09IDE4ID8gMTEgOiAzO1xuXG5cdCAgICB3aGlsZShrPCh0K2kpKXtcblx0ICAgICAgaWYobiE9MCl7XG5cdFx0cj1aX09LO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2V7XG5cdFx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0XHR6LmF2YWlsX2luPW47XG5cdFx0ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdFx0dGhpcy53cml0ZT1xO1xuXHRcdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgfTtcblx0ICAgICAgbi0tO1xuXHQgICAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICAgIGsrPTg7XG5cdCAgICB9XG5cblx0ICAgIGI+Pj49KHQpO2stPSh0KTtcblxuXHQgICAgaiArPSAoYiAmIGluZmxhdGVfbWFza1tpXSk7XG5cblx0ICAgIGI+Pj49KGkpO2stPShpKTtcblxuXHQgICAgaSA9IHRoaXMuaW5kZXg7XG5cdCAgICB0ID0gdGhpcy50YWJsZTtcblx0ICAgIGlmIChpICsgaiA+IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSB8fFxuXHRcdChjID09IDE2ICYmIGkgPCAxKSl7XG5cdCAgICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFwiO1xuXHQgICAgICByID0gWl9EQVRBX0VSUk9SO1xuXG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cblx0ICAgIGMgPSBjID09IDE2ID8gdGhpcy5ibGVuc1tpLTFdIDogMDtcblx0ICAgIGRve1xuXHQgICAgICB0aGlzLmJsZW5zW2krK10gPSBjO1xuXHQgICAgfVxuXHQgICAgd2hpbGUgKC0taiE9MCk7XG5cdCAgICB0aGlzLmluZGV4ID0gaTtcblx0ICB9XG5cdH1cblxuXHR0aGlzLnRiWzBdPS0xO1xuXHR7XG5cdCAgICB2YXIgYmw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgYmQ9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgdGw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICB2YXIgdGQ9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICBibFswXSA9IDk7ICAgICAgICAgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcblx0ICAgIGJkWzBdID0gNjsgICAgICAgICAvLyBtdXN0IGJlIDw9IDkgZm9yIGxvb2thaGVhZCBhc3N1bXB0aW9uc1xuXG5cdCAgICB0ID0gdGhpcy50YWJsZTtcblx0ICAgIHQgPSB0aGlzLmluZnRyZWUuaW5mbGF0ZV90cmVlc19keW5hbWljKDI1NyArICh0ICYgMHgxZiksIFxuXHRcdFx0XHRcdCAgICAgIDEgKyAoKHQgPj4gNSkgJiAweDFmKSxcblx0XHRcdFx0XHQgICAgICB0aGlzLmJsZW5zLCBibCwgYmQsIHRsLCB0ZCwgdGhpcy5odWZ0cywgeik7XG5cblx0ICAgIGlmICh0ICE9IFpfT0spe1xuXHQgICAgICAgIGlmICh0ID09IFpfREFUQV9FUlJPUil7XG5cdCAgICAgICAgICAgIHRoaXMuYmxlbnM9bnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5tb2RlID0gQkFEO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByID0gdDtcblxuXHQgICAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgICB0aGlzLmNvZGVzLmluaXQoYmxbMF0sIGJkWzBdLCB0aGlzLmh1ZnRzLCB0bFswXSwgdGhpcy5odWZ0cywgdGRbMF0sIHopO1xuXHR9XG5cdHRoaXMubW9kZSA9IElCX0NPREVTO1xuICAgICAgY2FzZSBJQl9DT0RFUzpcblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rO1xuXHR6LmF2YWlsX2luPW47IHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cblx0aWYgKChyID0gdGhpcy5jb2Rlcy5wcm9jKHRoaXMsIHosIHIpKSAhPSBaX1NUUkVBTV9FTkQpe1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cdH1cblx0ciA9IFpfT0s7XG5cdHRoaXMuY29kZXMuZnJlZSh6KTtcblxuXHRwPXoubmV4dF9pbl9pbmRleDsgbj16LmF2YWlsX2luO2I9dGhpcy5iaXRiO2s9dGhpcy5iaXRrO1xuXHRxPXRoaXMud3JpdGU7bSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXG5cdGlmICh0aGlzLmxhc3Q9PTApe1xuXHQgIHRoaXMubW9kZSA9IElCX1RZUEU7XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUJfRFJZO1xuICAgICAgY2FzZSBJQl9EUlk6XG5cdHRoaXMud3JpdGU9cTsgXG5cdHIgPSB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7IFxuXHRxPXRoaXMud3JpdGU7IG0gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblx0aWYgKHRoaXMucmVhZCAhPSB0aGlzLndyaXRlKXtcblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB0aGlzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblx0fVxuXHR0aGlzLm1vZGUgPSBET05FO1xuICAgICAgY2FzZSBJQl9ET05FOlxuXHRyID0gWl9TVFJFQU1fRU5EO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuICAgICAgY2FzZSBJQl9CQUQ6XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cbiAgICAgIGRlZmF1bHQ6XG5cdHIgPSBaX1NUUkVBTV9FUlJPUjtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24oeil7XG4gICAgdGhpcy5yZXNldCh6LCBudWxsKTtcbiAgICB0aGlzLndpbmRvdz1udWxsO1xuICAgIHRoaXMuaHVmdHM9bnVsbDtcbn1cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5zZXRfZGljdGlvbmFyeSA9IGZ1bmN0aW9uKGQsIHN0YXJ0LCBuKXtcbiAgICBhcnJheUNvcHkoZCwgc3RhcnQsIHdpbmRvdywgMCwgbik7XG4gICAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IG47XG59XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIGluZmxhdGUgaXMgY3VycmVudGx5IGF0IHRoZSBlbmQgb2YgYSBibG9jayBnZW5lcmF0ZWRcbiAgLy8gYnkgWl9TWU5DX0ZMVVNIIG9yIFpfRlVMTF9GTFVTSC4gXG5JbmZCbG9ja3MucHJvdG90eXBlLnN5bmNfcG9pbnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLm1vZGUgPT0gSUJfTEVOUztcbn1cblxuICAvLyBjb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgc2xpZGluZyB3aW5kb3cgdG8gdGhlIG91dHB1dCBhcmVhXG5JbmZCbG9ja3MucHJvdG90eXBlLmluZmxhdGVfZmx1c2ggPSBmdW5jdGlvbih6LCByKXtcbiAgICB2YXIgbjtcbiAgICB2YXIgcDtcbiAgICB2YXIgcTtcblxuICAgIC8vIGxvY2FsIGNvcGllcyBvZiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIHBvaW50ZXJzXG4gICAgcCA9IHoubmV4dF9vdXRfaW5kZXg7XG4gICAgcSA9IHRoaXMucmVhZDtcblxuICAgIC8vIGNvbXB1dGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcbiAgICBuID0gKChxIDw9IHRoaXMud3JpdGUgPyB0aGlzLndyaXRlIDogdGhpcy5lbmQpIC0gcSk7XG4gICAgaWYgKG4gPiB6LmF2YWlsX291dCkgbiA9IHouYXZhaWxfb3V0O1xuICAgIGlmIChuIT0wICYmIHIgPT0gWl9CVUZfRVJST1IpIHIgPSBaX09LO1xuXG4gICAgLy8gdXBkYXRlIGNvdW50ZXJzXG4gICAgei5hdmFpbF9vdXQgLT0gbjtcbiAgICB6LnRvdGFsX291dCArPSBuO1xuXG4gICAgLy8gdXBkYXRlIGNoZWNrIGluZm9ybWF0aW9uXG4gICAgaWYodGhpcy5jaGVja2ZuICE9IG51bGwpXG4gICAgICB6LmFkbGVyPXRoaXMuY2hlY2s9ei5fYWRsZXIuYWRsZXIzMih0aGlzLmNoZWNrLCB0aGlzLndpbmRvdywgcSwgbik7XG5cbiAgICAvLyBjb3B5IGFzIGZhciBhcyBlbmQgb2Ygd2luZG93XG4gICAgYXJyYXlDb3B5KHRoaXMud2luZG93LCBxLCB6Lm5leHRfb3V0LCBwLCBuKTtcbiAgICBwICs9IG47XG4gICAgcSArPSBuO1xuXG4gICAgLy8gc2VlIGlmIG1vcmUgdG8gY29weSBhdCBiZWdpbm5pbmcgb2Ygd2luZG93XG4gICAgaWYgKHEgPT0gdGhpcy5lbmQpe1xuICAgICAgLy8gd3JhcCBwb2ludGVyc1xuICAgICAgcSA9IDA7XG4gICAgICBpZiAodGhpcy53cml0ZSA9PSB0aGlzLmVuZClcbiAgICAgICAgdGhpcy53cml0ZSA9IDA7XG5cbiAgICAgIC8vIGNvbXB1dGUgYnl0ZXMgdG8gY29weVxuICAgICAgbiA9IHRoaXMud3JpdGUgLSBxO1xuICAgICAgaWYgKG4gPiB6LmF2YWlsX291dCkgbiA9IHouYXZhaWxfb3V0O1xuICAgICAgaWYgKG4hPTAgJiYgciA9PSBaX0JVRl9FUlJPUikgciA9IFpfT0s7XG5cbiAgICAgIC8vIHVwZGF0ZSBjb3VudGVyc1xuICAgICAgei5hdmFpbF9vdXQgLT0gbjtcbiAgICAgIHoudG90YWxfb3V0ICs9IG47XG5cbiAgICAgIC8vIHVwZGF0ZSBjaGVjayBpbmZvcm1hdGlvblxuICAgICAgaWYodGhpcy5jaGVja2ZuICE9IG51bGwpXG5cdHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKHRoaXMuY2hlY2ssIHRoaXMud2luZG93LCBxLCBuKTtcblxuICAgICAgLy8gY29weVxuICAgICAgYXJyYXlDb3B5KHRoaXMud2luZG93LCBxLCB6Lm5leHRfb3V0LCBwLCBuKTtcbiAgICAgIHAgKz0gbjtcbiAgICAgIHEgKz0gbjtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcG9pbnRlcnNcbiAgICB6Lm5leHRfb3V0X2luZGV4ID0gcDtcbiAgICB0aGlzLnJlYWQgPSBxO1xuXG4gICAgLy8gZG9uZVxuICAgIHJldHVybiByO1xuICB9XG5cbi8vXG4vLyBJbmZDb2Rlcy5qYXZhXG4vL1xuXG52YXIgSUNfU1RBUlQ9MDsgIC8vIHg6IHNldCB1cCBmb3IgTEVOXG52YXIgSUNfTEVOPTE7ICAgIC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxudmFyIElDX0xFTkVYVD0yOyAvLyBpOiBnZXR0aW5nIGxlbmd0aCBleHRyYSAoaGF2ZSBiYXNlKVxudmFyIElDX0RJU1Q9MzsgICAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxudmFyIElDX0RJU1RFWFQ9NDsvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXG52YXIgSUNfQ09QWT01OyAgIC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nIGZvciBzcGFjZVxudmFyIElDX0xJVD02OyAgICAvLyBvOiBnb3QgbGl0ZXJhbCwgd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlXG52YXIgSUNfV0FTSD03OyAgIC8vIG86IGdvdCBlb2IsIHBvc3NpYmx5IHN0aWxsIG91dHB1dCB3YWl0aW5nXG52YXIgSUNfRU5EPTg7ICAgIC8vIHg6IGdvdCBlb2IgYW5kIGFsbCBkYXRhIGZsdXNoZWRcbnZhciBJQ19CQURDT0RFPTk7Ly8geDogZ290IGVycm9yXG5cbmZ1bmN0aW9uIEluZkNvZGVzKCkge1xufVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGJsLCBiZCwgdGwsIHRsX2luZGV4LCB0ZCwgdGRfaW5kZXgsIHopIHtcbiAgICB0aGlzLm1vZGU9SUNfU1RBUlQ7XG4gICAgdGhpcy5sYml0cz1ibDtcbiAgICB0aGlzLmRiaXRzPWJkO1xuICAgIHRoaXMubHRyZWU9dGw7XG4gICAgdGhpcy5sdHJlZV9pbmRleD10bF9pbmRleDtcbiAgICB0aGlzLmR0cmVlID0gdGQ7XG4gICAgdGhpcy5kdHJlZV9pbmRleD10ZF9pbmRleDtcbiAgICB0aGlzLnRyZWU9bnVsbDtcbn1cblxuSW5mQ29kZXMucHJvdG90eXBlLnByb2MgPSBmdW5jdGlvbihzLCB6LCByKXsgXG4gICAgdmFyIGo7ICAgICAgICAgICAgICAvLyB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgIHZhciB0OyAgICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXIgKGludFtdKVxuICAgIHZhciB0aW5kZXg7ICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgZTsgICAgICAgICAgICAgIC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXG4gICAgdmFyIGI9MDsgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs9MDsgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcD0wOyAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG4gICAgdmFyIGY7ICAgICAgICAgICAgICAvLyBwb2ludGVyIHRvIGNvcHkgc3RyaW5ncyBmcm9tXG5cbiAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcbiAgICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG4gICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG4gICAgLy8gcHJvY2VzcyBpbnB1dCBhbmQgb3V0cHV0IGJhc2VkIG9uIGN1cnJlbnQgc3RhdGVcbiAgICB3aGlsZSAodHJ1ZSl7XG4gICAgICBzd2l0Y2ggKHRoaXMubW9kZSl7XG5cdC8vIHdhaXRpbmcgZm9yIFwiaTpcIj1pbnB1dCwgXCJvOlwiPW91dHB1dCwgXCJ4OlwiPW5vdGhpbmdcbiAgICAgIGNhc2UgSUNfU1RBUlQ6ICAgICAgICAgLy8geDogc2V0IHVwIGZvciBMRU5cblx0aWYgKG0gPj0gMjU4ICYmIG4gPj0gMTApe1xuXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblx0ICByID0gdGhpcy5pbmZsYXRlX2Zhc3QodGhpcy5sYml0cywgdGhpcy5kYml0cywgXG5cdFx0XHQgICB0aGlzLmx0cmVlLCB0aGlzLmx0cmVlX2luZGV4LCBcblx0XHRcdCAgIHRoaXMuZHRyZWUsIHRoaXMuZHRyZWVfaW5kZXgsXG5cdFx0XHQgICBzLCB6KTtcblxuXHQgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcblx0ICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0ICBpZiAociAhPSBaX09LKXtcblx0ICAgIHRoaXMubW9kZSA9IHIgPT0gWl9TVFJFQU1fRU5EID8gSUNfV0FTSCA6IElDX0JBRENPREU7XG5cdCAgICBicmVhaztcblx0ICB9XG5cdH1cblx0dGhpcy5uZWVkID0gdGhpcy5sYml0cztcblx0dGhpcy50cmVlID0gdGhpcy5sdHJlZTtcblx0dGhpcy50cmVlX2luZGV4PXRoaXMubHRyZWVfaW5kZXg7XG5cblx0dGhpcy5tb2RlID0gSUNfTEVOO1xuICAgICAgY2FzZSBJQ19MRU46ICAgICAgICAgICAvLyBpOiBnZXQgbGVuZ3RoL2xpdGVyYWwvZW9iIG5leHRcblx0aiA9IHRoaXMubmVlZDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRpbmRleD0odGhpcy50cmVlX2luZGV4KyhiJmluZmxhdGVfbWFza1tqXSkpKjM7XG5cblx0Yj4+Pj0odGhpcy50cmVlW3RpbmRleCsxXSk7XG5cdGstPSh0aGlzLnRyZWVbdGluZGV4KzFdKTtcblxuXHRlPXRoaXMudHJlZVt0aW5kZXhdO1xuXG5cdGlmKGUgPT0gMCl7ICAgICAgICAgICAgICAgLy8gbGl0ZXJhbFxuXHQgIHRoaXMubGl0ID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19MSVQ7XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYoKGUgJiAxNikhPTAgKXsgICAgICAgICAgLy8gbGVuZ3RoXG5cdCAgdGhpcy5nZXQgPSBlICYgMTU7XG5cdCAgdGhpcy5sZW4gPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0xFTkVYVDtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiA2NCkgPT0gMCl7ICAgICAgICAvLyBuZXh0IHRhYmxlXG5cdCAgdGhpcy5uZWVkID0gZTtcblx0ICB0aGlzLnRyZWVfaW5kZXggPSB0aW5kZXgvMyArIHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgYnJlYWs7XG5cdH1cblx0aWYgKChlICYgMzIpIT0wKXsgICAgICAgICAgICAgICAvLyBlbmQgb2YgYmxvY2tcblx0ICB0aGlzLm1vZGUgPSBJQ19XQVNIO1xuXHQgIGJyZWFrO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0JBRENPREU7ICAgICAgICAvLyBpbnZhbGlkIGNvZGVcblx0ei5tc2cgPSBcImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiO1xuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBjYXNlIElDX0xFTkVYVDogICAgICAgIC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXG5cdGogPSB0aGlzLmdldDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLmxlbiArPSAoYiAmIGluZmxhdGVfbWFza1tqXSk7XG5cblx0Yj4+PWo7XG5cdGstPWo7XG5cblx0dGhpcy5uZWVkID0gdGhpcy5kYml0cztcblx0dGhpcy50cmVlID0gdGhpcy5kdHJlZTtcblx0dGhpcy50cmVlX2luZGV4ID0gdGhpcy5kdHJlZV9pbmRleDtcblx0dGhpcy5tb2RlID0gSUNfRElTVDtcbiAgICAgIGNhc2UgSUNfRElTVDogICAgICAgICAgLy8gaTogZ2V0IGRpc3RhbmNlIG5leHRcblx0aiA9IHRoaXMubmVlZDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aW5kZXg9KHRoaXMudHJlZV9pbmRleCsoYiAmIGluZmxhdGVfbWFza1tqXSkpKjM7XG5cblx0Yj4+PXRoaXMudHJlZVt0aW5kZXgrMV07XG5cdGstPXRoaXMudHJlZVt0aW5kZXgrMV07XG5cblx0ZSA9ICh0aGlzLnRyZWVbdGluZGV4XSk7XG5cdGlmKChlICYgMTYpIT0wKXsgICAgICAgICAgICAgICAvLyBkaXN0YW5jZVxuXHQgIHRoaXMuZ2V0ID0gZSAmIDE1O1xuXHQgIHRoaXMuZGlzdCA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfRElTVEVYVDtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiA2NCkgPT0gMCl7ICAgICAgICAvLyBuZXh0IHRhYmxlXG5cdCAgdGhpcy5uZWVkID0gZTtcblx0ICB0aGlzLnRyZWVfaW5kZXggPSB0aW5kZXgvMyArIHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfQkFEQ09ERTsgICAgICAgIC8vIGludmFsaWQgY29kZVxuXHR6Lm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCI7XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfRElTVEVYVDogICAgICAgLy8gaTogZ2V0dGluZyBkaXN0YW5jZSBleHRyYVxuXHRqID0gdGhpcy5nZXQ7XG5cblx0d2hpbGUoazwoaikpe1xuXHQgIGlmKG4hPTApcj1aX09LO1xuXHQgIGVsc2V7XG5cblx0ICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgcy53cml0ZT1xO1xuXHQgICAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgIH1cblx0ICBuLS07IGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGhpcy5kaXN0ICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcblxuXHRiPj49ajtcblx0ay09ajtcblxuXHR0aGlzLm1vZGUgPSBJQ19DT1BZO1xuICAgICAgY2FzZSBJQ19DT1BZOiAgICAgICAgICAvLyBvOiBjb3B5aW5nIGJ5dGVzIGluIHdpbmRvdywgd2FpdGluZyBmb3Igc3BhY2VcbiAgICAgICAgZiA9IHEgLSB0aGlzLmRpc3Q7XG4gICAgICAgIHdoaWxlKGYgPCAwKXsgICAgIC8vIG1vZHVsbyB3aW5kb3cgc2l6ZS1cIndoaWxlXCIgaW5zdGVhZFxuICAgICAgICAgIGYgKz0gcy5lbmQ7ICAgICAvLyBvZiBcImlmXCIgaGFuZGxlcyBpbnZhbGlkIGRpc3RhbmNlc1xuXHR9XG5cdHdoaWxlICh0aGlzLmxlbiE9MCl7XG5cblx0ICBpZihtPT0wKXtcblx0ICAgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgcy53cml0ZT1xOyByPXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0ICAgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblxuXHQgICAgICBpZihtPT0wKXtcblx0XHRzLmJpdGI9YjtzLmJpdGs9aztcblx0XHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdFx0cy53cml0ZT1xO1xuXHRcdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgICAgfSAgXG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tmKytdOyBtLS07XG5cblx0ICBpZiAoZiA9PSBzLmVuZClcbiAgICAgICAgICAgIGYgPSAwO1xuXHQgIHRoaXMubGVuLS07XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfU1RBUlQ7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQ19MSVQ6ICAgICAgICAgICAvLyBvOiBnb3QgbGl0ZXJhbCwgd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlXG5cdGlmKG09PTApe1xuXHQgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cdCAgaWYobT09MCl7XG5cdCAgICBzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0ICAgIGlmKHE9PXMuZW5kJiZzLnJlYWQhPTApe3E9MDttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTt9XG5cdCAgICBpZihtPT0wKXtcblx0ICAgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdHI9Wl9PSztcblxuXHRzLndpbmRvd1txKytdPXRoaXMubGl0OyBtLS07XG5cblx0dGhpcy5tb2RlID0gSUNfU1RBUlQ7XG5cdGJyZWFrO1xuICAgICAgY2FzZSBJQ19XQVNIOiAgICAgICAgICAgLy8gbzogZ290IGVvYiwgcG9zc2libHkgbW9yZSBvdXRwdXRcblx0aWYgKGsgPiA3KXsgICAgICAgIC8vIHJldHVybiB1bnVzZWQgYnl0ZSwgaWYgYW55XG5cdCAgayAtPSA4O1xuXHQgIG4rKztcblx0ICBwLS07ICAgICAgICAgICAgIC8vIGNhbiBhbHdheXMgcmV0dXJuIG9uZVxuXHR9XG5cblx0cy53cml0ZT1xOyByPXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHRxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cblx0aWYgKHMucmVhZCAhPSBzLndyaXRlKXtcblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXHQgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19FTkQ7XG4gICAgICBjYXNlIElDX0VORDpcblx0ciA9IFpfU1RSRUFNX0VORDtcblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfQkFEQ09ERTogICAgICAgLy8geDogZ290IGVycm9yXG5cblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgZGVmYXVsdDpcblx0ciA9IFpfU1RSRUFNX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUuZnJlZSA9IGZ1bmN0aW9uKHope1xuICAgIC8vICBaRlJFRSh6LCBjKTtcbn1cblxuICAvLyBDYWxsZWQgd2l0aCBudW1iZXIgb2YgYnl0ZXMgbGVmdCB0byB3cml0ZSBpbiB3aW5kb3cgYXQgbGVhc3QgMjU4XG4gIC8vICh0aGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoKSBhbmQgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIGF2YWlsYWJsZVxuICAvLyBhdCBsZWFzdCB0ZW4uICBUaGUgdGVuIGJ5dGVzIGFyZSBzaXggYnl0ZXMgZm9yIHRoZSBsb25nZXN0IGxlbmd0aC9cbiAgLy8gZGlzdGFuY2UgcGFpciBwbHVzIGZvdXIgYnl0ZXMgZm9yIG92ZXJsb2FkaW5nIHRoZSBiaXQgYnVmZmVyLlxuXG5JbmZDb2Rlcy5wcm90b3R5cGUuaW5mbGF0ZV9mYXN0ID0gZnVuY3Rpb24oYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgcywgeikge1xuICAgIHZhciB0OyAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciAgIHRwOyAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlciAoaW50W10pXG4gICAgdmFyIHRwX2luZGV4OyAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyIGU7ICAgICAgICAgICAgICAgIC8vIGV4dHJhIGJpdHMgb3Igb3BlcmF0aW9uXG4gICAgdmFyIGI7ICAgICAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgazsgICAgICAgICAgICAgICAgLy8gYml0cyBpbiBiaXQgYnVmZmVyXG4gICAgdmFyIHA7ICAgICAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgICAgLy8gb3V0cHV0IHdpbmRvdyB3cml0ZSBwb2ludGVyXG4gICAgdmFyIG07ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG4gICAgdmFyIG1sOyAgICAgICAgICAgICAgIC8vIG1hc2sgZm9yIGxpdGVyYWwvbGVuZ3RoIHRyZWVcbiAgICB2YXIgbWQ7ICAgICAgICAgICAgICAgLy8gbWFzayBmb3IgZGlzdGFuY2UgdHJlZVxuICAgIHZhciBjOyAgICAgICAgICAgICAgICAvLyBieXRlcyB0byBjb3B5XG4gICAgdmFyIGQ7ICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIGJhY2sgdG8gY29weSBmcm9tXG4gICAgdmFyIHI7ICAgICAgICAgICAgICAgIC8vIGNvcHkgc291cmNlIHBvaW50ZXJcblxuICAgIHZhciB0cF9pbmRleF90XzM7ICAgICAvLyAodHBfaW5kZXgrdCkqM1xuXG4gICAgLy8gbG9hZCBpbnB1dCwgb3V0cHV0LCBiaXQgdmFsdWVzXG4gICAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuICAgIC8vIGluaXRpYWxpemUgbWFza3NcbiAgICBtbCA9IGluZmxhdGVfbWFza1tibF07XG4gICAgbWQgPSBpbmZsYXRlX21hc2tbYmRdO1xuXG4gICAgLy8gZG8gdW50aWwgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgc3BhY2UgZm9yIGZhc3QgbG9vcFxuICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBjYWxsZWQgd2l0aCBtID49IDI1OCAmJiBuID49IDEwXG4gICAgICAvLyBnZXQgbGl0ZXJhbC9sZW5ndGggY29kZVxuICAgICAgd2hpbGUoazwoMjApKXsgICAgICAgICAgICAgIC8vIG1heCBiaXRzIGZvciBsaXRlcmFsL2xlbmd0aCBjb2RlXG5cdG4tLTtcblx0Ynw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG4gICAgICB9XG5cbiAgICAgIHQ9IGImbWw7XG4gICAgICB0cD10bDsgXG4gICAgICB0cF9pbmRleD10bF9pbmRleDtcbiAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcbiAgICAgIGlmICgoZSA9IHRwW3RwX2luZGV4X3RfM10pID09IDApe1xuXHRiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdHMud2luZG93W3ErK10gPSB0cFt0cF9pbmRleF90XzMrMl07XG5cdG0tLTtcblx0Y29udGludWU7XG4gICAgICB9XG4gICAgICBkbyB7XG5cblx0Yj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHRpZigoZSYxNikhPTApe1xuXHQgIGUgJj0gMTU7XG5cdCAgYyA9IHRwW3RwX2luZGV4X3RfMysyXSArIChiICYgaW5mbGF0ZV9tYXNrW2VdKTtcblxuXHQgIGI+Pj1lOyBrLT1lO1xuXG5cdCAgLy8gZGVjb2RlIGRpc3RhbmNlIGJhc2Ugb2YgYmxvY2sgdG8gY29weVxuXHQgIHdoaWxlKGs8KDE1KSl7ICAgICAgICAgICAvLyBtYXggYml0cyBmb3IgZGlzdGFuY2UgY29kZVxuXHQgICAgbi0tO1xuXHQgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG5cdCAgfVxuXG5cdCAgdD0gYiZtZDtcblx0ICB0cD10ZDtcblx0ICB0cF9pbmRleD10ZF9pbmRleDtcbiAgICAgICAgICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG5cdCAgZSA9IHRwW3RwX2luZGV4X3RfM107XG5cblx0ICBkbyB7XG5cblx0ICAgIGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0ICAgIGlmKChlJjE2KSE9MCl7XG5cdCAgICAgIC8vIGdldCBleHRyYSBiaXRzIHRvIGFkZCB0byBkaXN0YW5jZSBiYXNlXG5cdCAgICAgIGUgJj0gMTU7XG5cdCAgICAgIHdoaWxlKGs8KGUpKXsgICAgICAgICAvLyBnZXQgZXh0cmEgYml0cyAodXAgdG8gMTMpXG5cdFx0bi0tO1xuXHRcdGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztrKz04O1xuXHQgICAgICB9XG5cblx0ICAgICAgZCA9IHRwW3RwX2luZGV4X3RfMysyXSArIChiJmluZmxhdGVfbWFza1tlXSk7XG5cblx0ICAgICAgYj4+PShlKTsgay09KGUpO1xuXG5cdCAgICAgIC8vIGRvIHRoZSBjb3B5XG5cdCAgICAgIG0gLT0gYztcblx0ICAgICAgaWYgKHEgPj0gZCl7ICAgICAgICAgICAgICAgIC8vIG9mZnNldCBiZWZvcmUgZGVzdFxuXHRcdC8vICBqdXN0IGNvcHlcblx0XHRyPXEtZDtcblx0XHRpZihxLXI+MCAmJiAyPihxLXIpKXsgICAgICAgICAgIFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBtaW5pbXVtIGNvdW50IGlzIHRocmVlLFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGwgbG9vcCBhIGxpdHRsZVxuXHRcdCAgYy09Mjtcblx0XHR9XG5cdFx0ZWxzZXtcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gbWluaW11bSBjb3VudCBpcyB0aHJlZSxcblx0XHQgIHMud2luZG93W3ErK109cy53aW5kb3dbcisrXTsgLy8gc28gdW5yb2xsIGxvb3AgYSBsaXR0bGVcblx0XHQgIGMtPTI7XG5cdFx0fVxuXHQgICAgICB9XG5cdCAgICAgIGVsc2V7ICAgICAgICAgICAgICAgICAgLy8gZWxzZSBvZmZzZXQgYWZ0ZXIgZGVzdGluYXRpb25cbiAgICAgICAgICAgICAgICByPXEtZDtcbiAgICAgICAgICAgICAgICBkb3tcbiAgICAgICAgICAgICAgICAgIHIrPXMuZW5kOyAgICAgICAgICAvLyBmb3JjZSBwb2ludGVyIGluIHdpbmRvd1xuICAgICAgICAgICAgICAgIH13aGlsZShyPDApOyAgICAgICAgIC8vIGNvdmVycyBpbnZhbGlkIGRpc3RhbmNlc1xuXHRcdGU9cy5lbmQtcjtcblx0XHRpZihjPmUpeyAgICAgICAgICAgICAvLyBpZiBzb3VyY2UgY3Jvc3Nlcyxcblx0XHQgIGMtPWU7ICAgICAgICAgICAgICAvLyB3cmFwcGVkIGNvcHlcblx0XHQgIGlmKHEtcj4wICYmIGU+KHEtcikpeyAgICAgICAgICAgXG5cdFx0ICAgIGRve3Mud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO31cblx0XHQgICAgd2hpbGUoLS1lIT0wKTtcblx0XHQgIH1cblx0XHQgIGVsc2V7XG5cdFx0ICAgIGFycmF5Q29weShzLndpbmRvdywgciwgcy53aW5kb3csIHEsIGUpO1xuXHRcdCAgICBxKz1lOyByKz1lOyBlPTA7XG5cdFx0ICB9XG5cdFx0ICByID0gMDsgICAgICAgICAgICAgICAgICAvLyBjb3B5IHJlc3QgZnJvbSBzdGFydCBvZiB3aW5kb3dcblx0XHR9XG5cblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGNvcHkgYWxsIG9yIHdoYXQncyBsZWZ0XG4gICAgICAgICAgICAgIGRve3Mud2luZG93W3ErK10gPSBzLndpbmRvd1tyKytdO31cblx0XHR3aGlsZSgtLWMhPTApO1xuXHQgICAgICBicmVhaztcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYoKGUmNjQpPT0wKXtcblx0ICAgICAgdCs9dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgICAgICB0Kz0oYiZpbmZsYXRlX21hc2tbZV0pO1xuXHQgICAgICB0cF9pbmRleF90XzM9KHRwX2luZGV4K3QpKjM7XG5cdCAgICAgIGU9dHBbdHBfaW5kZXhfdF8zXTtcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHoubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIjtcblxuXHQgICAgICBjPXouYXZhaWxfaW4tbjtjPShrPj4zKTxjP2s+PjM6YztuKz1jO3AtPWM7ay09Yzw8MztcblxuXHQgICAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICBzLndyaXRlPXE7XG5cblx0ICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcblx0ICAgIH1cblx0ICB9XG5cdCAgd2hpbGUodHJ1ZSk7XG5cdCAgYnJlYWs7XG5cdH1cblxuXHRpZigoZSY2NCk9PTApe1xuXHQgIHQrPXRwW3RwX2luZGV4X3RfMysyXTtcblx0ICB0Kz0oYiZpbmZsYXRlX21hc2tbZV0pO1xuXHQgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICBpZigoZT10cFt0cF9pbmRleF90XzNdKT09MCl7XG5cblx0ICAgIGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0ICAgIHMud2luZG93W3ErK109dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgICAgbS0tO1xuXHQgICAgYnJlYWs7XG5cdCAgfVxuXHR9XG5cdGVsc2UgaWYoKGUmMzIpIT0wKXtcblxuXHQgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuIFxuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cblx0ICByZXR1cm4gWl9TVFJFQU1fRU5EO1xuXHR9XG5cdGVsc2V7XG5cdCAgei5tc2c9XCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIjtcblxuXHQgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblxuXHQgIHJldHVybiBaX0RBVEFfRVJST1I7XG5cdH1cbiAgICAgIH0gXG4gICAgICB3aGlsZSh0cnVlKTtcbiAgICB9IFxuICAgIHdoaWxlKG0+PTI1OCAmJiBuPj0gMTApO1xuXG4gICAgLy8gbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQtLXJlc3RvcmUgcG9pbnRlcnMgYW5kIHJldHVyblxuICAgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG4gICAgcy5iaXRiPWI7cy5iaXRrPWs7XG4gICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuICAgIHMud3JpdGU9cTtcblxuICAgIHJldHVybiBaX09LO1xufVxuXG4vL1xuLy8gSW5mVHJlZS5qYXZhXG4vL1xuXG5mdW5jdGlvbiBJbmZUcmVlKCkge1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5odWZ0X2J1aWxkID0gZnVuY3Rpb24oYiwgYmluZGV4LCBuLCBzLCBkLCBlLCB0LCBtLCBocCwgaG4sIHYpIHtcblxuICAgIC8vIEdpdmVuIGEgbGlzdCBvZiBjb2RlIGxlbmd0aHMgYW5kIGEgbWF4aW11bSB0YWJsZSBzaXplLCBtYWtlIGEgc2V0IG9mXG4gICAgLy8gdGFibGVzIHRvIGRlY29kZSB0aGF0IHNldCBvZiBjb2Rlcy4gIFJldHVybiBaX09LIG9uIHN1Y2Nlc3MsIFpfQlVGX0VSUk9SXG4gICAgLy8gaWYgdGhlIGdpdmVuIGNvZGUgc2V0IGlzIGluY29tcGxldGUgKHRoZSB0YWJsZXMgYXJlIHN0aWxsIGJ1aWx0IGluIHRoaXNcbiAgICAvLyBjYXNlKSwgWl9EQVRBX0VSUk9SIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkIChhbiBvdmVyLXN1YnNjcmliZWQgc2V0IG9mXG4gICAgLy8gbGVuZ3RocyksIG9yIFpfTUVNX0VSUk9SIGlmIG5vdCBlbm91Z2ggbWVtb3J5LlxuXG4gICAgdmFyIGE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyIGZvciBjb2RlcyBvZiBsZW5ndGgga1xuICAgIHZhciBmOyAgICAgICAgICAgICAgICAgICAgICAgLy8gaSByZXBlYXRzIGluIHRhYmxlIGV2ZXJ5IGYgZW50cmllc1xuICAgIHZhciBnOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxuICAgIHZhciBoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFibGUgbGV2ZWxcbiAgICB2YXIgaTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIsIGN1cnJlbnQgY29kZVxuICAgIHZhciBqOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGJpdHMgaW4gY3VycmVudCBjb2RlXG4gICAgdmFyIGw7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIHBlciB0YWJsZSAocmV0dXJuZWQgaW4gbSlcbiAgICB2YXIgbWFzazsgICAgICAgICAgICAgICAgICAgIC8vICgxIDw8IHcpIC0gMSwgdG8gYXZvaWQgY2MgLU8gYnVnIG9uIEhQXG4gICAgdmFyIHA7ICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIGludG8gY1tdLCBiW10sIG9yIHZbXVxuICAgIHZhciBxOyAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzIHRvIGN1cnJlbnQgdGFibGVcbiAgICB2YXIgdzsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgYmVmb3JlIHRoaXMgdGFibGUgPT0gKGwgKiBoKVxuICAgIHZhciB4cDsgICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRlciBpbnRvIHhcbiAgICB2YXIgeTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiBkdW1teSBjb2RlcyBhZGRlZFxuICAgIHZhciB6OyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgaW4gY3VycmVudCB0YWJsZVxuXG4gICAgLy8gR2VuZXJhdGUgY291bnRzIGZvciBlYWNoIGJpdCBsZW5ndGhcblxuICAgIHAgPSAwOyBpID0gbjtcbiAgICBkbyB7XG4gICAgICB0aGlzLmNbYltiaW5kZXgrcF1dKys7IHArKzsgaS0tOyAgIC8vIGFzc3VtZSBhbGwgZW50cmllcyA8PSBCTUFYXG4gICAgfXdoaWxlKGkhPTApO1xuXG4gICAgaWYodGhpcy5jWzBdID09IG4peyAgICAgICAgICAgICAgICAvLyBudWxsIGlucHV0LS1hbGwgemVybyBsZW5ndGggY29kZXNcbiAgICAgIHRbMF0gPSAtMTtcbiAgICAgIG1bMF0gPSAwO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLy8gRmluZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCwgYm91bmQgKm0gYnkgdGhvc2VcbiAgICBsID0gbVswXTtcbiAgICBmb3IgKGogPSAxOyBqIDw9IEJNQVg7IGorKylcbiAgICAgIGlmKHRoaXMuY1tqXSE9MCkgYnJlYWs7XG4gICAgayA9IGo7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWluaW11bSBjb2RlIGxlbmd0aFxuICAgIGlmKGwgPCBqKXtcbiAgICAgIGwgPSBqO1xuICAgIH1cbiAgICBmb3IgKGkgPSBCTUFYOyBpIT0wOyBpLS0pe1xuICAgICAgaWYodGhpcy5jW2ldIT0wKSBicmVhaztcbiAgICB9XG4gICAgZyA9IGk7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4aW11bSBjb2RlIGxlbmd0aFxuICAgIGlmKGwgPiBpKXtcbiAgICAgIGwgPSBpO1xuICAgIH1cbiAgICBtWzBdID0gbDtcblxuICAgIC8vIEFkanVzdCBsYXN0IGxlbmd0aCBjb3VudCB0byBmaWxsIG91dCBjb2RlcywgaWYgbmVlZGVkXG4gICAgZm9yICh5ID0gMSA8PCBqOyBqIDwgaTsgaisrLCB5IDw8PSAxKXtcbiAgICAgIGlmICgoeSAtPSB0aGlzLmNbal0pIDwgMCl7XG4gICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoeSAtPSB0aGlzLmNbaV0pIDwgMCl7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgICB0aGlzLmNbaV0gKz0geTtcblxuICAgIC8vIEdlbmVyYXRlIHN0YXJ0aW5nIG9mZnNldHMgaW50byB0aGUgdmFsdWUgdGFibGUgZm9yIGVhY2ggbGVuZ3RoXG4gICAgdGhpcy54WzFdID0gaiA9IDA7XG4gICAgcCA9IDE7ICB4cCA9IDI7XG4gICAgd2hpbGUgKC0taSE9MCkgeyAgICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IGkgPT0gZyBmcm9tIGFib3ZlXG4gICAgICB0aGlzLnhbeHBdID0gKGogKz0gdGhpcy5jW3BdKTtcbiAgICAgIHhwKys7XG4gICAgICBwKys7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBhIHRhYmxlIG9mIHZhbHVlcyBpbiBvcmRlciBvZiBiaXQgbGVuZ3Roc1xuICAgIGkgPSAwOyBwID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoKGogPSBiW2JpbmRleCtwXSkgIT0gMCl7XG4gICAgICAgIHRoaXMudlt0aGlzLnhbal0rK10gPSBpO1xuICAgICAgfVxuICAgICAgcCsrO1xuICAgIH1cbiAgICB3aGlsZSAoKytpIDwgbik7XG4gICAgbiA9IHRoaXMueFtnXTsgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgbiB0byBsZW5ndGggb2YgdlxuXG4gICAgLy8gR2VuZXJhdGUgdGhlIEh1ZmZtYW4gY29kZXMgYW5kIGZvciBlYWNoLCBtYWtlIHRoZSB0YWJsZSBlbnRyaWVzXG4gICAgdGhpcy54WzBdID0gaSA9IDA7ICAgICAgICAgICAgICAgICAvLyBmaXJzdCBIdWZmbWFuIGNvZGUgaXMgemVyb1xuICAgIHAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdyYWIgdmFsdWVzIGluIGJpdCBvcmRlclxuICAgIGggPSAtMTsgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHRhYmxlcyB5ZXQtLWxldmVsIC0xXG4gICAgdyA9IC1sOyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBkZWNvZGVkID09IChsICogaClcbiAgICB0aGlzLnVbMF0gPSAwOyAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgdG8ga2VlcCBjb21waWxlcnMgaGFwcHlcbiAgICBxID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXR0b1xuICAgIHogPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdHRvXG5cbiAgICAvLyBnbyB0aHJvdWdoIHRoZSBiaXQgbGVuZ3RocyAoayBhbHJlYWR5IGlzIGJpdHMgaW4gc2hvcnRlc3QgY29kZSlcbiAgICBmb3IgKDsgayA8PSBnOyBrKyspe1xuICAgICAgYSA9IHRoaXMuY1trXTtcbiAgICAgIHdoaWxlIChhLS0hPTApe1xuXHQvLyBoZXJlIGkgaXMgdGhlIEh1ZmZtYW4gY29kZSBvZiBsZW5ndGggayBiaXRzIGZvciB2YWx1ZSAqcFxuXHQvLyBtYWtlIHRhYmxlcyB1cCB0byByZXF1aXJlZCBsZXZlbFxuICAgICAgICB3aGlsZSAoayA+IHcgKyBsKXtcbiAgICAgICAgICBoKys7XG4gICAgICAgICAgdyArPSBsOyAgICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgdGFibGUgYWx3YXlzIGwgYml0c1xuXHQgIC8vIGNvbXB1dGUgbWluaW11bSBzaXplIHRhYmxlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBsIGJpdHNcbiAgICAgICAgICB6ID0gZyAtIHc7XG4gICAgICAgICAgeiA9ICh6ID4gbCkgPyBsIDogejsgICAgICAgIC8vIHRhYmxlIHNpemUgdXBwZXIgbGltaXRcbiAgICAgICAgICBpZigoZj0xPDwoaj1rLXcpKT5hKzEpeyAgICAgLy8gdHJ5IGEgay13IGJpdCB0YWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0b28gZmV3IGNvZGVzIGZvciBrLXcgYml0IHRhYmxlXG4gICAgICAgICAgICBmIC09IGEgKyAxOyAgICAgICAgICAgICAgIC8vIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zIGxlZnRcbiAgICAgICAgICAgIHhwID0gaztcbiAgICAgICAgICAgIGlmKGogPCB6KXtcbiAgICAgICAgICAgICAgd2hpbGUgKCsraiA8IHopeyAgICAgICAgLy8gdHJ5IHNtYWxsZXIgdGFibGVzIHVwIHRvIHogYml0c1xuICAgICAgICAgICAgICAgIGlmKChmIDw8PSAxKSA8PSB0aGlzLmNbKyt4cF0pXG4gICAgICAgICAgICAgICAgICBicmVhazsgICAgICAgICAgICAgIC8vIGVub3VnaCBjb2RlcyB0byB1c2UgdXAgaiBiaXRzXG4gICAgICAgICAgICAgICAgZiAtPSB0aGlzLmNbeHBdOyAgICAgICAgICAgLy8gZWxzZSBkZWR1Y3QgY29kZXMgZnJvbSBwYXR0ZXJuc1xuICAgICAgICAgICAgICB9XG5cdCAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHogPSAxIDw8IGo7ICAgICAgICAgICAgICAgICAvLyB0YWJsZSBlbnRyaWVzIGZvciBqLWJpdCB0YWJsZVxuXG5cdCAgLy8gYWxsb2NhdGUgbmV3IHRhYmxlXG4gICAgICAgICAgaWYgKHRoaXMuaG5bMF0gKyB6ID4gTUFOWSl7ICAgICAgIC8vIChub3RlOiBkb2Vzbid0IG1hdHRlciBmb3IgZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SOyAgICAgICAvLyBvdmVyZmxvdyBvZiBNQU5ZXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudVtoXSA9IHEgPSAvKmhwKyovIHRoaXMuaG5bMF07ICAgLy8gREVCVUdcbiAgICAgICAgICB0aGlzLmhuWzBdICs9IHo7XG4gXG5cdCAgLy8gY29ubmVjdCB0byBsYXN0IHRhYmxlLCBpZiB0aGVyZSBpcyBvbmVcblx0ICBpZihoIT0wKXtcbiAgICAgICAgICAgIHRoaXMueFtoXT1pOyAgICAgICAgICAgLy8gc2F2ZSBwYXR0ZXJuIGZvciBiYWNraW5nIHVwXG4gICAgICAgICAgICB0aGlzLnJbMF09ajsgICAgIC8vIGJpdHMgaW4gdGhpcyB0YWJsZVxuICAgICAgICAgICAgdGhpcy5yWzFdPWw7ICAgICAvLyBiaXRzIHRvIGR1bXAgYmVmb3JlIHRoaXMgdGFibGVcbiAgICAgICAgICAgIGo9aT4+Pih3IC0gbCk7XG4gICAgICAgICAgICB0aGlzLnJbMl0gPSAocSAtIHRoaXMudVtoLTFdIC0gaik7ICAgICAgICAgICAgICAgLy8gb2Zmc2V0IHRvIHRoaXMgdGFibGVcbiAgICAgICAgICAgIGFycmF5Q29weSh0aGlzLnIsIDAsIGhwLCAodGhpcy51W2gtMV0raikqMywgMyk7IC8vIGNvbm5lY3QgdG8gbGFzdCB0YWJsZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgdFswXSA9IHE7ICAgICAgICAgICAgICAgLy8gZmlyc3QgdGFibGUgaXMgcmV0dXJuZWQgcmVzdWx0XG5cdCAgfVxuICAgICAgICB9XG5cblx0Ly8gc2V0IHVwIHRhYmxlIGVudHJ5IGluIHJcbiAgICAgICAgdGhpcy5yWzFdID0gKGsgLSB3KTtcbiAgICAgICAgaWYgKHAgPj0gbil7XG4gICAgICAgICAgdGhpcy5yWzBdID0gMTI4ICsgNjQ7ICAgICAgLy8gb3V0IG9mIHZhbHVlcy0taW52YWxpZCBjb2RlXG5cdH1cbiAgICAgICAgZWxzZSBpZiAodltwXSA8IHMpe1xuICAgICAgICAgIHRoaXMuclswXSA9ICh0aGlzLnZbcF0gPCAyNTYgPyAwIDogMzIgKyA2NCk7ICAvLyAyNTYgaXMgZW5kLW9mLWJsb2NrXG4gICAgICAgICAgdGhpcy5yWzJdID0gdGhpcy52W3ArK107ICAgICAgICAgIC8vIHNpbXBsZSBjb2RlIGlzIGp1c3QgdGhlIHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICB0aGlzLnJbMF09KGVbdGhpcy52W3BdLXNdKzE2KzY0KTsgLy8gbm9uLXNpbXBsZS0tbG9vayB1cCBpbiBsaXN0c1xuICAgICAgICAgIHRoaXMuclsyXT1kW3RoaXMudltwKytdIC0gc107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWxsIGNvZGUtbGlrZSBlbnRyaWVzIHdpdGggclxuICAgICAgICBmPTE8PChrLXcpO1xuICAgICAgICBmb3IgKGo9aT4+Pnc7ajx6O2orPWYpe1xuICAgICAgICAgIGFycmF5Q29weSh0aGlzLnIsIDAsIGhwLCAocStqKSozLCAzKTtcblx0fVxuXG5cdC8vIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGstYml0IGNvZGUgaVxuICAgICAgICBmb3IgKGogPSAxIDw8IChrIC0gMSk7IChpICYgaikhPTA7IGogPj4+PSAxKXtcbiAgICAgICAgICBpIF49IGo7XG5cdH1cbiAgICAgICAgaSBePSBqO1xuXG5cdC8vIGJhY2t1cCBvdmVyIGZpbmlzaGVkIHRhYmxlc1xuICAgICAgICBtYXNrID0gKDEgPDwgdykgLSAxOyAgICAgIC8vIG5lZWRlZCBvbiBIUCwgY2MgLU8gYnVnXG4gICAgICAgIHdoaWxlICgoaSAmIG1hc2spICE9IHRoaXMueFtoXSl7XG4gICAgICAgICAgaC0tOyAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgcVxuICAgICAgICAgIHcgLT0gbDtcbiAgICAgICAgICBtYXNrID0gKDEgPDwgdykgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiBaX0JVRl9FUlJPUiBpZiB3ZSB3ZXJlIGdpdmVuIGFuIGluY29tcGxldGUgdGFibGVcbiAgICByZXR1cm4geSAhPSAwICYmIGcgIT0gMSA/IFpfQlVGX0VSUk9SIDogWl9PSztcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5mbGF0ZV90cmVlc19iaXRzID0gZnVuY3Rpb24oYywgYmIsIHRiLCBocCwgeikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdGhpcy5pbml0V29ya0FyZWEoMTkpO1xuICAgIHRoaXMuaG5bMF09MDtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgMCwgMTksIDE5LCBudWxsLCBudWxsLCB0YiwgYmIsIGhwLCB0aGlzLmhuLCB0aGlzLnYpO1xuXG4gICAgaWYocmVzdWx0ID09IFpfREFUQV9FUlJPUil7XG4gICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYocmVzdWx0ID09IFpfQlVGX0VSUk9SIHx8IGJiWzBdID09IDApe1xuICAgICAgei5tc2cgPSBcImluY29tcGxldGUgZHluYW1pYyBiaXQgbGVuZ3RocyB0cmVlXCI7XG4gICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmluZmxhdGVfdHJlZXNfZHluYW1pYyA9IGZ1bmN0aW9uKG5sLCBuZCwgYywgYmwsIGJkLCB0bCwgdGQsIGhwLCB6KSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGJ1aWxkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgyODgpO1xuICAgIHRoaXMuaG5bMF09MDtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgMCwgbmwsIDI1NywgY3BsZW5zLCBjcGxleHQsIHRsLCBibCwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG4gICAgaWYgKHJlc3VsdCAhPSBaX09LIHx8IGJsWzBdID09IDApe1xuICAgICAgaWYocmVzdWx0ID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBsaXRlcmFsL2xlbmd0aCB0cmVlXCI7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyZXN1bHQgIT0gWl9NRU1fRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBsaXRlcmFsL2xlbmd0aCB0cmVlXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgZGlzdGFuY2UgdHJlZVxuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDI4OCk7XG4gICAgcmVzdWx0ID0gdGhpcy5odWZ0X2J1aWxkKGMsIG5sLCBuZCwgMCwgY3BkaXN0LCBjcGRleHQsIHRkLCBiZCwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG5cbiAgICBpZiAocmVzdWx0ICE9IFpfT0sgfHwgKGJkWzBdID09IDAgJiYgbmwgPiAyNTcpKXtcbiAgICAgIGlmIChyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGRpc3RhbmNlIHRyZWVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCA9PSBaX0JVRl9FUlJPUikge1xuICAgICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBkaXN0YW5jZSB0cmVlXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJlbXB0eSBkaXN0YW5jZSB0cmVlIHdpdGggbGVuZ3Roc1wiO1xuICAgICAgICByZXN1bHQgPSBaX0RBVEFfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBaX09LO1xufVxuLypcbiAgc3RhdGljIGludCBpbmZsYXRlX3RyZWVzX2ZpeGVkKGludFtdIGJsLCAgLy9saXRlcmFsIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W10gYmQsICAvL2Rpc3RhbmNlIGRlc2lyZWQvYWN0dWFsIGJpdCBkZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W11bXSB0bCwvL2xpdGVyYWwvbGVuZ3RoIHRyZWUgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXVtdIHRkLC8vZGlzdGFuY2UgdHJlZSByZXN1bHQgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBaU3RyZWFtIHogIC8vZm9yIG1lbW9yeSBhbGxvY2F0aW9uXG5cdFx0XHRcdCApe1xuXG4qL1xuXG5mdW5jdGlvbiBpbmZsYXRlX3RyZWVzX2ZpeGVkKGJsLCBiZCwgdGwsIHRkLCB6KSB7XG4gICAgYmxbMF09Zml4ZWRfYmw7XG4gICAgYmRbMF09Zml4ZWRfYmQ7XG4gICAgdGxbMF09Zml4ZWRfdGw7XG4gICAgdGRbMF09Zml4ZWRfdGQ7XG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmluaXRXb3JrQXJlYSA9IGZ1bmN0aW9uKHZzaXplKXtcbiAgICBpZih0aGlzLmhuPT1udWxsKXtcbiAgICAgICAgdGhpcy5obj1uZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgdGhpcy52PW5ldyBJbnQzMkFycmF5KHZzaXplKTtcbiAgICAgICAgdGhpcy5jPW5ldyBJbnQzMkFycmF5KEJNQVgrMSk7XG4gICAgICAgIHRoaXMucj1uZXcgSW50MzJBcnJheSgzKTtcbiAgICAgICAgdGhpcy51PW5ldyBJbnQzMkFycmF5KEJNQVgpO1xuICAgICAgICB0aGlzLng9bmV3IEludDMyQXJyYXkoQk1BWCsxKTtcbiAgICB9XG4gICAgaWYodGhpcy52Lmxlbmd0aDx2c2l6ZSl7IFxuICAgICAgICB0aGlzLnY9bmV3IEludDMyQXJyYXkodnNpemUpOyBcbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8dnNpemU7IGkrKyl7dGhpcy52W2ldPTA7fVxuICAgIGZvcih2YXIgaT0wOyBpPEJNQVgrMTsgaSsrKXt0aGlzLmNbaV09MDt9XG4gICAgZm9yKHZhciBpPTA7IGk8MzsgaSsrKXt0aGlzLnJbaV09MDt9XG4vLyAgZm9yKGludCBpPTA7IGk8Qk1BWDsgaSsrKXt1W2ldPTA7fVxuICAgIGFycmF5Q29weSh0aGlzLmMsIDAsIHRoaXMudSwgMCwgQk1BWCk7XG4vLyAgZm9yKGludCBpPTA7IGk8Qk1BWCsxOyBpKyspe3hbaV09MDt9XG4gICAgYXJyYXlDb3B5KHRoaXMuYywgMCwgdGhpcy54LCAwLCBCTUFYKzEpO1xufVxuXG52YXIgdGVzdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG52YXIgaGFzU3ViYXJyYXkgPSAodHlwZW9mIHRlc3RBcnJheS5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyk7XG52YXIgaGFzU2xpY2UgPSBmYWxzZTsgLyogKHR5cGVvZiB0ZXN0QXJyYXkuc2xpY2UgPT09ICdmdW5jdGlvbicpOyAqLyAvLyBDaHJvbWUgc2xpY2UgcGVyZm9ybWFuY2UgaXMgc28gZGlyZSB0aGF0IHdlJ3JlIGN1cnJlbnRseSBub3QgdXNpbmcgaXQuLi5cblxuZnVuY3Rpb24gYXJyYXlDb3B5KHNyYywgc3JjT2Zmc2V0LCBkZXN0LCBkZXN0T2Zmc2V0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IFxuICAgIGlmICghc3JjKSB7XG4gICAgICAgIHRocm93IFwiVW5kZWYgc3JjXCI7XG4gICAgfSBlbHNlIGlmICghZGVzdCkge1xuICAgICAgICB0aHJvdyBcIlVuZGVmIGRlc3RcIjtcbiAgICB9XG5cbiAgICBpZiAoc3JjT2Zmc2V0ID09IDAgJiYgY291bnQgPT0gc3JjLmxlbmd0aCkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChzcmMsIGRlc3QsIGRlc3RPZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoaGFzU3ViYXJyYXkpIHtcbiAgICAgICAgYXJyYXlDb3B5X2Zhc3Qoc3JjLnN1YmFycmF5KHNyY09mZnNldCwgc3JjT2Zmc2V0ICsgY291bnQpLCBkZXN0LCBkZXN0T2Zmc2V0KTsgXG4gICAgfSBlbHNlIGlmIChzcmMuQllURVNfUEVSX0VMRU1FTlQgPT0gMSAmJiBjb3VudCA+IDEwMCkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChuZXcgVWludDhBcnJheShzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCArIHNyY09mZnNldCwgY291bnQpLCBkZXN0LCBkZXN0T2Zmc2V0KTtcbiAgICB9IGVsc2UgeyBcbiAgICAgICAgYXJyYXlDb3B5X3Nsb3coc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KTtcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlDb3B5X3Nsb3coc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KSB7XG5cbiAgICAvLyBkbG9nKCdfc2xvdyBjYWxsOiBzcmNPZmZzZXQ9JyArIHNyY09mZnNldCArICc7IGRlc3RPZmZzZXQ9JyArIGRlc3RPZmZzZXQgKyAnOyBjb3VudD0nICsgY291bnQpO1xuXG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyBpXSA9IHNyY1tzcmNPZmZzZXQgKyBpXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFycmF5Q29weV9mYXN0KHNyYywgZGVzdCwgZGVzdE9mZnNldCkge1xuICAgIGRlc3Quc2V0KHNyYywgZGVzdE9mZnNldCk7XG59XG5cblxuICAvLyBsYXJnZXN0IHByaW1lIHNtYWxsZXIgdGhhbiA2NTUzNlxudmFyIEFETEVSX0JBU0U9NjU1MjE7IFxuICAvLyBOTUFYIGlzIHRoZSBsYXJnZXN0IG4gc3VjaCB0aGF0IDI1NW4obisxKS8yICsgKG4rMSkoQkFTRS0xKSA8PSAyXjMyLTFcbnZhciBBRExFUl9OTUFYPTU1NTI7XG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIC8qIGJ5dGVbXSAqLyBidWYsICBpbmRleCwgbGVuKXtcbiAgICBpZihidWYgPT0gbnVsbCl7IHJldHVybiAxOyB9XG5cbiAgICB2YXIgczE9YWRsZXImMHhmZmZmO1xuICAgIHZhciBzMj0oYWRsZXI+PjE2KSYweGZmZmY7XG4gICAgdmFyIGs7XG5cbiAgICB3aGlsZShsZW4gPiAwKSB7XG4gICAgICBrPWxlbjxBRExFUl9OTUFYP2xlbjpBRExFUl9OTUFYO1xuICAgICAgbGVuLT1rO1xuICAgICAgd2hpbGUoaz49MTYpe1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgay09MTY7XG4gICAgICB9XG4gICAgICBpZihrIT0wKXtcbiAgICAgICAgZG97XG4gICAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoLS1rIT0wKTtcbiAgICAgIH1cbiAgICAgIHMxJT1BRExFUl9CQVNFO1xuICAgICAgczIlPUFETEVSX0JBU0U7XG4gICAgfVxuICAgIHJldHVybiAoczI8PDE2KXxzMTtcbn1cblxuXG5cbmZ1bmN0aW9uIGpzemxpYl9pbmZsYXRlX2J1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgsIGFmdGVyVW5jT2Zmc2V0KSB7XG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHogPSBuZXcgWlN0cmVhbSgpO1xuICAgIHouaW5mbGF0ZUluaXQoREVGX1dCSVRTLCB0cnVlKTtcbiAgICB6Lm5leHRfaW4gPSBidWZmZXI7XG4gICAgei5uZXh0X2luX2luZGV4ID0gMDtcbiAgICB6LmF2YWlsX2luID0gYnVmZmVyLmxlbmd0aDtcblxuICAgIHZhciBvQmxvY2tMaXN0ID0gW107XG4gICAgdmFyIHRvdGFsU2l6ZSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIG9idWYgPSBuZXcgVWludDhBcnJheSgzMjAwMCk7XG4gICAgICAgIHoubmV4dF9vdXQgPSBvYnVmO1xuICAgICAgICB6Lm5leHRfb3V0X2luZGV4ID0gMDtcbiAgICAgICAgei5hdmFpbF9vdXQgPSBvYnVmLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHouaW5mbGF0ZShaX05PX0ZMVVNIKTtcbiAgICAgICAgaWYgKHN0YXR1cyAhPSBaX09LICYmIHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgICAgICAgIHRocm93IHoubXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6LmF2YWlsX291dCAhPSAwKSB7XG4gICAgICAgICAgICB2YXIgbmV3b2IgPSBuZXcgVWludDhBcnJheShvYnVmLmxlbmd0aCAtIHouYXZhaWxfb3V0KTtcbiAgICAgICAgICAgIGFycmF5Q29weShvYnVmLCAwLCBuZXdvYiwgMCwgKG9idWYubGVuZ3RoIC0gei5hdmFpbF9vdXQpKTtcbiAgICAgICAgICAgIG9idWYgPSBuZXdvYjtcbiAgICAgICAgfVxuICAgICAgICBvQmxvY2tMaXN0LnB1c2gob2J1Zik7XG4gICAgICAgIHRvdGFsU2l6ZSArPSBvYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSBaX1NUUkVBTV9FTkQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFmdGVyVW5jT2Zmc2V0KSB7XG4gICAgICAgIGFmdGVyVW5jT2Zmc2V0WzBdID0gKHN0YXJ0IHx8IDApICsgei5uZXh0X2luX2luZGV4O1xuICAgIH1cblxuICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdLmJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxTaXplKTtcbiAgICAgICAgdmFyIGN1cnNvciA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb0Jsb2NrTGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGIgPSBvQmxvY2tMaXN0W2ldO1xuICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XG4gICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XG4gICAgfVxufVxuXG5leHBvcnQge2pzemxpYl9pbmZsYXRlX2J1ZmZlcixhcnJheUNvcHl9Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vendor/inflate.js\n");

/***/ }),

/***/ "./src/vendor/zlib_and_gzip.min.js":
/*!*****************************************!*\
  !*** ./src/vendor/zlib_and_gzip.min.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function q(b){throw b;}var t=void 0,u=!0,aa=this;function A(b,a){var c=b.split(\".\"),d=aa;!(c[0]in d)&&d.execScript&&d.execScript(\"var \"+c[0]);for(var f;c.length&&(f=c.shift());)!c.length&&a!==t?d[f]=a:d=d[f]?d[f]:d[f]={}};var B=\"undefined\"!==typeof Uint8Array&&\"undefined\"!==typeof Uint16Array&&\"undefined\"!==typeof Uint32Array;function F(b,a){this.index=\"number\"===typeof a?a:0;this.m=0;this.buffer=b instanceof(B?Uint8Array:Array)?b:new (B?Uint8Array:Array)(32768);2*this.buffer.length<=this.index&&q(Error(\"invalid index\"));this.buffer.length<=this.index&&this.f()}F.prototype.f=function(){var b=this.buffer,a,c=b.length,d=new (B?Uint8Array:Array)(c<<1);if(B)d.set(b);else for(a=0;a<c;++a)d[a]=b[a];return this.buffer=d};\nF.prototype.d=function(b,a,c){var d=this.buffer,f=this.index,e=this.m,g=d[f],k;c&&1<a&&(b=8<a?(H[b&255]<<24|H[b>>>8&255]<<16|H[b>>>16&255]<<8|H[b>>>24&255])>>32-a:H[b]>>8-a);if(8>a+e)g=g<<a|b,e+=a;else for(k=0;k<a;++k)g=g<<1|b>>a-k-1&1,8===++e&&(e=0,d[f++]=H[g],g=0,f===d.length&&(d=this.f()));d[f]=g;this.buffer=d;this.m=e;this.index=f};F.prototype.finish=function(){var b=this.buffer,a=this.index,c;0<this.m&&(b[a]<<=8-this.m,b[a]=H[b[a]],a++);B?c=b.subarray(0,a):(b.length=a,c=b);return c};\nvar ba=new (B?Uint8Array:Array)(256),ca;for(ca=0;256>ca;++ca){for(var K=ca,da=K,ea=7,K=K>>>1;K;K>>>=1)da<<=1,da|=K&1,--ea;ba[ca]=(da<<ea&255)>>>0}var H=ba;function ja(b,a,c){var d,f=\"number\"===typeof a?a:a=0,e=\"number\"===typeof c?c:b.length;d=-1;for(f=e&7;f--;++a)d=d>>>8^O[(d^b[a])&255];for(f=e>>3;f--;a+=8)d=d>>>8^O[(d^b[a])&255],d=d>>>8^O[(d^b[a+1])&255],d=d>>>8^O[(d^b[a+2])&255],d=d>>>8^O[(d^b[a+3])&255],d=d>>>8^O[(d^b[a+4])&255],d=d>>>8^O[(d^b[a+5])&255],d=d>>>8^O[(d^b[a+6])&255],d=d>>>8^O[(d^b[a+7])&255];return(d^4294967295)>>>0}\nvar ka=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,\n2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,\n2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,\n2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,\n3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,\n936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],O=B?new Uint32Array(ka):ka;function P(){}P.prototype.getName=function(){return this.name};P.prototype.getData=function(){return this.data};P.prototype.X=function(){return this.Y};A(\"Zlib.GunzipMember\",P);A(\"Zlib.GunzipMember.prototype.getName\",P.prototype.getName);A(\"Zlib.GunzipMember.prototype.getData\",P.prototype.getData);A(\"Zlib.GunzipMember.prototype.getMtime\",P.prototype.X);function la(b){this.buffer=new (B?Uint16Array:Array)(2*b);this.length=0}la.prototype.getParent=function(b){return 2*((b-2)/4|0)};la.prototype.push=function(b,a){var c,d,f=this.buffer,e;c=this.length;f[this.length++]=a;for(f[this.length++]=b;0<c;)if(d=this.getParent(c),f[c]>f[d])e=f[c],f[c]=f[d],f[d]=e,e=f[c+1],f[c+1]=f[d+1],f[d+1]=e,c=d;else break;return this.length};\nla.prototype.pop=function(){var b,a,c=this.buffer,d,f,e;a=c[0];b=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(e=0;;){f=2*e+2;if(f>=this.length)break;f+2<this.length&&c[f+2]>c[f]&&(f+=2);if(c[f]>c[e])d=c[e],c[e]=c[f],c[f]=d,d=c[e+1],c[e+1]=c[f+1],c[f+1]=d;else break;e=f}return{index:b,value:a,length:this.length}};function ma(b){var a=b.length,c=0,d=Number.POSITIVE_INFINITY,f,e,g,k,h,l,s,n,m;for(n=0;n<a;++n)b[n]>c&&(c=b[n]),b[n]<d&&(d=b[n]);f=1<<c;e=new (B?Uint32Array:Array)(f);g=1;k=0;for(h=2;g<=c;){for(n=0;n<a;++n)if(b[n]===g){l=0;s=k;for(m=0;m<g;++m)l=l<<1|s&1,s>>=1;for(m=l;m<f;m+=h)e[m]=g<<16|n;++k}++g;k<<=1;h<<=1}return[e,c,d]};function na(b,a){this.k=qa;this.I=0;this.input=B&&b instanceof Array?new Uint8Array(b):b;this.b=0;a&&(a.lazy&&(this.I=a.lazy),\"number\"===typeof a.compressionType&&(this.k=a.compressionType),a.outputBuffer&&(this.a=B&&a.outputBuffer instanceof Array?new Uint8Array(a.outputBuffer):a.outputBuffer),\"number\"===typeof a.outputIndex&&(this.b=a.outputIndex));this.a||(this.a=new (B?Uint8Array:Array)(32768))}var qa=2,ra={NONE:0,v:1,o:qa,aa:3},sa=[],S;\nfor(S=0;288>S;S++)switch(u){case 143>=S:sa.push([S+48,8]);break;case 255>=S:sa.push([S-144+400,9]);break;case 279>=S:sa.push([S-256+0,7]);break;case 287>=S:sa.push([S-280+192,8]);break;default:q(\"invalid literal: \"+S)}\nna.prototype.g=function(){var b,a,c,d,f=this.input;switch(this.k){case 0:c=0;for(d=f.length;c<d;){a=B?f.subarray(c,c+65535):f.slice(c,c+65535);c+=a.length;var e=a,g=c===d,k=t,h=t,l=t,s=t,n=t,m=this.a,p=this.b;if(B){for(m=new Uint8Array(this.a.buffer);m.length<=p+e.length+5;)m=new Uint8Array(m.length<<1);m.set(this.a)}k=g?1:0;m[p++]=k|0;h=e.length;l=~h+65536&65535;m[p++]=h&255;m[p++]=h>>>8&255;m[p++]=l&255;m[p++]=l>>>8&255;if(B)m.set(e,p),p+=e.length,m=m.subarray(0,p);else{s=0;for(n=e.length;s<n;++s)m[p++]=\ne[s];m.length=p}this.b=p;this.a=m}break;case 1:var r=new F(B?new Uint8Array(this.a.buffer):this.a,this.b);r.d(1,1,u);r.d(1,2,u);var v=ta(this,f),x,Q,y;x=0;for(Q=v.length;x<Q;x++)if(y=v[x],F.prototype.d.apply(r,sa[y]),256<y)r.d(v[++x],v[++x],u),r.d(v[++x],5),r.d(v[++x],v[++x],u);else if(256===y)break;this.a=r.finish();this.b=this.a.length;break;case qa:var E=new F(B?new Uint8Array(this.a.buffer):this.a,this.b),Ja,R,X,Y,Z,pb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa,Ka,ga,La,oa,wa=Array(19),\nMa,$,pa,C,Na;Ja=qa;E.d(1,1,u);E.d(Ja,2,u);R=ta(this,f);fa=ua(this.V,15);Ka=va(fa);ga=ua(this.U,7);La=va(ga);for(X=286;257<X&&0===fa[X-1];X--);for(Y=30;1<Y&&0===ga[Y-1];Y--);var Oa=X,Pa=Y,J=new (B?Uint32Array:Array)(Oa+Pa),w,L,z,ha,I=new (B?Uint32Array:Array)(316),G,D,M=new (B?Uint8Array:Array)(19);for(w=L=0;w<Oa;w++)J[L++]=fa[w];for(w=0;w<Pa;w++)J[L++]=ga[w];if(!B){w=0;for(ha=M.length;w<ha;++w)M[w]=0}w=G=0;for(ha=J.length;w<ha;w+=L){for(L=1;w+L<ha&&J[w+L]===J[w];++L);z=L;if(0===J[w])if(3>z)for(;0<\nz--;)I[G++]=0,M[0]++;else for(;0<z;)D=138>z?z:138,D>z-3&&D<z&&(D=z-3),10>=D?(I[G++]=17,I[G++]=D-3,M[17]++):(I[G++]=18,I[G++]=D-11,M[18]++),z-=D;else if(I[G++]=J[w],M[J[w]]++,z--,3>z)for(;0<z--;)I[G++]=J[w],M[J[w]]++;else for(;0<z;)D=6>z?z:6,D>z-3&&D<z&&(D=z-3),I[G++]=16,I[G++]=D-3,M[16]++,z-=D}b=B?I.subarray(0,G):I.slice(0,G);oa=ua(M,7);for(C=0;19>C;C++)wa[C]=oa[pb[C]];for(Z=19;4<Z&&0===wa[Z-1];Z--);Ma=va(oa);E.d(X-257,5,u);E.d(Y-1,5,u);E.d(Z-4,4,u);for(C=0;C<Z;C++)E.d(wa[C],3,u);C=0;for(Na=b.length;C<\nNa;C++)if($=b[C],E.d(Ma[$],oa[$],u),16<=$){C++;switch($){case 16:pa=2;break;case 17:pa=3;break;case 18:pa=7;break;default:q(\"invalid code: \"+$)}E.d(b[C],pa,u)}var Qa=[Ka,fa],Ra=[La,ga],N,Sa,ia,za,Ta,Ua,Va,Wa;Ta=Qa[0];Ua=Qa[1];Va=Ra[0];Wa=Ra[1];N=0;for(Sa=R.length;N<Sa;++N)if(ia=R[N],E.d(Ta[ia],Ua[ia],u),256<ia)E.d(R[++N],R[++N],u),za=R[++N],E.d(Va[za],Wa[za],u),E.d(R[++N],R[++N],u);else if(256===ia)break;this.a=E.finish();this.b=this.a.length;break;default:q(\"invalid compression type\")}return this.a};\nfunction xa(b,a){this.length=b;this.P=a}\nvar ya=function(){function b(a){switch(u){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,\na-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:q(\"invalid length: \"+a)}}var a=[],c,d;for(c=3;258>=c;c++)d=b(c),a[c]=d[2]<<24|d[1]<<\n16|d[0];return a}(),Aa=B?new Uint32Array(ya):ya;\nfunction ta(b,a){function c(a,c){var b=a.P,d=[],e=0,f;f=Aa[a.length];d[e++]=f&65535;d[e++]=f>>16&255;d[e++]=f>>24;var g;switch(u){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===b:g=[3,b-4,0];break;case 6>=b:g=[4,b-5,1];break;case 8>=b:g=[5,b-7,1];break;case 12>=b:g=[6,b-9,2];break;case 16>=b:g=[7,b-13,2];break;case 24>=b:g=[8,b-17,3];break;case 32>=b:g=[9,b-25,3];break;case 48>=b:g=[10,b-33,4];break;case 64>=b:g=[11,b-49,4];break;case 96>=b:g=[12,b-\n65,5];break;case 128>=b:g=[13,b-97,5];break;case 192>=b:g=[14,b-129,6];break;case 256>=b:g=[15,b-193,6];break;case 384>=b:g=[16,b-257,7];break;case 512>=b:g=[17,b-385,7];break;case 768>=b:g=[18,b-513,8];break;case 1024>=b:g=[19,b-769,8];break;case 1536>=b:g=[20,b-1025,9];break;case 2048>=b:g=[21,b-1537,9];break;case 3072>=b:g=[22,b-2049,10];break;case 4096>=b:g=[23,b-3073,10];break;case 6144>=b:g=[24,b-4097,11];break;case 8192>=b:g=[25,b-6145,11];break;case 12288>=b:g=[26,b-8193,12];break;case 16384>=\nb:g=[27,b-12289,12];break;case 24576>=b:g=[28,b-16385,13];break;case 32768>=b:g=[29,b-24577,13];break;default:q(\"invalid distance\")}f=g;d[e++]=f[0];d[e++]=f[1];d[e++]=f[2];var h,k;h=0;for(k=d.length;h<k;++h)m[p++]=d[h];v[d[0]]++;x[d[3]]++;r=a.length+c-1;n=null}var d,f,e,g,k,h={},l,s,n,m=B?new Uint16Array(2*a.length):[],p=0,r=0,v=new (B?Uint32Array:Array)(286),x=new (B?Uint32Array:Array)(30),Q=b.I,y;if(!B){for(e=0;285>=e;)v[e++]=0;for(e=0;29>=e;)x[e++]=0}v[256]=1;d=0;for(f=a.length;d<f;++d){e=k=0;\nfor(g=3;e<g&&d+e!==f;++e)k=k<<8|a[d+e];h[k]===t&&(h[k]=[]);l=h[k];if(!(0<r--)){for(;0<l.length&&32768<d-l[0];)l.shift();if(d+3>=f){n&&c(n,-1);e=0;for(g=f-d;e<g;++e)y=a[d+e],m[p++]=y,++v[y];break}0<l.length?(s=Ba(a,d,l),n?n.length<s.length?(y=a[d-1],m[p++]=y,++v[y],c(s,0)):c(n,-1):s.length<Q?n=s:c(s,0)):n?c(n,-1):(y=a[d],m[p++]=y,++v[y])}l.push(d)}m[p++]=256;v[256]++;b.V=v;b.U=x;return B?m.subarray(0,p):m}\nfunction Ba(b,a,c){var d,f,e=0,g,k,h,l,s=b.length;k=0;l=c.length;a:for(;k<l;k++){d=c[l-k-1];g=3;if(3<e){for(h=e;3<h;h--)if(b[d+h-1]!==b[a+h-1])continue a;g=e}for(;258>g&&a+g<s&&b[d+g]===b[a+g];)++g;g>e&&(f=d,e=g);if(258===g)break}return new xa(e,a-f)}\nfunction ua(b,a){var c=b.length,d=new la(572),f=new (B?Uint8Array:Array)(c),e,g,k,h,l;if(!B)for(h=0;h<c;h++)f[h]=0;for(h=0;h<c;++h)0<b[h]&&d.push(h,b[h]);e=Array(d.length/2);g=new (B?Uint32Array:Array)(d.length/2);if(1===e.length)return f[d.pop().index]=1,f;h=0;for(l=d.length/2;h<l;++h)e[h]=d.pop(),g[h]=e[h].value;k=Ca(g,g.length,a);h=0;for(l=e.length;h<l;++h)f[e[h].index]=k[h];return f}\nfunction Ca(b,a,c){function d(b){var c=h[b][l[b]];c===a?(d(b+1),d(b+1)):--g[c];++l[b]}var f=new (B?Uint16Array:Array)(c),e=new (B?Uint8Array:Array)(c),g=new (B?Uint8Array:Array)(a),k=Array(c),h=Array(c),l=Array(c),s=(1<<c)-a,n=1<<c-1,m,p,r,v,x;f[c-1]=a;for(p=0;p<c;++p)s<n?e[p]=0:(e[p]=1,s-=n),s<<=1,f[c-2-p]=(f[c-1-p]/2|0)+a;f[0]=e[0];k[0]=Array(f[0]);h[0]=Array(f[0]);for(p=1;p<c;++p)f[p]>2*f[p-1]+e[p]&&(f[p]=2*f[p-1]+e[p]),k[p]=Array(f[p]),h[p]=Array(f[p]);for(m=0;m<a;++m)g[m]=c;for(r=0;r<f[c-1];++r)k[c-\n1][r]=b[r],h[c-1][r]=r;for(m=0;m<c;++m)l[m]=0;1===e[c-1]&&(--g[0],++l[c-1]);for(p=c-2;0<=p;--p){v=m=0;x=l[p+1];for(r=0;r<f[p];r++)v=k[p+1][x]+k[p+1][x+1],v>b[m]?(k[p][r]=v,h[p][r]=a,x+=2):(k[p][r]=b[m],h[p][r]=m,++m);l[p]=0;1===e[p]&&d(p)}return g}\nfunction va(b){var a=new (B?Uint16Array:Array)(b.length),c=[],d=[],f=0,e,g,k,h;e=0;for(g=b.length;e<g;e++)c[b[e]]=(c[b[e]]|0)+1;e=1;for(g=16;e<=g;e++)d[e]=f,f+=c[e]|0,f<<=1;e=0;for(g=b.length;e<g;e++){f=d[b[e]];d[b[e]]+=1;k=a[e]=0;for(h=b[e];k<h;k++)a[e]=a[e]<<1|f&1,f>>>=1}return a};function Da(b,a){this.input=b;this.b=this.c=0;this.i={};a&&(a.flags&&(this.i=a.flags),\"string\"===typeof a.filename&&(this.filename=a.filename),\"string\"===typeof a.comment&&(this.A=a.comment),a.deflateOptions&&(this.l=a.deflateOptions));this.l||(this.l={})}\nDa.prototype.g=function(){var b,a,c,d,f,e,g,k,h=new (B?Uint8Array:Array)(32768),l=0,s=this.input,n=this.c,m=this.filename,p=this.A;h[l++]=31;h[l++]=139;h[l++]=8;b=0;this.i.fname&&(b|=Ea);this.i.fcomment&&(b|=Fa);this.i.fhcrc&&(b|=Ga);h[l++]=b;a=(Date.now?Date.now():+new Date)/1E3|0;h[l++]=a&255;h[l++]=a>>>8&255;h[l++]=a>>>16&255;h[l++]=a>>>24&255;h[l++]=0;h[l++]=Ha;if(this.i.fname!==t){g=0;for(k=m.length;g<k;++g)e=m.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}if(this.i.comment){g=\n0;for(k=p.length;g<k;++g)e=p.charCodeAt(g),255<e&&(h[l++]=e>>>8&255),h[l++]=e&255;h[l++]=0}this.i.fhcrc&&(c=ja(h,0,l)&65535,h[l++]=c&255,h[l++]=c>>>8&255);this.l.outputBuffer=h;this.l.outputIndex=l;f=new na(s,this.l);h=f.g();l=f.b;B&&(l+8>h.buffer.byteLength?(this.a=new Uint8Array(l+8),this.a.set(new Uint8Array(h.buffer)),h=this.a):h=new Uint8Array(h.buffer));d=ja(s,t,t);h[l++]=d&255;h[l++]=d>>>8&255;h[l++]=d>>>16&255;h[l++]=d>>>24&255;k=s.length;h[l++]=k&255;h[l++]=k>>>8&255;h[l++]=k>>>16&255;h[l++]=\nk>>>24&255;this.c=n;B&&l<h.length&&(this.a=h=h.subarray(0,l));return h};var Ha=255,Ga=2,Ea=8,Fa=16;A(\"Zlib.Gzip\",Da);A(\"Zlib.Gzip.prototype.compress\",Da.prototype.g);function T(b,a){this.p=[];this.q=32768;this.e=this.j=this.c=this.u=0;this.input=B?new Uint8Array(b):b;this.w=!1;this.r=Ia;this.L=!1;if(a||!(a={}))a.index&&(this.c=a.index),a.bufferSize&&(this.q=a.bufferSize),a.bufferType&&(this.r=a.bufferType),a.resize&&(this.L=a.resize);switch(this.r){case Xa:this.b=32768;this.a=new (B?Uint8Array:Array)(32768+this.q+258);break;case Ia:this.b=0;this.a=new (B?Uint8Array:Array)(this.q);this.f=this.T;this.B=this.Q;this.s=this.S;break;default:q(Error(\"invalid inflate mode\"))}}\nvar Xa=0,Ia=1,Ya={N:Xa,M:Ia};\nT.prototype.h=function(){for(;!this.w;){var b=U(this,3);b&1&&(this.w=u);b>>>=1;switch(b){case 0:var a=this.input,c=this.c,d=this.a,f=this.b,e=t,g=t,k=t,h=d.length,l=t;this.e=this.j=0;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (first byte)\"));g=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: LEN (second byte)\"));g|=e<<8;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (first byte)\"));k=e;e=a[c++];e===t&&q(Error(\"invalid uncompressed block header: NLEN (second byte)\"));k|=\ne<<8;g===~k&&q(Error(\"invalid uncompressed block header: length verify\"));c+g>a.length&&q(Error(\"input buffer is broken\"));switch(this.r){case Xa:for(;f+g>d.length;){l=h-f;g-=l;if(B)d.set(a.subarray(c,c+l),f),f+=l,c+=l;else for(;l--;)d[f++]=a[c++];this.b=f;d=this.f();f=this.b}break;case Ia:for(;f+g>d.length;)d=this.f({F:2});break;default:q(Error(\"invalid inflate mode\"))}if(B)d.set(a.subarray(c,c+g),f),f+=g,c+=g;else for(;g--;)d[f++]=a[c++];this.c=c;this.b=f;this.a=d;break;case 1:this.s(Za,$a);break;\ncase 2:ab(this);break;default:q(Error(\"unknown BTYPE: \"+b))}}return this.B()};\nvar bb=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],cb=B?new Uint16Array(bb):bb,db=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],eb=B?new Uint16Array(db):db,fb=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],gb=B?new Uint8Array(fb):fb,hb=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ib=B?new Uint16Array(hb):hb,jb=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,\n10,11,11,12,12,13,13],kb=B?new Uint8Array(jb):jb,lb=new (B?Uint8Array:Array)(288),V,mb;V=0;for(mb=lb.length;V<mb;++V)lb[V]=143>=V?8:255>=V?9:279>=V?7:8;var Za=ma(lb),nb=new (B?Uint8Array:Array)(30),ob,qb;ob=0;for(qb=nb.length;ob<qb;++ob)nb[ob]=5;var $a=ma(nb);function U(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g;d<a;)g=f[e++],g===t&&q(Error(\"input buffer is broken\")),c|=g<<d,d+=8;g=c&(1<<a)-1;b.j=c>>>a;b.e=d-a;b.c=e;return g}\nfunction rb(b,a){for(var c=b.j,d=b.e,f=b.input,e=b.c,g=a[0],k=a[1],h,l,s;d<k;){h=f[e++];if(h===t)break;c|=h<<d;d+=8}l=g[c&(1<<k)-1];s=l>>>16;b.j=c>>s;b.e=d-s;b.c=e;return l&65535}\nfunction ab(b){function a(a,b,c){var d,e,f,g;for(g=0;g<a;)switch(d=rb(this,b),d){case 16:for(f=3+U(this,2);f--;)c[g++]=e;break;case 17:for(f=3+U(this,3);f--;)c[g++]=0;e=0;break;case 18:for(f=11+U(this,7);f--;)c[g++]=0;e=0;break;default:e=c[g++]=d}return c}var c=U(b,5)+257,d=U(b,5)+1,f=U(b,4)+4,e=new (B?Uint8Array:Array)(cb.length),g,k,h,l;for(l=0;l<f;++l)e[cb[l]]=U(b,3);g=ma(e);k=new (B?Uint8Array:Array)(c);h=new (B?Uint8Array:Array)(d);b.s(ma(a.call(b,c,g,k)),ma(a.call(b,d,g,h)))}\nT.prototype.s=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length-258,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(this.b=d,c=this.f(),d=this.b),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d>=f&&(this.b=d,c=this.f(),d=this.b);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.S=function(b,a){var c=this.a,d=this.b;this.C=b;for(var f=c.length,e,g,k,h;256!==(e=rb(this,b));)if(256>e)d>=f&&(c=this.f(),f=c.length),c[d++]=e;else{g=e-257;h=eb[g];0<gb[g]&&(h+=U(this,gb[g]));e=rb(this,a);k=ib[e];0<kb[e]&&(k+=U(this,kb[e]));d+h>f&&(c=this.f(),f=c.length);for(;h--;)c[d]=c[d++-k]}for(;8<=this.e;)this.e-=8,this.c--;this.b=d};\nT.prototype.f=function(){var b=new (B?Uint8Array:Array)(this.b-32768),a=this.b-32768,c,d,f=this.a;if(B)b.set(f.subarray(32768,b.length));else{c=0;for(d=b.length;c<d;++c)b[c]=f[c+32768]}this.p.push(b);this.u+=b.length;if(B)f.set(f.subarray(a,a+32768));else for(c=0;32768>c;++c)f[c]=f[a+c];this.b=32768;return f};\nT.prototype.T=function(b){var a,c=this.input.length/this.c+1|0,d,f,e,g=this.input,k=this.a;b&&(\"number\"===typeof b.F&&(c=b.F),\"number\"===typeof b.O&&(c+=b.O));2>c?(d=(g.length-this.c)/this.C[2],e=258*(d/2)|0,f=e<k.length?k.length+e:k.length<<1):f=k.length*c;B?(a=new Uint8Array(f),a.set(k)):a=k;return this.a=a};\nT.prototype.B=function(){var b=0,a=this.a,c=this.p,d,f=new (B?Uint8Array:Array)(this.u+(this.b-32768)),e,g,k,h;if(0===c.length)return B?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);e=0;for(g=c.length;e<g;++e){d=c[e];k=0;for(h=d.length;k<h;++k)f[b++]=d[k]}e=32768;for(g=this.b;e<g;++e)f[b++]=a[e];this.p=[];return this.buffer=f};\nT.prototype.Q=function(){var b,a=this.b;B?this.L?(b=new Uint8Array(a),b.set(this.a.subarray(0,a))):b=this.a.subarray(0,a):(this.a.length>a&&(this.a.length=a),b=this.a);return this.buffer=b};function sb(b){this.input=b;this.c=0;this.t=[];this.D=!1}sb.prototype.W=function(){this.D||this.h();return this.t.slice()};\nsb.prototype.h=function(){for(var b=this.input.length;this.c<b;){var a=new P,c=t,d=t,f=t,e=t,g=t,k=t,h=t,l=t,s=t,n=this.input,m=this.c;a.G=n[m++];a.H=n[m++];(31!==a.G||139!==a.H)&&q(Error(\"invalid file signature:\"+a.G+\",\"+a.H));a.z=n[m++];switch(a.z){case 8:break;default:q(Error(\"unknown compression method: \"+a.z))}a.n=n[m++];l=n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24;a.Y=new Date(1E3*l);a.ea=n[m++];a.da=n[m++];0<(a.n&4)&&(a.$=n[m++]|n[m++]<<8,m+=a.$);if(0<(a.n&Ea)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=\nString.fromCharCode(g);a.name=h.join(\"\")}if(0<(a.n&Fa)){h=[];for(k=0;0<(g=n[m++]);)h[k++]=String.fromCharCode(g);a.A=h.join(\"\")}0<(a.n&Ga)&&(a.R=ja(n,0,m)&65535,a.R!==(n[m++]|n[m++]<<8)&&q(Error(\"invalid header crc16\")));c=n[n.length-4]|n[n.length-3]<<8|n[n.length-2]<<16|n[n.length-1]<<24;n.length-m-4-4<512*c&&(e=c);d=new T(n,{index:m,bufferSize:e});a.data=f=d.h();m=d.c;a.ba=s=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;ja(f,t,t)!==s&&q(Error(\"invalid CRC-32 checksum: 0x\"+ja(f,t,t).toString(16)+\n\" / 0x\"+s.toString(16)));a.ca=c=(n[m++]|n[m++]<<8|n[m++]<<16|n[m++]<<24)>>>0;(f.length&4294967295)!==c&&q(Error(\"invalid input size: \"+(f.length&4294967295)+\" / \"+c));this.t.push(a);this.c=m}this.D=u;var p=this.t,r,v,x=0,Q=0,y;r=0;for(v=p.length;r<v;++r)Q+=p[r].data.length;if(B){y=new Uint8Array(Q);for(r=0;r<v;++r)y.set(p[r].data,x),x+=p[r].data.length}else{y=[];for(r=0;r<v;++r)y[r]=p[r].data;y=Array.prototype.concat.apply([],y)}return y};A(\"Zlib.Gunzip\",sb);A(\"Zlib.Gunzip.prototype.decompress\",sb.prototype.h);A(\"Zlib.Gunzip.prototype.getMembers\",sb.prototype.W);function tb(b){if(\"string\"===typeof b){var a=b.split(\"\"),c,d;c=0;for(d=a.length;c<d;c++)a[c]=(a[c].charCodeAt(0)&255)>>>0;b=a}for(var f=1,e=0,g=b.length,k,h=0;0<g;){k=1024<g?1024:g;g-=k;do f+=b[h++],e+=f;while(--k);f%=65521;e%=65521}return(e<<16|f)>>>0};function ub(b,a){var c,d;this.input=b;this.c=0;if(a||!(a={}))a.index&&(this.c=a.index),a.verify&&(this.Z=a.verify);c=b[this.c++];d=b[this.c++];switch(c&15){case vb:this.method=vb;break;default:q(Error(\"unsupported compression method\"))}0!==((c<<8)+d)%31&&q(Error(\"invalid fcheck flag:\"+((c<<8)+d)%31));d&32&&q(Error(\"fdict flag is not supported\"));this.K=new T(b,{index:this.c,bufferSize:a.bufferSize,bufferType:a.bufferType,resize:a.resize})}\nub.prototype.h=function(){var b=this.input,a,c;a=this.K.h();this.c=this.K.c;this.Z&&(c=(b[this.c++]<<24|b[this.c++]<<16|b[this.c++]<<8|b[this.c++])>>>0,c!==tb(a)&&q(Error(\"invalid adler-32 checksum\")));return a};var vb=8;function wb(b,a){this.input=b;this.a=new (B?Uint8Array:Array)(32768);this.k=W.o;var c={},d;if((a||!(a={}))&&\"number\"===typeof a.compressionType)this.k=a.compressionType;for(d in a)c[d]=a[d];c.outputBuffer=this.a;this.J=new na(this.input,c)}var W=ra;\nwb.prototype.g=function(){var b,a,c,d,f,e,g,k=0;g=this.a;b=vb;switch(b){case vb:a=Math.LOG2E*Math.log(32768)-8;break;default:q(Error(\"invalid compression method\"))}c=a<<4|b;g[k++]=c;switch(b){case vb:switch(this.k){case W.NONE:f=0;break;case W.v:f=1;break;case W.o:f=2;break;default:q(Error(\"unsupported compression type\"))}break;default:q(Error(\"invalid compression method\"))}d=f<<6|0;g[k++]=d|31-(256*c+d)%31;e=tb(this.input);this.J.b=k;g=this.J.g();k=g.length;B&&(g=new Uint8Array(g.buffer),g.length<=\nk+4&&(this.a=new Uint8Array(g.length+4),this.a.set(g),g=this.a),g=g.subarray(0,k+4));g[k++]=e>>24&255;g[k++]=e>>16&255;g[k++]=e>>8&255;g[k++]=e&255;return g};function xb(b,a){var c,d,f,e;if(Object.keys)c=Object.keys(a);else for(d in c=[],f=0,a)c[f++]=d;f=0;for(e=c.length;f<e;++f)d=c[f],A(b+\".\"+d,a[d])};A(\"Zlib.Inflate\",ub);A(\"Zlib.Inflate.prototype.decompress\",ub.prototype.h);xb(\"Zlib.Inflate.BufferType\",{ADAPTIVE:Ya.M,BLOCK:Ya.N});A(\"Zlib.Deflate\",wb);A(\"Zlib.Deflate.compress\",function(b,a){return(new wb(b,a)).g()});A(\"Zlib.Deflate.prototype.compress\",wb.prototype.g);xb(\"Zlib.Deflate.CompressionType\",{NONE:W.NONE,FIXED:W.v,DYNAMIC:W.o});}).call(this); //@ sourceMappingURL=zlib_and_gzip.min.js.map\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmVuZG9yL3psaWJfYW5kX2d6aXAubWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3ZlbmRvci96bGliX2FuZF9nemlwLm1pbi5qcz81NmRmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSB6bGliLmpzIDIwMTIgLSBpbWF5YSBbIGh0dHBzOi8vZ2l0aHViLmNvbS9pbWF5YS96bGliLmpzIF0gVGhlIE1JVCBMaWNlbnNlICovKGZ1bmN0aW9uKCkgeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBxKGIpe3Rocm93IGI7fXZhciB0PXZvaWQgMCx1PSEwLGFhPXRoaXM7ZnVuY3Rpb24gQShiLGEpe3ZhciBjPWIuc3BsaXQoXCIuXCIpLGQ9YWE7IShjWzBdaW4gZCkmJmQuZXhlY1NjcmlwdCYmZC5leGVjU2NyaXB0KFwidmFyIFwiK2NbMF0pO2Zvcih2YXIgZjtjLmxlbmd0aCYmKGY9Yy5zaGlmdCgpKTspIWMubGVuZ3RoJiZhIT09dD9kW2ZdPWE6ZD1kW2ZdP2RbZl06ZFtmXT17fX07dmFyIEI9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBVaW50OEFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQxNkFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQzMkFycmF5O2Z1bmN0aW9uIEYoYixhKXt0aGlzLmluZGV4PVwibnVtYmVyXCI9PT10eXBlb2YgYT9hOjA7dGhpcy5tPTA7dGhpcy5idWZmZXI9YiBpbnN0YW5jZW9mKEI/VWludDhBcnJheTpBcnJheSk/YjpuZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpOzIqdGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZxKEVycm9yKFwiaW52YWxpZCBpbmRleFwiKSk7dGhpcy5idWZmZXIubGVuZ3RoPD10aGlzLmluZGV4JiZ0aGlzLmYoKX1GLnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYSxjPWIubGVuZ3RoLGQ9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGM8PDEpO2lmKEIpZC5zZXQoYik7ZWxzZSBmb3IoYT0wO2E8YzsrK2EpZFthXT1iW2FdO3JldHVybiB0aGlzLmJ1ZmZlcj1kfTtcbkYucHJvdG90eXBlLmQ9ZnVuY3Rpb24oYixhLGMpe3ZhciBkPXRoaXMuYnVmZmVyLGY9dGhpcy5pbmRleCxlPXRoaXMubSxnPWRbZl0saztjJiYxPGEmJihiPTg8YT8oSFtiJjI1NV08PDI0fEhbYj4+PjgmMjU1XTw8MTZ8SFtiPj4+MTYmMjU1XTw8OHxIW2I+Pj4yNCYyNTVdKT4+MzItYTpIW2JdPj44LWEpO2lmKDg+YStlKWc9Zzw8YXxiLGUrPWE7ZWxzZSBmb3Ioaz0wO2s8YTsrK2spZz1nPDwxfGI+PmEtay0xJjEsOD09PSsrZSYmKGU9MCxkW2YrK109SFtnXSxnPTAsZj09PWQubGVuZ3RoJiYoZD10aGlzLmYoKSkpO2RbZl09Zzt0aGlzLmJ1ZmZlcj1kO3RoaXMubT1lO3RoaXMuaW5kZXg9Zn07Ri5wcm90b3R5cGUuZmluaXNoPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5idWZmZXIsYT10aGlzLmluZGV4LGM7MDx0aGlzLm0mJihiW2FdPDw9OC10aGlzLm0sYlthXT1IW2JbYV1dLGErKyk7Qj9jPWIuc3ViYXJyYXkoMCxhKTooYi5sZW5ndGg9YSxjPWIpO3JldHVybiBjfTtcbnZhciBiYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjU2KSxjYTtmb3IoY2E9MDsyNTY+Y2E7KytjYSl7Zm9yKHZhciBLPWNhLGRhPUssZWE9NyxLPUs+Pj4xO0s7Sz4+Pj0xKWRhPDw9MSxkYXw9SyYxLC0tZWE7YmFbY2FdPShkYTw8ZWEmMjU1KT4+PjB9dmFyIEg9YmE7ZnVuY3Rpb24gamEoYixhLGMpe3ZhciBkLGY9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E6YT0wLGU9XCJudW1iZXJcIj09PXR5cGVvZiBjP2M6Yi5sZW5ndGg7ZD0tMTtmb3IoZj1lJjc7Zi0tOysrYSlkPWQ+Pj44Xk9bKGReYlthXSkmMjU1XTtmb3IoZj1lPj4zO2YtLTthKz04KWQ9ZD4+PjheT1soZF5iW2FdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErMV0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSsyXSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzNdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErNF0pJjI1NV0sZD1kPj4+OF5PWyhkXmJbYSs1XSkmMjU1XSxkPWQ+Pj44Xk9bKGReYlthKzZdKSYyNTVdLGQ9ZD4+PjheT1soZF5iW2ErN10pJjI1NV07cmV0dXJuKGReNDI5NDk2NzI5NSk+Pj4wfVxudmFyIGthPVswLDE5OTY5NTk4OTQsMzk5MzkxOTc4OCwyNTY3NTI0Nzk0LDEyNDYzNDEzNywxODg2MDU3NjE1LDM5MTU2MjE2ODUsMjY1NzM5MjAzNSwyNDkyNjgyNzQsMjA0NDUwODMyNCwzNzcyMTE1MjMwLDI1NDcxNzc4NjQsMTYyOTQxOTk1LDIxMjU1NjEwMjEsMzg4NzYwNzA0NywyNDI4NDQ0MDQ5LDQ5ODUzNjU0OCwxNzg5OTI3NjY2LDQwODkwMTY2NDgsMjIyNzA2MTIxNCw0NTA1NDg4NjEsMTg0MzI1ODYwMyw0MTA3NTgwNzUzLDIyMTE2Nzc2MzksMzI1ODgzOTkwLDE2ODQ3NzcxNTIsNDI1MTEyMjA0MiwyMzIxOTI2NjM2LDMzNTYzMzQ4NywxNjYxMzY1NDY1LDQxOTUzMDI3NTUsMjM2NjExNTMxNyw5OTcwNzMwOTYsMTI4MTk1Mzg4NiwzNTc5ODU1MzMyLDI3MjQ2ODgyNDIsMTAwNjg4ODE0NSwxMjU4NjA3Njg3LDM1MjQxMDE2MjksMjc2ODk0MjQ0Myw5MDEwOTc3MjIsMTExOTAwMDY4NCwzNjg2NTE3MjA2LDI4OTgwNjU3MjgsODUzMDQ0NDUxLDExNzIyNjYxMDEsMzcwNTAxNTc1OSxcbjI4ODI2MTY2NjUsNjUxNzY3OTgwLDEzNzM1MDM1NDYsMzM2OTU1NDMwNCwzMjE4MTA0NTk4LDU2NTUwNzI1MywxNDU0NjIxNzMxLDM0ODUxMTE3MDUsMzA5OTQzNjMwMyw2NzEyNjY5NzQsMTU5NDE5ODAyNCwzMzIyNzMwOTMwLDI5NzAzNDc4MTIsNzk1ODM1NTI3LDE0ODMyMzAyMjUsMzI0NDM2NzI3NSwzMDYwMTQ5NTY1LDE5OTQxNDYxOTIsMzExNTg1MzQsMjU2MzkwNzc3Miw0MDIzNzE3OTMwLDE5MDc0NTk0NjUsMTEyNjM3MjE1LDI2ODAxNTMyNTMsMzkwNDQyNzA1OSwyMDEzNzc2MjkwLDI1MTcyMjAzNiwyNTE3MjE1Mzc0LDM3NzU4MzAwNDAsMjEzNzY1Njc2MywxNDEzNzY4MTMsMjQzOTI3NzcxOSwzODY1MjcxMjk3LDE4MDIxOTU0NDQsNDc2ODY0ODY2LDIyMzgwMDEzNjgsNDA2NjUwODg3OCwxODEyMzcwOTI1LDQ1MzA5MjczMSwyMTgxNjI1MDI1LDQxMTE0NTEyMjMsMTcwNjA4ODkwMiwzMTQwNDI3MDQsMjM0NDUzMjIwMiw0MjQwMDE3NTMyLDE2NTg2NTgyNzEsMzY2NjE5OTc3LFxuMjM2MjY3MDMyMyw0MjI0OTk0NDA1LDEzMDM1MzU5NjAsOTg0OTYxNDg2LDI3NDcwMDcwOTIsMzU2OTAzNzUzOCwxMjU2MTcwODE3LDEwMzc2MDQzMTEsMjc2NTIxMDczMywzNTU0MDc5OTk1LDExMzEwMTQ1MDYsODc5Njc5OTk2LDI5MDkyNDM0NjIsMzY2Mzc3MTg1NiwxMTQxMTI0NDY3LDg1NTg0MjI3NywyODUyODAxNjMxLDM3MDg2NDg2NDksMTM0MjUzMzk0OCw2NTQ0NTkzMDYsMzE4ODM5NjA0OCwzMzczMDE1MTc0LDE0NjY0Nzk5MDksNTQ0MTc5NjM1LDMxMTA1MjM5MTMsMzQ2MjUyMjAxNSwxNTkxNjcxMDU0LDcwMjEzODc3NiwyOTY2NDYwNDUwLDMzNTI3OTk0MTIsMTUwNDkxODgwNyw3ODM1NTE4NzMsMzA4MjY0MDQ0MywzMjMzNDQyOTg5LDM5ODgyOTIzODQsMjU5NjI1NDY0Niw2MjMxNzA2OCwxOTU3ODEwODQyLDM5Mzk4NDU5NDUsMjY0NzgxNjExMSw4MTQ3MDk5NywxOTQzODAzNTIzLDM4MTQ5MTg5MzAsMjQ4OTU5NjgwNCwyMjUyNzQ0MzAsMjA1Mzc5MDM3NiwzODI2MTc1NzU1LFxuMjQ2NjkwNjAxMywxNjc4MTY3NDMsMjA5NzY1MTM3Nyw0MDI3NTUyNTgwLDIyNjU0OTAzODYsNTAzNDQ0MDcyLDE3NjIwNTA4MTQsNDE1MDQxNzI0NSwyMTU0MTI5MzU1LDQyNjUyMjIyNSwxODUyNTA3ODc5LDQyNzUzMTM1MjYsMjMxMjMxNzkyMCwyODI3NTM2MjYsMTc0MjU1NTg1Miw0MTg5NzA4MTQzLDIzOTQ4Nzc5NDUsMzk3OTE3NzYzLDE2MjIxODM2MzcsMzYwNDM5MDg4OCwyNzE0ODY2NTU4LDk1MzcyOTczMiwxMzQwMDc2NjI2LDM1MTg3MTk5ODUsMjc5NzM2MDk5OSwxMDY4ODI4MzgxLDEyMTk2Mzg4NTksMzYyNDc0MTg1MCwyOTM2Njc1MTQ4LDkwNjE4NTQ2MiwxMDkwODEyNTEyLDM3NDc2NzIwMDMsMjgyNTM3OTY2OSw4MjkzMjkxMzUsMTE4MTMzNTE2MSwzNDEyMTc3ODA0LDMxNjA4MzQ4NDIsNjI4MDg1NDA4LDEzODI2MDUzNjYsMzQyMzM2OTEwOSwzMTM4MDc4NDY3LDU3MDU2MjIzMywxNDI2NDAwODE1LDMzMTczMTY1NDIsMjk5ODczMzYwOCw3MzMyMzk5NTQsMTU1NTI2MTk1NixcbjMyNjg5MzU1OTEsMzA1MDM2MDYyNSw3NTI0NTk0MDMsMTU0MTMyMDIyMSwyNjA3MDcxOTIwLDM5NjU5NzMwMzAsMTk2OTkyMjk3Miw0MDczNTQ5OCwyNjE3ODM3MjI1LDM5NDM1NzcxNTEsMTkxMzA4Nzg3Nyw4MzkwODM3MSwyNTEyMzQxNjM0LDM4MDM3NDA2OTIsMjA3NTIwODYyMiwyMTMyNjExMTIsMjQ2MzI3MjYwMywzODU1OTkwMjg1LDIwOTQ4NTQwNzEsMTk4OTU4ODgxLDIyNjIwMjkwMTIsNDA1NzI2MDYxMCwxNzU5MzU5OTkyLDUzNDQxNDE5MCwyMTc2NzE4NTQxLDQxMzkzMjkxMTUsMTg3MzgzNjAwMSw0MTQ2NjQ1NjcsMjI4MjI0ODkzNCw0Mjc5MjAwMzY4LDE3MTE2ODQ1NTQsMjg1MjgxMTE2LDI0MDU4MDE3MjcsNDE2NzIxNjc0NSwxNjM0NDY3Nzk1LDM3NjIyOTcwMSwyNjg1MDY3ODk2LDM2MDgwMDc0MDYsMTMwODkxODYxMiw5NTY1NDM5MzgsMjgwODU1NTEwNSwzNDk1OTU4MjYzLDEyMzE2MzYzMDEsMTA0NzQyNzAzNSwyOTMyOTU5ODE4LDM2NTQ3MDM4MzYsMTA4ODM1OTI3MCxcbjkzNjkxOEUzLDI4NDc3MTQ4OTksMzczNjgzNzgyOSwxMjAyOTAwODYzLDgxNzIzMzg5NywzMTgzMzQyMTA4LDM0MDEyMzcxMzAsMTQwNDI3NzU1Miw2MTU4MTgxNTAsMzEzNDIwNzQ5MywzNDUzNDIxMjAzLDE0MjM4NTc0NDksNjAxNDUwNDMxLDMwMDk4Mzc2MTQsMzI5NDcxMDQ1NiwxNTY3MTAzNzQ2LDcxMTkyODcyNCwzMDIwNjY4NDcxLDMyNzIzODAwNjUsMTUxMDMzNDIzNSw3NTUxNjcxMTddLE89Qj9uZXcgVWludDMyQXJyYXkoa2EpOmthO2Z1bmN0aW9uIFAoKXt9UC5wcm90b3R5cGUuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O1AucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfTtQLnByb3RvdHlwZS5YPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuWX07QShcIlpsaWIuR3VuemlwTWVtYmVyXCIsUCk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXROYW1lXCIsUC5wcm90b3R5cGUuZ2V0TmFtZSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXREYXRhXCIsUC5wcm90b3R5cGUuZ2V0RGF0YSk7QShcIlpsaWIuR3VuemlwTWVtYmVyLnByb3RvdHlwZS5nZXRNdGltZVwiLFAucHJvdG90eXBlLlgpO2Z1bmN0aW9uIGxhKGIpe3RoaXMuYnVmZmVyPW5ldyAoQj9VaW50MTZBcnJheTpBcnJheSkoMipiKTt0aGlzLmxlbmd0aD0wfWxhLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oYil7cmV0dXJuIDIqKChiLTIpLzR8MCl9O2xhLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKGIsYSl7dmFyIGMsZCxmPXRoaXMuYnVmZmVyLGU7Yz10aGlzLmxlbmd0aDtmW3RoaXMubGVuZ3RoKytdPWE7Zm9yKGZbdGhpcy5sZW5ndGgrK109YjswPGM7KWlmKGQ9dGhpcy5nZXRQYXJlbnQoYyksZltjXT5mW2RdKWU9ZltjXSxmW2NdPWZbZF0sZltkXT1lLGU9ZltjKzFdLGZbYysxXT1mW2QrMV0sZltkKzFdPWUsYz1kO2Vsc2UgYnJlYWs7cmV0dXJuIHRoaXMubGVuZ3RofTtcbmxhLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24oKXt2YXIgYixhLGM9dGhpcy5idWZmZXIsZCxmLGU7YT1jWzBdO2I9Y1sxXTt0aGlzLmxlbmd0aC09MjtjWzBdPWNbdGhpcy5sZW5ndGhdO2NbMV09Y1t0aGlzLmxlbmd0aCsxXTtmb3IoZT0wOzspe2Y9MiplKzI7aWYoZj49dGhpcy5sZW5ndGgpYnJlYWs7ZisyPHRoaXMubGVuZ3RoJiZjW2YrMl0+Y1tmXSYmKGYrPTIpO2lmKGNbZl0+Y1tlXSlkPWNbZV0sY1tlXT1jW2ZdLGNbZl09ZCxkPWNbZSsxXSxjW2UrMV09Y1tmKzFdLGNbZisxXT1kO2Vsc2UgYnJlYWs7ZT1mfXJldHVybntpbmRleDpiLHZhbHVlOmEsbGVuZ3RoOnRoaXMubGVuZ3RofX07ZnVuY3Rpb24gbWEoYil7dmFyIGE9Yi5sZW5ndGgsYz0wLGQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGYsZSxnLGssaCxsLHMsbixtO2ZvcihuPTA7bjxhOysrbiliW25dPmMmJihjPWJbbl0pLGJbbl08ZCYmKGQ9YltuXSk7Zj0xPDxjO2U9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShmKTtnPTE7az0wO2ZvcihoPTI7Zzw9Yzspe2ZvcihuPTA7bjxhOysrbilpZihiW25dPT09Zyl7bD0wO3M9aztmb3IobT0wO208ZzsrK20pbD1sPDwxfHMmMSxzPj49MTtmb3IobT1sO208ZjttKz1oKWVbbV09Zzw8MTZ8bjsrK2t9KytnO2s8PD0xO2g8PD0xfXJldHVybltlLGMsZF19O2Z1bmN0aW9uIG5hKGIsYSl7dGhpcy5rPXFhO3RoaXMuST0wO3RoaXMuaW5wdXQ9QiYmYiBpbnN0YW5jZW9mIEFycmF5P25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy5iPTA7YSYmKGEubGF6eSYmKHRoaXMuST1hLmxhenkpLFwibnVtYmVyXCI9PT10eXBlb2YgYS5jb21wcmVzc2lvblR5cGUmJih0aGlzLms9YS5jb21wcmVzc2lvblR5cGUpLGEub3V0cHV0QnVmZmVyJiYodGhpcy5hPUImJmEub3V0cHV0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXk/bmV3IFVpbnQ4QXJyYXkoYS5vdXRwdXRCdWZmZXIpOmEub3V0cHV0QnVmZmVyKSxcIm51bWJlclwiPT09dHlwZW9mIGEub3V0cHV0SW5kZXgmJih0aGlzLmI9YS5vdXRwdXRJbmRleCkpO3RoaXMuYXx8KHRoaXMuYT1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpKX12YXIgcWE9MixyYT17Tk9ORTowLHY6MSxvOnFhLGFhOjN9LHNhPVtdLFM7XG5mb3IoUz0wOzI4OD5TO1MrKylzd2l0Y2godSl7Y2FzZSAxNDM+PVM6c2EucHVzaChbUys0OCw4XSk7YnJlYWs7Y2FzZSAyNTU+PVM6c2EucHVzaChbUy0xNDQrNDAwLDldKTticmVhaztjYXNlIDI3OT49UzpzYS5wdXNoKFtTLTI1NiswLDddKTticmVhaztjYXNlIDI4Nz49UzpzYS5wdXNoKFtTLTI4MCsxOTIsOF0pO2JyZWFrO2RlZmF1bHQ6cShcImludmFsaWQgbGl0ZXJhbDogXCIrUyl9XG5uYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGY9dGhpcy5pbnB1dDtzd2l0Y2godGhpcy5rKXtjYXNlIDA6Yz0wO2ZvcihkPWYubGVuZ3RoO2M8ZDspe2E9Qj9mLnN1YmFycmF5KGMsYys2NTUzNSk6Zi5zbGljZShjLGMrNjU1MzUpO2MrPWEubGVuZ3RoO3ZhciBlPWEsZz1jPT09ZCxrPXQsaD10LGw9dCxzPXQsbj10LG09dGhpcy5hLHA9dGhpcy5iO2lmKEIpe2ZvcihtPW5ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpO20ubGVuZ3RoPD1wK2UubGVuZ3RoKzU7KW09bmV3IFVpbnQ4QXJyYXkobS5sZW5ndGg8PDEpO20uc2V0KHRoaXMuYSl9az1nPzE6MDttW3ArK109a3wwO2g9ZS5sZW5ndGg7bD1+aCs2NTUzNiY2NTUzNTttW3ArK109aCYyNTU7bVtwKytdPWg+Pj44JjI1NTttW3ArK109bCYyNTU7bVtwKytdPWw+Pj44JjI1NTtpZihCKW0uc2V0KGUscCkscCs9ZS5sZW5ndGgsbT1tLnN1YmFycmF5KDAscCk7ZWxzZXtzPTA7Zm9yKG49ZS5sZW5ndGg7czxuOysrcyltW3ArK109XG5lW3NdO20ubGVuZ3RoPXB9dGhpcy5iPXA7dGhpcy5hPW19YnJlYWs7Y2FzZSAxOnZhciByPW5ldyBGKEI/bmV3IFVpbnQ4QXJyYXkodGhpcy5hLmJ1ZmZlcik6dGhpcy5hLHRoaXMuYik7ci5kKDEsMSx1KTtyLmQoMSwyLHUpO3ZhciB2PXRhKHRoaXMsZikseCxRLHk7eD0wO2ZvcihRPXYubGVuZ3RoO3g8UTt4KyspaWYoeT12W3hdLEYucHJvdG90eXBlLmQuYXBwbHkocixzYVt5XSksMjU2PHkpci5kKHZbKyt4XSx2WysreF0sdSksci5kKHZbKyt4XSw1KSxyLmQodlsrK3hdLHZbKyt4XSx1KTtlbHNlIGlmKDI1Nj09PXkpYnJlYWs7dGhpcy5hPXIuZmluaXNoKCk7dGhpcy5iPXRoaXMuYS5sZW5ndGg7YnJlYWs7Y2FzZSBxYTp2YXIgRT1uZXcgRihCP25ldyBVaW50OEFycmF5KHRoaXMuYS5idWZmZXIpOnRoaXMuYSx0aGlzLmIpLEphLFIsWCxZLFoscGI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGZhLEthLGdhLExhLG9hLHdhPUFycmF5KDE5KSxcbk1hLCQscGEsQyxOYTtKYT1xYTtFLmQoMSwxLHUpO0UuZChKYSwyLHUpO1I9dGEodGhpcyxmKTtmYT11YSh0aGlzLlYsMTUpO0thPXZhKGZhKTtnYT11YSh0aGlzLlUsNyk7TGE9dmEoZ2EpO2ZvcihYPTI4NjsyNTc8WCYmMD09PWZhW1gtMV07WC0tKTtmb3IoWT0zMDsxPFkmJjA9PT1nYVtZLTFdO1ktLSk7dmFyIE9hPVgsUGE9WSxKPW5ldyAoQj9VaW50MzJBcnJheTpBcnJheSkoT2ErUGEpLHcsTCx6LGhhLEk9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMTYpLEcsRCxNPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgxOSk7Zm9yKHc9TD0wO3c8T2E7dysrKUpbTCsrXT1mYVt3XTtmb3Iodz0wO3c8UGE7dysrKUpbTCsrXT1nYVt3XTtpZighQil7dz0wO2ZvcihoYT1NLmxlbmd0aDt3PGhhOysrdylNW3ddPTB9dz1HPTA7Zm9yKGhhPUoubGVuZ3RoO3c8aGE7dys9TCl7Zm9yKEw9MTt3K0w8aGEmJkpbdytMXT09PUpbd107KytMKTt6PUw7aWYoMD09PUpbd10paWYoMz56KWZvcig7MDxcbnotLTspSVtHKytdPTAsTVswXSsrO2Vsc2UgZm9yKDswPHo7KUQ9MTM4Pno/ejoxMzgsRD56LTMmJkQ8eiYmKEQ9ei0zKSwxMD49RD8oSVtHKytdPTE3LElbRysrXT1ELTMsTVsxN10rKyk6KElbRysrXT0xOCxJW0crK109RC0xMSxNWzE4XSsrKSx6LT1EO2Vsc2UgaWYoSVtHKytdPUpbd10sTVtKW3ddXSsrLHotLSwzPnopZm9yKDswPHotLTspSVtHKytdPUpbd10sTVtKW3ddXSsrO2Vsc2UgZm9yKDswPHo7KUQ9Nj56P3o6NixEPnotMyYmRDx6JiYoRD16LTMpLElbRysrXT0xNixJW0crK109RC0zLE1bMTZdKyssei09RH1iPUI/SS5zdWJhcnJheSgwLEcpOkkuc2xpY2UoMCxHKTtvYT11YShNLDcpO2ZvcihDPTA7MTk+QztDKyspd2FbQ109b2FbcGJbQ11dO2ZvcihaPTE5OzQ8WiYmMD09PXdhW1otMV07Wi0tKTtNYT12YShvYSk7RS5kKFgtMjU3LDUsdSk7RS5kKFktMSw1LHUpO0UuZChaLTQsNCx1KTtmb3IoQz0wO0M8WjtDKyspRS5kKHdhW0NdLDMsdSk7Qz0wO2ZvcihOYT1iLmxlbmd0aDtDPFxuTmE7QysrKWlmKCQ9YltDXSxFLmQoTWFbJF0sb2FbJF0sdSksMTY8PSQpe0MrKztzd2l0Y2goJCl7Y2FzZSAxNjpwYT0yO2JyZWFrO2Nhc2UgMTc6cGE9MzticmVhaztjYXNlIDE4OnBhPTc7YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBjb2RlOiBcIiskKX1FLmQoYltDXSxwYSx1KX12YXIgUWE9W0thLGZhXSxSYT1bTGEsZ2FdLE4sU2EsaWEsemEsVGEsVWEsVmEsV2E7VGE9UWFbMF07VWE9UWFbMV07VmE9UmFbMF07V2E9UmFbMV07Tj0wO2ZvcihTYT1SLmxlbmd0aDtOPFNhOysrTilpZihpYT1SW05dLEUuZChUYVtpYV0sVWFbaWFdLHUpLDI1NjxpYSlFLmQoUlsrK05dLFJbKytOXSx1KSx6YT1SWysrTl0sRS5kKFZhW3phXSxXYVt6YV0sdSksRS5kKFJbKytOXSxSWysrTl0sdSk7ZWxzZSBpZigyNTY9PT1pYSlicmVhazt0aGlzLmE9RS5maW5pc2goKTt0aGlzLmI9dGhpcy5hLmxlbmd0aDticmVhaztkZWZhdWx0OnEoXCJpbnZhbGlkIGNvbXByZXNzaW9uIHR5cGVcIil9cmV0dXJuIHRoaXMuYX07XG5mdW5jdGlvbiB4YShiLGEpe3RoaXMubGVuZ3RoPWI7dGhpcy5QPWF9XG52YXIgeWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEpe3N3aXRjaCh1KXtjYXNlIDM9PT1hOnJldHVyblsyNTcsYS0zLDBdO2Nhc2UgND09PWE6cmV0dXJuWzI1OCxhLTQsMF07Y2FzZSA1PT09YTpyZXR1cm5bMjU5LGEtNSwwXTtjYXNlIDY9PT1hOnJldHVyblsyNjAsYS02LDBdO2Nhc2UgNz09PWE6cmV0dXJuWzI2MSxhLTcsMF07Y2FzZSA4PT09YTpyZXR1cm5bMjYyLGEtOCwwXTtjYXNlIDk9PT1hOnJldHVyblsyNjMsYS05LDBdO2Nhc2UgMTA9PT1hOnJldHVyblsyNjQsYS0xMCwwXTtjYXNlIDEyPj1hOnJldHVyblsyNjUsYS0xMSwxXTtjYXNlIDE0Pj1hOnJldHVyblsyNjYsYS0xMywxXTtjYXNlIDE2Pj1hOnJldHVyblsyNjcsYS0xNSwxXTtjYXNlIDE4Pj1hOnJldHVyblsyNjgsYS0xNywxXTtjYXNlIDIyPj1hOnJldHVyblsyNjksYS0xOSwyXTtjYXNlIDI2Pj1hOnJldHVyblsyNzAsYS0yMywyXTtjYXNlIDMwPj1hOnJldHVyblsyNzEsYS0yNywyXTtjYXNlIDM0Pj1hOnJldHVyblsyNzIsXG5hLTMxLDJdO2Nhc2UgNDI+PWE6cmV0dXJuWzI3MyxhLTM1LDNdO2Nhc2UgNTA+PWE6cmV0dXJuWzI3NCxhLTQzLDNdO2Nhc2UgNTg+PWE6cmV0dXJuWzI3NSxhLTUxLDNdO2Nhc2UgNjY+PWE6cmV0dXJuWzI3NixhLTU5LDNdO2Nhc2UgODI+PWE6cmV0dXJuWzI3NyxhLTY3LDRdO2Nhc2UgOTg+PWE6cmV0dXJuWzI3OCxhLTgzLDRdO2Nhc2UgMTE0Pj1hOnJldHVyblsyNzksYS05OSw0XTtjYXNlIDEzMD49YTpyZXR1cm5bMjgwLGEtMTE1LDRdO2Nhc2UgMTYyPj1hOnJldHVyblsyODEsYS0xMzEsNV07Y2FzZSAxOTQ+PWE6cmV0dXJuWzI4MixhLTE2Myw1XTtjYXNlIDIyNj49YTpyZXR1cm5bMjgzLGEtMTk1LDVdO2Nhc2UgMjU3Pj1hOnJldHVyblsyODQsYS0yMjcsNV07Y2FzZSAyNTg9PT1hOnJldHVyblsyODUsYS0yNTgsMF07ZGVmYXVsdDpxKFwiaW52YWxpZCBsZW5ndGg6IFwiK2EpfX12YXIgYT1bXSxjLGQ7Zm9yKGM9MzsyNTg+PWM7YysrKWQ9YihjKSxhW2NdPWRbMl08PDI0fGRbMV08PFxuMTZ8ZFswXTtyZXR1cm4gYX0oKSxBYT1CP25ldyBVaW50MzJBcnJheSh5YSk6eWE7XG5mdW5jdGlvbiB0YShiLGEpe2Z1bmN0aW9uIGMoYSxjKXt2YXIgYj1hLlAsZD1bXSxlPTAsZjtmPUFhW2EubGVuZ3RoXTtkW2UrK109ZiY2NTUzNTtkW2UrK109Zj4+MTYmMjU1O2RbZSsrXT1mPj4yNDt2YXIgZztzd2l0Y2godSl7Y2FzZSAxPT09YjpnPVswLGItMSwwXTticmVhaztjYXNlIDI9PT1iOmc9WzEsYi0yLDBdO2JyZWFrO2Nhc2UgMz09PWI6Zz1bMixiLTMsMF07YnJlYWs7Y2FzZSA0PT09YjpnPVszLGItNCwwXTticmVhaztjYXNlIDY+PWI6Zz1bNCxiLTUsMV07YnJlYWs7Y2FzZSA4Pj1iOmc9WzUsYi03LDFdO2JyZWFrO2Nhc2UgMTI+PWI6Zz1bNixiLTksMl07YnJlYWs7Y2FzZSAxNj49YjpnPVs3LGItMTMsMl07YnJlYWs7Y2FzZSAyND49YjpnPVs4LGItMTcsM107YnJlYWs7Y2FzZSAzMj49YjpnPVs5LGItMjUsM107YnJlYWs7Y2FzZSA0OD49YjpnPVsxMCxiLTMzLDRdO2JyZWFrO2Nhc2UgNjQ+PWI6Zz1bMTEsYi00OSw0XTticmVhaztjYXNlIDk2Pj1iOmc9WzEyLGItXG42NSw1XTticmVhaztjYXNlIDEyOD49YjpnPVsxMyxiLTk3LDVdO2JyZWFrO2Nhc2UgMTkyPj1iOmc9WzE0LGItMTI5LDZdO2JyZWFrO2Nhc2UgMjU2Pj1iOmc9WzE1LGItMTkzLDZdO2JyZWFrO2Nhc2UgMzg0Pj1iOmc9WzE2LGItMjU3LDddO2JyZWFrO2Nhc2UgNTEyPj1iOmc9WzE3LGItMzg1LDddO2JyZWFrO2Nhc2UgNzY4Pj1iOmc9WzE4LGItNTEzLDhdO2JyZWFrO2Nhc2UgMTAyND49YjpnPVsxOSxiLTc2OSw4XTticmVhaztjYXNlIDE1MzY+PWI6Zz1bMjAsYi0xMDI1LDldO2JyZWFrO2Nhc2UgMjA0OD49YjpnPVsyMSxiLTE1MzcsOV07YnJlYWs7Y2FzZSAzMDcyPj1iOmc9WzIyLGItMjA0OSwxMF07YnJlYWs7Y2FzZSA0MDk2Pj1iOmc9WzIzLGItMzA3MywxMF07YnJlYWs7Y2FzZSA2MTQ0Pj1iOmc9WzI0LGItNDA5NywxMV07YnJlYWs7Y2FzZSA4MTkyPj1iOmc9WzI1LGItNjE0NSwxMV07YnJlYWs7Y2FzZSAxMjI4OD49YjpnPVsyNixiLTgxOTMsMTJdO2JyZWFrO2Nhc2UgMTYzODQ+PVxuYjpnPVsyNyxiLTEyMjg5LDEyXTticmVhaztjYXNlIDI0NTc2Pj1iOmc9WzI4LGItMTYzODUsMTNdO2JyZWFrO2Nhc2UgMzI3Njg+PWI6Zz1bMjksYi0yNDU3NywxM107YnJlYWs7ZGVmYXVsdDpxKFwiaW52YWxpZCBkaXN0YW5jZVwiKX1mPWc7ZFtlKytdPWZbMF07ZFtlKytdPWZbMV07ZFtlKytdPWZbMl07dmFyIGgsaztoPTA7Zm9yKGs9ZC5sZW5ndGg7aDxrOysraCltW3ArK109ZFtoXTt2W2RbMF1dKys7eFtkWzNdXSsrO3I9YS5sZW5ndGgrYy0xO249bnVsbH12YXIgZCxmLGUsZyxrLGg9e30sbCxzLG4sbT1CP25ldyBVaW50MTZBcnJheSgyKmEubGVuZ3RoKTpbXSxwPTAscj0wLHY9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgyODYpLHg9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KSgzMCksUT1iLkkseTtpZighQil7Zm9yKGU9MDsyODU+PWU7KXZbZSsrXT0wO2ZvcihlPTA7Mjk+PWU7KXhbZSsrXT0wfXZbMjU2XT0xO2Q9MDtmb3IoZj1hLmxlbmd0aDtkPGY7KytkKXtlPWs9MDtcbmZvcihnPTM7ZTxnJiZkK2UhPT1mOysrZSlrPWs8PDh8YVtkK2VdO2hba109PT10JiYoaFtrXT1bXSk7bD1oW2tdO2lmKCEoMDxyLS0pKXtmb3IoOzA8bC5sZW5ndGgmJjMyNzY4PGQtbFswXTspbC5zaGlmdCgpO2lmKGQrMz49Zil7biYmYyhuLC0xKTtlPTA7Zm9yKGc9Zi1kO2U8ZzsrK2UpeT1hW2QrZV0sbVtwKytdPXksKyt2W3ldO2JyZWFrfTA8bC5sZW5ndGg/KHM9QmEoYSxkLGwpLG4/bi5sZW5ndGg8cy5sZW5ndGg/KHk9YVtkLTFdLG1bcCsrXT15LCsrdlt5XSxjKHMsMCkpOmMobiwtMSk6cy5sZW5ndGg8UT9uPXM6YyhzLDApKTpuP2MobiwtMSk6KHk9YVtkXSxtW3ArK109eSwrK3ZbeV0pfWwucHVzaChkKX1tW3ArK109MjU2O3ZbMjU2XSsrO2IuVj12O2IuVT14O3JldHVybiBCP20uc3ViYXJyYXkoMCxwKTptfVxuZnVuY3Rpb24gQmEoYixhLGMpe3ZhciBkLGYsZT0wLGcsayxoLGwscz1iLmxlbmd0aDtrPTA7bD1jLmxlbmd0aDthOmZvcig7azxsO2srKyl7ZD1jW2wtay0xXTtnPTM7aWYoMzxlKXtmb3IoaD1lOzM8aDtoLS0paWYoYltkK2gtMV0hPT1iW2EraC0xXSljb250aW51ZSBhO2c9ZX1mb3IoOzI1OD5nJiZhK2c8cyYmYltkK2ddPT09YlthK2ddOykrK2c7Zz5lJiYoZj1kLGU9Zyk7aWYoMjU4PT09ZylicmVha31yZXR1cm4gbmV3IHhhKGUsYS1mKX1cbmZ1bmN0aW9uIHVhKGIsYSl7dmFyIGM9Yi5sZW5ndGgsZD1uZXcgbGEoNTcyKSxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KShjKSxlLGcsayxoLGw7aWYoIUIpZm9yKGg9MDtoPGM7aCsrKWZbaF09MDtmb3IoaD0wO2g8YzsrK2gpMDxiW2hdJiZkLnB1c2goaCxiW2hdKTtlPUFycmF5KGQubGVuZ3RoLzIpO2c9bmV3IChCP1VpbnQzMkFycmF5OkFycmF5KShkLmxlbmd0aC8yKTtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGZbZC5wb3AoKS5pbmRleF09MSxmO2g9MDtmb3IobD1kLmxlbmd0aC8yO2g8bDsrK2gpZVtoXT1kLnBvcCgpLGdbaF09ZVtoXS52YWx1ZTtrPUNhKGcsZy5sZW5ndGgsYSk7aD0wO2ZvcihsPWUubGVuZ3RoO2g8bDsrK2gpZltlW2hdLmluZGV4XT1rW2hdO3JldHVybiBmfVxuZnVuY3Rpb24gQ2EoYixhLGMpe2Z1bmN0aW9uIGQoYil7dmFyIGM9aFtiXVtsW2JdXTtjPT09YT8oZChiKzEpLGQoYisxKSk6LS1nW2NdOysrbFtiXX12YXIgZj1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGMpLGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGMpLGc9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGEpLGs9QXJyYXkoYyksaD1BcnJheShjKSxsPUFycmF5KGMpLHM9KDE8PGMpLWEsbj0xPDxjLTEsbSxwLHIsdix4O2ZbYy0xXT1hO2ZvcihwPTA7cDxjOysrcClzPG4/ZVtwXT0wOihlW3BdPTEscy09biksczw8PTEsZltjLTItcF09KGZbYy0xLXBdLzJ8MCkrYTtmWzBdPWVbMF07a1swXT1BcnJheShmWzBdKTtoWzBdPUFycmF5KGZbMF0pO2ZvcihwPTE7cDxjOysrcClmW3BdPjIqZltwLTFdK2VbcF0mJihmW3BdPTIqZltwLTFdK2VbcF0pLGtbcF09QXJyYXkoZltwXSksaFtwXT1BcnJheShmW3BdKTtmb3IobT0wO208YTsrK20pZ1ttXT1jO2ZvcihyPTA7cjxmW2MtMV07KytyKWtbYy1cbjFdW3JdPWJbcl0saFtjLTFdW3JdPXI7Zm9yKG09MDttPGM7KyttKWxbbV09MDsxPT09ZVtjLTFdJiYoLS1nWzBdLCsrbFtjLTFdKTtmb3IocD1jLTI7MDw9cDstLXApe3Y9bT0wO3g9bFtwKzFdO2ZvcihyPTA7cjxmW3BdO3IrKyl2PWtbcCsxXVt4XStrW3ArMV1beCsxXSx2PmJbbV0/KGtbcF1bcl09dixoW3BdW3JdPWEseCs9Mik6KGtbcF1bcl09YlttXSxoW3BdW3JdPW0sKyttKTtsW3BdPTA7MT09PWVbcF0mJmQocCl9cmV0dXJuIGd9XG5mdW5jdGlvbiB2YShiKXt2YXIgYT1uZXcgKEI/VWludDE2QXJyYXk6QXJyYXkpKGIubGVuZ3RoKSxjPVtdLGQ9W10sZj0wLGUsZyxrLGg7ZT0wO2ZvcihnPWIubGVuZ3RoO2U8ZztlKyspY1tiW2VdXT0oY1tiW2VdXXwwKSsxO2U9MTtmb3IoZz0xNjtlPD1nO2UrKylkW2VdPWYsZis9Y1tlXXwwLGY8PD0xO2U9MDtmb3IoZz1iLmxlbmd0aDtlPGc7ZSsrKXtmPWRbYltlXV07ZFtiW2VdXSs9MTtrPWFbZV09MDtmb3IoaD1iW2VdO2s8aDtrKyspYVtlXT1hW2VdPDwxfGYmMSxmPj4+PTF9cmV0dXJuIGF9O2Z1bmN0aW9uIERhKGIsYSl7dGhpcy5pbnB1dD1iO3RoaXMuYj10aGlzLmM9MDt0aGlzLmk9e307YSYmKGEuZmxhZ3MmJih0aGlzLmk9YS5mbGFncyksXCJzdHJpbmdcIj09PXR5cGVvZiBhLmZpbGVuYW1lJiYodGhpcy5maWxlbmFtZT1hLmZpbGVuYW1lKSxcInN0cmluZ1wiPT09dHlwZW9mIGEuY29tbWVudCYmKHRoaXMuQT1hLmNvbW1lbnQpLGEuZGVmbGF0ZU9wdGlvbnMmJih0aGlzLmw9YS5kZWZsYXRlT3B0aW9ucykpO3RoaXMubHx8KHRoaXMubD17fSl9XG5EYS5wcm90b3R5cGUuZz1mdW5jdGlvbigpe3ZhciBiLGEsYyxkLGYsZSxnLGssaD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzI3NjgpLGw9MCxzPXRoaXMuaW5wdXQsbj10aGlzLmMsbT10aGlzLmZpbGVuYW1lLHA9dGhpcy5BO2hbbCsrXT0zMTtoW2wrK109MTM5O2hbbCsrXT04O2I9MDt0aGlzLmkuZm5hbWUmJihifD1FYSk7dGhpcy5pLmZjb21tZW50JiYoYnw9RmEpO3RoaXMuaS5maGNyYyYmKGJ8PUdhKTtoW2wrK109YjthPShEYXRlLm5vdz9EYXRlLm5vdygpOituZXcgRGF0ZSkvMUUzfDA7aFtsKytdPWEmMjU1O2hbbCsrXT1hPj4+OCYyNTU7aFtsKytdPWE+Pj4xNiYyNTU7aFtsKytdPWE+Pj4yNCYyNTU7aFtsKytdPTA7aFtsKytdPUhhO2lmKHRoaXMuaS5mbmFtZSE9PXQpe2c9MDtmb3Ioaz1tLmxlbmd0aDtnPGs7KytnKWU9bS5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfWlmKHRoaXMuaS5jb21tZW50KXtnPVxuMDtmb3Ioaz1wLmxlbmd0aDtnPGs7KytnKWU9cC5jaGFyQ29kZUF0KGcpLDI1NTxlJiYoaFtsKytdPWU+Pj44JjI1NSksaFtsKytdPWUmMjU1O2hbbCsrXT0wfXRoaXMuaS5maGNyYyYmKGM9amEoaCwwLGwpJjY1NTM1LGhbbCsrXT1jJjI1NSxoW2wrK109Yz4+PjgmMjU1KTt0aGlzLmwub3V0cHV0QnVmZmVyPWg7dGhpcy5sLm91dHB1dEluZGV4PWw7Zj1uZXcgbmEocyx0aGlzLmwpO2g9Zi5nKCk7bD1mLmI7QiYmKGwrOD5oLmJ1ZmZlci5ieXRlTGVuZ3RoPyh0aGlzLmE9bmV3IFVpbnQ4QXJyYXkobCs4KSx0aGlzLmEuc2V0KG5ldyBVaW50OEFycmF5KGguYnVmZmVyKSksaD10aGlzLmEpOmg9bmV3IFVpbnQ4QXJyYXkoaC5idWZmZXIpKTtkPWphKHMsdCx0KTtoW2wrK109ZCYyNTU7aFtsKytdPWQ+Pj44JjI1NTtoW2wrK109ZD4+PjE2JjI1NTtoW2wrK109ZD4+PjI0JjI1NTtrPXMubGVuZ3RoO2hbbCsrXT1rJjI1NTtoW2wrK109az4+PjgmMjU1O2hbbCsrXT1rPj4+MTYmMjU1O2hbbCsrXT1cbms+Pj4yNCYyNTU7dGhpcy5jPW47QiYmbDxoLmxlbmd0aCYmKHRoaXMuYT1oPWguc3ViYXJyYXkoMCxsKSk7cmV0dXJuIGh9O3ZhciBIYT0yNTUsR2E9MixFYT04LEZhPTE2O0EoXCJabGliLkd6aXBcIixEYSk7QShcIlpsaWIuR3ppcC5wcm90b3R5cGUuY29tcHJlc3NcIixEYS5wcm90b3R5cGUuZyk7ZnVuY3Rpb24gVChiLGEpe3RoaXMucD1bXTt0aGlzLnE9MzI3Njg7dGhpcy5lPXRoaXMuaj10aGlzLmM9dGhpcy51PTA7dGhpcy5pbnB1dD1CP25ldyBVaW50OEFycmF5KGIpOmI7dGhpcy53PSExO3RoaXMucj1JYTt0aGlzLkw9ITE7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEuYnVmZmVyU2l6ZSYmKHRoaXMucT1hLmJ1ZmZlclNpemUpLGEuYnVmZmVyVHlwZSYmKHRoaXMucj1hLmJ1ZmZlclR5cGUpLGEucmVzaXplJiYodGhpcy5MPWEucmVzaXplKTtzd2l0Y2godGhpcy5yKXtjYXNlIFhhOnRoaXMuYj0zMjc2ODt0aGlzLmE9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKDMyNzY4K3RoaXMucSsyNTgpO2JyZWFrO2Nhc2UgSWE6dGhpcy5iPTA7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnEpO3RoaXMuZj10aGlzLlQ7dGhpcy5CPXRoaXMuUTt0aGlzLnM9dGhpcy5TO2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgaW5mbGF0ZSBtb2RlXCIpKX19XG52YXIgWGE9MCxJYT0xLFlhPXtOOlhhLE06SWF9O1xuVC5wcm90b3R5cGUuaD1mdW5jdGlvbigpe2Zvcig7IXRoaXMudzspe3ZhciBiPVUodGhpcywzKTtiJjEmJih0aGlzLnc9dSk7Yj4+Pj0xO3N3aXRjaChiKXtjYXNlIDA6dmFyIGE9dGhpcy5pbnB1dCxjPXRoaXMuYyxkPXRoaXMuYSxmPXRoaXMuYixlPXQsZz10LGs9dCxoPWQubGVuZ3RoLGw9dDt0aGlzLmU9dGhpcy5qPTA7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IExFTiAoZmlyc3QgYnl0ZSlcIikpO2c9ZTtlPWFbYysrXTtlPT09dCYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogTEVOIChzZWNvbmQgYnl0ZSlcIikpO2d8PWU8PDg7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKGZpcnN0IGJ5dGUpXCIpKTtrPWU7ZT1hW2MrK107ZT09PXQmJnEoRXJyb3IoXCJpbnZhbGlkIHVuY29tcHJlc3NlZCBibG9jayBoZWFkZXI6IE5MRU4gKHNlY29uZCBieXRlKVwiKSk7a3w9XG5lPDw4O2c9PT1+ayYmcShFcnJvcihcImludmFsaWQgdW5jb21wcmVzc2VkIGJsb2NrIGhlYWRlcjogbGVuZ3RoIHZlcmlmeVwiKSk7YytnPmEubGVuZ3RoJiZxKEVycm9yKFwiaW5wdXQgYnVmZmVyIGlzIGJyb2tlblwiKSk7c3dpdGNoKHRoaXMucil7Y2FzZSBYYTpmb3IoO2YrZz5kLmxlbmd0aDspe2w9aC1mO2ctPWw7aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytsKSxmKSxmKz1sLGMrPWw7ZWxzZSBmb3IoO2wtLTspZFtmKytdPWFbYysrXTt0aGlzLmI9ZjtkPXRoaXMuZigpO2Y9dGhpcy5ifWJyZWFrO2Nhc2UgSWE6Zm9yKDtmK2c+ZC5sZW5ndGg7KWQ9dGhpcy5mKHtGOjJ9KTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGluZmxhdGUgbW9kZVwiKSl9aWYoQilkLnNldChhLnN1YmFycmF5KGMsYytnKSxmKSxmKz1nLGMrPWc7ZWxzZSBmb3IoO2ctLTspZFtmKytdPWFbYysrXTt0aGlzLmM9Yzt0aGlzLmI9Zjt0aGlzLmE9ZDticmVhaztjYXNlIDE6dGhpcy5zKFphLCRhKTticmVhaztcbmNhc2UgMjphYih0aGlzKTticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bmtub3duIEJUWVBFOiBcIitiKSl9fXJldHVybiB0aGlzLkIoKX07XG52YXIgYmI9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLGNiPUI/bmV3IFVpbnQxNkFycmF5KGJiKTpiYixkYj1bMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwyNTgsMjU4XSxlYj1CP25ldyBVaW50MTZBcnJheShkYik6ZGIsZmI9WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDBdLGdiPUI/bmV3IFVpbnQ4QXJyYXkoZmIpOmZiLGhiPVsxLDIsMyw0LDUsNyw5LDEzLDE3LDI1LDMzLDQ5LDY1LDk3LDEyOSwxOTMsMjU3LDM4NSw1MTMsNzY5LDEwMjUsMTUzNywyMDQ5LDMwNzMsNDA5Nyw2MTQ1LDgxOTMsMTIyODksMTYzODUsMjQ1NzddLGliPUI/bmV3IFVpbnQxNkFycmF5KGhiKTpoYixqYj1bMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCxcbjEwLDExLDExLDEyLDEyLDEzLDEzXSxrYj1CP25ldyBVaW50OEFycmF5KGpiKTpqYixsYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMjg4KSxWLG1iO1Y9MDtmb3IobWI9bGIubGVuZ3RoO1Y8bWI7KytWKWxiW1ZdPTE0Mz49Vj84OjI1NT49Vj85OjI3OT49Vj83Ojg7dmFyIFphPW1hKGxiKSxuYj1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoMzApLG9iLHFiO29iPTA7Zm9yKHFiPW5iLmxlbmd0aDtvYjxxYjsrK29iKW5iW29iXT01O3ZhciAkYT1tYShuYik7ZnVuY3Rpb24gVShiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc7ZDxhOylnPWZbZSsrXSxnPT09dCYmcShFcnJvcihcImlucHV0IGJ1ZmZlciBpcyBicm9rZW5cIikpLGN8PWc8PGQsZCs9ODtnPWMmKDE8PGEpLTE7Yi5qPWM+Pj5hO2IuZT1kLWE7Yi5jPWU7cmV0dXJuIGd9XG5mdW5jdGlvbiByYihiLGEpe2Zvcih2YXIgYz1iLmosZD1iLmUsZj1iLmlucHV0LGU9Yi5jLGc9YVswXSxrPWFbMV0saCxsLHM7ZDxrOyl7aD1mW2UrK107aWYoaD09PXQpYnJlYWs7Y3w9aDw8ZDtkKz04fWw9Z1tjJigxPDxrKS0xXTtzPWw+Pj4xNjtiLmo9Yz4+cztiLmU9ZC1zO2IuYz1lO3JldHVybiBsJjY1NTM1fVxuZnVuY3Rpb24gYWIoYil7ZnVuY3Rpb24gYShhLGIsYyl7dmFyIGQsZSxmLGc7Zm9yKGc9MDtnPGE7KXN3aXRjaChkPXJiKHRoaXMsYiksZCl7Y2FzZSAxNjpmb3IoZj0zK1UodGhpcywyKTtmLS07KWNbZysrXT1lO2JyZWFrO2Nhc2UgMTc6Zm9yKGY9MytVKHRoaXMsMyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7Y2FzZSAxODpmb3IoZj0xMStVKHRoaXMsNyk7Zi0tOyljW2crK109MDtlPTA7YnJlYWs7ZGVmYXVsdDplPWNbZysrXT1kfXJldHVybiBjfXZhciBjPVUoYiw1KSsyNTcsZD1VKGIsNSkrMSxmPVUoYiw0KSs0LGU9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKGNiLmxlbmd0aCksZyxrLGgsbDtmb3IobD0wO2w8ZjsrK2wpZVtjYltsXV09VShiLDMpO2c9bWEoZSk7az1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoYyk7aD1uZXcgKEI/VWludDhBcnJheTpBcnJheSkoZCk7Yi5zKG1hKGEuY2FsbChiLGMsZyxrKSksbWEoYS5jYWxsKGIsZCxnLGgpKSl9XG5ULnByb3RvdHlwZS5zPWZ1bmN0aW9uKGIsYSl7dmFyIGM9dGhpcy5hLGQ9dGhpcy5iO3RoaXMuQz1iO2Zvcih2YXIgZj1jLmxlbmd0aC0yNTgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpLGNbZCsrXT1lO2Vsc2V7Zz1lLTI1NztoPWViW2ddOzA8Z2JbZ10mJihoKz1VKHRoaXMsZ2JbZ10pKTtlPXJiKHRoaXMsYSk7az1pYltlXTswPGtiW2VdJiYoays9VSh0aGlzLGtiW2VdKSk7ZD49ZiYmKHRoaXMuYj1kLGM9dGhpcy5mKCksZD10aGlzLmIpO2Zvcig7aC0tOyljW2RdPWNbZCsrLWtdfWZvcig7ODw9dGhpcy5lOyl0aGlzLmUtPTgsdGhpcy5jLS07dGhpcy5iPWR9O1xuVC5wcm90b3R5cGUuUz1mdW5jdGlvbihiLGEpe3ZhciBjPXRoaXMuYSxkPXRoaXMuYjt0aGlzLkM9Yjtmb3IodmFyIGY9Yy5sZW5ndGgsZSxnLGssaDsyNTYhPT0oZT1yYih0aGlzLGIpKTspaWYoMjU2PmUpZD49ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCksY1tkKytdPWU7ZWxzZXtnPWUtMjU3O2g9ZWJbZ107MDxnYltnXSYmKGgrPVUodGhpcyxnYltnXSkpO2U9cmIodGhpcyxhKTtrPWliW2VdOzA8a2JbZV0mJihrKz1VKHRoaXMsa2JbZV0pKTtkK2g+ZiYmKGM9dGhpcy5mKCksZj1jLmxlbmd0aCk7Zm9yKDtoLS07KWNbZF09Y1tkKysta119Zm9yKDs4PD10aGlzLmU7KXRoaXMuZS09OCx0aGlzLmMtLTt0aGlzLmI9ZH07XG5ULnByb3RvdHlwZS5mPWZ1bmN0aW9uKCl7dmFyIGI9bmV3IChCP1VpbnQ4QXJyYXk6QXJyYXkpKHRoaXMuYi0zMjc2OCksYT10aGlzLmItMzI3NjgsYyxkLGY9dGhpcy5hO2lmKEIpYi5zZXQoZi5zdWJhcnJheSgzMjc2OCxiLmxlbmd0aCkpO2Vsc2V7Yz0wO2ZvcihkPWIubGVuZ3RoO2M8ZDsrK2MpYltjXT1mW2MrMzI3NjhdfXRoaXMucC5wdXNoKGIpO3RoaXMudSs9Yi5sZW5ndGg7aWYoQilmLnNldChmLnN1YmFycmF5KGEsYSszMjc2OCkpO2Vsc2UgZm9yKGM9MDszMjc2OD5jOysrYylmW2NdPWZbYStjXTt0aGlzLmI9MzI3Njg7cmV0dXJuIGZ9O1xuVC5wcm90b3R5cGUuVD1mdW5jdGlvbihiKXt2YXIgYSxjPXRoaXMuaW5wdXQubGVuZ3RoL3RoaXMuYysxfDAsZCxmLGUsZz10aGlzLmlucHV0LGs9dGhpcy5hO2ImJihcIm51bWJlclwiPT09dHlwZW9mIGIuRiYmKGM9Yi5GKSxcIm51bWJlclwiPT09dHlwZW9mIGIuTyYmKGMrPWIuTykpOzI+Yz8oZD0oZy5sZW5ndGgtdGhpcy5jKS90aGlzLkNbMl0sZT0yNTgqKGQvMil8MCxmPWU8ay5sZW5ndGg/ay5sZW5ndGgrZTprLmxlbmd0aDw8MSk6Zj1rLmxlbmd0aCpjO0I/KGE9bmV3IFVpbnQ4QXJyYXkoZiksYS5zZXQoaykpOmE9aztyZXR1cm4gdGhpcy5hPWF9O1xuVC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3ZhciBiPTAsYT10aGlzLmEsYz10aGlzLnAsZCxmPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSh0aGlzLnUrKHRoaXMuYi0zMjc2OCkpLGUsZyxrLGg7aWYoMD09PWMubGVuZ3RoKXJldHVybiBCP3RoaXMuYS5zdWJhcnJheSgzMjc2OCx0aGlzLmIpOnRoaXMuYS5zbGljZSgzMjc2OCx0aGlzLmIpO2U9MDtmb3IoZz1jLmxlbmd0aDtlPGc7KytlKXtkPWNbZV07az0wO2ZvcihoPWQubGVuZ3RoO2s8aDsrK2spZltiKytdPWRba119ZT0zMjc2ODtmb3IoZz10aGlzLmI7ZTxnOysrZSlmW2IrK109YVtlXTt0aGlzLnA9W107cmV0dXJuIHRoaXMuYnVmZmVyPWZ9O1xuVC5wcm90b3R5cGUuUT1mdW5jdGlvbigpe3ZhciBiLGE9dGhpcy5iO0I/dGhpcy5MPyhiPW5ldyBVaW50OEFycmF5KGEpLGIuc2V0KHRoaXMuYS5zdWJhcnJheSgwLGEpKSk6Yj10aGlzLmEuc3ViYXJyYXkoMCxhKToodGhpcy5hLmxlbmd0aD5hJiYodGhpcy5hLmxlbmd0aD1hKSxiPXRoaXMuYSk7cmV0dXJuIHRoaXMuYnVmZmVyPWJ9O2Z1bmN0aW9uIHNiKGIpe3RoaXMuaW5wdXQ9Yjt0aGlzLmM9MDt0aGlzLnQ9W107dGhpcy5EPSExfXNiLnByb3RvdHlwZS5XPWZ1bmN0aW9uKCl7dGhpcy5EfHx0aGlzLmgoKTtyZXR1cm4gdGhpcy50LnNsaWNlKCl9O1xuc2IucHJvdG90eXBlLmg9ZnVuY3Rpb24oKXtmb3IodmFyIGI9dGhpcy5pbnB1dC5sZW5ndGg7dGhpcy5jPGI7KXt2YXIgYT1uZXcgUCxjPXQsZD10LGY9dCxlPXQsZz10LGs9dCxoPXQsbD10LHM9dCxuPXRoaXMuaW5wdXQsbT10aGlzLmM7YS5HPW5bbSsrXTthLkg9blttKytdOygzMSE9PWEuR3x8MTM5IT09YS5IKSYmcShFcnJvcihcImludmFsaWQgZmlsZSBzaWduYXR1cmU6XCIrYS5HK1wiLFwiK2EuSCkpO2Euej1uW20rK107c3dpdGNoKGEueil7Y2FzZSA4OmJyZWFrO2RlZmF1bHQ6cShFcnJvcihcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kOiBcIithLnopKX1hLm49blttKytdO2w9blttKytdfG5bbSsrXTw8OHxuW20rK108PDE2fG5bbSsrXTw8MjQ7YS5ZPW5ldyBEYXRlKDFFMypsKTthLmVhPW5bbSsrXTthLmRhPW5bbSsrXTswPChhLm4mNCkmJihhLiQ9blttKytdfG5bbSsrXTw8OCxtKz1hLiQpO2lmKDA8KGEubiZFYSkpe2g9W107Zm9yKGs9MDswPChnPW5bbSsrXSk7KWhbaysrXT1cblN0cmluZy5mcm9tQ2hhckNvZGUoZyk7YS5uYW1lPWguam9pbihcIlwiKX1pZigwPChhLm4mRmEpKXtoPVtdO2ZvcihrPTA7MDwoZz1uW20rK10pOyloW2srK109U3RyaW5nLmZyb21DaGFyQ29kZShnKTthLkE9aC5qb2luKFwiXCIpfTA8KGEubiZHYSkmJihhLlI9amEobiwwLG0pJjY1NTM1LGEuUiE9PShuW20rK118blttKytdPDw4KSYmcShFcnJvcihcImludmFsaWQgaGVhZGVyIGNyYzE2XCIpKSk7Yz1uW24ubGVuZ3RoLTRdfG5bbi5sZW5ndGgtM108PDh8bltuLmxlbmd0aC0yXTw8MTZ8bltuLmxlbmd0aC0xXTw8MjQ7bi5sZW5ndGgtbS00LTQ8NTEyKmMmJihlPWMpO2Q9bmV3IFQobix7aW5kZXg6bSxidWZmZXJTaXplOmV9KTthLmRhdGE9Zj1kLmgoKTttPWQuYzthLmJhPXM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7amEoZix0LHQpIT09cyYmcShFcnJvcihcImludmFsaWQgQ1JDLTMyIGNoZWNrc3VtOiAweFwiK2phKGYsdCx0KS50b1N0cmluZygxNikrXG5cIiAvIDB4XCIrcy50b1N0cmluZygxNikpKTthLmNhPWM9KG5bbSsrXXxuW20rK108PDh8blttKytdPDwxNnxuW20rK108PDI0KT4+PjA7KGYubGVuZ3RoJjQyOTQ5NjcyOTUpIT09YyYmcShFcnJvcihcImludmFsaWQgaW5wdXQgc2l6ZTogXCIrKGYubGVuZ3RoJjQyOTQ5NjcyOTUpK1wiIC8gXCIrYykpO3RoaXMudC5wdXNoKGEpO3RoaXMuYz1tfXRoaXMuRD11O3ZhciBwPXRoaXMudCxyLHYseD0wLFE9MCx5O3I9MDtmb3Iodj1wLmxlbmd0aDtyPHY7KytyKVErPXBbcl0uZGF0YS5sZW5ndGg7aWYoQil7eT1uZXcgVWludDhBcnJheShRKTtmb3Iocj0wO3I8djsrK3IpeS5zZXQocFtyXS5kYXRhLHgpLHgrPXBbcl0uZGF0YS5sZW5ndGh9ZWxzZXt5PVtdO2ZvcihyPTA7cjx2Oysrcil5W3JdPXBbcl0uZGF0YTt5PUFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10seSl9cmV0dXJuIHl9O0EoXCJabGliLkd1bnppcFwiLHNiKTtBKFwiWmxpYi5HdW56aXAucHJvdG90eXBlLmRlY29tcHJlc3NcIixzYi5wcm90b3R5cGUuaCk7QShcIlpsaWIuR3VuemlwLnByb3RvdHlwZS5nZXRNZW1iZXJzXCIsc2IucHJvdG90eXBlLlcpO2Z1bmN0aW9uIHRiKGIpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYil7dmFyIGE9Yi5zcGxpdChcIlwiKSxjLGQ7Yz0wO2ZvcihkPWEubGVuZ3RoO2M8ZDtjKyspYVtjXT0oYVtjXS5jaGFyQ29kZUF0KDApJjI1NSk+Pj4wO2I9YX1mb3IodmFyIGY9MSxlPTAsZz1iLmxlbmd0aCxrLGg9MDswPGc7KXtrPTEwMjQ8Zz8xMDI0Omc7Zy09aztkbyBmKz1iW2grK10sZSs9Zjt3aGlsZSgtLWspO2YlPTY1NTIxO2UlPTY1NTIxfXJldHVybihlPDwxNnxmKT4+PjB9O2Z1bmN0aW9uIHViKGIsYSl7dmFyIGMsZDt0aGlzLmlucHV0PWI7dGhpcy5jPTA7aWYoYXx8IShhPXt9KSlhLmluZGV4JiYodGhpcy5jPWEuaW5kZXgpLGEudmVyaWZ5JiYodGhpcy5aPWEudmVyaWZ5KTtjPWJbdGhpcy5jKytdO2Q9Ylt0aGlzLmMrK107c3dpdGNoKGMmMTUpe2Nhc2UgdmI6dGhpcy5tZXRob2Q9dmI7YnJlYWs7ZGVmYXVsdDpxKEVycm9yKFwidW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX0wIT09KChjPDw4KStkKSUzMSYmcShFcnJvcihcImludmFsaWQgZmNoZWNrIGZsYWc6XCIrKChjPDw4KStkKSUzMSkpO2QmMzImJnEoRXJyb3IoXCJmZGljdCBmbGFnIGlzIG5vdCBzdXBwb3J0ZWRcIikpO3RoaXMuSz1uZXcgVChiLHtpbmRleDp0aGlzLmMsYnVmZmVyU2l6ZTphLmJ1ZmZlclNpemUsYnVmZmVyVHlwZTphLmJ1ZmZlclR5cGUscmVzaXplOmEucmVzaXplfSl9XG51Yi5wcm90b3R5cGUuaD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuaW5wdXQsYSxjO2E9dGhpcy5LLmgoKTt0aGlzLmM9dGhpcy5LLmM7dGhpcy5aJiYoYz0oYlt0aGlzLmMrK108PDI0fGJbdGhpcy5jKytdPDwxNnxiW3RoaXMuYysrXTw8OHxiW3RoaXMuYysrXSk+Pj4wLGMhPT10YihhKSYmcShFcnJvcihcImludmFsaWQgYWRsZXItMzIgY2hlY2tzdW1cIikpKTtyZXR1cm4gYX07dmFyIHZiPTg7ZnVuY3Rpb24gd2IoYixhKXt0aGlzLmlucHV0PWI7dGhpcy5hPW5ldyAoQj9VaW50OEFycmF5OkFycmF5KSgzMjc2OCk7dGhpcy5rPVcubzt2YXIgYz17fSxkO2lmKChhfHwhKGE9e30pKSYmXCJudW1iZXJcIj09PXR5cGVvZiBhLmNvbXByZXNzaW9uVHlwZSl0aGlzLms9YS5jb21wcmVzc2lvblR5cGU7Zm9yKGQgaW4gYSljW2RdPWFbZF07Yy5vdXRwdXRCdWZmZXI9dGhpcy5hO3RoaXMuSj1uZXcgbmEodGhpcy5pbnB1dCxjKX12YXIgVz1yYTtcbndiLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7dmFyIGIsYSxjLGQsZixlLGcsaz0wO2c9dGhpcy5hO2I9dmI7c3dpdGNoKGIpe2Nhc2UgdmI6YT1NYXRoLkxPRzJFKk1hdGgubG9nKDMyNzY4KS04O2JyZWFrO2RlZmF1bHQ6cShFcnJvcihcImludmFsaWQgY29tcHJlc3Npb24gbWV0aG9kXCIpKX1jPWE8PDR8YjtnW2srK109Yztzd2l0Y2goYil7Y2FzZSB2Yjpzd2l0Y2godGhpcy5rKXtjYXNlIFcuTk9ORTpmPTA7YnJlYWs7Y2FzZSBXLnY6Zj0xO2JyZWFrO2Nhc2UgVy5vOmY9MjticmVhaztkZWZhdWx0OnEoRXJyb3IoXCJ1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlXCIpKX1icmVhaztkZWZhdWx0OnEoRXJyb3IoXCJpbnZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZFwiKSl9ZD1mPDw2fDA7Z1trKytdPWR8MzEtKDI1NipjK2QpJTMxO2U9dGIodGhpcy5pbnB1dCk7dGhpcy5KLmI9aztnPXRoaXMuSi5nKCk7az1nLmxlbmd0aDtCJiYoZz1uZXcgVWludDhBcnJheShnLmJ1ZmZlciksZy5sZW5ndGg8PVxuays0JiYodGhpcy5hPW5ldyBVaW50OEFycmF5KGcubGVuZ3RoKzQpLHRoaXMuYS5zZXQoZyksZz10aGlzLmEpLGc9Zy5zdWJhcnJheSgwLGsrNCkpO2dbaysrXT1lPj4yNCYyNTU7Z1trKytdPWU+PjE2JjI1NTtnW2srK109ZT4+OCYyNTU7Z1trKytdPWUmMjU1O3JldHVybiBnfTtmdW5jdGlvbiB4YihiLGEpe3ZhciBjLGQsZixlO2lmKE9iamVjdC5rZXlzKWM9T2JqZWN0LmtleXMoYSk7ZWxzZSBmb3IoZCBpbiBjPVtdLGY9MCxhKWNbZisrXT1kO2Y9MDtmb3IoZT1jLmxlbmd0aDtmPGU7KytmKWQ9Y1tmXSxBKGIrXCIuXCIrZCxhW2RdKX07QShcIlpsaWIuSW5mbGF0ZVwiLHViKTtBKFwiWmxpYi5JbmZsYXRlLnByb3RvdHlwZS5kZWNvbXByZXNzXCIsdWIucHJvdG90eXBlLmgpO3hiKFwiWmxpYi5JbmZsYXRlLkJ1ZmZlclR5cGVcIix7QURBUFRJVkU6WWEuTSxCTE9DSzpZYS5OfSk7QShcIlpsaWIuRGVmbGF0ZVwiLHdiKTtBKFwiWmxpYi5EZWZsYXRlLmNvbXByZXNzXCIsZnVuY3Rpb24oYixhKXtyZXR1cm4obmV3IHdiKGIsYSkpLmcoKX0pO0EoXCJabGliLkRlZmxhdGUucHJvdG90eXBlLmNvbXByZXNzXCIsd2IucHJvdG90eXBlLmcpO3hiKFwiWmxpYi5EZWZsYXRlLkNvbXByZXNzaW9uVHlwZVwiLHtOT05FOlcuTk9ORSxGSVhFRDpXLnYsRFlOQU1JQzpXLm99KTt9KS5jYWxsKHRoaXMpOyAvL0Agc291cmNlTWFwcGluZ1VSTD16bGliX2FuZF9nemlwLm1pbi5qcy5tYXBcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/vendor/zlib_and_gzip.min.js\n");

/***/ }),

/***/ "canvas":
/*!*************************!*\
  !*** external "canvas" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"canvas\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FudmFzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY2FudmFzXCI/ZDFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjYW52YXNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///canvas\n");

/***/ }),

/***/ "extend":
/*!*************************!*\
  !*** external "extend" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"extend\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5kLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXh0ZW5kXCI/MGU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJleHRlbmRcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///extend\n");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiP2E0MGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///fs\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jquery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"jquery\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwianF1ZXJ5XCI/OGY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqcXVlcnlcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///jquery\n");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF0aC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIj83NGJiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///path\n");

/***/ }),

/***/ "xhr2":
/*!***********************!*\
  !*** external "xhr2" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"xhr2\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGhyMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInhocjJcIj85YTkwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInhocjJcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///xhr2\n");

/***/ })

/******/ });